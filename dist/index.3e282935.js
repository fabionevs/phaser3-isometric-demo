function t(t){return t&&t.__esModule?t.default:t}var e=globalThis,i={},n={},s=e.parcelRequiredc96;null==s&&((s=function(t){if(t in i)return i[t].exports;if(t in n){var e=n[t];delete n[t];var s={id:t,exports:{}};return i[t]=s,e.call(s.exports,s,s.exports),s.exports}var r=Error("Cannot find module '"+t+"'");throw r.code="MODULE_NOT_FOUND",r}).register=function(t,e){n[t]=e},e.parcelRequiredc96=s);var r=s.register;r("3qUcC",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * Phaser Blend Modes.
 * 
 * @namespace Phaser.BlendModes
 * @since 3.0.0
 */t.exports={/**
     * Skips the Blend Mode check in the renderer.
     * 
     * @name Phaser.BlendModes.SKIP_CHECK
     * @type {integer}
     * @const
     * @since 3.0.0
     */SKIP_CHECK:-1,/**
     * Normal blend mode. For Canvas and WebGL.
     * This is the default setting and draws new shapes on top of the existing canvas content.
     * 
     * @name Phaser.BlendModes.NORMAL
     * @type {integer}
     * @const
     * @since 3.0.0
     */NORMAL:0,/**
     * Add blend mode. For Canvas and WebGL.
     * Where both shapes overlap the color is determined by adding color values.
     * 
     * @name Phaser.BlendModes.ADD
     * @type {integer}
     * @const
     * @since 3.0.0
     */ADD:1,/**
     * Multiply blend mode. For Canvas and WebGL.
     * The pixels are of the top layer are multiplied with the corresponding pixel of the bottom layer. A darker picture is the result.
     * 
     * @name Phaser.BlendModes.MULTIPLY
     * @type {integer}
     * @const
     * @since 3.0.0
     */MULTIPLY:2,/**
     * Screen blend mode. For Canvas and WebGL.
     * The pixels are inverted, multiplied, and inverted again. A lighter picture is the result (opposite of multiply)
     * 
     * @name Phaser.BlendModes.SCREEN
     * @type {integer}
     * @const
     * @since 3.0.0
     */SCREEN:3,/**
     * Overlay blend mode. For Canvas only.
     * A combination of multiply and screen. Dark parts on the base layer become darker, and light parts become lighter.
     * 
     * @name Phaser.BlendModes.OVERLAY
     * @type {integer}
     * @const
     * @since 3.0.0
     */OVERLAY:4,/**
     * Darken blend mode. For Canvas only.
     * Retains the darkest pixels of both layers.
     * 
     * @name Phaser.BlendModes.DARKEN
     * @type {integer}
     * @const
     * @since 3.0.0
     */DARKEN:5,/**
     * Lighten blend mode. For Canvas only.
     * Retains the lightest pixels of both layers.
     * 
     * @name Phaser.BlendModes.LIGHTEN
     * @type {integer}
     * @const
     * @since 3.0.0
     */LIGHTEN:6,/**
     * Color Dodge blend mode. For Canvas only.
     * Divides the bottom layer by the inverted top layer.
     * 
     * @name Phaser.BlendModes.COLOR_DODGE
     * @type {integer}
     * @const
     * @since 3.0.0
     */COLOR_DODGE:7,/**
     * Color Burn blend mode. For Canvas only.
     * Divides the inverted bottom layer by the top layer, and then inverts the result.
     * 
     * @name Phaser.BlendModes.COLOR_BURN
     * @type {integer}
     * @const
     * @since 3.0.0
     */COLOR_BURN:8,/**
     * Hard Light blend mode. For Canvas only.
     * A combination of multiply and screen like overlay, but with top and bottom layer swapped.
     * 
     * @name Phaser.BlendModes.HARD_LIGHT
     * @type {integer}
     * @const
     * @since 3.0.0
     */HARD_LIGHT:9,/**
     * Soft Light blend mode. For Canvas only.
     * A softer version of hard-light. Pure black or white does not result in pure black or white.
     * 
     * @name Phaser.BlendModes.SOFT_LIGHT
     * @type {integer}
     * @const
     * @since 3.0.0
     */SOFT_LIGHT:10,/**
     * Difference blend mode. For Canvas only.
     * Subtracts the bottom layer from the top layer or the other way round to always get a positive value.
     * 
     * @name Phaser.BlendModes.DIFFERENCE
     * @type {integer}
     * @const
     * @since 3.0.0
     */DIFFERENCE:11,/**
     * Exclusion blend mode. For Canvas only.
     * Like difference, but with lower contrast.
     * 
     * @name Phaser.BlendModes.EXCLUSION
     * @type {integer}
     * @const
     * @since 3.0.0
     */EXCLUSION:12,/**
     * Hue blend mode. For Canvas only.
     * Preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.
     * 
     * @name Phaser.BlendModes.HUE
     * @type {integer}
     * @const
     * @since 3.0.0
     */HUE:13,/**
     * Saturation blend mode. For Canvas only.
     * Preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.
     * 
     * @name Phaser.BlendModes.SATURATION
     * @type {integer}
     * @const
     * @since 3.0.0
     */SATURATION:14,/**
     * Color blend mode. For Canvas only.
     * Preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.
     * 
     * @name Phaser.BlendModes.COLOR
     * @type {integer}
     * @const
     * @since 3.0.0
     */COLOR:15,/**
     * Luminosity blend mode. For Canvas only.
     * Preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.
     * 
     * @name Phaser.BlendModes.LUMINOSITY
     * @type {integer}
     * @const
     * @since 3.0.0
     */LUMINOSITY:16,/**
     * Alpha erase blend mode. For Canvas and WebGL.
     * 
     * @name Phaser.BlendModes.ERASE
     * @type {integer}
     * @const
     * @since 3.0.0
     */ERASE:17,/**
     * Source-in blend mode. For Canvas only.
     * The new shape is drawn only where both the new shape and the destination canvas overlap. Everything else is made transparent.
     * 
     * @name Phaser.BlendModes.SOURCE_IN
     * @type {integer}
     * @const
     * @since 3.0.0
     */SOURCE_IN:18,/**
     * Source-out blend mode. For Canvas only.
     * The new shape is drawn where it doesn't overlap the existing canvas content.
     * 
     * @name Phaser.BlendModes.SOURCE_OUT
     * @type {integer}
     * @const
     * @since 3.0.0
     */SOURCE_OUT:19,/**
     * Source-out blend mode. For Canvas only.
     * The new shape is only drawn where it overlaps the existing canvas content.
     * 
     * @name Phaser.BlendModes.SOURCE_ATOP
     * @type {integer}
     * @const
     * @since 3.0.0
     */SOURCE_ATOP:20,/**
     * Destination-over blend mode. For Canvas only.
     * New shapes are drawn behind the existing canvas content.
     * 
     * @name Phaser.BlendModes.DESTINATION_OVER
     * @type {integer}
     * @const
     * @since 3.0.0
     */DESTINATION_OVER:21,/**
     * Destination-in blend mode. For Canvas only.
     * The existing canvas content is kept where both the new shape and existing canvas content overlap. Everything else is made transparent.
     * 
     * @name Phaser.BlendModes.DESTINATION_IN
     * @type {integer}
     * @const
     * @since 3.0.0
     */DESTINATION_IN:22,/**
     * Destination-out blend mode. For Canvas only.
     * The existing content is kept where it doesn't overlap the new shape.
     * 
     * @name Phaser.BlendModes.DESTINATION_OUT
     * @type {integer}
     * @const
     * @since 3.0.0
     */DESTINATION_OUT:23,/**
     * Destination-out blend mode. For Canvas only.
     * The existing canvas is only kept where it overlaps the new shape. The new shape is drawn behind the canvas content.
     * 
     * @name Phaser.BlendModes.DESTINATION_ATOP
     * @type {integer}
     * @const
     * @since 3.0.0
     */DESTINATION_ATOP:24,/**
     * Lighten blend mode. For Canvas only.
     * Where both shapes overlap the color is determined by adding color values.
     * 
     * @name Phaser.BlendModes.LIGHTER
     * @type {integer}
     * @const
     * @since 3.0.0
     */LIGHTER:25,/**
     * Copy blend mode. For Canvas only.
     * Only the new shape is shown.
     * 
     * @name Phaser.BlendModes.COPY
     * @type {integer}
     * @const
     * @since 3.0.0
     */COPY:26,/**
     * Xor blend mode. For Canvas only.
     * Shapes are made transparent where both overlap and drawn normal everywhere else.
     * 
     * @name Phaser.BlendModes.XOR
     * @type {integer}
     * @const
     * @since 3.0.0
     */XOR:27}}),r("1iebW",function(t,e){t.exports={/**
     * Default Scale Mode (Linear).
     * 
     * @name Phaser.ScaleModes.DEFAULT
     * @type {integer}
     * @readonly
     * @since 3.0.0
     */DEFAULT:0,/**
     * Linear Scale Mode.
     * 
     * @name Phaser.ScaleModes.LINEAR
     * @type {integer}
     * @readonly
     * @since 3.0.0
     */LINEAR:0,/**
     * Nearest Scale Mode.
     * 
     * @name Phaser.ScaleModes.NEAREST
     * @type {integer}
     * @readonly
     * @since 3.0.0
     */NEAREST:1}}),r("hVk4C",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jC9MQ"),n=function(){var t,e,s,r,o,a,h=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof h&&(c=h,h=arguments[1]||{},// skip the boolean and the target
l=2),u===l&&(h=this,--l);l<u;l++)// Only deal with non-null/undefined values
if(null!=(t=arguments[l]))for(e in t)s=h[e],h!==(r=t[e])&&(c&&r&&(i(r)||(o=Array.isArray(r)))?(o?(o=!1,a=s&&Array.isArray(s)?s:[]):a=s&&i(s)?s:{},// Never move original objects, clone them
h[e]=n(c,a,r)):void 0!==r&&(h[e]=r));// Return the modified object
return h};t.exports=n}),r("jC9MQ",function(t,e){t.exports=function(t){// Not plain objects:
// - Any object or value whose internal [[Class]] property is not "[object Object]"
// - DOM nodes
// - window
if("object"!=typeof t||t.nodeType||t===t.window)return!1;// Support: Firefox <20
// The try/catch suppresses exceptions thrown when attempting to access
// the "constructor" property of certain host objects, ie. |window.location|
// https://bugzilla.mozilla.org/show_bug.cgi?id=814622
try{if(t.constructor&&!({}).hasOwnProperty.call(t.constructor.prototype,"isPrototypeOf"))return!1}catch(t){return!1}// If the function hasn't returned already, we're confident that
// |obj| is a plain object, created by {} or constructed with new Object
return!0}}),r("fs3fn",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Actions
 */t.exports={AlignTo:s("d60cE"),Angle:s("5uw5a"),Call:s("dNnjm"),GetFirst:s("7DHQp"),GetLast:s("e6e1x"),GridAlign:s("37cO8"),IncAlpha:s("51Ccp"),IncX:s("2geHo"),IncXY:s("aa2rH"),IncY:s("iNcUv"),PlaceOnCircle:s("irnRf"),PlaceOnEllipse:s("jYzIo"),PlaceOnLine:s("fTyAf"),PlaceOnRectangle:s("kQ8Yy"),PlaceOnTriangle:s("3aDNv"),PlayAnimation:s("58n2H"),PropertyValueInc:s("joPJC"),PropertyValueSet:s("2Alx8"),RandomCircle:s("feu3e"),RandomEllipse:s("4RfvK"),RandomLine:s("8FwLE"),RandomRectangle:s("km9Vj"),RandomTriangle:s("hQxDo"),Rotate:s("k3Z7N"),RotateAround:s("1iEaG"),RotateAroundDistance:s("jtzCa"),ScaleX:s("dElyt"),ScaleXY:s("fF8WC"),ScaleY:s("c6II7"),SetAlpha:s("kM3Np"),SetBlendMode:s("gYMnB"),SetDepth:s("7Nva9"),SetHitArea:s("128Rk"),SetOrigin:s("fvIPU"),SetRotation:s("dvgoG"),SetScale:s("43tcD"),SetScaleX:s("dajVg"),SetScaleY:s("eqA15"),SetScrollFactor:s("Horko"),SetScrollFactorX:s("8uqg5"),SetScrollFactorY:s("k9PTE"),SetTint:s("eXuqB"),SetVisible:s("j9xSq"),SetX:s("2IEMX"),SetXY:s("Wq1BO"),SetY:s("7yy0q"),ShiftPosition:s("7FJHd"),Shuffle:s("cTZaX"),SmootherStep:s("33Qfe"),SmoothStep:s("4e9ty"),Spread:s("e3WPZ"),ToggleVisible:s("f7rup"),WrapInRectangle:s("2Oe4l")}}),r("d60cE",function(t,e){/**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("g6HRX");t.exports=function(t,e,n,s){for(var r=t[0],o=1;o<t.length;o++){var a=t[o];i(a,r,e,n,s),r=a}return t}}),r("g6HRX",function(t,e){/**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hPWXH"),n=[];n[i.BOTTOM_CENTER]=s("7V1sp"),n[i.BOTTOM_LEFT]=s("hUnFl"),n[i.BOTTOM_RIGHT]=s("hyRjB"),n[i.LEFT_BOTTOM]=s("fNGut"),n[i.LEFT_CENTER]=s("1LQnW"),n[i.LEFT_TOP]=s("fPpzE"),n[i.RIGHT_BOTTOM]=s("7d2qQ"),n[i.RIGHT_CENTER]=s("lavD1"),n[i.RIGHT_TOP]=s("suJhd"),n[i.TOP_CENTER]=s("hjjdG"),n[i.TOP_LEFT]=s("5H3NR"),n[i.TOP_RIGHT]=s("6Cewx"),t.exports=function(t,e,i,s,r){return n[i](t,e,s,r)}}),r("hPWXH",function(t,e){t.exports={/**
    * A constant representing a top-left alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_LEFT
    * @since 3.0.0
    * @type {integer}
    */TOP_LEFT:0,/**
    * A constant representing a top-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_CENTER
    * @since 3.0.0
    * @type {integer}
    */TOP_CENTER:1,/**
    * A constant representing a top-right alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_RIGHT
    * @since 3.0.0
    * @type {integer}
    */TOP_RIGHT:2,/**
    * A constant representing a left-top alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_TOP
    * @since 3.0.0
    * @type {integer}
    */LEFT_TOP:3,/**
    * A constant representing a left-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_CENTER
    * @since 3.0.0
    * @type {integer}
    */LEFT_CENTER:4,/**
    * A constant representing a left-bottom alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_BOTTOM
    * @since 3.0.0
    * @type {integer}
    */LEFT_BOTTOM:5,/**
    * A constant representing a center alignment or position.
    * @constant
    * @name Phaser.Display.Align.CENTER
    * @since 3.0.0
    * @type {integer}
    */CENTER:6,/**
    * A constant representing a right-top alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_TOP
    * @since 3.0.0
    * @type {integer}
    */RIGHT_TOP:7,/**
    * A constant representing a right-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_CENTER
    * @since 3.0.0
    * @type {integer}
    */RIGHT_CENTER:8,/**
    * A constant representing a right-bottom alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_BOTTOM
    * @since 3.0.0
    * @type {integer}
    */RIGHT_BOTTOM:9,/**
    * A constant representing a bottom-left alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_LEFT
    * @since 3.0.0
    * @type {integer}
    */BOTTOM_LEFT:10,/**
    * A constant representing a bottom-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_CENTER
    * @since 3.0.0
    * @type {integer}
    */BOTTOM_CENTER:11,/**
    * A constant representing a bottom-right alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_RIGHT
    * @since 3.0.0
    * @type {integer}
    */BOTTOM_RIGHT:12}}),r("7V1sp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cWmua"),n=s("k74fg"),r=s("7ltKj"),o=s("2yhAk");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),r(t,n(e)+s),o(t,i(e)+a),t}}),r("cWmua",function(t,e){t.exports=function(t){return t.y+t.height-t.height*t.originY}}),r("k74fg",function(t,e){t.exports=function(t){return t.x-t.width*t.originX+.5*t.width}}),r("7ltKj",function(t,e){t.exports=function(t,e){var i=t.width*t.originX;return t.x=e+i-.5*t.width,t}}),r("2yhAk",function(t,e){t.exports=function(t,e){return t.y=e+t.height*t.originY,t}}),r("hUnFl",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cWmua"),n=s("7Hc2m"),r=s("jcMTD"),o=s("2yhAk");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),r(t,n(e)-s),o(t,i(e)+a),t}}),r("7Hc2m",function(t,e){t.exports=function(t){return t.x-t.width*t.originX}}),r("jcMTD",function(t,e){t.exports=function(t,e){return t.x=e+t.width*t.originX,t}}),r("hyRjB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cWmua"),n=s("dD4Dr"),r=s("4G1x9"),o=s("2yhAk");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),r(t,n(e)+s),o(t,i(e)+a),t}}),r("dD4Dr",function(t,e){t.exports=function(t){return t.x+t.width-t.width*t.originX}}),r("4G1x9",function(t,e){t.exports=function(t,e){return t.x=e-t.width+t.width*t.originX,t}}),r("fNGut",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cWmua"),n=s("7Hc2m"),r=s("gNxHP"),o=s("4G1x9");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),o(t,n(e)-s),r(t,i(e)+a),t}}),r("gNxHP",function(t,e){t.exports=function(t,e){return t.y=e-t.height+t.height*t.originY,t}}),r("1LQnW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("14FXn"),n=s("7Hc2m"),r=s("9L2xG"),o=s("4G1x9");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),o(t,n(e)-s),r(t,i(e)+a),t}}),r("14FXn",function(t,e){t.exports=function(t){return t.y-t.height*t.originY+.5*t.height}}),r("9L2xG",function(t,e){t.exports=function(t,e){var i=t.height*t.originY;return t.y=e+i-.5*t.height,t}}),r("fPpzE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7Hc2m"),n=s("b873I"),r=s("4G1x9"),o=s("2yhAk");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),r(t,i(e)-s),o(t,n(e)-a),t}}),r("b873I",function(t,e){t.exports=function(t){return t.y-t.height*t.originY}}),r("7d2qQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cWmua"),n=s("dD4Dr"),r=s("gNxHP"),o=s("jcMTD");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),o(t,n(e)+s),r(t,i(e)+a),t}}),r("lavD1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("14FXn"),n=s("dD4Dr"),r=s("9L2xG"),o=s("jcMTD");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),o(t,n(e)+s),r(t,i(e)+a),t}}),r("suJhd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("dD4Dr"),n=s("b873I"),r=s("jcMTD"),o=s("2yhAk");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),r(t,i(e)+s),o(t,n(e)-a),t}}),r("hjjdG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("k74fg"),n=s("b873I"),r=s("gNxHP"),o=s("7ltKj");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),o(t,i(e)+s),r(t,n(e)-a),t}}),r("5H3NR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7Hc2m"),n=s("b873I"),r=s("gNxHP"),o=s("jcMTD");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),o(t,i(e)-s),r(t,n(e)-a),t}}),r("6Cewx",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("dD4Dr"),n=s("b873I"),r=s("gNxHP"),o=s("4G1x9");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),o(t,i(e)+s),r(t,n(e)-a),t}}),r("5uw5a",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("joPJC");t.exports=function(t,e,n,s,r){return i(t,"angle",e,n,s,r)}}),r("joPJC",function(t,e){t.exports=function(t,e,i,n,s,r){void 0===n&&(n=0),void 0===s&&(s=0),void 0===r&&(r=1);var o,a=0,h=t.length;if(1===r)for(o=s;o<h;o++)t[o][e]+=i+a*n,a++;else for(o=s;o>=0;o--)t[o][e]+=i+a*n,a++;return t}}),r("dNnjm",function(t,e){t.exports=function(t,e,i){for(var n=0;n<t.length;n++){var s=t[n];e.call(i,s)}return t}}),r("7DHQp",function(t,e){t.exports=function(t,e,i){void 0===i&&(i=0);for(var n=i;n<t.length;n++){var s=t[n],r=!0;for(var o in e)s[o]!==e[o]&&(r=!1);if(r)return s}return null}}),r("e6e1x",function(t,e){t.exports=function(t,e,i){void 0===i&&(i=0);for(var n=i;n<t.length;n++){var s=t[n],r=!0;for(var o in e)s[o]!==e[o]&&(r=!1);if(r)return s}return null}}),r("37cO8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("lW6Z2"),n=s("hPWXH"),r=s("7BSWl"),o=s("13GYA"),a=new(s("dZGDG"))({sys:{queueDepthSort:o,events:{once:o}}},0,0,1,1);t.exports=function(t,e){void 0===e&&(e={});var s=e.hasOwnProperty("width"),o=e.hasOwnProperty("height"),h=r(e,"width",-1),l=r(e,"height",-1),u=r(e,"cellWidth",1),c=r(e,"cellHeight",u),d=r(e,"position",n.TOP_LEFT),f=r(e,"x",0),p=r(e,"y",0),g=0,v=0,m=h*u,y=l*c;a.setPosition(f,p),a.setSize(u,c);for(var x=0;x<t.length;x++)if(i(t[x],a,d),s&&-1===h)a.x+=u;else if(o&&-1===l)a.y+=c;else if(//  We keep laying them out until we hit the column limit
g+=u,a.x+=u,g===m&&(g=0,v+=c,a.x=f,a.y+=c,v===y))break;return t}}),r("lW6Z2",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hPWXH"),n=[];n[i.BOTTOM_CENTER]=s("bI66X"),n[i.BOTTOM_LEFT]=s("9aKJT"),n[i.BOTTOM_RIGHT]=s("57VIW"),n[i.CENTER]=s("8OPIk"),n[i.LEFT_CENTER]=s("lCav5"),n[i.RIGHT_CENTER]=s("d4CDm"),n[i.TOP_CENTER]=s("aBZ2v"),n[i.TOP_LEFT]=s("jIofi"),n[i.TOP_RIGHT]=s("gVJ1b"),n[i.LEFT_BOTTOM]=n[i.BOTTOM_LEFT],n[i.LEFT_TOP]=n[i.TOP_LEFT],n[i.RIGHT_BOTTOM]=n[i.BOTTOM_RIGHT],n[i.RIGHT_TOP]=n[i.TOP_RIGHT],t.exports=function(t,e,i,s,r){return n[i](t,e,s,r)}}),r("bI66X",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cWmua"),n=s("k74fg"),r=s("gNxHP"),o=s("7ltKj");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),o(t,n(e)+s),r(t,i(e)+a),t}}),r("9aKJT",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cWmua"),n=s("7Hc2m"),r=s("gNxHP"),o=s("jcMTD");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),o(t,n(e)-s),r(t,i(e)+a),t}}),r("57VIW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cWmua"),n=s("dD4Dr"),r=s("gNxHP"),o=s("4G1x9");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),o(t,n(e)+s),r(t,i(e)+a),t}}),r("8OPIk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("73gOb"),n=s("k74fg"),r=s("14FXn");t.exports=function(t,e,s,o){return void 0===s&&(s=0),void 0===o&&(o=0),i(t,n(e)+s,r(e)+o),t}}),r("73gOb",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7ltKj"),n=s("9L2xG");t.exports=function(t,e,s){return i(t,e),n(t,s)}}),r("lCav5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("14FXn"),n=s("7Hc2m"),r=s("9L2xG"),o=s("jcMTD");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),o(t,n(e)-s),r(t,i(e)+a),t}}),r("d4CDm",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("14FXn"),n=s("dD4Dr"),r=s("9L2xG"),o=s("4G1x9");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),o(t,n(e)+s),r(t,i(e)+a),t}}),r("aBZ2v",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("k74fg"),n=s("b873I"),r=s("7ltKj"),o=s("2yhAk");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),r(t,i(e)+s),o(t,n(e)-a),t}}),r("jIofi",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7Hc2m"),n=s("b873I"),r=s("jcMTD"),o=s("2yhAk");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),r(t,i(e)-s),o(t,n(e)-a),t}}),r("gVJ1b",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("dD4Dr"),n=s("b873I"),r=s("4G1x9"),o=s("2yhAk");t.exports=function(t,e,s,a){return void 0===s&&(s=0),void 0===a&&(a=0),r(t,i(e)+s),o(t,n(e)-a),t}}),r("7BSWl",function(t,e){t.exports=function(t,e,i){var n=typeof t;return t&&"number"!==n&&"string"!==n&&t.hasOwnProperty(e)&&void 0!==t[e]?t[e]:i}}),r("13GYA",function(t,e){t.exports=function(){//  NOOP
}}),r("dZGDG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("3qUcC"),n=s("eQ4tZ"),r=s("6hp2k"),o=s("jwj1g"),a=s("4FF1v"),h=s("1zqlR"),l=s("cwr8X"),u=s("6pEze"),c=new o({Extends:h,Mixins:[a.Depth,a.GetBounds,a.Origin,a.Transform,a.ScrollFactor,a.Visible],initialize:function(t,e,n,s,r){void 0===s&&(s=1),void 0===r&&(r=s),h.call(this,t,"Zone"),this.setPosition(e,n),/**
         * The native (un-scaled) width of this Game Object.
         *
         * @name Phaser.GameObjects.Zone#width
         * @type {number}
         * @since 3.0.0
         */this.width=s,/**
         * The native (un-scaled) height of this Game Object.
         *
         * @name Phaser.GameObjects.Zone#height
         * @type {number}
         * @since 3.0.0
         */this.height=r,/**
         * The Blend Mode of the Game Object.
         * Although a Zone never renders, it still has a blend mode to allow it to fit seamlessly into
         * display lists without causing a batch flush.
         *
         * @name Phaser.GameObjects.Zone#blendMode
         * @type {integer}
         * @since 3.0.0
         */this.blendMode=i.NORMAL,this.updateDisplayOrigin()},/**
     * The displayed width of this Game Object.
     * This value takes into account the scale factor.
     *
     * @name Phaser.GameObjects.Zone#displayWidth
     * @type {number}
     * @since 3.0.0
     */displayWidth:{get:function(){return this.scaleX*this.width},set:function(t){this.scaleX=t/this.width}},/**
     * The displayed height of this Game Object.
     * This value takes into account the scale factor.
     *
     * @name Phaser.GameObjects.Zone#displayHeight
     * @type {number}
     * @since 3.0.0
     */displayHeight:{get:function(){return this.scaleY*this.height},set:function(t){this.scaleY=t/this.height}},/**
     * Sets the size of this Game Object.
     *
     * @method Phaser.GameObjects.Zone#setSize
     * @since 3.0.0
     *
     * @param {number} width - The width of this Game Object.
     * @param {number} height - The height of this Game Object.
     * @param {boolean} [resizeInput=true] - If this Zone has a Rectangle for a hit area this argument will resize the hit area as well.
     *
     * @return {this} This Game Object.
     */setSize:function(t,e,i){void 0===i&&(i=!0),this.width=t,this.height=e,this.updateDisplayOrigin();var n=this.input;return i&&n&&!n.customHitArea&&(n.hitArea.width=t,n.hitArea.height=e),this},/**
     * Sets the display size of this Game Object.
     * Calling this will adjust the scale.
     *
     * @method Phaser.GameObjects.Zone#setDisplaySize
     * @since 3.0.0
     *
     * @param {number} width - The width of this Game Object.
     * @param {number} height - The height of this Game Object.
     *
     * @return {this} This Game Object.
     */setDisplaySize:function(t,e){return this.displayWidth=t,this.displayHeight=e,this},/**
     * Sets this Zone to be a Circular Drop Zone.
     * The circle is centered on this Zones `x` and `y` coordinates.
     *
     * @method Phaser.GameObjects.Zone#setCircleDropZone
     * @since 3.0.0
     *
     * @param {number} radius - The radius of the Circle that will form the Drop Zone.
     *
     * @return {this} This Game Object.
     */setCircleDropZone:function(t){return this.setDropZone(new n(0,0,t),r)},/**
     * Sets this Zone to be a Rectangle Drop Zone.
     * The rectangle is centered on this Zones `x` and `y` coordinates.
     *
     * @method Phaser.GameObjects.Zone#setRectangleDropZone
     * @since 3.0.0
     *
     * @param {number} width - The width of the rectangle drop zone.
     * @param {number} height - The height of the rectangle drop zone.
     *
     * @return {this} This Game Object.
     */setRectangleDropZone:function(t,e){return this.setDropZone(new l(0,0,t,e),u)},/**
     * Allows you to define your own Geometry shape to be used as a Drop Zone.
     *
     * @method Phaser.GameObjects.Zone#setDropZone
     * @since 3.0.0
     *
     * @param {object} shape - A Geometry shape instance, such as Phaser.Geom.Ellipse, or your own custom shape.
     * @param {Phaser.Types.Input.HitAreaCallback} callback - A function that will return `true` if the given x/y coords it is sent are within the shape.
     *
     * @return {this} This Game Object.
     */setDropZone:function(t,e){return void 0===t?this.setRectangleDropZone(this.width,this.height):this.input||this.setInteractive(t,e,!0),this},/**
     * A NOOP method so you can pass a Zone to a Container.
     * Calling this method will do nothing. It is intentionally empty.
     *
     * @method Phaser.GameObjects.Zone#setAlpha
     * @private
     * @since 3.11.0
     */setAlpha:function(){},/**
     * A NOOP method so you can pass a Zone to a Container in Canvas.
     * Calling this method will do nothing. It is intentionally empty.
     *
     * @method Phaser.GameObjects.Zone#setBlendMode
     * @private
     * @since 3.16.2
     */setBlendMode:function(){},/**
     * A Zone does not render.
     *
     * @method Phaser.GameObjects.Zone#renderCanvas
     * @private
     * @since 3.0.0
     */renderCanvas:function(){},/**
     * A Zone does not render.
     *
     * @method Phaser.GameObjects.Zone#renderWebGL
     * @private
     * @since 3.0.0
     */renderWebGL:function(){}});t.exports=c}),r("eQ4tZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("6hp2k"),r=s("dM9Ux"),o=s("80QEd"),a=s("gZ2BZ"),h=s("9zIIl"),l=new i({initialize:function(t,e,i){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),/**
         * The geometry constant type of this object: `GEOM_CONST.CIRCLE`.
         * Used for fast type comparisons.
         *
         * @name Phaser.Geom.Circle#type
         * @type {integer}
         * @readonly
         * @since 3.19.0
         */this.type=a.CIRCLE,/**
         * The x position of the center of the circle.
         *
         * @name Phaser.Geom.Circle#x
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.x=t,/**
         * The y position of the center of the circle.
         *
         * @name Phaser.Geom.Circle#y
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.y=e,/**
         * The internal radius of the circle.
         *
         * @name Phaser.Geom.Circle#_radius
         * @type {number}
         * @private
         * @since 3.0.0
         */this._radius=i,/**
         * The internal diameter of the circle.
         *
         * @name Phaser.Geom.Circle#_diameter
         * @type {number}
         * @private
         * @since 3.0.0
         */this._diameter=2*i},/**
     * Check to see if the Circle contains the given x / y coordinates.
     *
     * @method Phaser.Geom.Circle#contains
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate to check within the circle.
     * @param {number} y - The y coordinate to check within the circle.
     *
     * @return {boolean} True if the coordinates are within the circle, otherwise false.
     */contains:function(t,e){return n(this,t,e)},/**
     * Returns a Point object containing the coordinates of a point on the circumference of the Circle
     * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point
     * at 180 degrees around the circle.
     *
     * @method Phaser.Geom.Circle#getPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point} O - [out,$return]
     *
     * @param {number} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.
     * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.
     *
     * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the circle.
     */getPoint:function(t,e){return r(this,t,e)},/**
     * Returns an array of Point objects containing the coordinates of the points around the circumference of the Circle,
     * based on the given quantity or stepRate values.
     *
     * @method Phaser.Geom.Circle#getPoints
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point[]} O - [output,$return]
     *
     * @param {integer} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
     * @param {number} [stepRate] - Sets the quantity by getting the circumference of the circle and dividing it by the stepRate.
     * @param {(array|Phaser.Geom.Point[])} [output] - An array to insert the points in to. If not provided a new array will be created.
     *
     * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the circumference of the circle.
     */getPoints:function(t,e,i){return o(this,t,e,i)},/**
     * Returns a uniformly distributed random point from anywhere within the Circle.
     *
     * @method Phaser.Geom.Circle#getRandomPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point} O - [point,$return]
     *
     * @param {(Phaser.Geom.Point|object)} [point] - A Point or point-like object to set the random `x` and `y` values in.
     *
     * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.
     */getRandomPoint:function(t){return h(this,t)},/**
     * Sets the x, y and radius of this circle.
     *
     * @method Phaser.Geom.Circle#setTo
     * @since 3.0.0
     *
     * @param {number} [x=0] - The x position of the center of the circle.
     * @param {number} [y=0] - The y position of the center of the circle.
     * @param {number} [radius=0] - The radius of the circle.
     *
     * @return {this} This Circle object.
     */setTo:function(t,e,i){return this.x=t,this.y=e,this._radius=i,this._diameter=2*i,this},/**
     * Sets this Circle to be empty with a radius of zero.
     * Does not change its position.
     *
     * @method Phaser.Geom.Circle#setEmpty
     * @since 3.0.0
     *
     * @return {this} This Circle object.
     */setEmpty:function(){return this._radius=0,this._diameter=0,this},/**
     * Sets the position of this Circle.
     *
     * @method Phaser.Geom.Circle#setPosition
     * @since 3.0.0
     *
     * @param {number} [x=0] - The x position of the center of the circle.
     * @param {number} [y=0] - The y position of the center of the circle.
     *
     * @return {this} This Circle object.
     */setPosition:function(t,e){return void 0===e&&(e=t),this.x=t,this.y=e,this},/**
     * Checks to see if the Circle is empty: has a radius of zero.
     *
     * @method Phaser.Geom.Circle#isEmpty
     * @since 3.0.0
     *
     * @return {boolean} True if the Circle is empty, otherwise false.
     */isEmpty:function(){return this._radius<=0},/**
     * The radius of the Circle.
     *
     * @name Phaser.Geom.Circle#radius
     * @type {number}
     * @since 3.0.0
     */radius:{get:function(){return this._radius},set:function(t){this._radius=t,this._diameter=2*t}},/**
     * The diameter of the Circle.
     *
     * @name Phaser.Geom.Circle#diameter
     * @type {number}
     * @since 3.0.0
     */diameter:{get:function(){return this._diameter},set:function(t){this._diameter=t,this._radius=.5*t}},/**
     * The left position of the Circle.
     *
     * @name Phaser.Geom.Circle#left
     * @type {number}
     * @since 3.0.0
     */left:{get:function(){return this.x-this._radius},set:function(t){this.x=t+this._radius}},/**
     * The right position of the Circle.
     *
     * @name Phaser.Geom.Circle#right
     * @type {number}
     * @since 3.0.0
     */right:{get:function(){return this.x+this._radius},set:function(t){this.x=t-this._radius}},/**
     * The top position of the Circle.
     *
     * @name Phaser.Geom.Circle#top
     * @type {number}
     * @since 3.0.0
     */top:{get:function(){return this.y-this._radius},set:function(t){this.y=t+this._radius}},/**
     * The bottom position of the Circle.
     *
     * @name Phaser.Geom.Circle#bottom
     * @type {number}
     * @since 3.0.0
     */bottom:{get:function(){return this.y+this._radius},set:function(t){this.y=t-this._radius}}});t.exports=l}),r("jwj1g",function(t,e){/**
 * Extends the given `myClass` object's prototype with the properties of `definition`.
 *
 * @function extend
 * @param {Object} ctor The constructor object to mix into.
 * @param {Object} definition A dictionary of functions for the class.
 * @param {boolean} isClassDescriptor Is the definition a class descriptor?
 * @param {Object} [extend] The parent constructor object.
 */function i(t,e,i,n){for(var r in e)if(e.hasOwnProperty(r)){var o=function(t,e,i){//  This may be a lightweight object, OR it might be a property that was defined previously.
//  For simple class descriptors we can just assume its NOT previously defined.
var n,s=i?t[e]:Object.getOwnPropertyDescriptor(t,e);return(//  This might be a regular property, or it may be a getter/setter the user defined in a class.
!i&&s.value&&"object"==typeof s.value&&(s=s.value),!!s&&(!!(n=s).get&&"function"==typeof n.get||!!n.set&&"function"==typeof n.set)&&(void 0===s.enumerable&&(s.enumerable=!0),void 0===s.configurable&&(s.configurable=!0),s))}(e,r,i);if(!1!==o){if(function(t,e){var i=Object.getOwnPropertyDescriptor(t,e);return!!i&&(i.value&&"object"==typeof i.value&&(i=i.value),!1===i.configurable)}((n||t).prototype,r)){//  Just skip the final property
if(s.ignoreFinals)continue;//  We cannot re-define a property that is configurable=false.
//  So we will consider them final and throw an error. This is by
//  default so it is clear to the developer what is happening.
//  You can set ignoreFinals to true if you need to extend a class
//  which has configurable=false; it will simply not re-define final properties.
throw Error("cannot override final property '"+r+"', set Class.ignoreFinals = true to skip")}Object.defineProperty(t.prototype,r,o)}else t.prototype[r]=e[r]}}/**
 * Applies the given `mixins` to the prototype of `myClass`.
 *
 * @function mixin
 * @param {Object} myClass The constructor object to mix into.
 * @param {Object|Array<Object>} mixins The mixins to apply to the constructor.
 */function n(t,e){if(e){Array.isArray(e)||(e=[e]);for(var n=0;n<e.length;n++)i(t,e[n].prototype||e[n])}}/**
 * Creates a new class with the given descriptor.
 * The constructor, defined by the name `initialize`,
 * is an optional function. If unspecified, an anonymous
 * function will be used which calls the parent class (if
 * one exists).
 *
 * You can also use `Extends` and `Mixins` to provide subclassing
 * and inheritance.
 *
 * @class Phaser.Class
 * @constructor
 * @param {Object} definition a dictionary of functions for the class
 * @example
 *
 *      var MyClass = new Phaser.Class({
 *
 *          initialize: function() {
 *              this.foo = 2.0;
 *          },
 *
 *          bar: function() {
 *              return this.foo + 5;
 *          }
 *      });
 */function s(t){if(t||(t={}),t.initialize){if("function"!=typeof t.initialize)throw Error("initialize must be a function");e=t.initialize,//  Usually we should avoid 'delete' in V8 at all costs.
//  However, its unlikely to make any performance difference
//  here since we only call this on class creation (i.e. not object creation).
delete t.initialize}else if(t.Extends){var e,s,r=t.Extends;e=function(){r.apply(this,arguments)}}else e=function(){};t.Extends?(e.prototype=Object.create(t.Extends.prototype),e.prototype.constructor=e,//  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)
s=t.Extends,delete t.Extends):e.prototype.constructor=e;//  Grab the mixins, if they are specified...
var o=null;return t.Mixins&&(o=t.Mixins,delete t.Mixins),//  First, mixin if we can.
n(e,o),//  Now we grab the actual definition which defines the overrides.
i(e,t,!0,s),e}s.extend=i,s.mixin=n,s.ignoreFinals=!1,t.exports=s}),r("6hp2k",function(t,e){t.exports=function(t,e,i){return(//  Check if x/y are within the bounds first
t.radius>0&&e>=t.left&&e<=t.right&&i>=t.top&&i<=t.bottom&&(t.x-e)*(t.x-e)+(t.y-i)*(t.y-i)<=t.radius*t.radius)}}),r("dM9Ux",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("67VV6"),n=s("hqfaz"),r=s("bNtDi"),o=s("cSEB9");t.exports=function(t,e,s){return void 0===s&&(s=new o),i(t,n(e,0,r.PI2),s)}}),r("67VV6",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e,n){return void 0===n&&(n=new i),n.x=t.x+t.radius*Math.cos(e),n.y=t.y+t.radius*Math.sin(e),n}}),r("cSEB9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("gZ2BZ"),r=new i({initialize:function(t,e){void 0===t&&(t=0),void 0===e&&(e=t),/**
         * The geometry constant type of this object: `GEOM_CONST.POINT`.
         * Used for fast type comparisons.
         *
         * @name Phaser.Geom.Point#type
         * @type {integer}
         * @readonly
         * @since 3.19.0
         */this.type=n.POINT,/**
         * The x coordinate of this Point.
         *
         * @name Phaser.Geom.Point#x
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.x=t,/**
         * The y coordinate of this Point.
         *
         * @name Phaser.Geom.Point#y
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.y=e},/**
     * Set the x and y coordinates of the point to the given values.
     *
     * @method Phaser.Geom.Point#setTo
     * @since 3.0.0
     *
     * @param {number} [x=0] - The x coordinate of this Point.
     * @param {number} [y=x] - The y coordinate of this Point.
     *
     * @return {this} This Point object.
     */setTo:function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),this.x=t,this.y=e,this}});t.exports=r}),r("gZ2BZ",function(t,e){t.exports={/**
     * A Circle Geometry object type.
     * 
     * @name Phaser.Geom.CIRCLE
     * @type {integer}
     * @since 3.19.0
     */CIRCLE:0,/**
     * An Ellipse Geometry object type.
     * 
     * @name Phaser.Geom.ELLIPSE
     * @type {integer}
     * @since 3.19.0
     */ELLIPSE:1,/**
     * A Line Geometry object type.
     * 
     * @name Phaser.Geom.LINE
     * @type {integer}
     * @since 3.19.0
     */LINE:2,/**
     * A Point Geometry object type.
     * 
     * @name Phaser.Geom.POINT
     * @type {integer}
     * @since 3.19.0
     */POINT:3,/**
     * A Polygon Geometry object type.
     * 
     * @name Phaser.Geom.POLYGON
     * @type {integer}
     * @since 3.19.0
     */POLYGON:4,/**
     * A Rectangle Geometry object type.
     * 
     * @name Phaser.Geom.RECTANGLE
     * @type {integer}
     * @since 3.19.0
     */RECTANGLE:5,/**
     * A Triangle Geometry object type.
     * 
     * @name Phaser.Geom.TRIANGLE
     * @type {integer}
     * @since 3.19.0
     */TRIANGLE:6}}),r("hqfaz",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iEUUO");t.exports=function(t,e,n){return(n-e)*(t=i(t,0,1))}}),r("iEUUO",function(t,e){t.exports=function(t,e,i){return Math.max(e,Math.min(i,t))}}),r("bNtDi",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i={/**
     * The value of PI * 2.
     * 
     * @name Phaser.Math.PI2
     * @type {number}
     * @since 3.0.0
     */PI2:2*Math.PI,/**
     * The value of PI * 0.5.
     * 
     * @name Phaser.Math.TAU
     * @type {number}
     * @since 3.0.0
     */TAU:.5*Math.PI,/**
     * An epsilon value (1.0e-6)
     * 
     * @name Phaser.Math.EPSILON
     * @type {number}
     * @since 3.0.0
     */EPSILON:1e-6,/**
     * For converting degrees to radians (PI / 180)
     * 
     * @name Phaser.Math.DEG_TO_RAD
     * @type {number}
     * @since 3.0.0
     */DEG_TO_RAD:Math.PI/180,/**
     * For converting radians to degrees (180 / PI)
     * 
     * @name Phaser.Math.RAD_TO_DEG
     * @type {number}
     * @since 3.0.0
     */RAD_TO_DEG:180/Math.PI,/**
     * An instance of the Random Number Generator.
     * This is not set until the Game boots.
     * 
     * @name Phaser.Math.RND
     * @type {Phaser.Math.RandomDataGenerator}
     * @since 3.0.0
     */RND:null,/**
     * The minimum safe integer this browser supports.
     * We use a const for backward compatibility with Internet Explorer.
     * 
     * @name Phaser.Math.MIN_SAFE_INTEGER
     * @type {number}
     * @since 3.21.0
     */MIN_SAFE_INTEGER:Number.MIN_SAFE_INTEGER||-9007199254740991,/**
     * The maximum safe integer this browser supports.
     * We use a const for backward compatibility with Internet Explorer.
     * 
     * @name Phaser.Math.MAX_SAFE_INTEGER
     * @type {number}
     * @since 3.21.0
     */MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER||9007199254740991};t.exports=i}),r("80QEd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("c6ED3"),n=s("67VV6"),r=s("hqfaz"),o=s("bNtDi");t.exports=function(t,e,s,a){void 0===a&&(a=[]),!e&&s>0&&(e=i(t)/s);for(var h=0;h<e;h++){var l=r(h/e,0,o.PI2);a.push(n(t,l))}return a}}),r("c6ED3",function(t,e){t.exports=function(t){return 2*(Math.PI*t.radius)}}),r("9zIIl",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e){void 0===e&&(e=new i);var n=2*Math.PI*Math.random(),s=Math.random()+Math.random(),r=s>1?2-s:s,o=r*Math.cos(n),a=r*Math.sin(n);return e.x=t.x+o*t.radius,e.y=t.y+a*t.radius,e}}),r("4FF1v",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.GameObjects.Components
 */t.exports={Alpha:s("25pf7"),AlphaSingle:s("gRRWm"),Animation:s("18ZZu"),BlendMode:s("2UeGA"),ComputedSize:s("cbj9c"),Crop:s("bhbp7"),Depth:s("1CJAb"),Flip:s("fdnq8"),GetBounds:s("9r3lX"),Mask:s("42G5m"),Origin:s("18U1b"),PathFollower:s("dNtLk"),Pipeline:s("DznIZ"),ScrollFactor:s("hKiq1"),Size:s("aOXwH"),Texture:s("1qQq2"),TextureCrop:s("iwi57"),Tint:s("fpsqk"),ToJSON:s("bvPjF"),Transform:s("i5mxL"),TransformMatrix:s("azs1m"),Visible:s("fVg1f")}}),r("25pf7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iEUUO");t.exports={/**
     * Private internal value. Holds the global alpha value.
     *
     * @name Phaser.GameObjects.Components.Alpha#_alpha
     * @type {number}
     * @private
     * @default 1
     * @since 3.0.0
     */_alpha:1,/**
     * Private internal value. Holds the top-left alpha value.
     *
     * @name Phaser.GameObjects.Components.Alpha#_alphaTL
     * @type {number}
     * @private
     * @default 1
     * @since 3.0.0
     */_alphaTL:1,/**
     * Private internal value. Holds the top-right alpha value.
     *
     * @name Phaser.GameObjects.Components.Alpha#_alphaTR
     * @type {number}
     * @private
     * @default 1
     * @since 3.0.0
     */_alphaTR:1,/**
     * Private internal value. Holds the bottom-left alpha value.
     *
     * @name Phaser.GameObjects.Components.Alpha#_alphaBL
     * @type {number}
     * @private
     * @default 1
     * @since 3.0.0
     */_alphaBL:1,/**
     * Private internal value. Holds the bottom-right alpha value.
     *
     * @name Phaser.GameObjects.Components.Alpha#_alphaBR
     * @type {number}
     * @private
     * @default 1
     * @since 3.0.0
     */_alphaBR:1,/**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     *
     * @method Phaser.GameObjects.Components.Alpha#clearAlpha
     * @since 3.0.0
     *
     * @return {this} This Game Object instance.
     */clearAlpha:function(){return this.setAlpha(1)},/**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * If your game is running under WebGL you can optionally specify four different alpha values, each of which
     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
     *
     * @method Phaser.GameObjects.Components.Alpha#setAlpha
     * @since 3.0.0
     *
     * @param {number} [topLeft=1] - The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object.
     * @param {number} [topRight] - The alpha value used for the top-right of the Game Object. WebGL only.
     * @param {number} [bottomLeft] - The alpha value used for the bottom-left of the Game Object. WebGL only.
     * @param {number} [bottomRight] - The alpha value used for the bottom-right of the Game Object. WebGL only.
     *
     * @return {this} This Game Object instance.
     */setAlpha:function(t,e,n,s){return void 0===t&&(t=1),void 0===e?this.alpha=t:(this._alphaTL=i(t,0,1),this._alphaTR=i(e,0,1),this._alphaBL=i(n,0,1),this._alphaBR=i(s,0,1)),this},/**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     *
     * @name Phaser.GameObjects.Components.Alpha#alpha
     * @type {number}
     * @since 3.0.0
     */alpha:{get:function(){return this._alpha},set:function(t){var e=i(t,0,1);this._alpha=e,this._alphaTL=e,this._alphaTR=e,this._alphaBL=e,this._alphaBR=e,0===e?this.renderFlags&=-3:this.renderFlags|=2}},/**
     * The alpha value starting from the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     *
     * @name Phaser.GameObjects.Components.Alpha#alphaTopLeft
     * @type {number}
     * @webglOnly
     * @since 3.0.0
     */alphaTopLeft:{get:function(){return this._alphaTL},set:function(t){var e=i(t,0,1);this._alphaTL=e,0!==e&&(this.renderFlags|=2)}},/**
     * The alpha value starting from the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     *
     * @name Phaser.GameObjects.Components.Alpha#alphaTopRight
     * @type {number}
     * @webglOnly
     * @since 3.0.0
     */alphaTopRight:{get:function(){return this._alphaTR},set:function(t){var e=i(t,0,1);this._alphaTR=e,0!==e&&(this.renderFlags|=2)}},/**
     * The alpha value starting from the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     *
     * @name Phaser.GameObjects.Components.Alpha#alphaBottomLeft
     * @type {number}
     * @webglOnly
     * @since 3.0.0
     */alphaBottomLeft:{get:function(){return this._alphaBL},set:function(t){var e=i(t,0,1);this._alphaBL=e,0!==e&&(this.renderFlags|=2)}},/**
     * The alpha value starting from the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     *
     * @name Phaser.GameObjects.Components.Alpha#alphaBottomRight
     * @type {number}
     * @webglOnly
     * @since 3.0.0
     */alphaBottomRight:{get:function(){return this._alphaBR},set:function(t){var e=i(t,0,1);this._alphaBR=e,0!==e&&(this.renderFlags|=2)}}}}),r("gRRWm",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iEUUO");t.exports={/**
     * Private internal value. Holds the global alpha value.
     *
     * @name Phaser.GameObjects.Components.AlphaSingle#_alpha
     * @type {number}
     * @private
     * @default 1
     * @since 3.0.0
     */_alpha:1,/**
     * Clears all alpha values associated with this Game Object.
     *
     * Immediately sets the alpha levels back to 1 (fully opaque).
     *
     * @method Phaser.GameObjects.Components.AlphaSingle#clearAlpha
     * @since 3.0.0
     *
     * @return {this} This Game Object instance.
     */clearAlpha:function(){return this.setAlpha(1)},/**
     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * @method Phaser.GameObjects.Components.AlphaSingle#setAlpha
     * @since 3.0.0
     *
     * @param {number} [value=1] - The alpha value applied across the whole Game Object.
     *
     * @return {this} This Game Object instance.
     */setAlpha:function(t){return void 0===t&&(t=1),this.alpha=t,this},/**
     * The alpha value of the Game Object.
     *
     * This is a global value, impacting the entire Game Object, not just a region of it.
     *
     * @name Phaser.GameObjects.Components.AlphaSingle#alpha
     * @type {number}
     * @since 3.0.0
     */alpha:{get:function(){return this._alpha},set:function(t){var e=i(t,0,1);this._alpha=e,0===e?this.renderFlags&=-3:this.renderFlags|=2}}}}),r("18ZZu",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6gscN"),n=s("jwj1g"),r=s("61xd9"),o=new n({initialize:function(t){/**
         * The Game Object to which this animation controller belongs.
         *
         * @name Phaser.GameObjects.Components.Animation#parent
         * @type {Phaser.GameObjects.GameObject}
         * @since 3.0.0
         */this.parent=t,/**
         * A reference to the global Animation Manager.
         *
         * @name Phaser.GameObjects.Components.Animation#animationManager
         * @type {Phaser.Animations.AnimationManager}
         * @since 3.0.0
         */this.animationManager=t.scene.sys.anims,this.animationManager.once(r.REMOVE_ANIMATION,this.remove,this),/**
         * Is an animation currently playing or not?
         *
         * @name Phaser.GameObjects.Components.Animation#isPlaying
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.isPlaying=!1,/**
         * The current Animation loaded into this Animation Controller.
         *
         * @name Phaser.GameObjects.Components.Animation#currentAnim
         * @type {?Phaser.Animations.Animation}
         * @default null
         * @since 3.0.0
         */this.currentAnim=null,/**
         * The current AnimationFrame being displayed by this Animation Controller.
         *
         * @name Phaser.GameObjects.Components.Animation#currentFrame
         * @type {?Phaser.Animations.AnimationFrame}
         * @default null
         * @since 3.0.0
         */this.currentFrame=null,/**
         * The key of the next Animation to be loaded into this Animation Controller when the current animation completes.
         *
         * @name Phaser.GameObjects.Components.Animation#nextAnim
         * @type {?string}
         * @default null
         * @since 3.16.0
         */this.nextAnim=null,/**
         * Time scale factor.
         *
         * @name Phaser.GameObjects.Components.Animation#_timeScale
         * @type {number}
         * @private
         * @default 1
         * @since 3.0.0
         */this._timeScale=1,/**
         * The frame rate of playback in frames per second.
         * The default is 24 if the `duration` property is `null`.
         *
         * @name Phaser.GameObjects.Components.Animation#frameRate
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.frameRate=0,/**
         * How long the animation should play for, in milliseconds.
         * If the `frameRate` property has been set then it overrides this value,
         * otherwise the `frameRate` is derived from `duration`.
         *
         * @name Phaser.GameObjects.Components.Animation#duration
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.duration=0,/**
         * ms per frame, not including frame specific modifiers that may be present in the Animation data.
         *
         * @name Phaser.GameObjects.Components.Animation#msPerFrame
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.msPerFrame=0,/**
         * Skip frames if the time lags, or always advanced anyway?
         *
         * @name Phaser.GameObjects.Components.Animation#skipMissedFrames
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.skipMissedFrames=!0,/**
         * A delay before starting playback, in milliseconds.
         *
         * @name Phaser.GameObjects.Components.Animation#_delay
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._delay=0,/**
         * Number of times to repeat the animation (-1 for infinity)
         *
         * @name Phaser.GameObjects.Components.Animation#_repeat
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._repeat=0,/**
         * Delay before the repeat starts, in milliseconds.
         *
         * @name Phaser.GameObjects.Components.Animation#_repeatDelay
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._repeatDelay=0,/**
         * Should the animation yoyo? (reverse back down to the start) before repeating?
         *
         * @name Phaser.GameObjects.Components.Animation#_yoyo
         * @type {boolean}
         * @private
         * @default false
         * @since 3.0.0
         */this._yoyo=!1,/**
         * Will the playhead move forwards (`true`) or in reverse (`false`).
         *
         * @name Phaser.GameObjects.Components.Animation#forward
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.forward=!0,/**
         * An Internal trigger that's play the animation in reverse mode ('true') or not ('false'),
         * needed because forward can be changed by yoyo feature.
         *
         * @name Phaser.GameObjects.Components.Animation#_reverse
         * @type {boolean}
         * @default false
         * @private
         * @since 3.12.0
         */this._reverse=!1,/**
         * Internal time overflow accumulator.
         *
         * @name Phaser.GameObjects.Components.Animation#accumulator
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.accumulator=0,/**
         * The time point at which the next animation frame will change.
         *
         * @name Phaser.GameObjects.Components.Animation#nextTick
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.nextTick=0,/**
         * An internal counter keeping track of how many repeats are left to play.
         *
         * @name Phaser.GameObjects.Components.Animation#repeatCounter
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.repeatCounter=0,/**
         * An internal flag keeping track of pending repeats.
         *
         * @name Phaser.GameObjects.Components.Animation#pendingRepeat
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.pendingRepeat=!1,/**
         * Is the Animation paused?
         *
         * @name Phaser.GameObjects.Components.Animation#_paused
         * @type {boolean}
         * @private
         * @default false
         * @since 3.0.0
         */this._paused=!1,/**
         * Was the animation previously playing before being paused?
         *
         * @name Phaser.GameObjects.Components.Animation#_wasPlaying
         * @type {boolean}
         * @private
         * @default false
         * @since 3.0.0
         */this._wasPlaying=!1,/**
         * Internal property tracking if this Animation is waiting to stop.
         *
         * 0 = No
         * 1 = Waiting for ms to pass
         * 2 = Waiting for repeat
         * 3 = Waiting for specific frame
         *
         * @name Phaser.GameObjects.Components.Animation#_pendingStop
         * @type {integer}
         * @private
         * @since 3.4.0
         */this._pendingStop=0,/**
         * Internal property used by _pendingStop.
         *
         * @name Phaser.GameObjects.Components.Animation#_pendingStopValue
         * @type {any}
         * @private
         * @since 3.4.0
         */this._pendingStopValue},/**
     * Sets an animation to be played immediately after the current one completes.
     *
     * The current animation must enter a 'completed' state for this to happen, i.e. finish all of its repeats, delays, etc, or have the `stop` method called directly on it.
     *
     * An animation set to repeat forever will never enter a completed state.
     *
     * You can chain a new animation at any point, including before the current one starts playing, during it, or when it ends (via its `animationcomplete` callback).
     * Chained animations are specific to a Game Object, meaning different Game Objects can have different chained animations without impacting the global animation they're playing.
     *
     * Call this method with no arguments to reset the chained animation.
     *
     * @method Phaser.GameObjects.Components.Animation#chain
     * @since 3.16.0
     *
     * @param {(string|Phaser.Animations.Animation)} [key] - The string-based key of the animation to play next, as defined previously in the Animation Manager. Or an Animation instance.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */chain:function(t){return t instanceof i&&(t=t.key),this.nextAnim=t,this.parent},/**
     * Sets the amount of time, in milliseconds, that the animation will be delayed before starting playback.
     *
     * @method Phaser.GameObjects.Components.Animation#setDelay
     * @since 3.4.0
     *
     * @param {integer} [value=0] - The amount of time, in milliseconds, to wait before starting playback.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */setDelay:function(t){return void 0===t&&(t=0),this._delay=t,this.parent},/**
     * Gets the amount of time, in milliseconds that the animation will be delayed before starting playback.
     *
     * @method Phaser.GameObjects.Components.Animation#getDelay
     * @since 3.4.0
     *
     * @return {integer} The amount of time, in milliseconds, the Animation will wait before starting playback.
     */getDelay:function(){return this._delay},/**
     * Waits for the specified delay, in milliseconds, then starts playback of the requested animation.
     *
     * @method Phaser.GameObjects.Components.Animation#delayedPlay
     * @since 3.0.0
     *
     * @param {integer} delay - The delay, in milliseconds, to wait before starting the animation playing.
     * @param {string} key - The key of the animation to play.
     * @param {integer} [startFrame=0] - The frame of the animation to start from.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */delayedPlay:function(t,e,i){return this.play(e,!0,i),this.nextTick+=t,this.parent},/**
     * Returns the key of the animation currently loaded into this component.
     *
     * @method Phaser.GameObjects.Components.Animation#getCurrentKey
     * @since 3.0.0
     *
     * @return {string} The key of the Animation loaded into this component.
     */getCurrentKey:function(){if(this.currentAnim)return this.currentAnim.key},/**
     * Internal method used to load an animation into this component.
     *
     * @method Phaser.GameObjects.Components.Animation#load
     * @protected
     * @since 3.0.0
     *
     * @param {string} key - The key of the animation to load.
     * @param {integer} [startFrame=0] - The start frame of the animation to load.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */load:function(t,e){return void 0===e&&(e=0),this.isPlaying&&this.stop(),//  Load the new animation in
this.animationManager.load(this,t,e),this.parent},/**
     * Pause the current animation and set the `isPlaying` property to `false`.
     * You can optionally pause it at a specific frame.
     *
     * @method Phaser.GameObjects.Components.Animation#pause
     * @since 3.0.0
     *
     * @param {Phaser.Animations.AnimationFrame} [atFrame] - An optional frame to set after pausing the animation.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */pause:function(t){return this._paused||(this._paused=!0,this._wasPlaying=this.isPlaying,this.isPlaying=!1),void 0!==t&&this.updateFrame(t),this.parent},/**
     * Resumes playback of a paused animation and sets the `isPlaying` property to `true`.
     * You can optionally tell it to start playback from a specific frame.
     *
     * @method Phaser.GameObjects.Components.Animation#resume
     * @since 3.0.0
     *
     * @param {Phaser.Animations.AnimationFrame} [fromFrame] - An optional frame to set before restarting playback.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */resume:function(t){return this._paused&&(this._paused=!1,this.isPlaying=this._wasPlaying),void 0!==t&&this.updateFrame(t),this.parent},/**
     * `true` if the current animation is paused, otherwise `false`.
     *
     * @name Phaser.GameObjects.Components.Animation#isPaused
     * @readonly
     * @type {boolean}
     * @since 3.4.0
     */isPaused:{get:function(){return this._paused}},/**
     * Plays an Animation on a Game Object that has the Animation component, such as a Sprite.
     *
     * Animations are stored in the global Animation Manager and are referenced by a unique string-based key.
     *
     * @method Phaser.GameObjects.Components.Animation#play
     * @fires Phaser.GameObjects.Components.Animation#onStartEvent
     * @since 3.0.0
     *
     * @param {(string|Phaser.Animations.Animation)} key - The string-based key of the animation to play, as defined previously in the Animation Manager. Or an Animation instance.
     * @param {boolean} [ignoreIfPlaying=false] - If this animation is already playing then ignore this call.
     * @param {integer} [startFrame=0] - Optionally start the animation playing from this frame index.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */play:function(t,e,n){return(void 0===e&&(e=!1),void 0===n&&(n=0),t instanceof i&&(t=t.key),e&&this.isPlaying&&this.currentAnim.key===t)?this.parent:(this.forward=!0,this._reverse=!1,this._paused=!1,this._wasPlaying=!0,this._startAnimation(t,n))},/**
     * Plays an Animation (in reverse mode) on the Game Object that owns this Animation Component.
     *
     * @method Phaser.GameObjects.Components.Animation#playReverse
     * @fires Phaser.GameObjects.Components.Animation#onStartEvent
     * @since 3.12.0
     *
     * @param {(string|Phaser.Animations.Animation)} key - The string-based key of the animation to play, as defined previously in the Animation Manager. Or an Animation instance.
     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.
     * @param {integer} [startFrame=0] - Optionally start the animation playing from this frame index.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */playReverse:function(t,e,n){return(void 0===e&&(e=!1),void 0===n&&(n=0),t instanceof i&&(t=t.key),e&&this.isPlaying&&this.currentAnim.key===t)?this.parent:(this.forward=!1,this._reverse=!0,this._startAnimation(t,n))},/**
     * Load an Animation and fires 'onStartEvent' event, extracted from 'play' method.
     *
     * @method Phaser.GameObjects.Components.Animation#_startAnimation
     * @fires Phaser.Animations.Events#ANIMATION_START
     * @fires Phaser.Animations.Events#SPRITE_ANIMATION_START
     * @fires Phaser.Animations.Events#SPRITE_ANIMATION_KEY_START
     * @since 3.12.0
     *
     * @param {string} key - The string-based key of the animation to play, as defined previously in the Animation Manager.
     * @param {integer} [startFrame=0] - Optionally start the animation playing from this frame index.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */_startAnimation:function(t,e){this.load(t,e);var i=this.currentAnim,n=this.parent;if(!i)return n;//  Should give us 9,007,199,254,740,991 safe repeats
this.repeatCounter=-1===this._repeat?Number.MAX_VALUE:this._repeat,i.getFirstTick(this),this.isPlaying=!0,this.pendingRepeat=!1,i.showOnStart&&(n.visible=!0);var s=this.currentFrame;return i.emit(r.ANIMATION_START,i,s,n),n.emit(r.SPRITE_ANIMATION_KEY_START+t,i,s,n),n.emit(r.SPRITE_ANIMATION_START,i,s,n),n},/**
     * Reverse the Animation that is already playing on the Game Object.
     *
     * @method Phaser.GameObjects.Components.Animation#reverse
     * @since 3.12.0
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */reverse:function(){return this.isPlaying&&(this._reverse=!this._reverse,this.forward=!this.forward),this.parent},/**
     * Returns a value between 0 and 1 indicating how far this animation is through, ignoring repeats and yoyos.
     * If the animation has a non-zero repeat defined, `getProgress` and `getTotalProgress` will be different
     * because `getProgress` doesn't include any repeats or repeat delays, whereas `getTotalProgress` does.
     *
     * @method Phaser.GameObjects.Components.Animation#getProgress
     * @since 3.4.0
     *
     * @return {number} The progress of the current animation, between 0 and 1.
     */getProgress:function(){var t=this.currentFrame.progress;return this.forward||(t=1-t),t},/**
     * Takes a value between 0 and 1 and uses it to set how far this animation is through playback.
     * Does not factor in repeats or yoyos, but does handle playing forwards or backwards.
     *
     * @method Phaser.GameObjects.Components.Animation#setProgress
     * @since 3.4.0
     *
     * @param {number} [value=0] - The progress value, between 0 and 1.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */setProgress:function(t){return this.forward||(t=1-t),this.setCurrentFrame(this.currentAnim.getFrameByProgress(t)),this.parent},/**
     * Handle the removal of an animation from the Animation Manager.
     *
     * @method Phaser.GameObjects.Components.Animation#remove
     * @since 3.0.0
     *
     * @param {string} [key] - The key of the removed Animation.
     * @param {Phaser.Animations.Animation} [animation] - The removed Animation.
     */remove:function(t,e){void 0===e&&(e=this.currentAnim),this.isPlaying&&e.key===this.currentAnim.key&&(this.stop(),this.setCurrentFrame(this.currentAnim.frames[0]))},/**
     * Gets the number of times that the animation will repeat
     * after its first iteration. For example, if returns 1, the animation will
     * play a total of twice (the initial play plus 1 repeat).
     * A value of -1 means the animation will repeat indefinitely.
     *
     * @method Phaser.GameObjects.Components.Animation#getRepeat
     * @since 3.4.0
     *
     * @return {integer} The number of times that the animation will repeat.
     */getRepeat:function(){return this._repeat},/**
     * Sets the number of times that the animation should repeat
     * after its first iteration. For example, if repeat is 1, the animation will
     * play a total of twice (the initial play plus 1 repeat).
     * To repeat indefinitely, use -1. repeat should always be an integer.
     *
     * @method Phaser.GameObjects.Components.Animation#setRepeat
     * @since 3.4.0
     *
     * @param {integer} value - The number of times that the animation should repeat.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */setRepeat:function(t){return this._repeat=t,this.repeatCounter=-1===t?Number.MAX_VALUE:t,this.parent},/**
     * Gets the amount of delay between repeats, if any.
     *
     * @method Phaser.GameObjects.Components.Animation#getRepeatDelay
     * @since 3.4.0
     *
     * @return {number} The delay between repeats.
     */getRepeatDelay:function(){return this._repeatDelay},/**
     * Sets the amount of time in seconds between repeats.
     * For example, if `repeat` is 2 and `repeatDelay` is 10, the animation will play initially,
     * then wait for 10 seconds before repeating, then play again, then wait another 10 seconds
     * before doing its final repeat.
     *
     * @method Phaser.GameObjects.Components.Animation#setRepeatDelay
     * @since 3.4.0
     *
     * @param {number} value - The delay to wait between repeats, in seconds.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */setRepeatDelay:function(t){return this._repeatDelay=t,this.parent},/**
     * Restarts the current animation from its beginning, optionally including its delay value.
     *
     * @method Phaser.GameObjects.Components.Animation#restart
     * @fires Phaser.Animations.Events#ANIMATION_RESTART
     * @fires Phaser.Animations.Events#SPRITE_ANIMATION_RESTART
     * @fires Phaser.Animations.Events#SPRITE_ANIMATION_KEY_RESTART
     * @since 3.0.0
     *
     * @param {boolean} [includeDelay=false] - Whether to include the delay value of the animation when restarting.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */restart:function(t){void 0===t&&(t=!1);var e=this.currentAnim;e.getFirstTick(this,t),this.forward=!0,this.isPlaying=!0,this.pendingRepeat=!1,this._paused=!1,//  Set frame
this.updateFrame(e.frames[0]);var i=this.parent,n=this.currentFrame;return e.emit(r.ANIMATION_RESTART,e,n,i),i.emit(r.SPRITE_ANIMATION_KEY_RESTART+e.key,e,n,i),i.emit(r.SPRITE_ANIMATION_RESTART,e,n,i),this.parent},/**
     * Immediately stops the current animation from playing and dispatches the `animationcomplete` event.
     *
     * If no animation is set, no event will be dispatched.
     *
     * If there is another animation queued (via the `chain` method) then it will start playing immediately.
     *
     * @method Phaser.GameObjects.Components.Animation#stop
     * @fires Phaser.GameObjects.Components.Animation#onCompleteEvent
     * @since 3.0.0
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */stop:function(){this._pendingStop=0,this.isPlaying=!1;var t=this.parent,e=this.currentAnim,i=this.currentFrame;if(e&&(e.emit(r.ANIMATION_COMPLETE,e,i,t),t.emit(r.SPRITE_ANIMATION_KEY_COMPLETE+e.key,e,i,t),t.emit(r.SPRITE_ANIMATION_COMPLETE,e,i,t)),this.nextAnim){var n=this.nextAnim;this.nextAnim=null,this.play(n)}return t},/**
     * Stops the current animation from playing after the specified time delay, given in milliseconds.
     *
     * @method Phaser.GameObjects.Components.Animation#stopAfterDelay
     * @fires Phaser.GameObjects.Components.Animation#onCompleteEvent
     * @since 3.4.0
     *
     * @param {integer} delay - The number of milliseconds to wait before stopping this animation.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */stopAfterDelay:function(t){return this._pendingStop=1,this._pendingStopValue=t,this.parent},/**
     * Stops the current animation from playing when it next repeats.
     *
     * @method Phaser.GameObjects.Components.Animation#stopOnRepeat
     * @fires Phaser.GameObjects.Components.Animation#onCompleteEvent
     * @since 3.4.0
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */stopOnRepeat:function(){return this._pendingStop=2,this.parent},/**
     * Stops the current animation from playing when it next sets the given frame.
     * If this frame doesn't exist within the animation it will not stop it from playing.
     *
     * @method Phaser.GameObjects.Components.Animation#stopOnFrame
     * @fires Phaser.GameObjects.Components.Animation#onCompleteEvent
     * @since 3.4.0
     *
     * @param {Phaser.Animations.AnimationFrame} frame - The frame to check before stopping this animation.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */stopOnFrame:function(t){return this._pendingStop=3,this._pendingStopValue=t,this.parent},/**
     * Sets the Time Scale factor, allowing you to make the animation go go faster or slower than default.
     * Where 1 = normal speed (the default), 0.5 = half speed, 2 = double speed, etc.
     *
     * @method Phaser.GameObjects.Components.Animation#setTimeScale
     * @since 3.4.0
     *
     * @param {number} [value=1] - The time scale factor, where 1 is no change, 0.5 is half speed, etc.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.
     */setTimeScale:function(t){return void 0===t&&(t=1),this._timeScale=t,this.parent},/**
     * Gets the Time Scale factor.
     *
     * @method Phaser.GameObjects.Components.Animation#getTimeScale
     * @since 3.4.0
     *
     * @return {number} The Time Scale value.
     */getTimeScale:function(){return this._timeScale},/**
     * Returns the total number of frames in this animation.
     *
     * @method Phaser.GameObjects.Components.Animation#getTotalFrames
     * @since 3.4.0
     *
     * @return {integer} The total number of frames in this animation.
     */getTotalFrames:function(){return this.currentAnim.frames.length},/**
     * The internal update loop for the Animation Component.
     *
     * @method Phaser.GameObjects.Components.Animation#update
     * @since 3.0.0
     *
     * @param {number} time - The current timestamp.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */update:function(t,e){if(this.currentAnim&&this.isPlaying&&!this.currentAnim.paused){if(this.accumulator+=e*this._timeScale,1===this._pendingStop&&(this._pendingStopValue-=e,this._pendingStopValue<=0))return this.currentAnim.completeAnimation(this);this.accumulator>=this.nextTick&&this.currentAnim.setFrame(this)}},/**
     * Sets the given Animation Frame as being the current frame
     * and applies it to the parent Game Object, adjusting its size and origin as needed.
     *
     * @method Phaser.GameObjects.Components.Animation#setCurrentFrame
     * @since 3.4.0
     *
     * @param {Phaser.Animations.AnimationFrame} animationFrame - The Animation Frame to set as being current.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object this Animation Component belongs to.
     */setCurrentFrame:function(t){var e=this.parent;return this.currentFrame=t,e.texture=t.frame.texture,e.frame=t.frame,e.isCropped&&e.frame.updateCropUVs(e._crop,e.flipX,e.flipY),e.setSizeToFrame(),e._originComponent&&(t.frame.customPivot?e.setOrigin(t.frame.pivotX,t.frame.pivotY):e.updateDisplayOrigin()),e},/**
     * Internal frame change handler.
     *
     * @method Phaser.GameObjects.Components.Animation#updateFrame
     * @fires Phaser.Animations.Events#SPRITE_ANIMATION_UPDATE
     * @fires Phaser.Animations.Events#SPRITE_ANIMATION_KEY_UPDATE
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.Animations.AnimationFrame} animationFrame - The animation frame to change to.
     */updateFrame:function(t){var e=this.setCurrentFrame(t);if(this.isPlaying){t.setAlpha&&(e.alpha=t.alpha);var i=this.currentAnim;e.emit(r.SPRITE_ANIMATION_KEY_UPDATE+i.key,i,t,e),e.emit(r.SPRITE_ANIMATION_UPDATE,i,t,e),3===this._pendingStop&&this._pendingStopValue===t&&this.currentAnim.completeAnimation(this)}},/**
     * Advances the animation to the next frame, regardless of the time or animation state.
     * If the animation is set to repeat, or yoyo, this will still take effect.
     *
     * Calling this does not change the direction of the animation. I.e. if it was currently
     * playing in reverse, calling this method doesn't then change the direction to forwards.
     *
     * @method Phaser.GameObjects.Components.Animation#nextFrame
     * @since 3.16.0
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object this Animation Component belongs to.
     */nextFrame:function(){return this.currentAnim&&this.currentAnim.nextFrame(this),this.parent},/**
     * Advances the animation to the previous frame, regardless of the time or animation state.
     * If the animation is set to repeat, or yoyo, this will still take effect.
     *
     * Calling this does not change the direction of the animation. I.e. if it was currently
     * playing in forwards, calling this method doesn't then change the direction to backwards.
     *
     * @method Phaser.GameObjects.Components.Animation#previousFrame
     * @since 3.16.0
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object this Animation Component belongs to.
     */previousFrame:function(){return this.currentAnim&&this.currentAnim.previousFrame(this),this.parent},/**
     * Sets if the current Animation will yoyo when it reaches the end.
     * A yoyo'ing animation will play through consecutively, and then reverse-play back to the start again.
     *
     * @method Phaser.GameObjects.Components.Animation#setYoyo
     * @since 3.4.0
     *
     * @param {boolean} [value=false] - `true` if the animation should yoyo, `false` to not.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object this Animation Component belongs to.
     */setYoyo:function(t){return void 0===t&&(t=!1),this._yoyo=t,this.parent},/**
     * Gets if the current Animation will yoyo when it reaches the end.
     * A yoyo'ing animation will play through consecutively, and then reverse-play back to the start again.
     *
     * @method Phaser.GameObjects.Components.Animation#getYoyo
     * @since 3.4.0
     *
     * @return {boolean} `true` if the animation is set to yoyo, `false` if not.
     */getYoyo:function(){return this._yoyo},/**
     * Destroy this Animation component.
     *
     * Unregisters event listeners and cleans up its references.
     *
     * @method Phaser.GameObjects.Components.Animation#destroy
     * @since 3.0.0
     */destroy:function(){this.animationManager.off(r.REMOVE_ANIMATION,this.remove,this),this.animationManager=null,this.parent=null,this.currentAnim=null,this.currentFrame=null}});t.exports=o}),r("6gscN",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iEUUO"),n=s("jwj1g"),r=s("3vRz3"),o=s("61xd9"),a=s("3tt0c"),h=s("cDvmt"),l=s("5pMDk"),u=new n({Extends:r,initialize:function(t,e,i){r.call(this),/**
         * A reference to the global Animation Manager.
         *
         * @name Phaser.Animations.Animation#manager
         * @type {Phaser.Animations.AnimationManager}
         * @since 3.0.0
         */this.manager=t,/**
         * The unique identifying string for this animation.
         *
         * @name Phaser.Animations.Animation#key
         * @type {string}
         * @since 3.0.0
         */this.key=e,/**
         * A frame based animation (as opposed to a bone based animation)
         *
         * @name Phaser.Animations.Animation#type
         * @type {string}
         * @default frame
         * @since 3.0.0
         */this.type="frame",/**
         * Extract all the frame data into the frames array.
         *
         * @name Phaser.Animations.Animation#frames
         * @type {Phaser.Animations.AnimationFrame[]}
         * @since 3.0.0
         */this.frames=this.getFrames(t.textureManager,l(i,"frames",[]),l(i,"defaultTextureKey",null)),/**
         * The frame rate of playback in frames per second (default 24 if duration is null)
         *
         * @name Phaser.Animations.Animation#frameRate
         * @type {integer}
         * @default 24
         * @since 3.0.0
         */this.frameRate=l(i,"frameRate",null),/**
         * How long the animation should play for, in milliseconds.
         * If the `frameRate` property has been set then it overrides this value,
         * otherwise the `frameRate` is derived from `duration`.
         *
         * @name Phaser.Animations.Animation#duration
         * @type {integer}
         * @since 3.0.0
         */this.duration=l(i,"duration",null),null===this.duration&&null===this.frameRate?(//  No duration or frameRate given, use default frameRate of 24fps
this.frameRate=24,this.duration=this.frameRate/this.frames.length*1e3):this.duration&&null===this.frameRate?//  I.e. 12 frames in the animation, duration = 4000 ms
//  So frameRate is 12 / (4000 / 1000) = 3 fps
this.frameRate=this.frames.length/(this.duration/1e3)://  I.e. 15 frames in the animation, frameRate = 30 fps
//  So duration is 15 / 30 = 0.5 * 1000 (half a second, or 500ms)
this.duration=this.frames.length/this.frameRate*1e3,/**
         * How many ms per frame, not including frame specific modifiers.
         *
         * @name Phaser.Animations.Animation#msPerFrame
         * @type {integer}
         * @since 3.0.0
         */this.msPerFrame=1e3/this.frameRate,/**
         * Skip frames if the time lags, or always advanced anyway?
         *
         * @name Phaser.Animations.Animation#skipMissedFrames
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.skipMissedFrames=l(i,"skipMissedFrames",!0),/**
         * The delay in ms before the playback will begin.
         *
         * @name Phaser.Animations.Animation#delay
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.delay=l(i,"delay",0),/**
         * Number of times to repeat the animation. Set to -1 to repeat forever.
         *
         * @name Phaser.Animations.Animation#repeat
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.repeat=l(i,"repeat",0),/**
         * The delay in ms before the a repeat play starts.
         *
         * @name Phaser.Animations.Animation#repeatDelay
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.repeatDelay=l(i,"repeatDelay",0),/**
         * Should the animation yoyo (reverse back down to the start) before repeating?
         *
         * @name Phaser.Animations.Animation#yoyo
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.yoyo=l(i,"yoyo",!1),/**
         * Should the GameObject's `visible` property be set to `true` when the animation starts to play?
         *
         * @name Phaser.Animations.Animation#showOnStart
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.showOnStart=l(i,"showOnStart",!1),/**
         * Should the GameObject's `visible` property be set to `false` when the animation finishes?
         *
         * @name Phaser.Animations.Animation#hideOnComplete
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.hideOnComplete=l(i,"hideOnComplete",!1),/**
         * Global pause. All Game Objects using this Animation instance are impacted by this property.
         *
         * @name Phaser.Animations.Animation#paused
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.paused=!1,this.manager.on(o.PAUSE_ALL,this.pause,this),this.manager.on(o.RESUME_ALL,this.resume,this)},/**
     * Add frames to the end of the animation.
     *
     * @method Phaser.Animations.Animation#addFrame
     * @since 3.0.0
     *
     * @param {(string|Phaser.Types.Animations.AnimationFrame[])} config - Either a string, in which case it will use all frames from a texture with the matching key, or an array of Animation Frame configuration objects.
     *
     * @return {this} This Animation object.
     */addFrame:function(t){return this.addFrameAt(this.frames.length,t)},/**
     * Add frame/s into the animation.
     *
     * @method Phaser.Animations.Animation#addFrameAt
     * @since 3.0.0
     *
     * @param {integer} index - The index to insert the frame at within the animation.
     * @param {(string|Phaser.Types.Animations.AnimationFrame[])} config - Either a string, in which case it will use all frames from a texture with the matching key, or an array of Animation Frame configuration objects.
     *
     * @return {this} This Animation object.
     */addFrameAt:function(t,e){var i=this.getFrames(this.manager.textureManager,e);if(i.length>0){if(0===t)this.frames=i.concat(this.frames);else if(t===this.frames.length)this.frames=this.frames.concat(i);else{var n=this.frames.slice(0,t),s=this.frames.slice(t);this.frames=n.concat(i,s)}this.updateFrameSequence()}return this},/**
     * Check if the given frame index is valid.
     *
     * @method Phaser.Animations.Animation#checkFrame
     * @since 3.0.0
     *
     * @param {integer} index - The index to be checked.
     *
     * @return {boolean} `true` if the index is valid, otherwise `false`.
     */checkFrame:function(t){return t>=0&&t<this.frames.length},/**
     * Called internally when this Animation completes playback.
     * Optionally, hides the parent Game Object, then stops playback.
     *
     * @method Phaser.Animations.Animation#completeAnimation
     * @protected
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component belonging to the Game Object invoking this call.
     */completeAnimation:function(t){this.hideOnComplete&&(t.parent.visible=!1),t.stop()},/**
     * Called internally when this Animation first starts to play.
     * Sets the accumulator and nextTick properties.
     *
     * @method Phaser.Animations.Animation#getFirstTick
     * @protected
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component belonging to the Game Object invoking this call.
     * @param {boolean} [includeDelay=true] - If `true` the Animation Components delay value will be added to the `nextTick` total.
     */getFirstTick:function(t,e){void 0===e&&(e=!0),//  When is the first update due?
t.accumulator=0,t.nextTick=t.msPerFrame+t.currentFrame.duration,e&&(t.nextTick+=t._delay)},/**
     * Returns the AnimationFrame at the provided index
     *
     * @method Phaser.Animations.Animation#getFrameAt
     * @protected
     * @since 3.0.0
     *
     * @param {integer} index - The index in the AnimationFrame array
     *
     * @return {Phaser.Animations.AnimationFrame} The frame at the index provided from the animation sequence
     */getFrameAt:function(t){return this.frames[t]},/**
     * Creates AnimationFrame instances based on the given frame data.
     *
     * @method Phaser.Animations.Animation#getFrames
     * @since 3.0.0
     *
     * @param {Phaser.Textures.TextureManager} textureManager - A reference to the global Texture Manager.
     * @param {(string|Phaser.Types.Animations.AnimationFrame[])} frames - Either a string, in which case it will use all frames from a texture with the matching key, or an array of Animation Frame configuration objects.
     * @param {string} [defaultTextureKey] - The key to use if no key is set in the frame configuration object.
     *
     * @return {Phaser.Animations.AnimationFrame[]} An array of newly created AnimationFrame instances.
     */getFrames:function(t,e,i){var n,s,r,o,a=[],u=1;//  if frames is a string, we'll get all the frames from the texture manager as if it's a sprite sheet
if("string"==typeof e){o=e;var c=t.get(o).getFrameNames();e=[],c.forEach(function(t,i){e.push({key:o,frame:i})})}if(!Array.isArray(e)||0===e.length)return a;for(r=0;r<e.length;r++){var d=e[r],f=l(d,"key",i);if(f){//  Could be an integer or a string
var p=l(d,"frame",0),g=t.getFrame(f,p);(s=new h(f,p,u,g)).duration=l(d,"duration",0),s.isFirst=!n,n&&(n.nextFrame=s,s.prevFrame=n),a.push(s),n=s,u++}}if(a.length>0){s.isLast=!0,//  Link them end-to-end, so they loop
s.nextFrame=a[0],a[0].prevFrame=s;//  Generate the progress data
var v=1/(a.length-1);for(r=0;r<a.length;r++)a[r].progress=r*v}return a},/**
     * Called internally. Sets the accumulator and nextTick values of the current Animation.
     *
     * @method Phaser.Animations.Animation#getNextTick
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component belonging to the Game Object invoking this call.
     */getNextTick:function(t){// accumulator += delta * _timeScale
// after a large delta surge (perf issue for example) we need to adjust for it here
//  When is the next update due?
t.accumulator-=t.nextTick,t.nextTick=t.msPerFrame+t.currentFrame.duration},/**
     * Loads the Animation values into the Animation Component.
     *
     * @method Phaser.Animations.Animation#load
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component to load values into.
     * @param {integer} startFrame - The start frame of the animation to load.
     */load:function(t,e){e>=this.frames.length&&(e=0),t.currentAnim!==this&&(t.currentAnim=this,t.frameRate=this.frameRate,t.duration=this.duration,t.msPerFrame=this.msPerFrame,t.skipMissedFrames=this.skipMissedFrames,t._delay=this.delay,t._repeat=this.repeat,t._repeatDelay=this.repeatDelay,t._yoyo=this.yoyo);var i=this.frames[e];0!==e||t.forward||(i=this.getLastFrame()),t.updateFrame(i)},/**
     * Returns the frame closest to the given progress value between 0 and 1.
     *
     * @method Phaser.Animations.Animation#getFrameByProgress
     * @since 3.4.0
     *
     * @param {number} value - A value between 0 and 1.
     *
     * @return {Phaser.Animations.AnimationFrame} The frame closest to the given progress value.
     */getFrameByProgress:function(t){return a(t=i(t,0,1),this.frames,"progress")},/**
     * Advance the animation frame.
     *
     * @method Phaser.Animations.Animation#nextFrame
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component to advance.
     */nextFrame:function(t){var e=t.currentFrame;//  TODO: Add frame skip support
e.isLast?t._yoyo?this.handleYoyoFrame(t,!1):t.repeatCounter>0?t._reverse&&t.forward?t.forward=!1:this.repeatAnimation(t):this.completeAnimation(t):this.updateAndGetNextTick(t,e.nextFrame)},/**
     * Handle the yoyo functionality in nextFrame and previousFrame methods.
     *
     * @method Phaser.Animations.Animation#handleYoyoFrame
     * @private
     * @since 3.12.0
     *
     * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component to advance.
     * @param {boolean} isReverse - Is animation in reverse mode? (Default: false)
     */handleYoyoFrame:function(t,e){if(e||(e=!1),!e===t._reverse&&t.repeatCounter>0){(!t._repeatDelay||t.pendingRepeat)&&(t.forward=e),this.repeatAnimation(t);return}if(t._reverse!==e&&0===t.repeatCounter){this.completeAnimation(t);return}t.forward=e;var i=e?t.currentFrame.nextFrame:t.currentFrame.prevFrame;this.updateAndGetNextTick(t,i)},/**
     * Returns the animation last frame.
     *
     * @method Phaser.Animations.Animation#getLastFrame
     * @since 3.12.0
     *
     * @return {Phaser.Animations.AnimationFrame} component - The Animation Last Frame.
     */getLastFrame:function(){return this.frames[this.frames.length-1]},/**
     * Called internally when the Animation is playing backwards.
     * Sets the previous frame, causing a yoyo, repeat, complete or update, accordingly.
     *
     * @method Phaser.Animations.Animation#previousFrame
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component belonging to the Game Object invoking this call.
     */previousFrame:function(t){var e=t.currentFrame;//  TODO: Add frame skip support
e.isFirst?t._yoyo?this.handleYoyoFrame(t,!0):t.repeatCounter>0?(t._reverse&&!t.forward?t.currentFrame=this.getLastFrame()://  Repeat (happens before complete)
t.forward=!0,this.repeatAnimation(t)):this.completeAnimation(t):this.updateAndGetNextTick(t,e.prevFrame)},/**
     * Update Frame and Wait next tick.
     *
     * @method Phaser.Animations.Animation#updateAndGetNextTick
     * @private
     * @since 3.12.0
     *
     * @param {Phaser.Animations.AnimationFrame} frame - An Animation frame.
     */updateAndGetNextTick:function(t,e){t.updateFrame(e),this.getNextTick(t)},/**
     * Removes the given AnimationFrame from this Animation instance.
     * This is a global action. Any Game Object using this Animation will be impacted by this change.
     *
     * @method Phaser.Animations.Animation#removeFrame
     * @since 3.0.0
     *
     * @param {Phaser.Animations.AnimationFrame} frame - The AnimationFrame to be removed.
     *
     * @return {this} This Animation object.
     */removeFrame:function(t){var e=this.frames.indexOf(t);return -1!==e&&this.removeFrameAt(e),this},/**
     * Removes a frame from the AnimationFrame array at the provided index
     * and updates the animation accordingly.
     *
     * @method Phaser.Animations.Animation#removeFrameAt
     * @since 3.0.0
     *
     * @param {integer} index - The index in the AnimationFrame array
     *
     * @return {this} This Animation object.
     */removeFrameAt:function(t){return this.frames.splice(t,1),this.updateFrameSequence(),this},/**
     * Called internally during playback. Forces the animation to repeat, providing there are enough counts left
     * in the repeat counter.
     *
     * @method Phaser.Animations.Animation#repeatAnimation
     * @fires Phaser.Animations.Events#ANIMATION_REPEAT
     * @fires Phaser.Animations.Events#SPRITE_ANIMATION_REPEAT
     * @fires Phaser.Animations.Events#SPRITE_ANIMATION_KEY_REPEAT
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component belonging to the Game Object invoking this call.
     */repeatAnimation:function(t){if(2===t._pendingStop)return this.completeAnimation(t);if(t._repeatDelay>0&&!1===t.pendingRepeat)t.pendingRepeat=!0,t.accumulator-=t.nextTick,t.nextTick+=t._repeatDelay;else if(t.repeatCounter--,t.updateFrame(t.currentFrame[t.forward?"nextFrame":"prevFrame"]),t.isPlaying){this.getNextTick(t),t.pendingRepeat=!1;var e=t.currentFrame,i=t.parent;this.emit(o.ANIMATION_REPEAT,this,e),i.emit(o.SPRITE_ANIMATION_KEY_REPEAT+this.key,this,e,t.repeatCounter,i),i.emit(o.SPRITE_ANIMATION_REPEAT,this,e,t.repeatCounter,i)}},/**
     * Sets the texture frame the animation uses for rendering.
     *
     * @method Phaser.Animations.Animation#setFrame
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component belonging to the Game Object invoking this call.
     */setFrame:function(t){//  Work out which frame should be set next on the child, and set it
t.forward?this.nextFrame(t):this.previousFrame(t)},/**
     * Converts the animation data to JSON.
     *
     * @method Phaser.Animations.Animation#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.Animations.JSONAnimation} The resulting JSONAnimation formatted object.
     */toJSON:function(){var t={key:this.key,type:this.type,frames:[],frameRate:this.frameRate,duration:this.duration,skipMissedFrames:this.skipMissedFrames,delay:this.delay,repeat:this.repeat,repeatDelay:this.repeatDelay,yoyo:this.yoyo,showOnStart:this.showOnStart,hideOnComplete:this.hideOnComplete};return this.frames.forEach(function(e){t.frames.push(e.toJSON())}),t},/**
     * Called internally whenever frames are added to, or removed from, this Animation.
     *
     * @method Phaser.Animations.Animation#updateFrameSequence
     * @since 3.0.0
     *
     * @return {this} This Animation object.
     */updateFrameSequence:function(){for(var t,e=this.frames.length,i=1/(e-1),n=0;n<e;n++)(t=this.frames[n]).index=n+1,t.isFirst=!1,t.isLast=!1,t.progress=n*i,0===n?(t.isFirst=!0,1===e?(t.isLast=!0,t.nextFrame=t,t.prevFrame=t):(t.isLast=!1,t.prevFrame=this.frames[e-1],t.nextFrame=this.frames[n+1])):n===e-1&&e>1?(t.isLast=!0,t.prevFrame=this.frames[e-2],t.nextFrame=this.frames[0]):e>1&&(t.prevFrame=this.frames[n-1],t.nextFrame=this.frames[n+1]);return this},/**
     * Pauses playback of this Animation. The paused state is set immediately.
     *
     * @method Phaser.Animations.Animation#pause
     * @since 3.0.0
     *
     * @return {this} This Animation object.
     */pause:function(){return this.paused=!0,this},/**
     * Resumes playback of this Animation. The paused state is reset immediately.
     *
     * @method Phaser.Animations.Animation#resume
     * @since 3.0.0
     *
     * @return {this} This Animation object.
     */resume:function(){return this.paused=!1,this},/**
     * Destroys this Animation instance. It will remove all event listeners,
     * remove this animation and its key from the global Animation Manager,
     * and then destroy all Animation Frames in turn.
     *
     * @method Phaser.Animations.Animation#destroy
     * @since 3.0.0
     */destroy:function(){this.removeAllListeners(),this.manager.off(o.PAUSE_ALL,this.pause,this),this.manager.off(o.RESUME_ALL,this.resume,this),this.manager.remove(this.key);for(var t=0;t<this.frames.length;t++)this.frames[t].destroy();this.frames=[],this.manager=null}});t.exports=u}),r("3vRz3",function(t,e){var i=Object.prototype.hasOwnProperty,n="~";/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */function s(){}/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */function r(t,e,i){this.fn=t,this.context=e,this.once=i||!1}/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */function o(t,e,i,s,o){if("function"!=typeof i)throw TypeError("The listener must be a function");var a=new r(i,s||t,o),h=n?n+e:e;return t._events[h]?t._events[h].fn?t._events[h]=[t._events[h],a]:t._events[h].push(a):(t._events[h]=a,t._eventsCount++),t}/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */function a(t,e){0==--t._eventsCount?t._events=new s:delete t._events[e]}/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */function h(){this._events=new s,this._eventsCount=0}Object.create&&(s.prototype=Object.create(null),new s().__proto__||(n=!1)),/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */h.prototype.eventNames=function(){var t,e,s=[];if(0===this._eventsCount)return s;for(e in t=this._events)i.call(t,e)&&s.push(n?e.slice(1):e);return Object.getOwnPropertySymbols?s.concat(Object.getOwnPropertySymbols(t)):s},/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */h.prototype.listeners=function(t){var e=n?n+t:t,i=this._events[e];if(!i)return[];if(i.fn)return[i.fn];for(var s=0,r=i.length,o=Array(r);s<r;s++)o[s]=i[s].fn;return o},/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */h.prototype.listenerCount=function(t){var e=n?n+t:t,i=this._events[e];return i?i.fn?1:i.length:0},/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */h.prototype.emit=function(t,e,i,s,r,o){var a=n?n+t:t;if(!this._events[a])return!1;var h,l,u=this._events[a],c=arguments.length;if(u.fn){switch(u.once&&this.removeListener(t,u.fn,void 0,!0),c){case 1:return u.fn.call(u.context),!0;case 2:return u.fn.call(u.context,e),!0;case 3:return u.fn.call(u.context,e,i),!0;case 4:return u.fn.call(u.context,e,i,s),!0;case 5:return u.fn.call(u.context,e,i,s,r),!0;case 6:return u.fn.call(u.context,e,i,s,r,o),!0}for(l=1,h=Array(c-1);l<c;l++)h[l-1]=arguments[l];u.fn.apply(u.context,h)}else{var d,f=u.length;for(l=0;l<f;l++)switch(u[l].once&&this.removeListener(t,u[l].fn,void 0,!0),c){case 1:u[l].fn.call(u[l].context);break;case 2:u[l].fn.call(u[l].context,e);break;case 3:u[l].fn.call(u[l].context,e,i);break;case 4:u[l].fn.call(u[l].context,e,i,s);break;default:if(!h)for(d=1,h=Array(c-1);d<c;d++)h[d-1]=arguments[d];u[l].fn.apply(u[l].context,h)}}return!0},/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */h.prototype.on=function(t,e,i){return o(this,t,e,i,!1)},/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */h.prototype.once=function(t,e,i){return o(this,t,e,i,!0)},/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */h.prototype.removeListener=function(t,e,i,s){var r=n?n+t:t;if(!this._events[r])return this;if(!e)return a(this,r),this;var o=this._events[r];if(o.fn)o.fn!==e||s&&!o.once||i&&o.context!==i||a(this,r);else{for(var h=0,l=[],u=o.length;h<u;h++)(o[h].fn!==e||s&&!o[h].once||i&&o[h].context!==i)&&l.push(o[h]);//
// Reset the array, or remove it completely if we have no more listeners.
//
l.length?this._events[r]=1===l.length?l[0]:l:a(this,r)}return this},/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */h.prototype.removeAllListeners=function(t){var e;return t?(e=n?n+t:t,this._events[e]&&a(this,e)):(this._events=new s,this._eventsCount=0),this},//
// Alias methods names because people roll like that.
//
h.prototype.off=h.prototype.removeListener,h.prototype.addListener=h.prototype.on,//
// Expose the prefix.
//
h.prefixed=n,//
// Allow `EventEmitter` to be imported as module namespace.
//
h.EventEmitter=h,t.exports=h}),r("61xd9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Animations.Events
 */t.exports={ADD_ANIMATION:s("b20ka"),ANIMATION_COMPLETE:s("6Scfk"),ANIMATION_REPEAT:s("1i5Tk"),ANIMATION_RESTART:s("9o6zt"),ANIMATION_START:s("c1HtP"),PAUSE_ALL:s("7jA9x"),REMOVE_ANIMATION:s("dZYdG"),RESUME_ALL:s("cgaPE"),SPRITE_ANIMATION_COMPLETE:s("a1gn7"),SPRITE_ANIMATION_KEY_COMPLETE:s("3jlNk"),SPRITE_ANIMATION_KEY_REPEAT:s("blGC8"),SPRITE_ANIMATION_KEY_RESTART:s("jn7dJ"),SPRITE_ANIMATION_KEY_START:s("kCQEk"),SPRITE_ANIMATION_KEY_UPDATE:s("jWo5U"),SPRITE_ANIMATION_REPEAT:s("gU3w7"),SPRITE_ANIMATION_RESTART:s("dDu4A"),SPRITE_ANIMATION_START:s("e6SNr"),SPRITE_ANIMATION_UPDATE:s("4QTC8")}}),r("b20ka",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Add Animation Event.
 * 
 * This event is dispatched when a new animation is added to the global Animation Manager.
 * 
 * This can happen either as a result of an animation instance being added to the Animation Manager,
 * or the Animation Manager creating a new animation directly.
 *
 * @event Phaser.Animations.Events#ADD_ANIMATION
 * @since 3.0.0
 * 
 * @param {string} key - The key of the Animation that was added to the global Animation Manager.
 * @param {Phaser.Animations.Animation} animation - An instance of the newly created Animation.
 */t.exports="add"}),r("6Scfk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Animation Complete Event.
 * 
 * This event is dispatched by an Animation instance when it completes, i.e. finishes playing or is manually stopped.
 * 
 * Be careful with the volume of events this could generate. If a group of Sprites all complete the same
 * animation at the same time, this event will invoke its handler for each one of them.
 *
 * @event Phaser.Animations.Events#ANIMATION_COMPLETE
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that completed.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame that the Animation completed on.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation completed.
 */t.exports="complete"}),r("1i5Tk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Animation Repeat Event.
 * 
 * This event is dispatched when a currently playing animation repeats.
 * 
 * The event is dispatched directly from the Animation object itself. Which means that listeners
 * bound to this event will be invoked every time the Animation repeats, for every Game Object that may have it.
 *
 * @event Phaser.Animations.Events#ANIMATION_REPEAT
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that repeated.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame that the Animation was on when it repeated.
 */t.exports="repeat"}),r("9o6zt",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Animation Restart Event.
 * 
 * This event is dispatched by an Animation instance when it restarts.
 * 
 * Be careful with the volume of events this could generate. If a group of Sprites all restart the same
 * animation at the same time, this event will invoke its handler for each one of them.
 *
 * @event Phaser.Animations.Events#ANIMATION_RESTART
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that restarted playing.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame that the Animation restarted with.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation restarted playing.
 */t.exports="restart"}),r("c1HtP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Animation Start Event.
 * 
 * This event is dispatched by an Animation instance when it starts playing.
 * 
 * Be careful with the volume of events this could generate. If a group of Sprites all play the same
 * animation at the same time, this event will invoke its handler for each one of them.
 *
 * @event Phaser.Animations.Events#ANIMATION_START
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that started playing.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame that the Animation started with.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation started playing.
 */t.exports="start"}),r("7jA9x",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pause All Animations Event.
 * 
 * This event is dispatched when the global Animation Manager is told to pause.
 * 
 * When this happens all current animations will stop updating, although it doesn't necessarily mean
 * that the game has paused as well.
 *
 * @event Phaser.Animations.Events#PAUSE_ALL
 * @since 3.0.0
 */t.exports="pauseall"}),r("dZYdG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Remove Animation Event.
 * 
 * This event is dispatched when an animation is removed from the global Animation Manager.
 *
 * @event Phaser.Animations.Events#REMOVE_ANIMATION
 * @since 3.0.0
 * 
 * @param {string} key - The key of the Animation that was removed from the global Animation Manager.
 * @param {Phaser.Animations.Animation} animation - An instance of the removed Animation.
 */t.exports="remove"}),r("cgaPE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Resume All Animations Event.
 * 
 * This event is dispatched when the global Animation Manager resumes, having been previously paused.
 * 
 * When this happens all current animations will continue updating again.
 *
 * @event Phaser.Animations.Events#RESUME_ALL
 * @since 3.0.0
 */t.exports="resumeall"}),r("a1gn7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sprite Animation Complete Event.
 * 
 * This event is dispatched by a Sprite when an animation finishes playing on it.
 * 
 * Listen for it on the Sprite using `sprite.on('animationcomplete', listener)`
 * 
 * This same event is dispatched for all animations. To listen for a specific animation, use the `SPRITE_ANIMATION_KEY_COMPLETE` event.
 *
 * @event Phaser.Animations.Events#SPRITE_ANIMATION_COMPLETE
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that completed.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame that the Animation completed on.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation completed.
 */t.exports="animationcomplete"}),r("3jlNk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sprite Animation Key Complete Event.
 * 
 * This event is dispatched by a Sprite when a specific animation finishes playing on it.
 * 
 * Listen for it on the Sprite using `sprite.on('animationcomplete-key', listener)` where `key` is the key of
 * the animation. For example, if you had an animation with the key 'explode' you should listen for `animationcomplete-explode`.
 *
 * @event Phaser.Animations.Events#SPRITE_ANIMATION_KEY_COMPLETE
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that completed.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame that the Animation completed on.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation completed.
 */t.exports="animationcomplete-"}),r("blGC8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sprite Animation Key Repeat Event.
 * 
 * This event is dispatched by a Sprite when a specific animation repeats playing on it.
 * 
 * Listen for it on the Sprite using `sprite.on('animationrepeat-key', listener)` where `key` is the key of
 * the animation. For example, if you had an animation with the key 'explode' you should listen for `animationrepeat-explode`.
 *
 * @event Phaser.Animations.Events#SPRITE_ANIMATION_KEY_REPEAT
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that is repeating on the Sprite.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame that the Animation started with.
 * @param {integer} repeatCount - The number of times the Animation has repeated so far.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation repeated playing.
 */t.exports="animationrepeat-"}),r("jn7dJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sprite Animation Key Restart Event.
 * 
 * This event is dispatched by a Sprite when a specific animation restarts playing on it.
 * 
 * Listen for it on the Sprite using `sprite.on('animationrestart-key', listener)` where `key` is the key of
 * the animation. For example, if you had an animation with the key 'explode' you should listen for `animationrestart-explode`.
 *
 * @event Phaser.Animations.Events#SPRITE_ANIMATION_KEY_RESTART
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that was restarted on the Sprite.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame that the Animation restarted with.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation restarted playing.
 */t.exports="animationrestart-"}),r("kCQEk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sprite Animation Key Start Event.
 * 
 * This event is dispatched by a Sprite when a specific animation starts playing on it.
 * 
 * Listen for it on the Sprite using `sprite.on('animationstart-key', listener)` where `key` is the key of
 * the animation. For example, if you had an animation with the key 'explode' you should listen for `animationstart-explode`.
 *
 * @event Phaser.Animations.Events#SPRITE_ANIMATION_KEY_START
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that was started on the Sprite.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame that the Animation started with.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation started playing.
 */t.exports="animationstart-"}),r("jWo5U",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sprite Animation Key Update Event.
 * 
 * This event is dispatched by a Sprite when a specific animation playing on it updates. This happens when the animation changes frame,
 * based on the animation frame rate and other factors like `timeScale` and `delay`.
 * 
 * Listen for it on the Sprite using `sprite.on('animationupdate-key', listener)` where `key` is the key of
 * the animation. For example, if you had an animation with the key 'explode' you should listen for `animationupdate-explode`.
 *
 * @event Phaser.Animations.Events#SPRITE_ANIMATION_KEY_UPDATE
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that has updated on the Sprite.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame of the Animation.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation updated.
 */t.exports="animationupdate-"}),r("gU3w7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sprite Animation Repeat Event.
 * 
 * This event is dispatched by a Sprite when an animation repeats playing on it.
 * 
 * Listen for it on the Sprite using `sprite.on('animationrepeat', listener)`
 * 
 * This same event is dispatched for all animations. To listen for a specific animation, use the `SPRITE_ANIMATION_KEY_REPEAT` event.
 *
 * @event Phaser.Animations.Events#SPRITE_ANIMATION_REPEAT
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that is repeating on the Sprite.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame that the Animation started with.
 * @param {integer} repeatCount - The number of times the Animation has repeated so far.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation repeated playing.
 */t.exports="animationrepeat"}),r("dDu4A",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sprite Animation Restart Event.
 * 
 * This event is dispatched by a Sprite when an animation restarts playing on it.
 * 
 * Listen for it on the Sprite using `sprite.on('animationrestart', listener)`
 * 
 * This same event is dispatched for all animations. To listen for a specific animation, use the `SPRITE_ANIMATION_KEY_RESTART` event.
 *
 * @event Phaser.Animations.Events#SPRITE_ANIMATION_RESTART
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that was restarted on the Sprite.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame that the Animation restarted with.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation restarted playing.
 */t.exports="animationrestart"}),r("e6SNr",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sprite Animation Start Event.
 * 
 * This event is dispatched by a Sprite when an animation starts playing on it.
 * 
 * Listen for it on the Sprite using `sprite.on('animationstart', listener)`
 * 
 * This same event is dispatched for all animations. To listen for a specific animation, use the `SPRITE_ANIMATION_KEY_START` event.
 *
 * @event Phaser.Animations.Events#SPRITE_ANIMATION_START
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that was started on the Sprite.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame that the Animation started with.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation started playing.
 */t.exports="animationstart"}),r("4QTC8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sprite Animation Update Event.
 * 
 * This event is dispatched by a Sprite when an animation playing on it updates. This happens when the animation changes frame,
 * based on the animation frame rate and other factors like `timeScale` and `delay`.
 * 
 * Listen for it on the Sprite using `sprite.on('animationupdate', listener)`
 * 
 * This same event is dispatched for all animations. To listen for a specific animation, use the `SPRITE_ANIMATION_KEY_UPDATE` event.
 *
 * @event Phaser.Animations.Events#SPRITE_ANIMATION_UPDATE
 * @since 3.16.1
 * 
 * @param {Phaser.Animations.Animation} animation - A reference to the Animation that has updated on the Sprite.
 * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame of the Animation.
 * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation updated.
 */t.exports="animationupdate"}),r("3tt0c",function(t,e){t.exports=function(t,e,i){if(!e.length)return NaN;if(1===e.length)return e[0];var n,s,r=1;if(i){if(t<e[0][i])return e[0];for(;e[r][i]<t;)r++}else for(;e[r]<t;)r++;return(r>e.length&&(r=e.length),i)?(n=e[r-1][i],(s=e[r][i])-t<=t-n?e[r]:e[r-1]):(n=e[r-1],(s=e[r])-t<=t-n?s:n)}}),r("cDvmt",function(t,e){/**
 * @classdesc
 * A single frame in an Animation sequence.
 *
 * An AnimationFrame consists of a reference to the Texture it uses for rendering, references to other
 * frames in the animation, and index data. It also has the ability to modify the animation timing.
 *
 * AnimationFrames are generated automatically by the Animation class.
 *
 * @class AnimationFrame
 * @memberof Phaser.Animations
 * @constructor
 * @since 3.0.0
 *
 * @param {string} textureKey - The key of the Texture this AnimationFrame uses.
 * @param {(string|integer)} textureFrame - The key of the Frame within the Texture that this AnimationFrame uses.
 * @param {integer} index - The index of this AnimationFrame within the Animation sequence.
 * @param {Phaser.Textures.Frame} frame - A reference to the Texture Frame this AnimationFrame uses for rendering.
 */var i=new(s("jwj1g"))({initialize:function(t,e,i,n){/**
         * The key of the Texture this AnimationFrame uses.
         *
         * @name Phaser.Animations.AnimationFrame#textureKey
         * @type {string}
         * @since 3.0.0
         */this.textureKey=t,/**
         * The key of the Frame within the Texture that this AnimationFrame uses.
         *
         * @name Phaser.Animations.AnimationFrame#textureFrame
         * @type {(string|integer)}
         * @since 3.0.0
         */this.textureFrame=e,/**
         * The index of this AnimationFrame within the Animation sequence.
         *
         * @name Phaser.Animations.AnimationFrame#index
         * @type {integer}
         * @since 3.0.0
         */this.index=i,/**
         * A reference to the Texture Frame this AnimationFrame uses for rendering.
         *
         * @name Phaser.Animations.AnimationFrame#frame
         * @type {Phaser.Textures.Frame}
         * @since 3.0.0
         */this.frame=n,/**
         * Is this the first frame in an animation sequence?
         *
         * @name Phaser.Animations.AnimationFrame#isFirst
         * @type {boolean}
         * @default false
         * @readonly
         * @since 3.0.0
         */this.isFirst=!1,/**
         * Is this the last frame in an animation sequence?
         *
         * @name Phaser.Animations.AnimationFrame#isLast
         * @type {boolean}
         * @default false
         * @readonly
         * @since 3.0.0
         */this.isLast=!1,/**
         * A reference to the AnimationFrame that comes before this one in the animation, if any.
         *
         * @name Phaser.Animations.AnimationFrame#prevFrame
         * @type {?Phaser.Animations.AnimationFrame}
         * @default null
         * @readonly
         * @since 3.0.0
         */this.prevFrame=null,/**
         * A reference to the AnimationFrame that comes after this one in the animation, if any.
         *
         * @name Phaser.Animations.AnimationFrame#nextFrame
         * @type {?Phaser.Animations.AnimationFrame}
         * @default null
         * @readonly
         * @since 3.0.0
         */this.nextFrame=null,/**
         * Additional time (in ms) that this frame should appear for during playback.
         * The value is added onto the msPerFrame set by the animation.
         *
         * @name Phaser.Animations.AnimationFrame#duration
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.duration=0,/**
         * What % through the animation does this frame come?
         * This value is generated when the animation is created and cached here.
         *
         * @name Phaser.Animations.AnimationFrame#progress
         * @type {number}
         * @default 0
         * @readonly
         * @since 3.0.0
         */this.progress=0},/**
     * Generates a JavaScript object suitable for converting to JSON.
     *
     * @method Phaser.Animations.AnimationFrame#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.Animations.JSONAnimationFrame} The AnimationFrame data.
     */toJSON:function(){return{key:this.textureKey,frame:this.textureFrame,duration:this.duration}},/**
     * Destroys this object by removing references to external resources and callbacks.
     *
     * @method Phaser.Animations.AnimationFrame#destroy
     * @since 3.0.0
     */destroy:function(){this.frame=void 0}});t.exports=i}),r("5pMDk",function(t,e){t.exports=function(t,e,i){if(!t||"number"==typeof t)return i;if(t.hasOwnProperty(e))return t[e];if(-1===e.indexOf("."))return i;//  Use for loop here so we can break early
for(var n=e.split("."),s=t,r=i,o=0;o<n.length;o++)if(s.hasOwnProperty(n[o]))//  Yes it has a key property, let's carry on down
r=s[n[o]],s=s[n[o]];else{//  Can't go any further, so reset to default
r=i;break}return r}}),r("2UeGA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("3qUcC"),n={/**
     * Private internal value. Holds the current blend mode.
     * 
     * @name Phaser.GameObjects.Components.BlendMode#_blendMode
     * @type {integer}
     * @private
     * @default 0
     * @since 3.0.0
     */_blendMode:i.NORMAL,/**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
     * are used.
     *
     * @name Phaser.GameObjects.Components.BlendMode#blendMode
     * @type {(Phaser.BlendModes|string)}
     * @since 3.0.0
     */blendMode:{get:function(){return this._blendMode},set:function(t){"string"==typeof t&&(t=i[t]),(t|=0)>=-1&&(this._blendMode=t)}},/**
     * Sets the Blend Mode being used by this Game Object.
     *
     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
     *
     * Under WebGL only the following Blend Modes are available:
     *
     * * ADD
     * * MULTIPLY
     * * SCREEN
     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
     *
     * Canvas has more available depending on browser support.
     *
     * You can also create your own custom Blend Modes in WebGL.
     *
     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
     * are used.
     *
     * @method Phaser.GameObjects.Components.BlendMode#setBlendMode
     * @since 3.0.0
     *
     * @param {(string|Phaser.BlendModes)} value - The BlendMode value. Either a string or a CONST.
     *
     * @return {this} This Game Object instance.
     */setBlendMode:function(t){return this.blendMode=t,this}};t.exports=n}),r("cbj9c",function(t,e){t.exports={/**
     * The native (un-scaled) width of this Game Object.
     * 
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     * 
     * @name Phaser.GameObjects.Components.ComputedSize#width
     * @type {number}
     * @since 3.0.0
     */width:0,/**
     * The native (un-scaled) height of this Game Object.
     * 
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     * 
     * @name Phaser.GameObjects.Components.ComputedSize#height
     * @type {number}
     * @since 3.0.0
     */height:0,/**
     * The displayed width of this Game Object.
     * 
     * This value takes into account the scale factor.
     * 
     * Setting this value will adjust the Game Object's scale property.
     * 
     * @name Phaser.GameObjects.Components.ComputedSize#displayWidth
     * @type {number}
     * @since 3.0.0
     */displayWidth:{get:function(){return this.scaleX*this.width},set:function(t){this.scaleX=t/this.width}},/**
     * The displayed height of this Game Object.
     * 
     * This value takes into account the scale factor.
     * 
     * Setting this value will adjust the Game Object's scale property.
     * 
     * @name Phaser.GameObjects.Components.ComputedSize#displayHeight
     * @type {number}
     * @since 3.0.0
     */displayHeight:{get:function(){return this.scaleY*this.height},set:function(t){this.scaleY=t/this.height}},/**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     * 
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     * 
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * 
     * @method Phaser.GameObjects.Components.ComputedSize#setSize
     * @since 3.4.0
     *
     * @param {number} width - The width of this Game Object.
     * @param {number} height - The height of this Game Object.
     * 
     * @return {this} This Game Object instance.
     */setSize:function(t,e){return this.width=t,this.height=e,this},/**
     * Sets the display size of this Game Object.
     * 
     * Calling this will adjust the scale.
     * 
     * @method Phaser.GameObjects.Components.ComputedSize#setDisplaySize
     * @since 3.4.0
     *
     * @param {number} width - The width of this Game Object.
     * @param {number} height - The height of this Game Object.
     * 
     * @return {this} This Game Object instance.
     */setDisplaySize:function(t,e){return this.displayWidth=t,this.displayHeight=e,this}}}),r("bhbp7",function(t,e){t.exports={/**
     * The Texture this Game Object is using to render with.
     *
     * @name Phaser.GameObjects.Components.Crop#texture
     * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}
     * @since 3.0.0
     */texture:null,/**
     * The Texture Frame this Game Object is using to render with.
     *
     * @name Phaser.GameObjects.Components.Crop#frame
     * @type {Phaser.Textures.Frame}
     * @since 3.0.0
     */frame:null,/**
     * A boolean flag indicating if this Game Object is being cropped or not.
     * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
     * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
     *
     * @name Phaser.GameObjects.Components.Crop#isCropped
     * @type {boolean}
     * @since 3.11.0
     */isCropped:!1,/**
     * Applies a crop to a texture based Game Object, such as a Sprite or Image.
     * 
     * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
     * 
     * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
     * changes what is shown when rendered.
     * 
     * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
     * 
     * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
     * half of it, you could call `setCrop(0, 0, 400, 600)`.
     * 
     * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
     * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
     * 
     * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
     * 
     * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
     * 
     * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
     * the renderer to skip several internal calculations.
     *
     * @method Phaser.GameObjects.Components.Crop#setCrop
     * @since 3.11.0
     *
     * @param {(number|Phaser.Geom.Rectangle)} [x] - The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
     * @param {number} [y] - The y coordinate to start the crop from.
     * @param {number} [width] - The width of the crop rectangle in pixels.
     * @param {number} [height] - The height of the crop rectangle in pixels.
     *
     * @return {this} This Game Object instance.
     */setCrop:function(t,e,i,n){return void 0===t?this.isCropped=!1:this.frame&&("number"==typeof t?this.frame.setCropUVs(this._crop,t,e,i,n,this.flipX,this.flipY):this.frame.setCropUVs(this._crop,t.x,t.y,t.width,t.height,this.flipX,this.flipY),this.isCropped=!0),this},/**
     * Internal method that returns a blank, well-formed crop object for use by a Game Object.
     *
     * @method Phaser.GameObjects.Components.Crop#resetCropObject
     * @private
     * @since 3.12.0
     * 
     * @return {object} The crop object.
     */resetCropObject:function(){return{u0:0,v0:0,u1:0,v1:0,width:0,height:0,x:0,y:0,flipX:!1,flipY:!1,cx:0,cy:0,cw:0,ch:0}}}}),r("1CJAb",function(t,e){t.exports={/**
     * Private internal value. Holds the depth of the Game Object.
     * 
     * @name Phaser.GameObjects.Components.Depth#_depth
     * @type {integer}
     * @private
     * @default 0
     * @since 3.0.0
     */_depth:0,/**
     * The depth of this Game Object within the Scene.
     * 
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * 
     * @name Phaser.GameObjects.Components.Depth#depth
     * @type {number}
     * @since 3.0.0
     */depth:{get:function(){return this._depth},set:function(t){this.scene.sys.queueDepthSort(),this._depth=t}},/**
     * The depth of this Game Object within the Scene.
     * 
     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
     * of Game Objects, without actually moving their position in the display list.
     *
     * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
     * value will always render in front of one with a lower value.
     *
     * Setting the depth will queue a depth sort event within the Scene.
     * 
     * @method Phaser.GameObjects.Components.Depth#setDepth
     * @since 3.0.0
     *
     * @param {integer} value - The depth of this Game Object.
     * 
     * @return {this} This Game Object instance.
     */setDepth:function(t){return void 0===t&&(t=0),this.depth=t,this}}}),r("fdnq8",function(t,e){t.exports={/**
     * The horizontally flipped state of the Game Object.
     * 
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * 
     * @name Phaser.GameObjects.Components.Flip#flipX
     * @type {boolean}
     * @default false
     * @since 3.0.0
     */flipX:!1,/**
     * The vertically flipped state of the Game Object.
     * 
     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * 
     * @name Phaser.GameObjects.Components.Flip#flipY
     * @type {boolean}
     * @default false
     * @since 3.0.0
     */flipY:!1,/**
     * Toggles the horizontal flipped state of this Game Object.
     * 
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * 
     * @method Phaser.GameObjects.Components.Flip#toggleFlipX
     * @since 3.0.0
     * 
     * @return {this} This Game Object instance.
     */toggleFlipX:function(){return this.flipX=!this.flipX,this},/**
     * Toggles the vertical flipped state of this Game Object.
     * 
     * @method Phaser.GameObjects.Components.Flip#toggleFlipY
     * @since 3.0.0
     * 
     * @return {this} This Game Object instance.
     */toggleFlipY:function(){return this.flipY=!this.flipY,this},/**
     * Sets the horizontal flipped state of this Game Object.
     * 
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * 
     * @method Phaser.GameObjects.Components.Flip#setFlipX
     * @since 3.0.0
     *
     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.
     * 
     * @return {this} This Game Object instance.
     */setFlipX:function(t){return this.flipX=t,this},/**
     * Sets the vertical flipped state of this Game Object.
     * 
     * @method Phaser.GameObjects.Components.Flip#setFlipY
     * @since 3.0.0
     *
     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.
     * 
     * @return {this} This Game Object instance.
     */setFlipY:function(t){return this.flipY=t,this},/**
     * Sets the horizontal and vertical flipped state of this Game Object.
     * 
     * A Game Object that is flipped will render inversed on the flipped axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * 
     * @method Phaser.GameObjects.Components.Flip#setFlip
     * @since 3.0.0
     *
     * @param {boolean} x - The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * @param {boolean} y - The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * 
     * @return {this} This Game Object instance.
     */setFlip:function(t,e){return this.flipX=t,this.flipY=e,this},/**
     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
     * 
     * @method Phaser.GameObjects.Components.Flip#resetFlip
     * @since 3.0.0
     *
     * @return {this} This Game Object instance.
     */resetFlip:function(){return this.flipX=!1,this.flipY=!1,this}}}),r("9r3lX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cwr8X"),n=s("5Ntai"),r=s("7SBSk");t.exports={/**
     * Processes the bounds output vector before returning it.
     *
     * @method Phaser.GameObjects.Components.GetBounds#prepareBoundsOutput
     * @private
     * @since 3.18.0
     *
     * @generic {Phaser.Math.Vector2} O - [output,$return]
     *
     * @param {(Phaser.Math.Vector2|object)} output - An object to store the values in. If not provided a new Vector2 will be created.
     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?
     *
     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.
     */prepareBoundsOutput:function(t,e){return void 0===e&&(e=!1),0!==this.rotation&&n(t,this.x,this.y,this.rotation),e&&this.parentContainer&&this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x,t.y,t),t},/**
     * Gets the center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     *
     * @method Phaser.GameObjects.Components.GetBounds#getCenter
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [output,$return]
     *
     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.
     *
     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.
     */getCenter:function(t){return void 0===t&&(t=new r),t.x=this.x-this.displayWidth*this.originX+this.displayWidth/2,t.y=this.y-this.displayHeight*this.originY+this.displayHeight/2,t},/**
     * Gets the top-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     *
     * @method Phaser.GameObjects.Components.GetBounds#getTopLeft
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [output,$return]
     *
     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.
     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?
     *
     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.
     */getTopLeft:function(t,e){return t||(t=new r),t.x=this.x-this.displayWidth*this.originX,t.y=this.y-this.displayHeight*this.originY,this.prepareBoundsOutput(t,e)},/**
     * Gets the top-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     *
     * @method Phaser.GameObjects.Components.GetBounds#getTopCenter
     * @since 3.18.0
     *
     * @generic {Phaser.Math.Vector2} O - [output,$return]
     *
     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.
     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?
     *
     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.
     */getTopCenter:function(t,e){return t||(t=new r),t.x=this.x-this.displayWidth*this.originX+this.displayWidth/2,t.y=this.y-this.displayHeight*this.originY,this.prepareBoundsOutput(t,e)},/**
     * Gets the top-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     *
     * @method Phaser.GameObjects.Components.GetBounds#getTopRight
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [output,$return]
     *
     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.
     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?
     *
     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.
     */getTopRight:function(t,e){return t||(t=new r),t.x=this.x-this.displayWidth*this.originX+this.displayWidth,t.y=this.y-this.displayHeight*this.originY,this.prepareBoundsOutput(t,e)},/**
     * Gets the left-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     *
     * @method Phaser.GameObjects.Components.GetBounds#getLeftCenter
     * @since 3.18.0
     *
     * @generic {Phaser.Math.Vector2} O - [output,$return]
     *
     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.
     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?
     *
     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.
     */getLeftCenter:function(t,e){return t||(t=new r),t.x=this.x-this.displayWidth*this.originX,t.y=this.y-this.displayHeight*this.originY+this.displayHeight/2,this.prepareBoundsOutput(t,e)},/**
     * Gets the right-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     *
     * @method Phaser.GameObjects.Components.GetBounds#getRightCenter
     * @since 3.18.0
     *
     * @generic {Phaser.Math.Vector2} O - [output,$return]
     *
     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.
     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?
     *
     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.
     */getRightCenter:function(t,e){return t||(t=new r),t.x=this.x-this.displayWidth*this.originX+this.displayWidth,t.y=this.y-this.displayHeight*this.originY+this.displayHeight/2,this.prepareBoundsOutput(t,e)},/**
     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     *
     * @method Phaser.GameObjects.Components.GetBounds#getBottomLeft
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [output,$return]
     *
     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.
     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?
     *
     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.
     */getBottomLeft:function(t,e){return t||(t=new r),t.x=this.x-this.displayWidth*this.originX,t.y=this.y-this.displayHeight*this.originY+this.displayHeight,this.prepareBoundsOutput(t,e)},/**
     * Gets the bottom-center coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     *
     * @method Phaser.GameObjects.Components.GetBounds#getBottomCenter
     * @since 3.18.0
     *
     * @generic {Phaser.Math.Vector2} O - [output,$return]
     *
     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.
     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?
     *
     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.
     */getBottomCenter:function(t,e){return t||(t=new r),t.x=this.x-this.displayWidth*this.originX+this.displayWidth/2,t.y=this.y-this.displayHeight*this.originY+this.displayHeight,this.prepareBoundsOutput(t,e)},/**
     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
     * The returned point is calculated in local space and does not factor in any parent containers
     *
     * @method Phaser.GameObjects.Components.GetBounds#getBottomRight
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [output,$return]
     *
     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.
     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?
     *
     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.
     */getBottomRight:function(t,e){return t||(t=new r),t.x=this.x-this.displayWidth*this.originX+this.displayWidth,t.y=this.y-this.displayHeight*this.originY+this.displayHeight,this.prepareBoundsOutput(t,e)},/**
     * Gets the bounds of this Game Object, regardless of origin.
     * The values are stored and returned in a Rectangle, or Rectangle-like, object.
     *
     * @method Phaser.GameObjects.Components.GetBounds#getBounds
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Rectangle} O - [output,$return]
     *
     * @param {(Phaser.Geom.Rectangle|object)} [output] - An object to store the values in. If not provided a new Rectangle will be created.
     *
     * @return {(Phaser.Geom.Rectangle|object)} The values stored in the output object.
     */getBounds:function(t){// Instead of doing a check if parent container is 
// defined per corner we only do it once.
if(void 0===t&&(t=new i),this.parentContainer){var e,n,s,r,o,a,h,l,u=this.parentContainer.getBoundsTransformMatrix();this.getTopLeft(t),u.transformPoint(t.x,t.y,t),e=t.x,n=t.y,this.getTopRight(t),u.transformPoint(t.x,t.y,t),s=t.x,r=t.y,this.getBottomLeft(t),u.transformPoint(t.x,t.y,t),o=t.x,a=t.y,this.getBottomRight(t),u.transformPoint(t.x,t.y,t),h=t.x,l=t.y}else this.getTopLeft(t),e=t.x,n=t.y,this.getTopRight(t),s=t.x,r=t.y,this.getBottomLeft(t),o=t.x,a=t.y,this.getBottomRight(t),h=t.x,l=t.y;return t.x=Math.min(e,s,o,h),t.y=Math.min(n,r,a,l),t.width=Math.max(e,s,o,h)-t.x,t.height=Math.max(n,r,a,l)-t.y,t}}}),r("cwr8X",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("6pEze"),r=s("cu9YH"),o=s("c3WbB"),a=s("gZ2BZ"),h=s("1LRPh"),l=s("xap54"),u=new i({initialize:function(t,e,i,n){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=0),/**
         * The geometry constant type of this object: `GEOM_CONST.RECTANGLE`.
         * Used for fast type comparisons.
         *
         * @name Phaser.Geom.Rectangle#type
         * @type {integer}
         * @readonly
         * @since 3.19.0
         */this.type=a.RECTANGLE,/**
         * The X coordinate of the top left corner of the Rectangle.
         *
         * @name Phaser.Geom.Rectangle#x
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.x=t,/**
         * The Y coordinate of the top left corner of the Rectangle.
         *
         * @name Phaser.Geom.Rectangle#y
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.y=e,/**
         * The width of the Rectangle, i.e. the distance between its left side (defined by `x`) and its right side.
         *
         * @name Phaser.Geom.Rectangle#width
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.width=i,/**
         * The height of the Rectangle, i.e. the distance between its top side (defined by `y`) and its bottom side.
         *
         * @name Phaser.Geom.Rectangle#height
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.height=n},/**
     * Checks if the given point is inside the Rectangle's bounds.
     *
     * @method Phaser.Geom.Rectangle#contains
     * @since 3.0.0
     *
     * @param {number} x - The X coordinate of the point to check.
     * @param {number} y - The Y coordinate of the point to check.
     *
     * @return {boolean} `true` if the point is within the Rectangle's bounds, otherwise `false`.
     */contains:function(t,e){return n(this,t,e)},/**
     * Calculates the coordinates of a point at a certain `position` on the Rectangle's perimeter.
     * 
     * The `position` is a fraction between 0 and 1 which defines how far into the perimeter the point is.
     * 
     * A value of 0 or 1 returns the point at the top left corner of the rectangle, while a value of 0.5 returns the point at the bottom right corner of the rectangle. Values between 0 and 0.5 are on the top or the right side and values between 0.5 and 1 are on the bottom or the left side.
     *
     * @method Phaser.Geom.Rectangle#getPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point} O - [output,$return]
     *
     * @param {number} position - The normalized distance into the Rectangle's perimeter to return.
     * @param {(Phaser.Geom.Point|object)} [output] - An object to update with the `x` and `y` coordinates of the point.
     *
     * @return {(Phaser.Geom.Point|object)} The updated `output` object, or a new Point if no `output` object was given.
     */getPoint:function(t,e){return r(this,t,e)},/**
     * Returns an array of points from the perimeter of the Rectangle, each spaced out based on the quantity or step required.
     *
     * @method Phaser.Geom.Rectangle#getPoints
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point[]} O - [output,$return]
     *
     * @param {integer} quantity - The number of points to return. Set to `false` or 0 to return an arbitrary number of points (`perimeter / stepRate`) evenly spaced around the Rectangle based on the `stepRate`.
     * @param {number} [stepRate] - If `quantity` is 0, determines the normalized distance between each returned point.
     * @param {(array|Phaser.Geom.Point[])} [output] - An array to which to append the points.
     *
     * @return {(array|Phaser.Geom.Point[])} The modified `output` array, or a new array if none was provided.
     */getPoints:function(t,e,i){return o(this,t,e,i)},/**
     * Returns a random point within the Rectangle's bounds.
     *
     * @method Phaser.Geom.Rectangle#getRandomPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point} O - [point,$return]
     *
     * @param {Phaser.Geom.Point} [point] - The object in which to store the `x` and `y` coordinates of the point.
     *
     * @return {Phaser.Geom.Point} The updated `point`, or a new Point if none was provided.
     */getRandomPoint:function(t){return l(this,t)},/**
     * Sets the position, width, and height of the Rectangle.
     *
     * @method Phaser.Geom.Rectangle#setTo
     * @since 3.0.0
     *
     * @param {number} x - The X coordinate of the top left corner of the Rectangle.
     * @param {number} y - The Y coordinate of the top left corner of the Rectangle.
     * @param {number} width - The width of the Rectangle.
     * @param {number} height - The height of the Rectangle.
     *
     * @return {this} This Rectangle object.
     */setTo:function(t,e,i,n){return this.x=t,this.y=e,this.width=i,this.height=n,this},/**
     * Resets the position, width, and height of the Rectangle to 0.
     *
     * @method Phaser.Geom.Rectangle#setEmpty
     * @since 3.0.0
     *
     * @return {this} This Rectangle object.
     */setEmpty:function(){return this.setTo(0,0,0,0)},/**
     * Sets the position of the Rectangle.
     *
     * @method Phaser.Geom.Rectangle#setPosition
     * @since 3.0.0
     *
     * @param {number} x - The X coordinate of the top left corner of the Rectangle.
     * @param {number} [y=x] - The Y coordinate of the top left corner of the Rectangle.
     *
     * @return {this} This Rectangle object.
     */setPosition:function(t,e){return void 0===e&&(e=t),this.x=t,this.y=e,this},/**
     * Sets the width and height of the Rectangle.
     *
     * @method Phaser.Geom.Rectangle#setSize
     * @since 3.0.0
     *
     * @param {number} width - The width to set the Rectangle to.
     * @param {number} [height=width] - The height to set the Rectangle to.
     *
     * @return {this} This Rectangle object.
     */setSize:function(t,e){return void 0===e&&(e=t),this.width=t,this.height=e,this},/**
     * Determines if the Rectangle is empty. A Rectangle is empty if its width or height is less than or equal to 0.
     *
     * @method Phaser.Geom.Rectangle#isEmpty
     * @since 3.0.0
     *
     * @return {boolean} `true` if the Rectangle is empty. A Rectangle object is empty if its width or height is less than or equal to 0.
     */isEmpty:function(){return this.width<=0||this.height<=0},/**
     * Returns a Line object that corresponds to the top of this Rectangle.
     *
     * @method Phaser.Geom.Rectangle#getLineA
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Line} O - [line,$return]
     *
     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
     *
     * @return {Phaser.Geom.Line} A Line object that corresponds to the top of this Rectangle.
     */getLineA:function(t){return void 0===t&&(t=new h),t.setTo(this.x,this.y,this.right,this.y),t},/**
     * Returns a Line object that corresponds to the right of this Rectangle.
     *
     * @method Phaser.Geom.Rectangle#getLineB
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Line} O - [line,$return]
     *
     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
     *
     * @return {Phaser.Geom.Line} A Line object that corresponds to the right of this Rectangle.
     */getLineB:function(t){return void 0===t&&(t=new h),t.setTo(this.right,this.y,this.right,this.bottom),t},/**
     * Returns a Line object that corresponds to the bottom of this Rectangle.
     *
     * @method Phaser.Geom.Rectangle#getLineC
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Line} O - [line,$return]
     *
     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
     *
     * @return {Phaser.Geom.Line} A Line object that corresponds to the bottom of this Rectangle.
     */getLineC:function(t){return void 0===t&&(t=new h),t.setTo(this.right,this.bottom,this.x,this.bottom),t},/**
     * Returns a Line object that corresponds to the left of this Rectangle.
     *
     * @method Phaser.Geom.Rectangle#getLineD
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Line} O - [line,$return]
     *
     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
     *
     * @return {Phaser.Geom.Line} A Line object that corresponds to the left of this Rectangle.
     */getLineD:function(t){return void 0===t&&(t=new h),t.setTo(this.x,this.bottom,this.x,this.y),t},/**
     * The x coordinate of the left of the Rectangle.
     * Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.
     *
     * @name Phaser.Geom.Rectangle#left
     * @type {number}
     * @since 3.0.0
     */left:{get:function(){return this.x},set:function(t){t>=this.right?this.width=0:this.width=this.right-t,this.x=t}},/**
     * The sum of the x and width properties.
     * Changing the right property of a Rectangle object has no effect on the x, y and height properties, however it does affect the width property.
     *
     * @name Phaser.Geom.Rectangle#right
     * @type {number}
     * @since 3.0.0
     */right:{get:function(){return this.x+this.width},set:function(t){t<=this.x?this.width=0:this.width=t-this.x}},/**
     * The y coordinate of the top of the Rectangle. Changing the top property of a Rectangle object has no effect on the x and width properties.
     * However it does affect the height property, whereas changing the y value does not affect the height property.
     *
     * @name Phaser.Geom.Rectangle#top
     * @type {number}
     * @since 3.0.0
     */top:{get:function(){return this.y},set:function(t){t>=this.bottom?this.height=0:this.height=this.bottom-t,this.y=t}},/**
     * The sum of the y and height properties.
     * Changing the bottom property of a Rectangle object has no effect on the x, y and width properties, but does change the height property.
     *
     * @name Phaser.Geom.Rectangle#bottom
     * @type {number}
     * @since 3.0.0
     */bottom:{get:function(){return this.y+this.height},set:function(t){t<=this.y?this.height=0:this.height=t-this.y}},/**
     * The x coordinate of the center of the Rectangle.
     *
     * @name Phaser.Geom.Rectangle#centerX
     * @type {number}
     * @since 3.0.0
     */centerX:{get:function(){return this.x+this.width/2},set:function(t){this.x=t-this.width/2}},/**
     * The y coordinate of the center of the Rectangle.
     *
     * @name Phaser.Geom.Rectangle#centerY
     * @type {number}
     * @since 3.0.0
     */centerY:{get:function(){return this.y+this.height/2},set:function(t){this.y=t-this.height/2}}});t.exports=u}),r("6pEze",function(t,e){t.exports=function(t,e,i){return!(t.width<=0)&&!(t.height<=0)&&t.x<=e&&t.x+t.width>=e&&t.y<=i&&t.y+t.height>=i}}),r("cu9YH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ltSp2"),n=s("cSEB9");t.exports=function(t,e,s){if(void 0===s&&(s=new n),e<=0||e>=1)return s.x=t.x,s.y=t.y,s;var r=i(t)*e;return e>.5?(r-=t.width+t.height)<=t.width?(//  Face 3
s.x=t.right-r,s.y=t.bottom):(//  Face 4
s.x=t.x,s.y=t.bottom-(r-t.width)):r<=t.width?(//  Face 1
s.x=t.x+r,s.y=t.y):(//  Face 2
s.x=t.right,s.y=t.y+(r-t.width)),s}}),r("ltSp2",function(t,e){t.exports=function(t){return 2*(t.width+t.height)}}),r("c3WbB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cu9YH"),n=s("ltSp2");t.exports=function(t,e,s,r){void 0===r&&(r=[]),!e&&s>0&&(e=n(t)/s);for(var o=0;o<e;o++){var a=o/e;r.push(i(t,a))}return r}}),r("1LRPh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("9T44R"),r=s("fYnml"),o=s("gZ2BZ"),a=s("1Ap5d"),h=s("7SBSk"),l=new i({initialize:function(t,e,i,n){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=0),/**
         * The geometry constant type of this object: `GEOM_CONST.LINE`.
         * Used for fast type comparisons.
         *
         * @name Phaser.Geom.Line#type
         * @type {integer}
         * @readonly
         * @since 3.19.0
         */this.type=o.LINE,/**
         * The x coordinate of the lines starting point.
         *
         * @name Phaser.Geom.Line#x1
         * @type {number}
         * @since 3.0.0
         */this.x1=t,/**
         * The y coordinate of the lines starting point.
         *
         * @name Phaser.Geom.Line#y1
         * @type {number}
         * @since 3.0.0
         */this.y1=e,/**
         * The x coordinate of the lines ending point.
         *
         * @name Phaser.Geom.Line#x2
         * @type {number}
         * @since 3.0.0
         */this.x2=i,/**
         * The y coordinate of the lines ending point.
         *
         * @name Phaser.Geom.Line#y2
         * @type {number}
         * @since 3.0.0
         */this.y2=n},/**
     * Get a point on a line that's a given percentage along its length.
     *
     * @method Phaser.Geom.Line#getPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point} O - [output,$return]
     *
     * @param {number} position - A value between 0 and 1, where 0 is the start, 0.5 is the middle and 1 is the end of the line.
     * @param {(Phaser.Geom.Point|object)} [output] - An optional point, or point-like object, to store the coordinates of the point on the line.
     *
     * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point on the line.
     */getPoint:function(t,e){return n(this,t,e)},/**
     * Get a number of points along a line's length.
     *
     * Provide a `quantity` to get an exact number of points along the line.
     *
     * Provide a `stepRate` to ensure a specific distance between each point on the line. Set `quantity` to `0` when
     * providing a `stepRate`.
     *
     * @method Phaser.Geom.Line#getPoints
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point[]} O - [output,$return]
     *
     * @param {integer} quantity - The number of points to place on the line. Set to `0` to use `stepRate` instead.
     * @param {integer} [stepRate] - The distance between each point on the line. When set, `quantity` is implied and should be set to `0`.
     * @param {(array|Phaser.Geom.Point[])} [output] - An optional array of Points, or point-like objects, to store the coordinates of the points on the line.
     *
     * @return {(array|Phaser.Geom.Point[])} An array of Points, or point-like objects, containing the coordinates of the points on the line.
     */getPoints:function(t,e,i){return r(this,t,e,i)},/**
     * Get a random Point on the Line.
     *
     * @method Phaser.Geom.Line#getRandomPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point} O - [point,$return]
     *
     * @param {(Phaser.Geom.Point|object)} [point] - An instance of a Point to be modified.
     *
     * @return {Phaser.Geom.Point} A random Point on the Line.
     */getRandomPoint:function(t){return a(this,t)},/**
     * Set new coordinates for the line endpoints.
     *
     * @method Phaser.Geom.Line#setTo
     * @since 3.0.0
     *
     * @param {number} [x1=0] - The x coordinate of the lines starting point.
     * @param {number} [y1=0] - The y coordinate of the lines starting point.
     * @param {number} [x2=0] - The x coordinate of the lines ending point.
     * @param {number} [y2=0] - The y coordinate of the lines ending point.
     *
     * @return {this} This Line object.
     */setTo:function(t,e,i,n){return void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=0),this.x1=t,this.y1=e,this.x2=i,this.y2=n,this},/**
     * Returns a Vector2 object that corresponds to the start of this Line.
     *
     * @method Phaser.Geom.Line#getPointA
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [vec2,$return]
     *
     * @param {Phaser.Math.Vector2} [vec2] - A Vector2 object to set the results in. If `undefined` a new Vector2 will be created.
     *
     * @return {Phaser.Math.Vector2} A Vector2 object that corresponds to the start of this Line.
     */getPointA:function(t){return void 0===t&&(t=new h),t.set(this.x1,this.y1),t},/**
     * Returns a Vector2 object that corresponds to the end of this Line.
     *
     * @method Phaser.Geom.Line#getPointB
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [vec2,$return]
     *
     * @param {Phaser.Math.Vector2} [vec2] - A Vector2 object to set the results in. If `undefined` a new Vector2 will be created.
     *
     * @return {Phaser.Math.Vector2} A Vector2 object that corresponds to the end of this Line.
     */getPointB:function(t){return void 0===t&&(t=new h),t.set(this.x2,this.y2),t},/**
     * The left position of the Line.
     *
     * @name Phaser.Geom.Line#left
     * @type {number}
     * @since 3.0.0
     */left:{get:function(){return Math.min(this.x1,this.x2)},set:function(t){this.x1<=this.x2?this.x1=t:this.x2=t}},/**
     * The right position of the Line.
     *
     * @name Phaser.Geom.Line#right
     * @type {number}
     * @since 3.0.0
     */right:{get:function(){return Math.max(this.x1,this.x2)},set:function(t){this.x1>this.x2?this.x1=t:this.x2=t}},/**
     * The top position of the Line.
     *
     * @name Phaser.Geom.Line#top
     * @type {number}
     * @since 3.0.0
     */top:{get:function(){return Math.min(this.y1,this.y2)},set:function(t){this.y1<=this.y2?this.y1=t:this.y2=t}},/**
     * The bottom position of the Line.
     *
     * @name Phaser.Geom.Line#bottom
     * @type {number}
     * @since 3.0.0
     */bottom:{get:function(){return Math.max(this.y1,this.y2)},set:function(t){this.y1>this.y2?this.y1=t:this.y2=t}}});t.exports=l}),r("9T44R",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e,n){return void 0===n&&(n=new i),n.x=t.x1+(t.x2-t.x1)*e,n.y=t.y1+(t.y2-t.y1)*e,n}}),r("fYnml",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7Smss"),n=s("cSEB9");t.exports=function(t,e,s,r){void 0===r&&(r=[]),!e&&s>0&&(e=i(t)/s);for(var o=t.x1,a=t.y1,h=t.x2,l=t.y2,u=0;u<e;u++){var c=u/e,d=o+(h-o)*c,f=a+(l-a)*c;r.push(new n(d,f))}return r}}),r("7Smss",function(t,e){t.exports=function(t){return Math.sqrt((t.x2-t.x1)*(t.x2-t.x1)+(t.y2-t.y1)*(t.y2-t.y1))}}),r("1Ap5d",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e){void 0===e&&(e=new i);var n=Math.random();return e.x=t.x1+n*(t.x2-t.x1),e.y=t.y1+n*(t.y2-t.y1),e}}),r("7SBSk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji
//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl
var i=s("jwj1g"),n=s("4cohD"),r=new i({initialize:function(t,e){/**
         * The x component of this Vector.
         *
         * @name Phaser.Math.Vector2#x
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.x=0,/**
         * The y component of this Vector.
         *
         * @name Phaser.Math.Vector2#y
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.y=0,"object"==typeof t?(this.x=t.x||0,this.y=t.y||0):(void 0===e&&(e=t),this.x=t||0,this.y=e||0)},/**
     * Make a clone of this Vector2.
     *
     * @method Phaser.Math.Vector2#clone
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector2} A clone of this Vector2.
     */clone:function(){return new r(this.x,this.y)},/**
     * Copy the components of a given Vector into this Vector.
     *
     * @method Phaser.Math.Vector2#copy
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} src - The Vector to copy the components from.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */copy:function(t){return this.x=t.x||0,this.y=t.y||0,this},/**
     * Set the component values of this Vector from a given Vector2Like object.
     *
     * @method Phaser.Math.Vector2#setFromObject
     * @since 3.0.0
     *
     * @param {Phaser.Types.Math.Vector2Like} obj - The object containing the component values to set for this Vector.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */setFromObject:function(t){return this.x=t.x||0,this.y=t.y||0,this},/**
     * Set the `x` and `y` components of the this Vector to the given `x` and `y` values.
     *
     * @method Phaser.Math.Vector2#set
     * @since 3.0.0
     *
     * @param {number} x - The x value to set for this Vector.
     * @param {number} [y=x] - The y value to set for this Vector.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */set:function(t,e){return void 0===e&&(e=t),this.x=t,this.y=e,this},/**
     * This method is an alias for `Vector2.set`.
     *
     * @method Phaser.Math.Vector2#setTo
     * @since 3.4.0
     *
     * @param {number} x - The x value to set for this Vector.
     * @param {number} [y=x] - The y value to set for this Vector.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */setTo:function(t,e){return this.set(t,e)},/**
     * Sets the `x` and `y` values of this object from a given polar coordinate.
     *
     * @method Phaser.Math.Vector2#setToPolar
     * @since 3.0.0
     *
     * @param {number} azimuth - The angular coordinate, in radians.
     * @param {number} [radius=1] - The radial coordinate (length).
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */setToPolar:function(t,e){return null==e&&(e=1),this.x=Math.cos(t)*e,this.y=Math.sin(t)*e,this},/**
     * Check whether this Vector is equal to a given Vector.
     *
     * Performs a strict equality check against each Vector's components.
     *
     * @method Phaser.Math.Vector2#equals
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} v - The vector to compare with this Vector.
     *
     * @return {boolean} Whether the given Vector is equal to this Vector.
     */equals:function(t){return this.x===t.x&&this.y===t.y},/**
     * Check whether this Vector is approximately equal to a given Vector.
     *
     * @method Phaser.Math.Vector2#fuzzyEquals
     * @since 3.23.0
     *
     * @param {Phaser.Math.Vector2} v - The vector to compare with this Vector.
     * @param {number} [epsilon=0.0001] - The tolerance value.
     *
     * @return {boolean} Whether both absolute differences of the x and y components are smaller than `epsilon`.
     */fuzzyEquals:function(t,e){return n(this.x,t.x,e)&&n(this.y,t.y,e)},/**
     * Calculate the angle between this Vector and the positive x-axis, in radians.
     *
     * @method Phaser.Math.Vector2#angle
     * @since 3.0.0
     *
     * @return {number} The angle between this Vector, and the positive x-axis, given in radians.
     */angle:function(){// computes the angle in radians with respect to the positive x-axis
var t=Math.atan2(this.y,this.x);return t<0&&(t+=2*Math.PI),t},/**
     * Set the angle of this Vector.
     *
     * @method Phaser.Math.Vector2#setAngle
     * @since 3.23.0
     *
     * @param {number} angle - The angle, in radians.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */setAngle:function(t){return this.setToPolar(t,this.length())},/**
     * Add a given Vector to this Vector. Addition is component-wise.
     *
     * @method Phaser.Math.Vector2#add
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} src - The Vector to add to this Vector.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */add:function(t){return this.x+=t.x,this.y+=t.y,this},/**
     * Subtract the given Vector from this Vector. Subtraction is component-wise.
     *
     * @method Phaser.Math.Vector2#subtract
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} src - The Vector to subtract from this Vector.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */subtract:function(t){return this.x-=t.x,this.y-=t.y,this},/**
     * Perform a component-wise multiplication between this Vector and the given Vector.
     *
     * Multiplies this Vector by the given Vector.
     *
     * @method Phaser.Math.Vector2#multiply
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} src - The Vector to multiply this Vector by.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */multiply:function(t){return this.x*=t.x,this.y*=t.y,this},/**
     * Scale this Vector by the given value.
     *
     * @method Phaser.Math.Vector2#scale
     * @since 3.0.0
     *
     * @param {number} value - The value to scale this Vector by.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */scale:function(t){return isFinite(t)?(this.x*=t,this.y*=t):(this.x=0,this.y=0),this},/**
     * Perform a component-wise division between this Vector and the given Vector.
     *
     * Divides this Vector by the given Vector.
     *
     * @method Phaser.Math.Vector2#divide
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} src - The Vector to divide this Vector by.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */divide:function(t){return this.x/=t.x,this.y/=t.y,this},/**
     * Negate the `x` and `y` components of this Vector.
     *
     * @method Phaser.Math.Vector2#negate
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */negate:function(){return this.x=-this.x,this.y=-this.y,this},/**
     * Calculate the distance between this Vector and the given Vector.
     *
     * @method Phaser.Math.Vector2#distance
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.
     *
     * @return {number} The distance from this Vector to the given Vector.
     */distance:function(t){var e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)},/**
     * Calculate the distance between this Vector and the given Vector, squared.
     *
     * @method Phaser.Math.Vector2#distanceSq
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.
     *
     * @return {number} The distance from this Vector to the given Vector, squared.
     */distanceSq:function(t){var e=t.x-this.x,i=t.y-this.y;return e*e+i*i},/**
     * Calculate the length (or magnitude) of this Vector.
     *
     * @method Phaser.Math.Vector2#length
     * @since 3.0.0
     *
     * @return {number} The length of this Vector.
     */length:function(){var t=this.x,e=this.y;return Math.sqrt(t*t+e*e)},/**
     * Set the length (or magnitude) of this Vector.
     *
     * @method Phaser.Math.Vector2#setLength
     * @since 3.23.0
     *
     * @param {number} length
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */setLength:function(t){return this.normalize().scale(t)},/**
     * Calculate the length of this Vector squared.
     *
     * @method Phaser.Math.Vector2#lengthSq
     * @since 3.0.0
     *
     * @return {number} The length of this Vector, squared.
     */lengthSq:function(){var t=this.x,e=this.y;return t*t+e*e},/**
     * Normalize this Vector.
     *
     * Makes the vector a unit length vector (magnitude of 1) in the same direction.
     *
     * @method Phaser.Math.Vector2#normalize
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */normalize:function(){var t=this.x,e=this.y,i=t*t+e*e;return i>0&&(i=1/Math.sqrt(i),this.x=t*i,this.y=e*i),this},/**
     * Rotate this Vector to its perpendicular, in the positive direction.
     *
     * @method Phaser.Math.Vector2#normalizeRightHand
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */normalizeRightHand:function(){var t=this.x;return this.x=-1*this.y,this.y=t,this},/**
     * Rotate this Vector to its perpendicular, in the negative direction.
     *
     * @method Phaser.Math.Vector2#normalizeLeftHand
     * @since 3.23.0
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */normalizeLeftHand:function(){var t=this.x;return this.x=this.y,this.y=-1*t,this},/**
     * Calculate the dot product of this Vector and the given Vector.
     *
     * @method Phaser.Math.Vector2#dot
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} src - The Vector2 to dot product with this Vector2.
     *
     * @return {number} The dot product of this Vector and the given Vector.
     */dot:function(t){return this.x*t.x+this.y*t.y},/**
     * Calculate the cross product of this Vector and the given Vector.
     *
     * @method Phaser.Math.Vector2#cross
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} src - The Vector2 to cross with this Vector2.
     *
     * @return {number} The cross product of this Vector and the given Vector.
     */cross:function(t){return this.x*t.y-this.y*t.x},/**
     * Linearly interpolate between this Vector and the given Vector.
     *
     * Interpolates this Vector towards the given Vector.
     *
     * @method Phaser.Math.Vector2#lerp
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} src - The Vector2 to interpolate towards.
     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */lerp:function(t,e){void 0===e&&(e=0);var i=this.x,n=this.y;return this.x=i+e*(t.x-i),this.y=n+e*(t.y-n),this},/**
     * Transform this Vector with the given Matrix.
     *
     * @method Phaser.Math.Vector2#transformMat3
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector2 with.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */transformMat3:function(t){var e=this.x,i=this.y,n=t.val;return this.x=n[0]*e+n[3]*i+n[6],this.y=n[1]*e+n[4]*i+n[7],this},/**
     * Transform this Vector with the given Matrix.
     *
     * @method Phaser.Math.Vector2#transformMat4
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector2 with.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */transformMat4:function(t){var e=this.x,i=this.y,n=t.val;return this.x=n[0]*e+n[4]*i+n[12],this.y=n[1]*e+n[5]*i+n[13],this},/**
     * Make this Vector the zero vector (0, 0).
     *
     * @method Phaser.Math.Vector2#reset
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */reset:function(){return this.x=0,this.y=0,this},/**
     * Limit the length (or magnitude) of this Vector.
     *
     * @method Phaser.Math.Vector2#limit
     * @since 3.23.0
     *
     * @param {number} max - The maximum length.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */limit:function(t){var e=this.length();return e&&e>t&&this.scale(t/e),this},/**
     * Reflect this Vector off a line defined by a normal.
     *
     * @method Phaser.Math.Vector2#reflect
     * @since 3.23.0
     *
     * @param {Phaser.Math.Vector2} normal - A vector perpendicular to the line.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */reflect:function(t){return t=t.clone().normalize(),this.subtract(t.scale(2*this.dot(t)))},/**
     * Reflect this Vector across another.
     *
     * @method Phaser.Math.Vector2#mirror
     * @since 3.23.0
     *
     * @param {Phaser.Math.Vector2} axis - A vector to reflect across.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */mirror:function(t){return this.reflect(t).negate()},/**
     * Rotate this Vector by an angle amount.
     *
     * @method Phaser.Math.Vector2#rotate
     * @since 3.23.0
     *
     * @param {number} delta - The angle to rotate by, in radians.
     *
     * @return {Phaser.Math.Vector2} This Vector2.
     */rotate:function(t){var e=Math.cos(t),i=Math.sin(t);return this.set(e*this.x-i*this.y,i*this.x+e*this.y)}});/**
 * A static zero Vector2 for use by reference.
 *
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector2.ZERO
 * @type {Phaser.Math.Vector2}
 * @since 3.1.0
 */r.ZERO=new r,/**
 * A static right Vector2 for use by reference.
 *
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector2.RIGHT
 * @type {Phaser.Math.Vector2}
 * @since 3.16.0
 */r.RIGHT=new r(1,0),/**
 * A static left Vector2 for use by reference.
 *
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector2.LEFT
 * @type {Phaser.Math.Vector2}
 * @since 3.16.0
 */r.LEFT=new r(-1,0),/**
 * A static up Vector2 for use by reference.
 *
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector2.UP
 * @type {Phaser.Math.Vector2}
 * @since 3.16.0
 */r.UP=new r(0,-1),/**
 * A static down Vector2 for use by reference.
 *
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector2.DOWN
 * @type {Phaser.Math.Vector2}
 * @since 3.16.0
 */r.DOWN=new r(0,1),/**
 * A static one Vector2 for use by reference.
 *
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector2.ONE
 * @type {Phaser.Math.Vector2}
 * @since 3.16.0
 */r.ONE=new r(1,1),t.exports=r}),r("4cohD",function(t,e){t.exports=function(t,e,i){return void 0===i&&(i=1e-4),Math.abs(t-e)<i}}),r("xap54",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e){return void 0===e&&(e=new i),e.x=t.x+Math.random()*t.width,e.y=t.y+Math.random()*t.height,e}}),r("5Ntai",function(t,e){t.exports=function(t,e,i,n){var s=Math.cos(n),r=Math.sin(n),o=t.x-e,a=t.y-i;return t.x=o*s-a*r+e,t.y=o*r+a*s+i,t}}),r("42G5m",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("JBPsZ"),n=s("gPaIB");t.exports={/**
     * The Mask this Game Object is using during render.
     *
     * @name Phaser.GameObjects.Components.Mask#mask
     * @type {Phaser.Display.Masks.BitmapMask|Phaser.Display.Masks.GeometryMask}
     * @since 3.0.0
     */mask:null,/**
     * Sets the mask that this Game Object will use to render with.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Game Object it will be immediately replaced.
     * 
     * Masks are positioned in global space and are not relative to the Game Object to which they
     * are applied. The reason for this is that multiple Game Objects can all share the same mask.
     * 
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     *
     * @method Phaser.GameObjects.Components.Mask#setMask
     * @since 3.6.2
     *
     * @param {Phaser.Display.Masks.BitmapMask|Phaser.Display.Masks.GeometryMask} mask - The mask this Game Object will use when rendering.
     *
     * @return {this} This Game Object instance.
     */setMask:function(t){return this.mask=t,this},/**
     * Clears the mask that this Game Object was using.
     *
     * @method Phaser.GameObjects.Components.Mask#clearMask
     * @since 3.6.2
     *
     * @param {boolean} [destroyMask=false] - Destroy the mask before clearing it?
     *
     * @return {this} This Game Object instance.
     */clearMask:function(t){return void 0===t&&(t=!1),t&&this.mask&&this.mask.destroy(),this.mask=null,this},/**
     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a renderable Game Object.
     * A renderable Game Object is one that uses a texture to render with, such as an
     * Image, Sprite, Render Texture or BitmapText.
     *
     * If you do not provide a renderable object, and this Game Object has a texture,
     * it will use itself as the object. This means you can call this method to create
     * a Bitmap Mask from any renderable Game Object.
     *
     * @method Phaser.GameObjects.Components.Mask#createBitmapMask
     * @since 3.6.2
     * 
     * @param {Phaser.GameObjects.GameObject} [renderable] - A renderable Game Object that uses a texture, such as a Sprite.
     *
     * @return {Phaser.Display.Masks.BitmapMask} This Bitmap Mask that was created.
     */createBitmapMask:function(t){return void 0===t&&(this.texture||this.shader)&&(t=this),new i(this.scene,t)},/**
     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
     * including this one.
     *
     * To create the mask you need to pass in a reference to a Graphics Game Object.
     *
     * If you do not provide a graphics object, and this Game Object is an instance
     * of a Graphics object, then it will use itself to create the mask.
     * 
     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
     *
     * @method Phaser.GameObjects.Components.Mask#createGeometryMask
     * @since 3.6.2
     * 
     * @param {Phaser.GameObjects.Graphics} [graphics] - A Graphics Game Object. The geometry within it will be used as the mask.
     *
     * @return {Phaser.Display.Masks.GeometryMask} This Geometry Mask that was created.
     */createGeometryMask:function(t){return void 0===t&&"Graphics"===this.type&&(t=this),new n(this.scene,t)}}}),r("JBPsZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("aqcI1"),r=new i({initialize:function(t,e){var i=t.sys.game.renderer;if(/**
         * A reference to either the Canvas or WebGL Renderer that this Mask is using.
         *
         * @name Phaser.Display.Masks.BitmapMask#renderer
         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}
         * @since 3.11.0
         */this.renderer=i,/**
         * A renderable Game Object that uses a texture, such as a Sprite.
         *
         * @name Phaser.Display.Masks.BitmapMask#bitmapMask
         * @type {Phaser.GameObjects.GameObject}
         * @since 3.0.0
         */this.bitmapMask=e,/**
         * The texture used for the mask's framebuffer.
         *
         * @name Phaser.Display.Masks.BitmapMask#maskTexture
         * @type {WebGLTexture}
         * @default null
         * @since 3.0.0
         */this.maskTexture=null,/**
         * The texture used for the main framebuffer.
         *
         * @name Phaser.Display.Masks.BitmapMask#mainTexture
         * @type {WebGLTexture}
         * @default null
         * @since 3.0.0
         */this.mainTexture=null,/**
         * Whether the Bitmap Mask is dirty and needs to be updated.
         *
         * @name Phaser.Display.Masks.BitmapMask#dirty
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.dirty=!0,/**
         * The framebuffer to which a masked Game Object is rendered.
         *
         * @name Phaser.Display.Masks.BitmapMask#mainFramebuffer
         * @type {WebGLFramebuffer}
         * @since 3.0.0
         */this.mainFramebuffer=null,/**
         * The framebuffer to which the Bitmap Mask's masking Game Object is rendered.
         *
         * @name Phaser.Display.Masks.BitmapMask#maskFramebuffer
         * @type {WebGLFramebuffer}
         * @since 3.0.0
         */this.maskFramebuffer=null,/**
         * The previous framebuffer set in the renderer before this one was enabled.
         *
         * @name Phaser.Display.Masks.BitmapMask#prevFramebuffer
         * @type {WebGLFramebuffer}
         * @since 3.17.0
         */this.prevFramebuffer=null,/**
         * Whether to invert the masks alpha.
         *
         * If `true`, the alpha of the masking pixel will be inverted before it's multiplied with the masked pixel. Essentially, this means that a masked area will be visible only if the corresponding area in the mask is invisible.
         *
         * @name Phaser.Display.Masks.BitmapMask#invertAlpha
         * @type {boolean}
         * @since 3.1.2
         */this.invertAlpha=!1,/**
         * Is this mask a stencil mask?
         *
         * @name Phaser.Display.Masks.BitmapMask#isStencil
         * @type {boolean}
         * @readonly
         * @since 3.17.0
         */this.isStencil=!1,i&&i.gl){var s=i.width,r=i.height,o=(s&s-1)==0&&(r&r-1)==0,a=i.gl,h=o?a.REPEAT:a.CLAMP_TO_EDGE,l=a.LINEAR;this.mainTexture=i.createTexture2D(0,l,l,h,h,a.RGBA,null,s,r),this.maskTexture=i.createTexture2D(0,l,l,h,h,a.RGBA,null,s,r),this.mainFramebuffer=i.createFramebuffer(s,r,this.mainTexture,!0),this.maskFramebuffer=i.createFramebuffer(s,r,this.maskTexture,!0),t.sys.game.events.on(n.CONTEXT_RESTORED,function(t){var e=t.width,i=t.height,n=(e&e-1)==0&&(i&i-1)==0,s=t.gl,r=n?s.REPEAT:s.CLAMP_TO_EDGE,o=s.LINEAR;this.mainTexture=t.createTexture2D(0,o,o,r,r,s.RGBA,null,e,i),this.maskTexture=t.createTexture2D(0,o,o,r,r,s.RGBA,null,e,i),this.mainFramebuffer=t.createFramebuffer(e,i,this.mainTexture,!0),this.maskFramebuffer=t.createFramebuffer(e,i,this.maskTexture,!0)},this)}},/**
     * Sets a new masking Game Object for the Bitmap Mask.
     *
     * @method Phaser.Display.Masks.BitmapMask#setBitmap
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} renderable - A renderable Game Object that uses a texture, such as a Sprite.
     */setBitmap:function(t){this.bitmapMask=t},/**
     * Prepares the WebGL Renderer to render a Game Object with this mask applied.
     *
     * This renders the masking Game Object to the mask framebuffer and switches to the main framebuffer so that the masked Game Object will be rendered to it instead of being rendered directly to the frame.
     *
     * @method Phaser.Display.Masks.BitmapMask#preRenderWebGL
     * @since 3.0.0
     *
     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The WebGL Renderer to prepare.
     * @param {Phaser.GameObjects.GameObject} maskedObject - The masked Game Object which will be drawn.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to render to.
     */preRenderWebGL:function(t,e,i){t.pipelines.BitmapMaskPipeline.beginMask(this,e,i)},/**
     * Finalizes rendering of a masked Game Object.
     *
     * This resets the previously bound framebuffer and switches the WebGL Renderer to the Bitmap Mask Pipeline, which uses a special fragment shader to apply the masking effect.
     *
     * @method Phaser.Display.Masks.BitmapMask#postRenderWebGL
     * @since 3.0.0
     *
     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The WebGL Renderer to clean up.
     */postRenderWebGL:function(t,e){t.pipelines.BitmapMaskPipeline.endMask(this,e)},/**
     * This is a NOOP method. Bitmap Masks are not supported by the Canvas Renderer.
     *
     * @method Phaser.Display.Masks.BitmapMask#preRenderCanvas
     * @since 3.0.0
     *
     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The Canvas Renderer which would be rendered to.
     * @param {Phaser.GameObjects.GameObject} mask - The masked Game Object which would be rendered.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to render to.
     */preRenderCanvas:function(){// NOOP
},/**
     * This is a NOOP method. Bitmap Masks are not supported by the Canvas Renderer.
     *
     * @method Phaser.Display.Masks.BitmapMask#postRenderCanvas
     * @since 3.0.0
     *
     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The Canvas Renderer which would be rendered to.
     */postRenderCanvas:function(){// NOOP
},/**
     * Destroys this BitmapMask and nulls any references it holds.
     * 
     * Note that if a Game Object is currently using this mask it will _not_ automatically detect you have destroyed it,
     * so be sure to call `clearMask` on any Game Object using it, before destroying it.
     *
     * @method Phaser.Display.Masks.BitmapMask#destroy
     * @since 3.7.0
     */destroy:function(){this.bitmapMask=null;var t=this.renderer;t&&t.gl&&(t.deleteTexture(this.mainTexture),t.deleteTexture(this.maskTexture),t.deleteFramebuffer(this.mainFramebuffer),t.deleteFramebuffer(this.maskFramebuffer)),this.mainTexture=null,this.maskTexture=null,this.mainFramebuffer=null,this.maskFramebuffer=null,this.prevFramebuffer=null,this.renderer=null}});t.exports=r}),r("aqcI1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Core.Events
 */t.exports={BLUR:s("S6Md2"),BOOT:s("3p34r"),CONTEXT_LOST:s("bJTme"),CONTEXT_RESTORED:s("7xqgL"),DESTROY:s("3iWin"),FOCUS:s("guddj"),HIDDEN:s("chX2D"),PAUSE:s("cVdWs"),POST_RENDER:s("8VThq"),POST_STEP:s("fxnQ0"),PRE_RENDER:s("aiE4o"),PRE_STEP:s("2OcNY"),READY:s("la08S"),RESUME:s("aQzHg"),STEP:s("eLbUF"),VISIBLE:s("hBIP0")}}),r("S6Md2",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Blur Event.
 * 
 * This event is dispatched by the Game Visibility Handler when the window in which the Game instance is embedded
 * enters a blurred state. The blur event is raised when the window loses focus. This can happen if a user swaps
 * tab, or if they simply remove focus from the browser to another app.
 *
 * @event Phaser.Core.Events#BLUR
 * @since 3.0.0
 */t.exports="blur"}),r("3p34r",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Boot Event.
 * 
 * This event is dispatched when the Phaser Game instance has finished booting, but before it is ready to start running.
 * The global systems use this event to know when to set themselves up, dispatching their own `ready` events as required.
 *
 * @event Phaser.Core.Events#BOOT
 * @since 3.0.0
 */t.exports="boot"}),r("bJTme",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Context Lost Event.
 * 
 * This event is dispatched by the Game if the WebGL Renderer it is using encounters a WebGL Context Lost event from the browser.
 * 
 * The partner event is `CONTEXT_RESTORED`.
 *
 * @event Phaser.Core.Events#CONTEXT_LOST
 * @since 3.19.0
 */t.exports="contextlost"}),r("7xqgL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Context Restored Event.
 * 
 * This event is dispatched by the Game if the WebGL Renderer it is using encounters a WebGL Context Restored event from the browser.
 * 
 * The partner event is `CONTEXT_LOST`.
 *
 * @event Phaser.Core.Events#CONTEXT_RESTORED
 * @since 3.19.0
 */t.exports="contextrestored"}),r("3iWin",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Destroy Event.
 * 
 * This event is dispatched when the game instance has been told to destroy itself.
 * Lots of internal systems listen to this event in order to clear themselves out.
 * Custom plugins and game code should also do the same.
 *
 * @event Phaser.Core.Events#DESTROY
 * @since 3.0.0
 */t.exports="destroy"}),r("guddj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Focus Event.
 * 
 * This event is dispatched by the Game Visibility Handler when the window in which the Game instance is embedded
 * enters a focused state. The focus event is raised when the window re-gains focus, having previously lost it.
 *
 * @event Phaser.Core.Events#FOCUS
 * @since 3.0.0
 */t.exports="focus"}),r("chX2D",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Hidden Event.
 * 
 * This event is dispatched by the Game Visibility Handler when the document in which the Game instance is embedded
 * enters a hidden state. Only browsers that support the Visibility API will cause this event to be emitted.
 * 
 * In most modern browsers, when the document enters a hidden state, the Request Animation Frame and setTimeout, which
 * control the main game loop, will automatically pause. There is no way to stop this from happening. It is something
 * your game should account for in its own code, should the pause be an issue (i.e. for multiplayer games)
 *
 * @event Phaser.Core.Events#HIDDEN
 * @since 3.0.0
 */t.exports="hidden"}),r("cVdWs",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Pause Event.
 * 
 * This event is dispatched when the Game loop enters a paused state, usually as a result of the Visibility Handler.
 *
 * @event Phaser.Core.Events#PAUSE
 * @since 3.0.0
 */t.exports="pause"}),r("8VThq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Post-Render Event.
 * 
 * This event is dispatched right at the end of the render process.
 * 
 * Every Scene will have rendered and been drawn to the canvas by the time this event is fired.
 * Use it for any last minute post-processing before the next game step begins.
 *
 * @event Phaser.Core.Events#POST_RENDER
 * @since 3.0.0
 * 
 * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - A reference to the current renderer being used by the Game instance.
 */t.exports="postrender"}),r("fxnQ0",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Post-Step Event.
 * 
 * This event is dispatched after the Scene Manager has updated.
 * Hook into it from plugins or systems that need to do things before the render starts.
 *
 * @event Phaser.Core.Events#POST_STEP
 * @since 3.0.0
 * 
 * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
 * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
 */t.exports="poststep"}),r("aiE4o",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Pre-Render Event.
 * 
 * This event is dispatched immediately before any of the Scenes have started to render.
 * 
 * The renderer will already have been initialized this frame, clearing itself and preparing to receive the Scenes for rendering, but it won't have actually drawn anything yet.
 *
 * @event Phaser.Core.Events#PRE_RENDER
 * @since 3.0.0
 * 
 * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - A reference to the current renderer being used by the Game instance.
 */t.exports="prerender"}),r("2OcNY",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Pre-Step Event.
 * 
 * This event is dispatched before the main Game Step starts. By this point in the game cycle none of the Scene updates have yet happened.
 * Hook into it from plugins or systems that need to update before the Scene Manager does.
 *
 * @event Phaser.Core.Events#PRE_STEP
 * @since 3.0.0
 * 
 * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
 * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
 */t.exports="prestep"}),r("la08S",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Ready Event.
 * 
 * This event is dispatched when the Phaser Game instance has finished booting, the Texture Manager is fully ready,
 * and all local systems are now able to start.
 *
 * @event Phaser.Core.Events#READY
 * @since 3.0.0
 */t.exports="ready"}),r("aQzHg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Resume Event.
 * 
 * This event is dispatched when the game loop leaves a paused state and resumes running.
 *
 * @event Phaser.Core.Events#RESUME
 * @since 3.0.0
 */t.exports="resume"}),r("eLbUF",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Step Event.
 * 
 * This event is dispatched after the Game Pre-Step and before the Scene Manager steps.
 * Hook into it from plugins or systems that need to update before the Scene Manager does, but after the core Systems have.
 *
 * @event Phaser.Core.Events#STEP
 * @since 3.0.0
 * 
 * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
 * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
 */t.exports="step"}),r("hBIP0",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Visible Event.
 * 
 * This event is dispatched by the Game Visibility Handler when the document in which the Game instance is embedded
 * enters a visible state, previously having been hidden.
 * 
 * Only browsers that support the Visibility API will cause this event to be emitted.
 *
 * @event Phaser.Core.Events#VISIBLE
 * @since 3.0.0
 */t.exports="visible"}),r("gPaIB",function(t,e){/**
 * @classdesc
 * A Geometry Mask can be applied to a Game Object to hide any pixels of it which don't intersect
 * a visible pixel from the geometry mask. The mask is essentially a clipping path which can only
 * make a masked pixel fully visible or fully invisible without changing its alpha (opacity).
 *
 * A Geometry Mask uses a Graphics Game Object to determine which pixels of the masked Game Object(s)
 * should be clipped. For any given point of a masked Game Object's texture, the pixel will only be displayed
 * if the Graphics Game Object of the Geometry Mask has a visible pixel at the same position. The color and
 * alpha of the pixel from the Geometry Mask do not matter.
 *
 * The Geometry Mask's location matches the location of its Graphics object, not the location of the masked objects.
 * Moving or transforming the underlying Graphics object will change the mask (and affect the visibility
 * of any masked objects), whereas moving or transforming a masked object will not affect the mask.
 * You can think of the Geometry Mask (or rather, of its Graphics object) as an invisible curtain placed
 * in front of all masked objects which has its own visual properties and, naturally, respects the camera's
 * visual properties, but isn't affected by and doesn't follow the masked objects by itself.
 *
 * @class GeometryMask
 * @memberof Phaser.Display.Masks
 * @constructor
 * @since 3.0.0
 *
 * @param {Phaser.Scene} scene - This parameter is not used.
 * @param {Phaser.GameObjects.Graphics} graphicsGeometry - The Graphics Game Object to use for the Geometry Mask. Doesn't have to be in the Display List.
 */var i=new(s("jwj1g"))({initialize:function(t,e){/**
         * The Graphics object which describes the Geometry Mask.
         *
         * @name Phaser.Display.Masks.GeometryMask#geometryMask
         * @type {Phaser.GameObjects.Graphics}
         * @since 3.0.0
         */this.geometryMask=e,/**
         * Similar to the BitmapMasks invertAlpha setting this to true will then hide all pixels
         * drawn to the Geometry Mask.
         *
         * @name Phaser.Display.Masks.GeometryMask#invertAlpha
         * @type {boolean}
         * @since 3.16.0
         */this.invertAlpha=!1,/**
         * Is this mask a stencil mask?
         *
         * @name Phaser.Display.Masks.GeometryMask#isStencil
         * @type {boolean}
         * @readonly
         * @since 3.17.0
         */this.isStencil=!0,/**
         * The current stencil level.
         *
         * @name Phaser.Display.Masks.GeometryMask#level
         * @type {boolean}
         * @private
         * @since 3.17.0
         */this.level=0},/**
     * Sets a new Graphics object for the Geometry Mask.
     *
     * @method Phaser.Display.Masks.GeometryMask#setShape
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Graphics} graphicsGeometry - The Graphics object which will be used for the Geometry Mask.
     * 
     * @return {this} This Geometry Mask
     */setShape:function(t){return this.geometryMask=t,this},/**
     * Sets the `invertAlpha` property of this Geometry Mask.
     * Inverting the alpha essentially flips the way the mask works.
     *
     * @method Phaser.Display.Masks.GeometryMask#setInvertAlpha
     * @since 3.17.0
     *
     * @param {boolean} [value=true] - Invert the alpha of this mask?
     * 
     * @return {this} This Geometry Mask
     */setInvertAlpha:function(t){return void 0===t&&(t=!0),this.invertAlpha=t,this},/**
     * Renders the Geometry Mask's underlying Graphics object to the OpenGL stencil buffer and enables the stencil test, which clips rendered pixels according to the mask.
     *
     * @method Phaser.Display.Masks.GeometryMask#preRenderWebGL
     * @since 3.0.0
     *
     * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw to.
     * @param {Phaser.GameObjects.GameObject} child - The Game Object being rendered.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.
     */preRenderWebGL:function(t,e,i){var n=t.gl;//  Force flushing before drawing to stencil buffer
t.flush(),0===t.maskStack.length&&(n.enable(n.STENCIL_TEST),n.clear(n.STENCIL_BUFFER_BIT),t.maskCount=0),t.currentCameraMask.mask!==this&&(t.currentMask.mask=this),t.maskStack.push({mask:this,camera:i}),this.applyStencil(t,i,!0),t.maskCount++},/**
     * Applies the current stencil mask to the renderer.
     *
     * @method Phaser.Display.Masks.GeometryMask#applyStencil
     * @since 3.17.0
     *
     * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw to.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.
     * @param {boolean} inc - Is this an INCR stencil or a DECR stencil?
     */applyStencil:function(t,e,i){var n=t.gl,s=this.geometryMask,r=t.maskCount;n.colorMask(!1,!1,!1,!1),i?(n.stencilFunc(n.EQUAL,r,255),n.stencilOp(n.KEEP,n.KEEP,n.INCR)):(n.stencilFunc(n.EQUAL,r+1,255),n.stencilOp(n.KEEP,n.KEEP,n.DECR)),//  Write stencil buffer
s.renderWebGL(t,s,0,e),t.flush(),n.colorMask(!0,!0,!0,!0),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),i?this.invertAlpha?n.stencilFunc(n.NOTEQUAL,r+1,255):n.stencilFunc(n.EQUAL,r+1,255):this.invertAlpha?n.stencilFunc(n.NOTEQUAL,r,255):n.stencilFunc(n.EQUAL,r,255)},/**
     * Flushes all rendered pixels and disables the stencil test of a WebGL context, thus disabling the mask for it.
     *
     * @method Phaser.Display.Masks.GeometryMask#postRenderWebGL
     * @since 3.0.0
     *
     * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw flush.
     */postRenderWebGL:function(t){var e=t.gl;if(t.maskStack.pop(),t.maskCount--,0===t.maskStack.length)//  If this is the only mask in the stack, flush and disable
t.flush(),t.currentMask.mask=null,e.disable(e.STENCIL_TEST);else{//  Force flush before disabling stencil test
t.flush();var i=t.maskStack[t.maskStack.length-1];i.mask.applyStencil(t,i.camera,!1),t.currentCameraMask.mask!==i.mask?(t.currentMask.mask=i.mask,t.currentMask.camera=i.camera):t.currentMask.mask=null}},/**
     * Sets the clipping path of a 2D canvas context to the Geometry Mask's underlying Graphics object.
     *
     * @method Phaser.Display.Masks.GeometryMask#preRenderCanvas
     * @since 3.0.0
     *
     * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - The Canvas Renderer instance to set the clipping path on.
     * @param {Phaser.GameObjects.GameObject} mask - The Game Object being rendered.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.
     */preRenderCanvas:function(t,e,i){var n=this.geometryMask;t.currentContext.save(),n.renderCanvas(t,n,0,i,null,null,!0),t.currentContext.clip()},/**
     * Restore the canvas context's previous clipping path, thus turning off the mask for it.
     *
     * @method Phaser.Display.Masks.GeometryMask#postRenderCanvas
     * @since 3.0.0
     *
     * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - The Canvas Renderer instance being restored.
     */postRenderCanvas:function(t){t.currentContext.restore()},/**
     * Destroys this GeometryMask and nulls any references it holds.
     *
     * Note that if a Game Object is currently using this mask it will _not_ automatically detect you have destroyed it,
     * so be sure to call `clearMask` on any Game Object using it, before destroying it.
     *
     * @method Phaser.Display.Masks.GeometryMask#destroy
     * @since 3.7.0
     */destroy:function(){this.geometryMask=null}});t.exports=i}),r("18U1b",function(t,e){t.exports={/**
     * A property indicating that a Game Object has this component.
     *
     * @name Phaser.GameObjects.Components.Origin#_originComponent
     * @type {boolean}
     * @private
     * @default true
     * @since 3.2.0
     */_originComponent:!0,/**
     * The horizontal origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the left of the Game Object.
     *
     * @name Phaser.GameObjects.Components.Origin#originX
     * @type {number}
     * @default 0.5
     * @since 3.0.0
     */originX:.5,/**
     * The vertical origin of this Game Object.
     * The origin maps the relationship between the size and position of the Game Object.
     * The default value is 0.5, meaning all Game Objects are positioned based on their center.
     * Setting the value to 0 means the position now relates to the top of the Game Object.
     *
     * @name Phaser.GameObjects.Components.Origin#originY
     * @type {number}
     * @default 0.5
     * @since 3.0.0
     */originY:.5,//  private + read only
_displayOriginX:0,_displayOriginY:0,/**
     * The horizontal display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     *
     * @name Phaser.GameObjects.Components.Origin#displayOriginX
     * @type {number}
     * @since 3.0.0
     */displayOriginX:{get:function(){return this._displayOriginX},set:function(t){this._displayOriginX=t,this.originX=t/this.width}},/**
     * The vertical display origin of this Game Object.
     * The origin is a normalized value between 0 and 1.
     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
     *
     * @name Phaser.GameObjects.Components.Origin#displayOriginY
     * @type {number}
     * @since 3.0.0
     */displayOriginY:{get:function(){return this._displayOriginY},set:function(t){this._displayOriginY=t,this.originY=t/this.height}},/**
     * Sets the origin of this Game Object.
     *
     * The values are given in the range 0 to 1.
     *
     * @method Phaser.GameObjects.Components.Origin#setOrigin
     * @since 3.0.0
     *
     * @param {number} [x=0.5] - The horizontal origin value.
     * @param {number} [y=x] - The vertical origin value. If not defined it will be set to the value of `x`.
     *
     * @return {this} This Game Object instance.
     */setOrigin:function(t,e){return void 0===t&&(t=.5),void 0===e&&(e=t),this.originX=t,this.originY=e,this.updateDisplayOrigin()},/**
     * Sets the origin of this Game Object based on the Pivot values in its Frame.
     *
     * @method Phaser.GameObjects.Components.Origin#setOriginFromFrame
     * @since 3.0.0
     *
     * @return {this} This Game Object instance.
     */setOriginFromFrame:function(){return this.frame&&this.frame.customPivot?(this.originX=this.frame.pivotX,this.originY=this.frame.pivotY,this.updateDisplayOrigin()):this.setOrigin()},/**
     * Sets the display origin of this Game Object.
     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
     *
     * @method Phaser.GameObjects.Components.Origin#setDisplayOrigin
     * @since 3.0.0
     *
     * @param {number} [x=0] - The horizontal display origin value.
     * @param {number} [y=x] - The vertical display origin value. If not defined it will be set to the value of `x`.
     *
     * @return {this} This Game Object instance.
     */setDisplayOrigin:function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),this.displayOriginX=t,this.displayOriginY=e,this},/**
     * Updates the Display Origin cached values internally stored on this Game Object.
     * You don't usually call this directly, but it is exposed for edge-cases where you may.
     *
     * @method Phaser.GameObjects.Components.Origin#updateDisplayOrigin
     * @since 3.0.0
     *
     * @return {this} This Game Object instance.
     */updateDisplayOrigin:function(){return this._displayOriginX=this.originX*this.width,this._displayOriginY=this.originY*this.height,this}}}),r("dNtLk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2zqSA"),n=s("iuXOO"),r=s("5pMDk"),o=s("7lENH"),a=s("7SBSk"),h={/**
     * The Path this PathFollower is following. It can only follow one Path at a time.
     *
     * @name Phaser.GameObjects.Components.PathFollower#path
     * @type {Phaser.Curves.Path}
     * @since 3.0.0
     */path:null,/**
     * Should the PathFollower automatically rotate to point in the direction of the Path?
     *
     * @name Phaser.GameObjects.Components.PathFollower#rotateToPath
     * @type {boolean}
     * @default false
     * @since 3.0.0
     */rotateToPath:!1,/**
     * If the PathFollower is rotating to match the Path (@see Phaser.GameObjects.PathFollower#rotateToPath)
     * this value is added to the rotation value. This allows you to rotate objects to a path but control
     * the angle of the rotation as well.
     *
     * @name Phaser.GameObjects.PathFollower#pathRotationOffset
     * @type {number}
     * @default 0
     * @since 3.0.0
     */pathRotationOffset:0,/**
     * An additional vector to add to the PathFollowers position, allowing you to offset it from the
     * Path coordinates.
     *
     * @name Phaser.GameObjects.PathFollower#pathOffset
     * @type {Phaser.Math.Vector2}
     * @since 3.0.0
     */pathOffset:null,/**
     * A Vector2 that stores the current point of the path the follower is on.
     *
     * @name Phaser.GameObjects.PathFollower#pathVector
     * @type {Phaser.Math.Vector2}
     * @since 3.0.0
     */pathVector:null,/**
     * The distance the follower has traveled from the previous point to the current one, at the last update.
     *
     * @name Phaser.GameObjects.PathFollower#pathDelta
     * @type {Phaser.Math.Vector2}
     * @since 3.23.0
     */pathDelta:null,/**
     * The Tween used for following the Path.
     *
     * @name Phaser.GameObjects.PathFollower#pathTween
     * @type {Phaser.Tweens.Tween}
     * @since 3.0.0
     */pathTween:null,/**
     * Settings for the PathFollower.
     *
     * @name Phaser.GameObjects.PathFollower#pathConfig
     * @type {?Phaser.Types.GameObjects.PathFollower.PathConfig}
     * @default null
     * @since 3.0.0
     */pathConfig:null,/**
     * Records the direction of the follower so it can change direction.
     *
     * @name Phaser.GameObjects.PathFollower#_prevDirection
     * @type {integer}
     * @private
     * @since 3.0.0
     */_prevDirection:o.PLAYING_FORWARD,/**
     * Set the Path that this PathFollower should follow.
     *
     * Optionally accepts {@link Phaser.Types.GameObjects.PathFollower.PathConfig} settings.
     *
     * @method Phaser.GameObjects.Components.PathFollower#setPath
     * @since 3.0.0
     *
     * @param {Phaser.Curves.Path} path - The Path this PathFollower is following. It can only follow one Path at a time.
     * @param {(number|Phaser.Types.GameObjects.PathFollower.PathConfig|Phaser.Types.Tweens.NumberTweenBuilderConfig)} [config] - Settings for the PathFollower.
     *
     * @return {this} This Game Object.
     */setPath:function(t,e){void 0===e&&(e=this.pathConfig);var i=this.pathTween;return i&&i.isPlaying()&&i.stop(),this.path=t,e&&this.startFollow(e),this},/**
     * Set whether the PathFollower should automatically rotate to point in the direction of the Path.
     *
     * @method Phaser.GameObjects.Components.PathFollower#setRotateToPath
     * @since 3.0.0
     *
     * @param {boolean} value - Whether the PathFollower should automatically rotate to point in the direction of the Path.
     * @param {number} [offset=0] - Rotation offset in degrees.
     *
     * @return {this} This Game Object.
     */setRotateToPath:function(t,e){return void 0===e&&(e=0),this.rotateToPath=t,this.pathRotationOffset=e,this},/**
     * Is this PathFollower actively following a Path or not?
     *
     * To be considered as `isFollowing` it must be currently moving on a Path, and not paused.
     *
     * @method Phaser.GameObjects.Components.PathFollower#isFollowing
     * @since 3.0.0
     *
     * @return {boolean} `true` is this PathFollower is actively following a Path, otherwise `false`.
     */isFollowing:function(){var t=this.pathTween;return t&&t.isPlaying()},/**
     * Starts this PathFollower following its given Path.
     *
     * @method Phaser.GameObjects.Components.PathFollower#startFollow
     * @since 3.3.0
     *
     * @param {(number|Phaser.Types.GameObjects.PathFollower.PathConfig|Phaser.Types.Tweens.NumberTweenBuilderConfig)} [config={}] - The duration of the follow, or a PathFollower config object.
     * @param {number} [startAt=0] - Optional start position of the follow, between 0 and 1.
     *
     * @return {this} This Game Object.
     */startFollow:function(t,e){void 0===t&&(t={}),void 0===e&&(e=0);var s=this.pathTween;s&&s.isPlaying()&&s.stop(),"number"==typeof t&&(t={duration:t}),//  Override in case they've been specified in the config
t.from=r(t,"from",0),t.to=r(t,"to",1);var h=n(t,"positionOnPath",!1);this.rotateToPath=n(t,"rotateToPath",!1),this.pathRotationOffset=r(t,"rotationOffset",0);//  This works, but it's not an ideal way of doing it as the follower jumps position
var l=r(t,"startAt",e);if(l&&(t.onStart=function(t){var e=t.data[0];e.progress=l,e.elapsed=e.duration*l;var i=e.ease(e.progress);e.current=e.start+(e.end-e.start)*i,e.target[e.key]=e.current}),this.pathOffset||(this.pathOffset=new a(this.x,this.y)),this.pathVector||(this.pathVector=new a),this.pathDelta||(this.pathDelta=new a),this.pathDelta.reset(),this.pathTween=this.scene.sys.tweens.addCounter(t),//  The starting point of the path, relative to this follower
this.path.getStartPoint(this.pathOffset),h&&(this.x=this.pathOffset.x,this.y=this.pathOffset.y),this.pathOffset.x=this.x-this.pathOffset.x,this.pathOffset.y=this.y-this.pathOffset.y,this._prevDirection=o.PLAYING_FORWARD,this.rotateToPath){//  Set the rotation now (in case the tween has a delay on it, etc)
var u=this.path.getPoint(.1);this.rotation=Math.atan2(u.y-this.y,u.x-this.x)+i(this.pathRotationOffset)}return this.pathConfig=t,this},/**
     * Pauses this PathFollower. It will still continue to render, but it will remain motionless at the
     * point on the Path at which you paused it.
     *
     * @method Phaser.GameObjects.Components.PathFollower#pauseFollow
     * @since 3.3.0
     *
     * @return {this} This Game Object.
     */pauseFollow:function(){var t=this.pathTween;return t&&t.isPlaying()&&t.pause(),this},/**
     * Resumes a previously paused PathFollower.
     *
     * If the PathFollower was not paused this has no effect.
     *
     * @method Phaser.GameObjects.Components.PathFollower#resumeFollow
     * @since 3.3.0
     *
     * @return {this} This Game Object.
     */resumeFollow:function(){var t=this.pathTween;return t&&t.isPaused()&&t.resume(),this},/**
     * Stops this PathFollower from following the path any longer.
     *
     * This will invoke any 'stop' conditions that may exist on the Path, or for the follower.
     *
     * @method Phaser.GameObjects.Components.PathFollower#stopFollow
     * @since 3.3.0
     *
     * @return {this} This Game Object.
     */stopFollow:function(){var t=this.pathTween;return t&&t.isPlaying()&&t.stop(),this},/**
     * Internal update handler that advances this PathFollower along the path.
     *
     * Called automatically by the Scene step, should not typically be called directly.
     *
     * @method Phaser.GameObjects.Components.PathFollower#pathUpdate
     * @since 3.17.0
     */pathUpdate:function(){var t=this.pathTween;if(t){var e=t.data[0],n=this.pathDelta,s=this.pathVector;if(n.copy(s).negate(),e.state===o.COMPLETE){this.path.getPoint(1,s),n.add(s),s.add(this.pathOffset),this.setPosition(s.x,s.y);return}if(e.state!==o.PLAYING_FORWARD&&e.state!==o.PLAYING_BACKWARD)return;this.path.getPoint(t.getValue(),s),n.add(s),s.add(this.pathOffset);var r=this.x,a=this.y;this.setPosition(s.x,s.y);var h=this.x-r,l=this.y-a;if(0===h&&0===l)return;if(e.state!==this._prevDirection){//  We've changed direction, so don't do a rotate this frame
this._prevDirection=e.state;return}this.rotateToPath&&(this.rotation=Math.atan2(l,h)+i(this.pathRotationOffset))}}};t.exports=h}),r("2zqSA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bNtDi");t.exports=function(t){return t*i.DEG_TO_RAD}}),r("iuXOO",function(t,e){t.exports=function(t,e,i){return t&&t.hasOwnProperty(e)?t[e]:i}}),r("7lENH",function(t,e){t.exports={/**
     * TweenData state.
     * 
     * @name Phaser.Tweens.CREATED
     * @type {integer}
     * @since 3.0.0
     */CREATED:0,/**
     * TweenData state.
     * 
     * @name Phaser.Tweens.INIT
     * @type {integer}
     * @since 3.0.0
     */INIT:1,/**
     * TweenData state.
     * 
     * @name Phaser.Tweens.DELAY
     * @type {integer}
     * @since 3.0.0
     */DELAY:2,/**
     * TweenData state.
     * 
     * @name Phaser.Tweens.OFFSET_DELAY
     * @type {integer}
     * @since 3.0.0
     */OFFSET_DELAY:3,/**
     * TweenData state.
     * 
     * @name Phaser.Tweens.PENDING_RENDER
     * @type {integer}
     * @since 3.0.0
     */PENDING_RENDER:4,/**
     * TweenData state.
     * 
     * @name Phaser.Tweens.PLAYING_FORWARD
     * @type {integer}
     * @since 3.0.0
     */PLAYING_FORWARD:5,/**
     * TweenData state.
     * 
     * @name Phaser.Tweens.PLAYING_BACKWARD
     * @type {integer}
     * @since 3.0.0
     */PLAYING_BACKWARD:6,/**
     * TweenData state.
     * 
     * @name Phaser.Tweens.HOLD_DELAY
     * @type {integer}
     * @since 3.0.0
     */HOLD_DELAY:7,/**
     * TweenData state.
     * 
     * @name Phaser.Tweens.REPEAT_DELAY
     * @type {integer}
     * @since 3.0.0
     */REPEAT_DELAY:8,/**
     * TweenData state.
     * 
     * @name Phaser.Tweens.COMPLETE
     * @type {integer}
     * @since 3.0.0
     */COMPLETE:9,//  Tween specific (starts from 20 to cleanly allow extra TweenData consts in the future)
/**
     * Tween state.
     * 
     * @name Phaser.Tweens.PENDING_ADD
     * @type {integer}
     * @since 3.0.0
     */PENDING_ADD:20,/**
     * Tween state.
     * 
     * @name Phaser.Tweens.PAUSED
     * @type {integer}
     * @since 3.0.0
     */PAUSED:21,/**
     * Tween state.
     * 
     * @name Phaser.Tweens.LOOP_DELAY
     * @type {integer}
     * @since 3.0.0
     */LOOP_DELAY:22,/**
     * Tween state.
     * 
     * @name Phaser.Tweens.ACTIVE
     * @type {integer}
     * @since 3.0.0
     */ACTIVE:23,/**
     * Tween state.
     * 
     * @name Phaser.Tweens.COMPLETE_DELAY
     * @type {integer}
     * @since 3.0.0
     */COMPLETE_DELAY:24,/**
     * Tween state.
     * 
     * @name Phaser.Tweens.PENDING_REMOVE
     * @type {integer}
     * @since 3.0.0
     */PENDING_REMOVE:25,/**
     * Tween state.
     * 
     * @name Phaser.Tweens.REMOVED
     * @type {integer}
     * @since 3.0.0
     */REMOVED:26}}),r("DznIZ",function(t,e){t.exports={/**
     * The initial WebGL pipeline of this Game Object.
     *
     * @name Phaser.GameObjects.Components.Pipeline#defaultPipeline
     * @type {Phaser.Renderer.WebGL.WebGLPipeline}
     * @default null
     * @webglOnly
     * @since 3.0.0
     */defaultPipeline:null,/**
     * The current WebGL pipeline of this Game Object.
     *
     * @name Phaser.GameObjects.Components.Pipeline#pipeline
     * @type {Phaser.Renderer.WebGL.WebGLPipeline}
     * @default null
     * @webglOnly
     * @since 3.0.0
     */pipeline:null,/**
     * Sets the initial WebGL Pipeline of this Game Object.
     * This should only be called during the instantiation of the Game Object.
     *
     * @method Phaser.GameObjects.Components.Pipeline#initPipeline
     * @webglOnly
     * @since 3.0.0
     *
     * @param {string} [pipelineName=TextureTintPipeline] - The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline.
     *
     * @return {boolean} `true` if the pipeline was set successfully, otherwise `false`.
     */initPipeline:function(t){void 0===t&&(t="TextureTintPipeline");var e=this.scene.sys.game.renderer;return!!(e&&e.gl&&e.hasPipeline(t))&&(this.defaultPipeline=e.getPipeline(t),this.pipeline=this.defaultPipeline,!0)},/**
     * Sets the active WebGL Pipeline of this Game Object.
     *
     * @method Phaser.GameObjects.Components.Pipeline#setPipeline
     * @webglOnly
     * @since 3.0.0
     *
     * @param {string} pipelineName - The name of the pipeline to set on this Game Object.
     *
     * @return {this} This Game Object instance.
     */setPipeline:function(t){var e=this.scene.sys.game.renderer;return e&&e.gl&&e.hasPipeline(t)&&(this.pipeline=e.getPipeline(t)),this},/**
     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
     *
     * @method Phaser.GameObjects.Components.Pipeline#resetPipeline
     * @webglOnly
     * @since 3.0.0
     *
     * @return {boolean} `true` if the pipeline was set successfully, otherwise `false`.
     */resetPipeline:function(){return this.pipeline=this.defaultPipeline,null!==this.pipeline},/**
     * Gets the name of the WebGL Pipeline this Game Object is currently using.
     *
     * @method Phaser.GameObjects.Components.Pipeline#getPipelineName
     * @webglOnly
     * @since 3.0.0
     *
     * @return {string} The string-based name of the pipeline being used by this Game Object.
     */getPipelineName:function(){return this.pipeline.name}}}),r("hKiq1",function(t,e){t.exports={/**
     * The horizontal scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     * 
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     *
     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorX
     * @type {number}
     * @default 1
     * @since 3.0.0
     */scrollFactorX:1,/**
     * The vertical scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     * 
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     *
     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorY
     * @type {number}
     * @default 1
     * @since 3.0.0
     */scrollFactorY:1,/**
     * Sets the scroll factor of this Game Object.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     * 
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     *
     * @method Phaser.GameObjects.Components.ScrollFactor#setScrollFactor
     * @since 3.0.0
     *
     * @param {number} x - The horizontal scroll factor of this Game Object.
     * @param {number} [y=x] - The vertical scroll factor of this Game Object. If not set it will use the `x` value.
     *
     * @return {this} This Game Object instance.
     */setScrollFactor:function(t,e){return void 0===e&&(e=t),this.scrollFactorX=t,this.scrollFactorY=e,this}}}),r("aOXwH",function(t,e){t.exports={/**
     * A property indicating that a Game Object has this component.
     * 
     * @name Phaser.GameObjects.Components.Size#_sizeComponent
     * @type {boolean}
     * @private
     * @default true
     * @since 3.2.0
     */_sizeComponent:!0,/**
     * The native (un-scaled) width of this Game Object.
     * 
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayWidth` property.
     * 
     * @name Phaser.GameObjects.Components.Size#width
     * @type {number}
     * @since 3.0.0
     */width:0,/**
     * The native (un-scaled) height of this Game Object.
     * 
     * Changing this value will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or use
     * the `displayHeight` property.
     * 
     * @name Phaser.GameObjects.Components.Size#height
     * @type {number}
     * @since 3.0.0
     */height:0,/**
     * The displayed width of this Game Object.
     * 
     * This value takes into account the scale factor.
     * 
     * Setting this value will adjust the Game Object's scale property.
     * 
     * @name Phaser.GameObjects.Components.Size#displayWidth
     * @type {number}
     * @since 3.0.0
     */displayWidth:{get:function(){return Math.abs(this.scaleX*this.frame.realWidth)},set:function(t){this.scaleX=t/this.frame.realWidth}},/**
     * The displayed height of this Game Object.
     * 
     * This value takes into account the scale factor.
     * 
     * Setting this value will adjust the Game Object's scale property.
     * 
     * @name Phaser.GameObjects.Components.Size#displayHeight
     * @type {number}
     * @since 3.0.0
     */displayHeight:{get:function(){return Math.abs(this.scaleY*this.frame.realHeight)},set:function(t){this.scaleY=t/this.frame.realHeight}},/**
     * Sets the size of this Game Object to be that of the given Frame.
     * 
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     * 
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * 
     * @method Phaser.GameObjects.Components.Size#setSizeToFrame
     * @since 3.0.0
     *
     * @param {Phaser.Textures.Frame} frame - The frame to base the size of this Game Object on.
     * 
     * @return {this} This Game Object instance.
     */setSizeToFrame:function(t){return void 0===t&&(t=this.frame),this.width=t.realWidth,this.height=t.realHeight,this},/**
     * Sets the internal size of this Game Object, as used for frame or physics body creation.
     * 
     * This will not change the size that the Game Object is rendered in-game.
     * For that you need to either set the scale of the Game Object (`setScale`) or call the
     * `setDisplaySize` method, which is the same thing as changing the scale but allows you
     * to do so by giving pixel values.
     * 
     * If you have enabled this Game Object for input, changing the size will _not_ change the
     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
     * 
     * @method Phaser.GameObjects.Components.Size#setSize
     * @since 3.0.0
     *
     * @param {number} width - The width of this Game Object.
     * @param {number} height - The height of this Game Object.
     * 
     * @return {this} This Game Object instance.
     */setSize:function(t,e){return this.width=t,this.height=e,this},/**
     * Sets the display size of this Game Object.
     * 
     * Calling this will adjust the scale.
     * 
     * @method Phaser.GameObjects.Components.Size#setDisplaySize
     * @since 3.0.0
     *
     * @param {number} width - The width of this Game Object.
     * @param {number} height - The height of this Game Object.
     * 
     * @return {this} This Game Object instance.
     */setDisplaySize:function(t,e){return this.displayWidth=t,this.displayHeight=e,this}}}),r("1qQq2",function(t,e){t.exports={/**
     * The Texture this Game Object is using to render with.
     *
     * @name Phaser.GameObjects.Components.Texture#texture
     * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}
     * @since 3.0.0
     */texture:null,/**
     * The Texture Frame this Game Object is using to render with.
     *
     * @name Phaser.GameObjects.Components.Texture#frame
     * @type {Phaser.Textures.Frame}
     * @since 3.0.0
     */frame:null,/**
     * Internal flag. Not to be set by this Game Object.
     *
     * @name Phaser.GameObjects.Components.Texture#isCropped
     * @type {boolean}
     * @private
     * @since 3.11.0
     */isCropped:!1,/**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     *
     * @method Phaser.GameObjects.Components.Texture#setTexture
     * @since 3.0.0
     *
     * @param {(string|Phaser.Textures.Texture)} key - The key of the texture to be used, as stored in the Texture Manager, or a Texture instance.
     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.
     *
     * @return {this} This Game Object instance.
     */setTexture:function(t,e){return this.texture=this.scene.sys.textures.get(t),this.setFrame(e)},/**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     *
     * @method Phaser.GameObjects.Components.Texture#setFrame
     * @since 3.0.0
     *
     * @param {(string|integer)} frame - The name or index of the frame within the Texture.
     * @param {boolean} [updateSize=true] - Should this call adjust the size of the Game Object?
     * @param {boolean} [updateOrigin=true] - Should this call adjust the origin of the Game Object?
     *
     * @return {this} This Game Object instance.
     */setFrame:function(t,e,i){return void 0===e&&(e=!0),void 0===i&&(i=!0),this.frame=this.texture.get(t),this.frame.cutWidth&&this.frame.cutHeight?this.renderFlags|=8:this.renderFlags&=-9,this._sizeComponent&&e&&this.setSizeToFrame(),this._originComponent&&i&&(this.frame.customPivot?this.setOrigin(this.frame.pivotX,this.frame.pivotY):this.updateDisplayOrigin()),this}}}),r("iwi57",function(t,e){t.exports={/**
     * The Texture this Game Object is using to render with.
     *
     * @name Phaser.GameObjects.Components.TextureCrop#texture
     * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}
     * @since 3.0.0
     */texture:null,/**
     * The Texture Frame this Game Object is using to render with.
     *
     * @name Phaser.GameObjects.Components.TextureCrop#frame
     * @type {Phaser.Textures.Frame}
     * @since 3.0.0
     */frame:null,/**
     * A boolean flag indicating if this Game Object is being cropped or not.
     * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
     * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
     *
     * @name Phaser.GameObjects.Components.TextureCrop#isCropped
     * @type {boolean}
     * @since 3.11.0
     */isCropped:!1,/**
     * Applies a crop to a texture based Game Object, such as a Sprite or Image.
     * 
     * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
     * 
     * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
     * changes what is shown when rendered.
     * 
     * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
     * 
     * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
     * half of it, you could call `setCrop(0, 0, 400, 600)`.
     * 
     * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
     * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
     * 
     * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
     * 
     * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
     * 
     * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
     * the renderer to skip several internal calculations.
     *
     * @method Phaser.GameObjects.Components.TextureCrop#setCrop
     * @since 3.11.0
     *
     * @param {(number|Phaser.Geom.Rectangle)} [x] - The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
     * @param {number} [y] - The y coordinate to start the crop from.
     * @param {number} [width] - The width of the crop rectangle in pixels.
     * @param {number} [height] - The height of the crop rectangle in pixels.
     *
     * @return {this} This Game Object instance.
     */setCrop:function(t,e,i,n){return void 0===t?this.isCropped=!1:this.frame&&("number"==typeof t?this.frame.setCropUVs(this._crop,t,e,i,n,this.flipX,this.flipY):this.frame.setCropUVs(this._crop,t.x,t.y,t.width,t.height,this.flipX,this.flipY),this.isCropped=!0),this},/**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     *
     * @method Phaser.GameObjects.Components.TextureCrop#setTexture
     * @since 3.0.0
     *
     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.
     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.
     *
     * @return {this} This Game Object instance.
     */setTexture:function(t,e){return this.texture=this.scene.sys.textures.get(t),this.setFrame(e)},/**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     *
     * @method Phaser.GameObjects.Components.TextureCrop#setFrame
     * @since 3.0.0
     *
     * @param {(string|integer)} frame - The name or index of the frame within the Texture.
     * @param {boolean} [updateSize=true] - Should this call adjust the size of the Game Object?
     * @param {boolean} [updateOrigin=true] - Should this call adjust the origin of the Game Object?
     *
     * @return {this} This Game Object instance.
     */setFrame:function(t,e,i){return void 0===e&&(e=!0),void 0===i&&(i=!0),this.frame=this.texture.get(t),this.frame.cutWidth&&this.frame.cutHeight?this.renderFlags|=8:this.renderFlags&=-9,this._sizeComponent&&e&&this.setSizeToFrame(),this._originComponent&&i&&(this.frame.customPivot?this.setOrigin(this.frame.pivotX,this.frame.pivotY):this.updateDisplayOrigin()),this.isCropped&&this.frame.updateCropUVs(this._crop,this.flipX,this.flipY),this},/**
     * Internal method that returns a blank, well-formed crop object for use by a Game Object.
     *
     * @method Phaser.GameObjects.Components.TextureCrop#resetCropObject
     * @private
     * @since 3.12.0
     * 
     * @return {object} The crop object.
     */resetCropObject:function(){return{u0:0,v0:0,u1:0,v1:0,width:0,height:0,x:0,y:0,flipX:!1,flipY:!1,cx:0,cy:0,cw:0,ch:0}}}}),r("fpsqk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @function GetColor
 * @since 3.0.0
 * @private
 */var i=function(t){return(t>>16)+(65280&t)+((255&t)<<16)};t.exports={/**
     * Private internal value. Holds the top-left tint value.
     * 
     * @name Phaser.GameObjects.Components.Tint#_tintTL
     * @type {number}
     * @private
     * @default 16777215
     * @since 3.0.0
     */_tintTL:16777215,/**
     * Private internal value. Holds the top-right tint value.
     * 
     * @name Phaser.GameObjects.Components.Tint#_tintTR
     * @type {number}
     * @private
     * @default 16777215
     * @since 3.0.0
     */_tintTR:16777215,/**
     * Private internal value. Holds the bottom-left tint value.
     * 
     * @name Phaser.GameObjects.Components.Tint#_tintBL
     * @type {number}
     * @private
     * @default 16777215
     * @since 3.0.0
     */_tintBL:16777215,/**
     * Private internal value. Holds the bottom-right tint value.
     * 
     * @name Phaser.GameObjects.Components.Tint#_tintBR
     * @type {number}
     * @private
     * @default 16777215
     * @since 3.0.0
     */_tintBR:16777215,/**
     * Private internal value. Holds if the Game Object is tinted or not.
     * 
     * @name Phaser.GameObjects.Components.Tint#_isTinted
     * @type {boolean}
     * @private
     * @default false
     * @since 3.11.0
     */_isTinted:!1,/**
     * Fill or additive?
     * 
     * @name Phaser.GameObjects.Components.Tint#tintFill
     * @type {boolean}
     * @default false
     * @since 3.11.0
     */tintFill:!1,/**
     * Clears all tint values associated with this Game Object.
     * 
     * Immediately sets the color values back to 0xffffff and the tint type to 'additive',
     * which results in no visible change to the texture.
     *
     * @method Phaser.GameObjects.Components.Tint#clearTint
     * @webglOnly
     * @since 3.0.0
     * 
     * @return {this} This Game Object instance.
     */clearTint:function(){return this.setTint(16777215),this._isTinted=!1,this},/**
     * Sets an additive tint on this Game Object.
     * 
     * The tint works by taking the pixel color values from the Game Objects texture, and then
     * multiplying it by the color value of the tint. You can provide either one color value,
     * in which case the whole Game Object will be tinted in that color. Or you can provide a color
     * per corner. The colors are blended together across the extent of the Game Object.
     * 
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     * 
     * To remove a tint call `clearTint`.
     * 
     * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
     *
     * @method Phaser.GameObjects.Components.Tint#setTint
     * @webglOnly
     * @since 3.0.0
     *
     * @param {integer} [topLeft=0xffffff] - The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object.
     * @param {integer} [topRight] - The tint being applied to the top-right of the Game Object.
     * @param {integer} [bottomLeft] - The tint being applied to the bottom-left of the Game Object.
     * @param {integer} [bottomRight] - The tint being applied to the bottom-right of the Game Object.
     * 
     * @return {this} This Game Object instance.
     */setTint:function(t,e,n,s){return void 0===t&&(t=16777215),void 0===e&&(e=t,n=t,s=t),this._tintTL=i(t),this._tintTR=i(e),this._tintBL=i(n),this._tintBR=i(s),this._isTinted=!0,this.tintFill=!1,this},/**
     * Sets a fill-based tint on this Game Object.
     * 
     * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
     * with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. You can provide either one color value, in which case the whole
     * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
     * are blended together across the extent of the Game Object.
     * 
     * To modify the tint color once set, either call this method again with new values or use the
     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
     * 
     * To remove a tint call `clearTint`.
     * 
     * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
     *
     * @method Phaser.GameObjects.Components.Tint#setTintFill
     * @webglOnly
     * @since 3.11.0
     *
     * @param {integer} [topLeft=0xffffff] - The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object.
     * @param {integer} [topRight] - The tint being applied to the top-right of the Game Object.
     * @param {integer} [bottomLeft] - The tint being applied to the bottom-left of the Game Object.
     * @param {integer} [bottomRight] - The tint being applied to the bottom-right of the Game Object.
     * 
     * @return {this} This Game Object instance.
     */setTintFill:function(t,e,i,n){return this.setTint(t,e,i,n),this.tintFill=!0,this},/**
     * The tint value being applied to the top-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * 
     * @name Phaser.GameObjects.Components.Tint#tintTopLeft
     * @type {integer}
     * @webglOnly
     * @since 3.0.0
     */tintTopLeft:{get:function(){return this._tintTL},set:function(t){this._tintTL=i(t),this._isTinted=!0}},/**
     * The tint value being applied to the top-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * 
     * @name Phaser.GameObjects.Components.Tint#tintTopRight
     * @type {integer}
     * @webglOnly
     * @since 3.0.0
     */tintTopRight:{get:function(){return this._tintTR},set:function(t){this._tintTR=i(t),this._isTinted=!0}},/**
     * The tint value being applied to the bottom-left of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * 
     * @name Phaser.GameObjects.Components.Tint#tintBottomLeft
     * @type {integer}
     * @webglOnly
     * @since 3.0.0
     */tintBottomLeft:{get:function(){return this._tintBL},set:function(t){this._tintBL=i(t),this._isTinted=!0}},/**
     * The tint value being applied to the bottom-right of the Game Object.
     * This value is interpolated from the corner to the center of the Game Object.
     * 
     * @name Phaser.GameObjects.Components.Tint#tintBottomRight
     * @type {integer}
     * @webglOnly
     * @since 3.0.0
     */tintBottomRight:{get:function(){return this._tintBR},set:function(t){this._tintBR=i(t),this._isTinted=!0}},/**
     * The tint value being applied to the whole of the Game Object.
     * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.
     * 
     * @name Phaser.GameObjects.Components.Tint#tint
     * @type {integer}
     * @webglOnly
     * @since 3.0.0
     */tint:{set:function(t){this.setTint(t,t,t,t)}},/**
     * Does this Game Object have a tint applied to it or not?
     * 
     * @name Phaser.GameObjects.Components.Tint#isTinted
     * @type {boolean}
     * @webglOnly
     * @readonly
     * @since 3.11.0
     */isTinted:{get:function(){return this._isTinted}}}}),r("bvPjF",function(t,e){t.exports=function(t){var e={name:t.name,type:t.type,x:t.x,y:t.y,depth:t.depth,scale:{x:t.scaleX,y:t.scaleY},origin:{x:t.originX,y:t.originY},flipX:t.flipX,flipY:t.flipY,rotation:t.rotation,alpha:t.alpha,visible:t.visible,blendMode:t.blendMode,textureKey:"",frameKey:"",data:{}};return t.texture&&(e.textureKey=t.texture.key,e.frameKey=t.frame.name),e}}),r("i5mxL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bNtDi"),n=s("azs1m"),r=s("1W59j"),o=s("dokq5");t.exports={/**
     * Private internal value. Holds the horizontal scale value.
     *
     * @name Phaser.GameObjects.Components.Transform#_scaleX
     * @type {number}
     * @private
     * @default 1
     * @since 3.0.0
     */_scaleX:1,/**
     * Private internal value. Holds the vertical scale value.
     *
     * @name Phaser.GameObjects.Components.Transform#_scaleY
     * @type {number}
     * @private
     * @default 1
     * @since 3.0.0
     */_scaleY:1,/**
     * Private internal value. Holds the rotation value in radians.
     *
     * @name Phaser.GameObjects.Components.Transform#_rotation
     * @type {number}
     * @private
     * @default 0
     * @since 3.0.0
     */_rotation:0,/**
     * The x position of this Game Object.
     *
     * @name Phaser.GameObjects.Components.Transform#x
     * @type {number}
     * @default 0
     * @since 3.0.0
     */x:0,/**
     * The y position of this Game Object.
     *
     * @name Phaser.GameObjects.Components.Transform#y
     * @type {number}
     * @default 0
     * @since 3.0.0
     */y:0,/**
     * The z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#depth} instead.
     *
     * @name Phaser.GameObjects.Components.Transform#z
     * @type {number}
     * @default 0
     * @since 3.0.0
     */z:0,/**
     * The w position of this Game Object.
     *
     * @name Phaser.GameObjects.Components.Transform#w
     * @type {number}
     * @default 0
     * @since 3.0.0
     */w:0,/**
     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object
     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.
     *
     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this
     * isn't the case, use the `scaleX` or `scaleY` properties instead.
     *
     * @name Phaser.GameObjects.Components.Transform#scale
     * @type {number}
     * @default 1
     * @since 3.18.0
     */scale:{get:function(){return(this._scaleX+this._scaleY)/2},set:function(t){this._scaleX=t,this._scaleY=t,0===t?this.renderFlags&=-5:this.renderFlags|=4}},/**
     * The horizontal scale of this Game Object.
     *
     * @name Phaser.GameObjects.Components.Transform#scaleX
     * @type {number}
     * @default 1
     * @since 3.0.0
     */scaleX:{get:function(){return this._scaleX},set:function(t){this._scaleX=t,0===t?this.renderFlags&=-5:this.renderFlags|=4}},/**
     * The vertical scale of this Game Object.
     *
     * @name Phaser.GameObjects.Components.Transform#scaleY
     * @type {number}
     * @default 1
     * @since 3.0.0
     */scaleY:{get:function(){return this._scaleY},set:function(t){this._scaleY=t,0===t?this.renderFlags&=-5:this.renderFlags|=4}},/**
     * The angle of this Game Object as expressed in degrees.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left
     * and -90 is up.
     *
     * If you prefer to work in radians, see the `rotation` property instead.
     *
     * @name Phaser.GameObjects.Components.Transform#angle
     * @type {integer}
     * @default 0
     * @since 3.0.0
     */angle:{get:function(){return o(this._rotation*i.RAD_TO_DEG)},set:function(t){//  value is in degrees
this.rotation=o(t)*i.DEG_TO_RAD}},/**
     * The angle of this Game Object in radians.
     *
     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left
     * and -PI/2 is up.
     *
     * If you prefer to work in degrees, see the `angle` property instead.
     *
     * @name Phaser.GameObjects.Components.Transform#rotation
     * @type {number}
     * @default 1
     * @since 3.0.0
     */rotation:{get:function(){return this._rotation},set:function(t){//  value is in radians
this._rotation=r(t)}},/**
     * Sets the position of this Game Object.
     *
     * @method Phaser.GameObjects.Components.Transform#setPosition
     * @since 3.0.0
     *
     * @param {number} [x=0] - The x position of this Game Object.
     * @param {number} [y=x] - The y position of this Game Object. If not set it will use the `x` value.
     * @param {number} [z=0] - The z position of this Game Object.
     * @param {number} [w=0] - The w position of this Game Object.
     *
     * @return {this} This Game Object instance.
     */setPosition:function(t,e,i,n){return void 0===t&&(t=0),void 0===e&&(e=t),void 0===i&&(i=0),void 0===n&&(n=0),this.x=t,this.y=e,this.z=i,this.w=n,this},/**
     * Sets the position of this Game Object to be a random position within the confines of
     * the given area.
     *
     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
     *
     * The position does not factor in the size of this Game Object, meaning that only the origin is
     * guaranteed to be within the area.
     *
     * @method Phaser.GameObjects.Components.Transform#setRandomPosition
     * @since 3.8.0
     *
     * @param {number} [x=0] - The x position of the top-left of the random area.
     * @param {number} [y=0] - The y position of the top-left of the random area.
     * @param {number} [width] - The width of the random area.
     * @param {number} [height] - The height of the random area.
     *
     * @return {this} This Game Object instance.
     */setRandomPosition:function(t,e,i,n){return void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=this.scene.sys.scale.width),void 0===n&&(n=this.scene.sys.scale.height),this.x=t+Math.random()*i,this.y=e+Math.random()*n,this},/**
     * Sets the rotation of this Game Object.
     *
     * @method Phaser.GameObjects.Components.Transform#setRotation
     * @since 3.0.0
     *
     * @param {number} [radians=0] - The rotation of this Game Object, in radians.
     *
     * @return {this} This Game Object instance.
     */setRotation:function(t){return void 0===t&&(t=0),this.rotation=t,this},/**
     * Sets the angle of this Game Object.
     *
     * @method Phaser.GameObjects.Components.Transform#setAngle
     * @since 3.0.0
     *
     * @param {number} [degrees=0] - The rotation of this Game Object, in degrees.
     *
     * @return {this} This Game Object instance.
     */setAngle:function(t){return void 0===t&&(t=0),this.angle=t,this},/**
     * Sets the scale of this Game Object.
     *
     * @method Phaser.GameObjects.Components.Transform#setScale
     * @since 3.0.0
     *
     * @param {number} x - The horizontal scale of this Game Object.
     * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the `x` value.
     *
     * @return {this} This Game Object instance.
     */setScale:function(t,e){return void 0===t&&(t=1),void 0===e&&(e=t),this.scaleX=t,this.scaleY=e,this},/**
     * Sets the x position of this Game Object.
     *
     * @method Phaser.GameObjects.Components.Transform#setX
     * @since 3.0.0
     *
     * @param {number} [value=0] - The x position of this Game Object.
     *
     * @return {this} This Game Object instance.
     */setX:function(t){return void 0===t&&(t=0),this.x=t,this},/**
     * Sets the y position of this Game Object.
     *
     * @method Phaser.GameObjects.Components.Transform#setY
     * @since 3.0.0
     *
     * @param {number} [value=0] - The y position of this Game Object.
     *
     * @return {this} This Game Object instance.
     */setY:function(t){return void 0===t&&(t=0),this.y=t,this},/**
     * Sets the z position of this Game Object.
     *
     * Note: The z position does not control the rendering order of 2D Game Objects. Use
     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.
     *
     * @method Phaser.GameObjects.Components.Transform#setZ
     * @since 3.0.0
     *
     * @param {number} [value=0] - The z position of this Game Object.
     *
     * @return {this} This Game Object instance.
     */setZ:function(t){return void 0===t&&(t=0),this.z=t,this},/**
     * Sets the w position of this Game Object.
     *
     * @method Phaser.GameObjects.Components.Transform#setW
     * @since 3.0.0
     *
     * @param {number} [value=0] - The w position of this Game Object.
     *
     * @return {this} This Game Object instance.
     */setW:function(t){return void 0===t&&(t=0),this.w=t,this},/**
     * Gets the local transform matrix for this Game Object.
     *
     * @method Phaser.GameObjects.Components.Transform#getLocalTransformMatrix
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.
     *
     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.
     */getLocalTransformMatrix:function(t){return void 0===t&&(t=new n),t.applyITRS(this.x,this.y,this._rotation,this._scaleX,this._scaleY)},/**
     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
     *
     * @method Phaser.GameObjects.Components.Transform#getWorldTransformMatrix
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.
     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - A temporary matrix to hold parent values during the calculations.
     *
     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.
     */getWorldTransformMatrix:function(t,e){void 0===t&&(t=new n),void 0===e&&(e=new n);var i=this.parentContainer;if(!i)return this.getLocalTransformMatrix(t);for(t.applyITRS(this.x,this.y,this._rotation,this._scaleX,this._scaleY);i;)e.applyITRS(i.x,i.y,i._rotation,i._scaleX,i._scaleY),e.multiply(t,t),i=i.parentContainer;return t},/**
     * Gets the sum total rotation of all of this Game Objects parent Containers.
     *
     * The returned value is in radians and will be zero if this Game Object has no parent container.
     *
     * @method Phaser.GameObjects.Components.Transform#getParentRotation
     * @since 3.18.0
     *
     * @return {number} The sum total rotation, in radians, of all parent containers of this Game Object.
     */getParentRotation:function(){for(var t=0,e=this.parentContainer;e;)t+=e.rotation,e=e.parentContainer;return t}}}),r("azs1m",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("bNtDi"),r=s("7SBSk"),o=new i({initialize:function(t,e,i,n,s,r){void 0===t&&(t=1),void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=1),void 0===s&&(s=0),void 0===r&&(r=0),/**
         * The matrix values.
         *
         * @name Phaser.GameObjects.Components.TransformMatrix#matrix
         * @type {Float32Array}
         * @since 3.0.0
         */this.matrix=new Float32Array([t,e,i,n,s,r,0,0,1]),/**
         * The decomposed matrix.
         *
         * @name Phaser.GameObjects.Components.TransformMatrix#decomposedMatrix
         * @type {object}
         * @since 3.0.0
         */this.decomposedMatrix={translateX:0,translateY:0,scaleX:1,scaleY:1,rotation:0}},/**
     * The Scale X value.
     *
     * @name Phaser.GameObjects.Components.TransformMatrix#a
     * @type {number}
     * @since 3.4.0
     */a:{get:function(){return this.matrix[0]},set:function(t){this.matrix[0]=t}},/**
     * The Skew Y value.
     *
     * @name Phaser.GameObjects.Components.TransformMatrix#b
     * @type {number}
     * @since 3.4.0
     */b:{get:function(){return this.matrix[1]},set:function(t){this.matrix[1]=t}},/**
     * The Skew X value.
     *
     * @name Phaser.GameObjects.Components.TransformMatrix#c
     * @type {number}
     * @since 3.4.0
     */c:{get:function(){return this.matrix[2]},set:function(t){this.matrix[2]=t}},/**
     * The Scale Y value.
     *
     * @name Phaser.GameObjects.Components.TransformMatrix#d
     * @type {number}
     * @since 3.4.0
     */d:{get:function(){return this.matrix[3]},set:function(t){this.matrix[3]=t}},/**
     * The Translate X value.
     *
     * @name Phaser.GameObjects.Components.TransformMatrix#e
     * @type {number}
     * @since 3.11.0
     */e:{get:function(){return this.matrix[4]},set:function(t){this.matrix[4]=t}},/**
     * The Translate Y value.
     *
     * @name Phaser.GameObjects.Components.TransformMatrix#f
     * @type {number}
     * @since 3.11.0
     */f:{get:function(){return this.matrix[5]},set:function(t){this.matrix[5]=t}},/**
     * The Translate X value.
     *
     * @name Phaser.GameObjects.Components.TransformMatrix#tx
     * @type {number}
     * @since 3.4.0
     */tx:{get:function(){return this.matrix[4]},set:function(t){this.matrix[4]=t}},/**
     * The Translate Y value.
     *
     * @name Phaser.GameObjects.Components.TransformMatrix#ty
     * @type {number}
     * @since 3.4.0
     */ty:{get:function(){return this.matrix[5]},set:function(t){this.matrix[5]=t}},/**
     * The rotation of the Matrix. Value is in radians.
     *
     * @name Phaser.GameObjects.Components.TransformMatrix#rotation
     * @type {number}
     * @readonly
     * @since 3.4.0
     */rotation:{get:function(){return Math.acos(this.a/this.scaleX)*(0>Math.atan(-this.c/this.a)?-1:1)}},/**
     * The rotation of the Matrix, normalized to be within the Phaser right-handed
     * clockwise rotation space. Value is in radians.
     *
     * @name Phaser.GameObjects.Components.TransformMatrix#rotationNormalized
     * @type {number}
     * @readonly
     * @since 3.19.0
     */rotationNormalized:{get:function(){var t=this.matrix,e=t[0],i=t[1],s=t[2],r=t[3];return e||i?i>0?Math.acos(e/this.scaleX):-Math.acos(e/this.scaleX):s||r?n.TAU-(r>0?Math.acos(-s/this.scaleY):-Math.acos(s/this.scaleY)):0}},/**
     * The decomposed horizontal scale of the Matrix. This value is always positive.
     *
     * @name Phaser.GameObjects.Components.TransformMatrix#scaleX
     * @type {number}
     * @readonly
     * @since 3.4.0
     */scaleX:{get:function(){return Math.sqrt(this.a*this.a+this.b*this.b)}},/**
     * The decomposed vertical scale of the Matrix. This value is always positive.
     *
     * @name Phaser.GameObjects.Components.TransformMatrix#scaleY
     * @type {number}
     * @readonly
     * @since 3.4.0
     */scaleY:{get:function(){return Math.sqrt(this.c*this.c+this.d*this.d)}},/**
     * Reset the Matrix to an identity matrix.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#loadIdentity
     * @since 3.0.0
     *
     * @return {this} This TransformMatrix.
     */loadIdentity:function(){var t=this.matrix;return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,this},/**
     * Translate the Matrix.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#translate
     * @since 3.0.0
     *
     * @param {number} x - The horizontal translation value.
     * @param {number} y - The vertical translation value.
     *
     * @return {this} This TransformMatrix.
     */translate:function(t,e){var i=this.matrix;return i[4]=i[0]*t+i[2]*e+i[4],i[5]=i[1]*t+i[3]*e+i[5],this},/**
     * Scale the Matrix.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#scale
     * @since 3.0.0
     *
     * @param {number} x - The horizontal scale value.
     * @param {number} y - The vertical scale value.
     *
     * @return {this} This TransformMatrix.
     */scale:function(t,e){var i=this.matrix;return i[0]*=t,i[1]*=t,i[2]*=e,i[3]*=e,this},/**
     * Rotate the Matrix.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#rotate
     * @since 3.0.0
     *
     * @param {number} angle - The angle of rotation in radians.
     *
     * @return {this} This TransformMatrix.
     */rotate:function(t){var e=Math.sin(t),i=Math.cos(t),n=this.matrix,s=n[0],r=n[1],o=n[2],a=n[3];return n[0]=s*i+o*e,n[1]=r*i+a*e,n[2]=-(s*e)+o*i,n[3]=-(r*e)+a*i,this},/**
     * Multiply this Matrix by the given Matrix.
     * 
     * If an `out` Matrix is given then the results will be stored in it.
     * If it is not given, this matrix will be updated in place instead.
     * Use an `out` Matrix if you do not wish to mutate this matrix.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#multiply
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Components.TransformMatrix} rhs - The Matrix to multiply by.
     * @param {Phaser.GameObjects.Components.TransformMatrix} [out] - An optional Matrix to store the results in.
     *
     * @return {(this|Phaser.GameObjects.Components.TransformMatrix)} Either this TransformMatrix, or the `out` Matrix, if given in the arguments.
     */multiply:function(t,e){var i=this.matrix,n=t.matrix,s=i[0],r=i[1],o=i[2],a=i[3],h=i[4],l=i[5],u=n[0],c=n[1],d=n[2],f=n[3],p=n[4],g=n[5],v=void 0===e?this:e;return v.a=u*s+c*o,v.b=u*r+c*a,v.c=d*s+f*o,v.d=d*r+f*a,v.e=p*s+g*o+h,v.f=p*r+g*a+l,v},/**
     * Multiply this Matrix by the matrix given, including the offset.
     * 
     * The offsetX is added to the tx value: `offsetX * a + offsetY * c + tx`.
     * The offsetY is added to the ty value: `offsetY * b + offsetY * d + ty`.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#multiplyWithOffset
     * @since 3.11.0
     *
     * @param {Phaser.GameObjects.Components.TransformMatrix} src - The source Matrix to copy from.
     * @param {number} offsetX - Horizontal offset to factor in to the multiplication.
     * @param {number} offsetY - Vertical offset to factor in to the multiplication.
     *
     * @return {this} This TransformMatrix.
     */multiplyWithOffset:function(t,e,i){var n=this.matrix,s=t.matrix,r=n[0],o=n[1],a=n[2],h=n[3],l=n[4],u=n[5],c=s[0],d=s[1],f=s[2],p=s[3],g=s[4],v=s[5];return n[0]=c*r+d*a,n[1]=c*o+d*h,n[2]=f*r+p*a,n[3]=f*o+p*h,n[4]=g*r+v*a+(e*r+i*a+l),n[5]=g*o+v*h+(e*o+i*h+u),this},/**
     * Transform the Matrix.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#transform
     * @since 3.0.0
     *
     * @param {number} a - The Scale X value.
     * @param {number} b - The Shear Y value.
     * @param {number} c - The Shear X value.
     * @param {number} d - The Scale Y value.
     * @param {number} tx - The Translate X value.
     * @param {number} ty - The Translate Y value.
     *
     * @return {this} This TransformMatrix.
     */transform:function(t,e,i,n,s,r){var o=this.matrix,a=o[0],h=o[1],l=o[2],u=o[3],c=o[4],d=o[5];return o[0]=t*a+e*l,o[1]=t*h+e*u,o[2]=i*a+n*l,o[3]=i*h+n*u,o[4]=s*a+r*l+c,o[5]=s*h+r*u+d,this},/**
     * Transform a point using this Matrix.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#transformPoint
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate of the point to transform.
     * @param {number} y - The y coordinate of the point to transform.
     * @param {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} point - The Point object to store the transformed coordinates.
     *
     * @return {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} The Point containing the transformed coordinates.
     */transformPoint:function(t,e,i){void 0===i&&(i={x:0,y:0});var n=this.matrix,s=n[0],r=n[1],o=n[2],a=n[3],h=n[4],l=n[5];return i.x=t*s+e*o+h,i.y=t*r+e*a+l,i},/**
     * Invert the Matrix.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#invert
     * @since 3.0.0
     *
     * @return {this} This TransformMatrix.
     */invert:function(){var t=this.matrix,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],o=t[5],a=e*s-i*n;return t[0]=s/a,t[1]=-i/a,t[2]=-n/a,t[3]=e/a,t[4]=(n*o-s*r)/a,t[5]=-(e*o-i*r)/a,this},/**
     * Set the values of this Matrix to copy those of the matrix given.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#copyFrom
     * @since 3.11.0
     *
     * @param {Phaser.GameObjects.Components.TransformMatrix} src - The source Matrix to copy from.
     *
     * @return {this} This TransformMatrix.
     */copyFrom:function(t){var e=this.matrix;return e[0]=t.a,e[1]=t.b,e[2]=t.c,e[3]=t.d,e[4]=t.e,e[5]=t.f,this},/**
     * Set the values of this Matrix to copy those of the array given.
     * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#copyFromArray
     * @since 3.11.0
     *
     * @param {array} src - The array of values to set into this matrix.
     *
     * @return {this} This TransformMatrix.
     */copyFromArray:function(t){var e=this.matrix;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],this},/**
     * Copy the values from this Matrix to the given Canvas Rendering Context.
     * This will use the Context.transform method.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#copyToContext
     * @since 3.12.0
     *
     * @param {CanvasRenderingContext2D} ctx - The Canvas Rendering Context to copy the matrix values to.
     *
     * @return {CanvasRenderingContext2D} The Canvas Rendering Context.
     */copyToContext:function(t){var e=this.matrix;return t.transform(e[0],e[1],e[2],e[3],e[4],e[5]),t},/**
     * Copy the values from this Matrix to the given Canvas Rendering Context.
     * This will use the Context.setTransform method.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#setToContext
     * @since 3.12.0
     *
     * @param {CanvasRenderingContext2D} ctx - The Canvas Rendering Context to copy the matrix values to.
     *
     * @return {CanvasRenderingContext2D} The Canvas Rendering Context.
     */setToContext:function(t){var e=this.matrix;return t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),t},/**
     * Copy the values in this Matrix to the array given.
     * 
     * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#copyToArray
     * @since 3.12.0
     *
     * @param {array} [out] - The array to copy the matrix values in to.
     *
     * @return {array} An array where elements 0 to 5 contain the values from this matrix.
     */copyToArray:function(t){var e=this.matrix;return void 0===t?t=[e[0],e[1],e[2],e[3],e[4],e[5]]:(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5]),t},/**
     * Set the values of this Matrix.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#setTransform
     * @since 3.0.0
     *
     * @param {number} a - The Scale X value.
     * @param {number} b - The Shear Y value.
     * @param {number} c - The Shear X value.
     * @param {number} d - The Scale Y value.
     * @param {number} tx - The Translate X value.
     * @param {number} ty - The Translate Y value.
     *
     * @return {this} This TransformMatrix.
     */setTransform:function(t,e,i,n,s,r){var o=this.matrix;return o[0]=t,o[1]=e,o[2]=i,o[3]=n,o[4]=s,o[5]=r,this},/**
     * Decompose this Matrix into its translation, scale and rotation values using QR decomposition.
     * 
     * The result must be applied in the following order to reproduce the current matrix:
     * 
     * translate -> rotate -> scale
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#decomposeMatrix
     * @since 3.0.0
     *
     * @return {object} The decomposed Matrix.
     */decomposeMatrix:function(){var t=this.decomposedMatrix,e=this.matrix,i=e[0],n=e[1],s=e[2],r=e[3],o=i*r-n*s;if(t.translateX=e[4],t.translateY=e[5],i||n){var a=Math.sqrt(i*i+n*n);t.rotation=n>0?Math.acos(i/a):-Math.acos(i/a),t.scaleX=a,t.scaleY=o/a}else if(s||r){var h=Math.sqrt(s*s+r*r);t.rotation=.5*Math.PI-(r>0?Math.acos(-s/h):-Math.acos(s/h)),t.scaleX=o/h,t.scaleY=h}else t.rotation=0,t.scaleX=0,t.scaleY=0;return t},/**
     * Apply the identity, translate, rotate and scale operations on the Matrix.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#applyITRS
     * @since 3.0.0
     *
     * @param {number} x - The horizontal translation.
     * @param {number} y - The vertical translation.
     * @param {number} rotation - The angle of rotation in radians.
     * @param {number} scaleX - The horizontal scale.
     * @param {number} scaleY - The vertical scale.
     *
     * @return {this} This TransformMatrix.
     */applyITRS:function(t,e,i,n,s){var r=this.matrix,o=Math.sin(i),a=Math.cos(i);return(// Translate
r[4]=t,r[5]=e,// Rotate and Scale
r[0]=a*n,r[1]=o*n,r[2]=-o*s,r[3]=a*s,this)},/**
     * Takes the `x` and `y` values and returns a new position in the `output` vector that is the inverse of
     * the current matrix with its transformation applied.
     * 
     * Can be used to translate points from world to local space.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#applyInverse
     * @since 3.12.0
     *
     * @param {number} x - The x position to translate.
     * @param {number} y - The y position to translate.
     * @param {Phaser.Math.Vector2} [output] - A Vector2, or point-like object, to store the results in.
     *
     * @return {Phaser.Math.Vector2} The coordinates, inverse-transformed through this matrix.
     */applyInverse:function(t,e,i){void 0===i&&(i=new r);var n=this.matrix,s=n[0],o=n[1],a=n[2],h=n[3],l=n[4],u=n[5],c=1/(s*h+-(a*o));return i.x=h*c*t+-a*c*e+(u*a-l*h)*c,i.y=s*c*e+-o*c*t+(-u*s+l*o)*c,i},/**
     * Returns the X component of this matrix multiplied by the given values.
     * This is the same as `x * a + y * c + e`.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#getX
     * @since 3.12.0
     * 
     * @param {number} x - The x value.
     * @param {number} y - The y value.
     *
     * @return {number} The calculated x value.
     */getX:function(t,e){return t*this.a+e*this.c+this.e},/**
     * Returns the Y component of this matrix multiplied by the given values.
     * This is the same as `x * b + y * d + f`.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#getY
     * @since 3.12.0
     * 
     * @param {number} x - The x value.
     * @param {number} y - The y value.
     *
     * @return {number} The calculated y value.
     */getY:function(t,e){return t*this.b+e*this.d+this.f},/**
     * Returns a string that can be used in a CSS Transform call as a `matrix` property.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#getCSSMatrix
     * @since 3.12.0
     *
     * @return {string} A string containing the CSS Transform matrix values.
     */getCSSMatrix:function(){var t=this.matrix;return"matrix("+t[0]+","+t[1]+","+t[2]+","+t[3]+","+t[4]+","+t[5]+")"},/**
     * Destroys this Transform Matrix.
     *
     * @method Phaser.GameObjects.Components.TransformMatrix#destroy
     * @since 3.4.0
     */destroy:function(){this.matrix=null,this.decomposedMatrix=null}});t.exports=o}),r("1W59j",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("8qWuA");t.exports=function(t){return i(t,-Math.PI,Math.PI)}}),r("8qWuA",function(t,e){t.exports=function(t,e,i){var n=i-e;return e+((t-e)%n+n)%n}}),r("dokq5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("8qWuA");t.exports=function(t){return i(t,-180,180)}}),r("fVg1f",function(t,e){t.exports={/**
     * Private internal value. Holds the visible value.
     * 
     * @name Phaser.GameObjects.Components.Visible#_visible
     * @type {boolean}
     * @private
     * @default true
     * @since 3.0.0
     */_visible:!0,/**
     * The visible state of the Game Object.
     * 
     * An invisible Game Object will skip rendering, but will still process update logic.
     * 
     * @name Phaser.GameObjects.Components.Visible#visible
     * @type {boolean}
     * @since 3.0.0
     */visible:{get:function(){return this._visible},set:function(t){t?(this._visible=!0,this.renderFlags|=1):(this._visible=!1,this.renderFlags&=-2)}},/**
     * Sets the visibility of this Game Object.
     * 
     * An invisible Game Object will skip rendering, but will still process update logic.
     *
     * @method Phaser.GameObjects.Components.Visible#setVisible
     * @since 3.0.0
     *
     * @param {boolean} value - The visible state of the Game Object.
     * 
     * @return {this} This Game Object instance.
     */setVisible:function(t){return this.visible=t,this}}}),r("1zqlR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("bvPjF"),r=s("ewzDY"),o=s("3vRz3"),a=s("jIv3O"),h=new i({Extends:o,initialize:function(t,e){o.call(this),/**
         * The Scene to which this Game Object belongs.
         * Game Objects can only belong to one Scene.
         *
         * @name Phaser.GameObjects.GameObject#scene
         * @type {Phaser.Scene}
         * @protected
         * @since 3.0.0
         */this.scene=t,/**
         * A textual representation of this Game Object, i.e. `sprite`.
         * Used internally by Phaser but is available for your own custom classes to populate.
         *
         * @name Phaser.GameObjects.GameObject#type
         * @type {string}
         * @since 3.0.0
         */this.type=e,/**
         * The current state of this Game Object.
         * 
         * Phaser itself will never modify this value, although plugins may do so.
         * 
         * Use this property to track the state of a Game Object during its lifetime. For example, it could change from
         * a state of 'moving', to 'attacking', to 'dead'. The state value should be an integer (ideally mapped to a constant
         * in your game code), or a string. These are recommended to keep it light and simple, with fast comparisons.
         * If you need to store complex data about your Game Object, look at using the Data Component instead.
         *
         * @name Phaser.GameObjects.GameObject#state
         * @type {(integer|string)}
         * @since 3.16.0
         */this.state=0,/**
         * The parent Container of this Game Object, if it has one.
         *
         * @name Phaser.GameObjects.GameObject#parentContainer
         * @type {Phaser.GameObjects.Container}
         * @since 3.4.0
         */this.parentContainer=null,/**
         * The name of this Game Object.
         * Empty by default and never populated by Phaser, this is left for developers to use.
         *
         * @name Phaser.GameObjects.GameObject#name
         * @type {string}
         * @default ''
         * @since 3.0.0
         */this.name="",/**
         * The active state of this Game Object.
         * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.
         * An active object is one which is having its logic and internal systems updated.
         *
         * @name Phaser.GameObjects.GameObject#active
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.active=!0,/**
         * The Tab Index of the Game Object.
         * Reserved for future use by plugins and the Input Manager.
         *
         * @name Phaser.GameObjects.GameObject#tabIndex
         * @type {integer}
         * @default -1
         * @since 3.0.0
         */this.tabIndex=-1,/**
         * A Data Manager.
         * It allows you to store, query and get key/value paired information specific to this Game Object.
         * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.
         *
         * @name Phaser.GameObjects.GameObject#data
         * @type {Phaser.Data.DataManager}
         * @default null
         * @since 3.0.0
         */this.data=null,/**
         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.
         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.
         * If those components are not used by your custom class then you can use this bitmask as you wish.
         *
         * @name Phaser.GameObjects.GameObject#renderFlags
         * @type {integer}
         * @default 15
         * @since 3.0.0
         */this.renderFlags=15,/**
         * A bitmask that controls if this Game Object is drawn by a Camera or not.
         * Not usually set directly, instead call `Camera.ignore`, however you can
         * set this property directly using the Camera.id property:
         *
         * @example
         * this.cameraFilter |= camera.id
         *
         * @name Phaser.GameObjects.GameObject#cameraFilter
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.cameraFilter=0,/**
         * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.
         * Not usually set directly. Instead call `GameObject.setInteractive()`.
         *
         * @name Phaser.GameObjects.GameObject#input
         * @type {?Phaser.Types.Input.InteractiveObject}
         * @default null
         * @since 3.0.0
         */this.input=null,/**
         * If this Game Object is enabled for Arcade or Matter Physics then this property will contain a reference to a Physics Body.
         *
         * @name Phaser.GameObjects.GameObject#body
         * @type {?(object|Phaser.Physics.Arcade.Body|MatterJS.BodyType)}
         * @default null
         * @since 3.0.0
         */this.body=null,/**
         * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.
         * This includes calls that may come from a Group, Container or the Scene itself.
         * While it allows you to persist a Game Object across Scenes, please understand you are entirely
         * responsible for managing references to and from this Game Object.
         *
         * @name Phaser.GameObjects.GameObject#ignoreDestroy
         * @type {boolean}
         * @default false
         * @since 3.5.0
         */this.ignoreDestroy=!1,//  Tell the Scene to re-sort the children
t.sys.queueDepthSort()},/**
     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.
     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.
     *
     * @method Phaser.GameObjects.GameObject#setActive
     * @since 3.0.0
     *
     * @param {boolean} value - True if this Game Object should be set as active, false if not.
     *
     * @return {this} This GameObject.
     */setActive:function(t){return this.active=t,this},/**
     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.
     * The `name` property is not populated by Phaser and is presented for your own use.
     *
     * @method Phaser.GameObjects.GameObject#setName
     * @since 3.0.0
     *
     * @param {string} value - The name to be given to this Game Object.
     *
     * @return {this} This GameObject.
     */setName:function(t){return this.name=t,this},/**
     * Sets the current state of this Game Object.
     * 
     * Phaser itself will never modify the State of a Game Object, although plugins may do so.
     * 
     * For example, a Game Object could change from a state of 'moving', to 'attacking', to 'dead'.
     * The state value should typically be an integer (ideally mapped to a constant
     * in your game code), but could also be a string. It is recommended to keep it light and simple.
     * If you need to store complex data about your Game Object, look at using the Data Component instead.
     *
     * @method Phaser.GameObjects.GameObject#setState
     * @since 3.16.0
     *
     * @param {(integer|string)} value - The state of the Game Object.
     *
     * @return {this} This GameObject.
     */setState:function(t){return this.state=t,this},/**
     * Adds a Data Manager component to this Game Object.
     *
     * @method Phaser.GameObjects.GameObject#setDataEnabled
     * @since 3.0.0
     * @see Phaser.Data.DataManager
     *
     * @return {this} This GameObject.
     */setDataEnabled:function(){return this.data||(this.data=new r(this)),this},/**
     * Allows you to store a key value pair within this Game Objects Data Manager.
     *
     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled
     * before setting the value.
     *
     * If the key doesn't already exist in the Data Manager then it is created.
     *
     * ```javascript
     * sprite.setData('name', 'Red Gem Stone');
     * ```
     *
     * You can also pass in an object of key value pairs as the first argument:
     *
     * ```javascript
     * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });
     * ```
     *
     * To get a value back again you can call `getData`:
     *
     * ```javascript
     * sprite.getData('gold');
     * ```
     *
     * Or you can access the value directly via the `values` property, where it works like any other variable:
     *
     * ```javascript
     * sprite.data.values.gold += 50;
     * ```
     *
     * When the value is first set, a `setdata` event is emitted from this Game Object.
     *
     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.
     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.
     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.
     *
     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.
     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.
     *
     * @method Phaser.GameObjects.GameObject#setData
     * @since 3.0.0
     *
     * @param {(string|object)} key - The key to set the value for. Or an object of key value pairs. If an object the `data` argument is ignored.
     * @param {*} [data] - The value to set for the given key. If an object is provided as the key this argument is ignored.
     *
     * @return {this} This GameObject.
     */setData:function(t,e){return this.data||(this.data=new r(this)),this.data.set(t,e),this},/**
     * Increase a value for the given key within this Game Objects Data Manager. If the key doesn't already exist in the Data Manager then it is increased from 0.
     *
     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled
     * before setting the value.
     *
     * If the key doesn't already exist in the Data Manager then it is created.
     * 
     * When the value is first set, a `setdata` event is emitted from this Game Object.
     *
     * @method Phaser.GameObjects.GameObject#incData
     * @since 3.23.0
     *
     * @param {(string|object)} key - The key to increase the value for.
     * @param {*} [data] - The value to increase for the given key.
     *
     * @return {this} This GameObject.
     */incData:function(t,e){return this.data||(this.data=new r(this)),this.data.inc(t,e),this},/**
     * Toggle a boolean value for the given key within this Game Objects Data Manager. If the key doesn't already exist in the Data Manager then it is toggled from false.
     *
     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled
     * before setting the value.
     *
     * If the key doesn't already exist in the Data Manager then it is created.
     * 
     * When the value is first set, a `setdata` event is emitted from this Game Object.
     *
     * @method Phaser.GameObjects.GameObject#toggleData
     * @since 3.23.0
     *
     * @param {(string|object)} key - The key to toggle the value for.
     *
     * @return {this} This GameObject.
     */toggleData:function(t){return this.data||(this.data=new r(this)),this.data.toggle(t),this},/**
     * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.
     *
     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:
     *
     * ```javascript
     * sprite.getData('gold');
     * ```
     *
     * Or access the value directly:
     *
     * ```javascript
     * sprite.data.values.gold;
     * ```
     *
     * You can also pass in an array of keys, in which case an array of values will be returned:
     *
     * ```javascript
     * sprite.getData([ 'gold', 'armor', 'health' ]);
     * ```
     *
     * This approach is useful for destructuring arrays in ES6.
     *
     * @method Phaser.GameObjects.GameObject#getData
     * @since 3.0.0
     *
     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.
     *
     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.
     */getData:function(t){return this.data||(this.data=new r(this)),this.data.get(t)},/**
     * Pass this Game Object to the Input Manager to enable it for Input.
     *
     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area
     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced
     * input detection.
     *
     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If
     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific
     * shape for it to use.
     *
     * You can also provide an Input Configuration Object as the only argument to this method.
     *
     * @method Phaser.GameObjects.GameObject#setInteractive
     * @since 3.0.0
     *
     * @param {(Phaser.Types.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.
     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.
     * @param {boolean} [dropZone=false] - Should this Game Object be treated as a drop zone target?
     *
     * @return {this} This GameObject.
     */setInteractive:function(t,e,i){return this.scene.sys.input.enable(this,t,e,i),this},/**
     * If this Game Object has previously been enabled for input, this will disable it.
     *
     * An object that is disabled for input stops processing or being considered for
     * input events, but can be turned back on again at any time by simply calling
     * `setInteractive()` with no arguments provided.
     *
     * If want to completely remove interaction from this Game Object then use `removeInteractive` instead.
     *
     * @method Phaser.GameObjects.GameObject#disableInteractive
     * @since 3.7.0
     *
     * @return {this} This GameObject.
     */disableInteractive:function(){return this.input&&(this.input.enabled=!1),this},/**
     * If this Game Object has previously been enabled for input, this will queue it
     * for removal, causing it to no longer be interactive. The removal happens on
     * the next game step, it is not immediate.
     *
     * The Interactive Object that was assigned to this Game Object will be destroyed,
     * removed from the Input Manager and cleared from this Game Object.
     *
     * If you wish to re-enable this Game Object at a later date you will need to
     * re-create its InteractiveObject by calling `setInteractive` again.
     *
     * If you wish to only temporarily stop an object from receiving input then use
     * `disableInteractive` instead, as that toggles the interactive state, where-as
     * this erases it completely.
     * 
     * If you wish to resize a hit area, don't remove and then set it as being
     * interactive. Instead, access the hitarea object directly and resize the shape
     * being used. I.e.: `sprite.input.hitArea.setSize(width, height)` (assuming the
     * shape is a Rectangle, which it is by default.)
     *
     * @method Phaser.GameObjects.GameObject#removeInteractive
     * @since 3.7.0
     *
     * @return {this} This GameObject.
     */removeInteractive:function(){return this.scene.sys.input.clear(this),this.input=void 0,this},/**
     * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.
     *
     * @method Phaser.GameObjects.GameObject#update
     * @since 3.0.0
     *
     * @param {...*} [args] - args
     */update:function(){},/**
     * Returns a JSON representation of the Game Object.
     *
     * @method Phaser.GameObjects.GameObject#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.
     */toJSON:function(){return n(this)},/**
     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.
     * Also checks the Game Object against the given Cameras exclusion list.
     *
     * @method Phaser.GameObjects.GameObject#willRender
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.
     *
     * @return {boolean} True if the Game Object should be rendered, otherwise false.
     */willRender:function(t){return!(h.RENDER_MASK!==this.renderFlags||0!==this.cameraFilter&&this.cameraFilter&t.id)},/**
     * Returns an array containing the display list index of either this Game Object, or if it has one,
     * its parent Container. It then iterates up through all of the parent containers until it hits the
     * root of the display list (which is index 0 in the returned array).
     *
     * Used internally by the InputPlugin but also useful if you wish to find out the display depth of
     * this Game Object and all of its ancestors.
     *
     * @method Phaser.GameObjects.GameObject#getIndexList
     * @since 3.4.0
     *
     * @return {integer[]} An array of display list position indexes.
     */getIndexList:function(){for(// eslint-disable-next-line consistent-this
var t=this,e=this.parentContainer,i=[];e;)if(// indexes.unshift([parent.getIndex(child), parent.name]);
i.unshift(e.getIndex(t)),t=e,e.parentContainer)e=e.parentContainer;else break;return(// indexes.unshift([this.scene.sys.displayList.getIndex(child), 'root']);
i.unshift(this.scene.sys.displayList.getIndex(t)),i)},/**
     * Destroys this Game Object removing it from the Display List and Update List and
     * severing all ties to parent resources.
     *
     * Also removes itself from the Input Manager and Physics Manager if previously enabled.
     *
     * Use this to remove a Game Object from your game if you don't ever plan to use it again.
     * As long as no reference to it exists within your own code it should become free for
     * garbage collection by the browser.
     *
     * If you just want to temporarily disable an object then look at using the
     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.
     *
     * @method Phaser.GameObjects.GameObject#destroy
     * @fires Phaser.GameObjects.Events#DESTROY
     * @since 3.0.0
     *
     * @param {boolean} [fromScene=false] - Is this Game Object being destroyed as the result of a Scene shutdown?
     */destroy:function(t){//  This Game Object has already been destroyed
if(void 0===t&&(t=!1),this.scene&&!this.ignoreDestroy){this.preDestroy&&this.preDestroy.call(this),this.emit(a.DESTROY,this);var e=this.scene.sys;t||(e.displayList.remove(this),e.updateList.remove(this)),this.input&&(e.input.clear(this),this.input=void 0),this.data&&(this.data.destroy(),this.data=void 0),this.body&&(this.body.destroy(),this.body=void 0),t||e.queueDepthSort(),this.active=!1,this.visible=!1,this.scene=void 0,this.parentContainer=void 0,this.removeAllListeners()}}});/**
 * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.
 *
 * @constant {integer} RENDER_MASK
 * @memberof Phaser.GameObjects.GameObject
 * @default
 */h.RENDER_MASK=15,t.exports=h}),r("ewzDY",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jKmu9"),r=new i({initialize:function(t,e){/**
         * The object that this DataManager belongs to.
         *
         * @name Phaser.Data.DataManager#parent
         * @type {*}
         * @since 3.0.0
         */this.parent=t,/**
         * The DataManager's event emitter.
         *
         * @name Phaser.Data.DataManager#events
         * @type {Phaser.Events.EventEmitter}
         * @since 3.0.0
         */this.events=e,e||(this.events=t.events?t.events:t),/**
         * The data list.
         *
         * @name Phaser.Data.DataManager#list
         * @type {Object.<string, *>}
         * @default {}
         * @since 3.0.0
         */this.list={},/**
         * The public values list. You can use this to access anything you have stored
         * in this Data Manager. For example, if you set a value called `gold` you can
         * access it via:
         *
         * ```javascript
         * this.data.values.gold;
         * ```
         *
         * You can also modify it directly:
         * 
         * ```javascript
         * this.data.values.gold += 1000;
         * ```
         *
         * Doing so will emit a `setdata` event from the parent of this Data Manager.
         * 
         * Do not modify this object directly. Adding properties directly to this object will not
         * emit any events. Always use `DataManager.set` to create new items the first time around.
         *
         * @name Phaser.Data.DataManager#values
         * @type {Object.<string, *>}
         * @default {}
         * @since 3.10.0
         */this.values={},/**
         * Whether setting data is frozen for this DataManager.
         *
         * @name Phaser.Data.DataManager#_frozen
         * @type {boolean}
         * @private
         * @default false
         * @since 3.0.0
         */this._frozen=!1,!t.hasOwnProperty("sys")&&this.events&&this.events.once("destroy",this.destroy,this)},/**
     * Retrieves the value for the given key, or undefined if it doesn't exist.
     *
     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:
     * 
     * ```javascript
     * this.data.get('gold');
     * ```
     *
     * Or access the value directly:
     * 
     * ```javascript
     * this.data.values.gold;
     * ```
     *
     * You can also pass in an array of keys, in which case an array of values will be returned:
     * 
     * ```javascript
     * this.data.get([ 'gold', 'armor', 'health' ]);
     * ```
     *
     * This approach is useful for destructuring arrays in ES6.
     *
     * @method Phaser.Data.DataManager#get
     * @since 3.0.0
     *
     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.
     *
     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.
     */get:function(t){var e=this.list;if(!Array.isArray(t))return e[t];for(var i=[],n=0;n<t.length;n++)i.push(e[t[n]]);return i},/**
     * Retrieves all data values in a new object.
     *
     * @method Phaser.Data.DataManager#getAll
     * @since 3.0.0
     *
     * @return {Object.<string, *>} All data values.
     */getAll:function(){var t={};for(var e in this.list)this.list.hasOwnProperty(e)&&(t[e]=this.list[e]);return t},/**
     * Queries the DataManager for the values of keys matching the given regular expression.
     *
     * @method Phaser.Data.DataManager#query
     * @since 3.0.0
     *
     * @param {RegExp} search - A regular expression object. If a non-RegExp object obj is passed, it is implicitly converted to a RegExp by using new RegExp(obj).
     *
     * @return {Object.<string, *>} The values of the keys matching the search string.
     */query:function(t){var e={};for(var i in this.list)this.list.hasOwnProperty(i)&&i.match(t)&&(e[i]=this.list[i]);return e},/**
     * Sets a value for the given key. If the key doesn't already exist in the Data Manager then it is created.
     * 
     * ```javascript
     * data.set('name', 'Red Gem Stone');
     * ```
     *
     * You can also pass in an object of key value pairs as the first argument:
     *
     * ```javascript
     * data.set({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });
     * ```
     *
     * To get a value back again you can call `get`:
     * 
     * ```javascript
     * data.get('gold');
     * ```
     * 
     * Or you can access the value directly via the `values` property, where it works like any other variable:
     * 
     * ```javascript
     * data.values.gold += 50;
     * ```
     *
     * When the value is first set, a `setdata` event is emitted.
     *
     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.
     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.
     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.
     *
     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.
     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.
     *
     * @method Phaser.Data.DataManager#set
     * @fires Phaser.Data.Events#SET_DATA
     * @fires Phaser.Data.Events#CHANGE_DATA
     * @fires Phaser.Data.Events#CHANGE_DATA_KEY
     * @since 3.0.0
     *
     * @param {(string|object)} key - The key to set the value for. Or an object or key value pairs. If an object the `data` argument is ignored.
     * @param {*} data - The value to set for the given key. If an object is provided as the key this argument is ignored.
     *
     * @return {this} This DataManager object.
     */set:function(t,e){if(this._frozen)return this;if("string"==typeof t)return this.setValue(t,e);for(var i in t)this.setValue(i,t[i]);return this},/**
     * Increase a value for the given key. If the key doesn't already exist in the Data Manager then it is increased from 0.
     * 
     * When the value is first set, a `setdata` event is emitted.
     * 
     * @method Phaser.Data.DataManager#inc
     * @fires Phaser.Data.Events#SET_DATA
     * @fires Phaser.Data.Events#CHANGE_DATA
     * @fires Phaser.Data.Events#CHANGE_DATA_KEY
     * @since 3.23.0
     *
     * @param {(string|object)} key - The key to increase the value for.
     * @param {*} [data] - The value to increase for the given key.
     *
     * @return {Phaser.Data.DataManager} This DataManager object.
     */inc:function(t,e){if(this._frozen)return this;void 0===e&&(e=1);var i=this.get(t);return void 0===i&&(i=0),this.set(t,i+e),this},/**
     * Toggle a boolean value for the given key. If the key doesn't already exist in the Data Manager then it is toggled from false.
     * 
     * When the value is first set, a `setdata` event is emitted.
     * 
     * @method Phaser.Data.DataManager#toggle
     * @fires Phaser.Data.Events#SET_DATA
     * @fires Phaser.Data.Events#CHANGE_DATA
     * @fires Phaser.Data.Events#CHANGE_DATA_KEY
     * @since 3.23.0
     *
     * @param {(string|object)} key - The key to toggle the value for.
     *
     * @return {Phaser.Data.DataManager} This DataManager object.
     */toggle:function(t){return this._frozen||this.set(t,!this.get(t)),this},/**
     * Internal value setter, called automatically by the `set` method.
     *
     * @method Phaser.Data.DataManager#setValue
     * @fires Phaser.Data.Events#SET_DATA
     * @fires Phaser.Data.Events#CHANGE_DATA
     * @fires Phaser.Data.Events#CHANGE_DATA_KEY
     * @private
     * @since 3.10.0
     *
     * @param {string} key - The key to set the value for.
     * @param {*} data - The value to set.
     *
     * @return {this} This DataManager object.
     */setValue:function(t,e){if(this._frozen)return this;if(this.has(t))this.values[t]=e;else{var i=this,s=this.list,r=this.events,o=this.parent;Object.defineProperty(this.values,t,{enumerable:!0,configurable:!0,get:function(){return s[t]},set:function(e){if(!i._frozen){var a=s[t];s[t]=e,r.emit(n.CHANGE_DATA,o,t,e,a),r.emit(n.CHANGE_DATA_KEY+t,o,e,a)}}}),s[t]=e,r.emit(n.SET_DATA,o,t,e)}return this},/**
     * Passes all data entries to the given callback.
     *
     * @method Phaser.Data.DataManager#each
     * @since 3.0.0
     *
     * @param {DataEachCallback} callback - The function to call.
     * @param {*} [context] - Value to use as `this` when executing callback.
     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the game object, key, and data.
     *
     * @return {this} This DataManager object.
     */each:function(t,e){for(var i=[this.parent,null,void 0],n=1;n<arguments.length;n++)i.push(arguments[n]);for(var s in this.list)i[1]=s,i[2]=this.list[s],t.apply(e,i);return this},/**
     * Merge the given object of key value pairs into this DataManager.
     *
     * Any newly created values will emit a `setdata` event. Any updated values (see the `overwrite` argument)
     * will emit a `changedata` event.
     *
     * @method Phaser.Data.DataManager#merge
     * @fires Phaser.Data.Events#SET_DATA
     * @fires Phaser.Data.Events#CHANGE_DATA
     * @fires Phaser.Data.Events#CHANGE_DATA_KEY
     * @since 3.0.0
     *
     * @param {Object.<string, *>} data - The data to merge.
     * @param {boolean} [overwrite=true] - Whether to overwrite existing data. Defaults to true.
     *
     * @return {this} This DataManager object.
     */merge:function(t,e){//  Merge data from another component into this one
for(var i in void 0===e&&(e=!0),t)t.hasOwnProperty(i)&&(e||!e&&!this.has(i))&&this.setValue(i,t[i]);return this},/**
     * Remove the value for the given key.
     *
     * If the key is found in this Data Manager it is removed from the internal lists and a
     * `removedata` event is emitted.
     * 
     * You can also pass in an array of keys, in which case all keys in the array will be removed:
     * 
     * ```javascript
     * this.data.remove([ 'gold', 'armor', 'health' ]);
     * ```
     *
     * @method Phaser.Data.DataManager#remove
     * @fires Phaser.Data.Events#REMOVE_DATA
     * @since 3.0.0
     *
     * @param {(string|string[])} key - The key to remove, or an array of keys to remove.
     *
     * @return {this} This DataManager object.
     */remove:function(t){if(this._frozen)return this;if(!Array.isArray(t))return this.removeValue(t);for(var e=0;e<t.length;e++)this.removeValue(t[e]);return this},/**
     * Internal value remover, called automatically by the `remove` method.
     *
     * @method Phaser.Data.DataManager#removeValue
     * @private
     * @fires Phaser.Data.Events#REMOVE_DATA
     * @since 3.10.0
     *
     * @param {string} key - The key to set the value for.
     *
     * @return {this} This DataManager object.
     */removeValue:function(t){if(this.has(t)){var e=this.list[t];delete this.list[t],delete this.values[t],this.events.emit(n.REMOVE_DATA,this.parent,t,e)}return this},/**
     * Retrieves the data associated with the given 'key', deletes it from this Data Manager, then returns it.
     *
     * @method Phaser.Data.DataManager#pop
     * @fires Phaser.Data.Events#REMOVE_DATA
     * @since 3.0.0
     *
     * @param {string} key - The key of the value to retrieve and delete.
     *
     * @return {*} The value of the given key.
     */pop:function(t){var e=void 0;return!this._frozen&&this.has(t)&&(e=this.list[t],delete this.list[t],delete this.values[t],this.events.emit(n.REMOVE_DATA,this.parent,t,e)),e},/**
     * Determines whether the given key is set in this Data Manager.
     * 
     * Please note that the keys are case-sensitive and must be valid JavaScript Object property strings.
     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.
     *
     * @method Phaser.Data.DataManager#has
     * @since 3.0.0
     *
     * @param {string} key - The key to check.
     *
     * @return {boolean} Returns `true` if the key exists, otherwise `false`.
     */has:function(t){return this.list.hasOwnProperty(t)},/**
     * Freeze or unfreeze this Data Manager. A frozen Data Manager will block all attempts
     * to create new values or update existing ones.
     *
     * @method Phaser.Data.DataManager#setFreeze
     * @since 3.0.0
     *
     * @param {boolean} value - Whether to freeze or unfreeze the Data Manager.
     *
     * @return {this} This DataManager object.
     */setFreeze:function(t){return this._frozen=t,this},/**
     * Delete all data in this Data Manager and unfreeze it.
     *
     * @method Phaser.Data.DataManager#reset
     * @since 3.0.0
     *
     * @return {this} This DataManager object.
     */reset:function(){for(var t in this.list)delete this.list[t],delete this.values[t];return this._frozen=!1,this},/**
     * Destroy this data manager.
     *
     * @method Phaser.Data.DataManager#destroy
     * @since 3.0.0
     */destroy:function(){this.reset(),this.events.off(n.CHANGE_DATA),this.events.off(n.SET_DATA),this.events.off(n.REMOVE_DATA),this.parent=null},/**
     * Gets or sets the frozen state of this Data Manager.
     * A frozen Data Manager will block all attempts to create new values or update existing ones.
     *
     * @name Phaser.Data.DataManager#freeze
     * @type {boolean}
     * @since 3.0.0
     */freeze:{get:function(){return this._frozen},set:function(t){this._frozen=!!t}},/**
     * Return the total number of entries in this Data Manager.
     *
     * @name Phaser.Data.DataManager#count
     * @type {integer}
     * @since 3.0.0
     */count:{get:function(){var t=0;for(var e in this.list)void 0!==this.list[e]&&t++;return t}}});t.exports=r}),r("jKmu9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Data.Events
 */t.exports={CHANGE_DATA:s("7E9xa"),CHANGE_DATA_KEY:s("hH5Zt"),REMOVE_DATA:s("dfc2G"),SET_DATA:s("6oQwq")}}),r("7E9xa",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Change Data Event.
 * 
 * This event is dispatched by a Data Manager when an item in the data store is changed.
 * 
 * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for
 * a change data event from a Game Object you would use: `sprite.data.on('changedata', listener)`.
 * 
 * This event is dispatched for all items that change in the Data Manager.
 * To listen for the change of a specific item, use the `CHANGE_DATA_KEY_EVENT` event.
 *
 * @event Phaser.Data.Events#CHANGE_DATA
 * @since 3.0.0
 * 
 * @param {any} parent - A reference to the object that the Data Manager responsible for this event belongs to.
 * @param {string} key - The unique key of the data item within the Data Manager.
 * @param {any} value - The new value of the item in the Data Manager.
 * @param {any} previousValue - The previous value of the item in the Data Manager.
 */t.exports="changedata"}),r("hH5Zt",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Change Data Key Event.
 * 
 * This event is dispatched by a Data Manager when an item in the data store is changed.
 * 
 * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for
 * the change of a specific data item from a Game Object you would use: `sprite.data.on('changedata-key', listener)`,
 * where `key` is the unique string key of the data item. For example, if you have a data item stored called `gold`
 * then you can listen for `sprite.data.on('changedata-gold')`.
 *
 * @event Phaser.Data.Events#CHANGE_DATA_KEY
 * @since 3.16.1
 * 
 * @param {any} parent - A reference to the object that owns the instance of the Data Manager responsible for this event.
 * @param {any} value - The item that was updated in the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.
 * @param {any} previousValue - The previous item that was updated in the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.
 */t.exports="changedata-"}),r("dfc2G",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Remove Data Event.
 * 
 * This event is dispatched by a Data Manager when an item is removed from it.
 * 
 * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for
 * the removal of a data item on a Game Object you would use: `sprite.data.on('removedata', listener)`.
 *
 * @event Phaser.Data.Events#REMOVE_DATA
 * @since 3.0.0
 * 
 * @param {any} parent - A reference to the object that owns the instance of the Data Manager responsible for this event.
 * @param {string} key - The unique key of the data item within the Data Manager.
 * @param {any} data - The item that was removed from the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.
 */t.exports="removedata"}),r("6oQwq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Set Data Event.
 * 
 * This event is dispatched by a Data Manager when a new item is added to the data store.
 * 
 * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for
 * the addition of a new data item on a Game Object you would use: `sprite.data.on('setdata', listener)`.
 *
 * @event Phaser.Data.Events#SET_DATA
 * @since 3.0.0
 * 
 * @param {any} parent - A reference to the object that owns the instance of the Data Manager responsible for this event.
 * @param {string} key - The unique key of the data item within the Data Manager.
 * @param {any} data - The item that was added to the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.
 */t.exports="setdata"}),r("jIv3O",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.GameObjects.Events
 */t.exports={DESTROY:s("MWlUo"),VIDEO_COMPLETE:s("bWZ21"),VIDEO_CREATED:s("fqYHh"),VIDEO_ERROR:s("glcsh"),VIDEO_LOOP:s("jJLzr"),VIDEO_PLAY:s("fSNwG"),VIDEO_SEEKED:s("7xtDe"),VIDEO_SEEKING:s("dRWxs"),VIDEO_STOP:s("gNOgs"),VIDEO_TIMEOUT:s("guzLM"),VIDEO_UNLOCKED:s("4041a")}}),r("MWlUo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Destroy Event.
 * 
 * This event is dispatched when a Game Object instance is being destroyed.
 * 
 * Listen for it on a Game Object instance using `GameObject.on('destroy', listener)`.
 *
 * @event Phaser.GameObjects.Events#DESTROY
 * @since 3.0.0
 * 
 * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object which is being destroyed.
 */t.exports="destroy"}),r("bWZ21",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Video Game Object Complete Event.
 * 
 * This event is dispatched when a Video finishes playback by reaching the end of its duration. It
 * is also dispatched if a video marker sequence is being played and reaches the end.
 * 
 * Note that not all videos can fire this event. Live streams, for example, have no fixed duration,
 * so never technically 'complete'.
 * 
 * If a video is stopped from playback, via the `Video.stop` method, it will emit the
 * `VIDEO_STOP` event instead of this one.
 * 
 * Listen for it from a Video Game Object instance using `Video.on('complete', listener)`.
 *
 * @event Phaser.GameObjects.Events#VIDEO_COMPLETE
 * @since 3.20.0
 * 
 * @param {Phaser.GameObjects.Video} video - The Video Game Object which completed playback.
 */t.exports="complete"}),r("fqYHh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Video Game Object Created Event.
 * 
 * This event is dispatched when the texture for a Video has been created. This happens
 * when enough of the video source has been loaded that the browser is able to render a
 * frame from it.
 * 
 * Listen for it from a Video Game Object instance using `Video.on('created', listener)`.
 *
 * @event Phaser.GameObjects.Events#VIDEO_CREATED
 * @since 3.20.0
 * 
 * @param {Phaser.GameObjects.Video} video - The Video Game Object which raised the event.
 * @param {integer} width - The width of the video.
 * @param {integer} height - The height of the video.
 */t.exports="created"}),r("glcsh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Video Game Object Error Event.
 * 
 * This event is dispatched when a Video tries to play a source that does not exist, or is the wrong file type.
 * 
 * Listen for it from a Video Game Object instance using `Video.on('error', listener)`.
 *
 * @event Phaser.GameObjects.Events#VIDEO_ERROR
 * @since 3.20.0
 * 
 * @param {Phaser.GameObjects.Video} video - The Video Game Object which threw the error.
 * @param {Event} event - The native DOM event the browser raised during playback.
 */t.exports="error"}),r("jJLzr",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Video Game Object Loop Event.
 * 
 * This event is dispatched when a Video that is currently playing has looped. This only
 * happens if the `loop` parameter was specified, or the `setLoop` method was called,
 * and if the video has a fixed duration. Video streams, for example, cannot loop, as
 * they have no duration.
 * 
 * Looping is based on the result of the Video `timeupdate` event. This event is not
 * frame-accurate, due to the way browsers work, so please do not rely on this loop
 * event to be time or frame precise.
 * 
 * Listen for it from a Video Game Object instance using `Video.on('loop', listener)`.
 *
 * @event Phaser.GameObjects.Events#VIDEO_LOOP
 * @since 3.20.0
 * 
 * @param {Phaser.GameObjects.Video} video - The Video Game Object which has looped.
 */t.exports="loop"}),r("fSNwG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Video Game Object Play Event.
 * 
 * This event is dispatched when a Video begins playback. For videos that do not require
 * interaction unlocking, this is usually as soon as the `Video.play` method is called.
 * However, for videos that require unlocking, it is fired once playback begins after
 * they've been unlocked.
 * 
 * Listen for it from a Video Game Object instance using `Video.on('play', listener)`.
 *
 * @event Phaser.GameObjects.Events#VIDEO_PLAY
 * @since 3.20.0
 * 
 * @param {Phaser.GameObjects.Video} video - The Video Game Object which started playback.
 */t.exports="play"}),r("7xtDe",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Video Game Object Seeked Event.
 * 
 * This event is dispatched when a Video completes seeking to a new point in its timeline.
 * 
 * Listen for it from a Video Game Object instance using `Video.on('seeked', listener)`.
 *
 * @event Phaser.GameObjects.Events#VIDEO_SEEKED
 * @since 3.20.0
 * 
 * @param {Phaser.GameObjects.Video} video - The Video Game Object which completed seeking.
 */t.exports="seeked"}),r("dRWxs",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Video Game Object Seeking Event.
 * 
 * This event is dispatched when a Video _begins_ seeking to a new point in its timeline.
 * When the seek is complete, it will dispatch the `VIDEO_SEEKED` event to conclude.
 * 
 * Listen for it from a Video Game Object instance using `Video.on('seeking', listener)`.
 *
 * @event Phaser.GameObjects.Events#VIDEO_SEEKING
 * @since 3.20.0
 * 
 * @param {Phaser.GameObjects.Video} video - The Video Game Object which started seeking.
 */t.exports="seeking"}),r("gNOgs",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Video Game Object Stopped Event.
 * 
 * This event is dispatched when a Video is stopped from playback via a call to the `Video.stop` method,
 * either directly via game code, or indirectly as the result of changing a video source or destroying it.
 * 
 * Listen for it from a Video Game Object instance using `Video.on('stop', listener)`.
 *
 * @event Phaser.GameObjects.Events#VIDEO_STOP
 * @since 3.20.0
 * 
 * @param {Phaser.GameObjects.Video} video - The Video Game Object which stopped playback.
 */t.exports="stop"}),r("guzLM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Video Game Object Timeout Event.
 * 
 * This event is dispatched when a Video has exhausted its allocated time while trying to connect to a video
 * source to start playback.
 * 
 * Listen for it from a Video Game Object instance using `Video.on('timeout', listener)`.
 *
 * @event Phaser.GameObjects.Events#VIDEO_TIMEOUT
 * @since 3.20.0
 * 
 * @param {Phaser.GameObjects.Video} video - The Video Game Object which timed out.
 */t.exports="timeout"}),r("4041a",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Video Game Object Unlocked Event.
 * 
 * This event is dispatched when a Video that was prevented from playback due to the browsers
 * Media Engagement Interaction policy, is unlocked by a user gesture.
 * 
 * Listen for it from a Video Game Object instance using `Video.on('unlocked', listener)`.
 *
 * @event Phaser.GameObjects.Events#VIDEO_UNLOCKED
 * @since 3.20.0
 * 
 * @param {Phaser.GameObjects.Video} video - The Video Game Object which raised the event.
 */t.exports="unlocked"}),r("51Ccp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("joPJC");t.exports=function(t,e,n,s,r){return i(t,"alpha",e,n,s,r)}}),r("2geHo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("joPJC");t.exports=function(t,e,n,s,r){return i(t,"x",e,n,s,r)}}),r("aa2rH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("joPJC");t.exports=function(t,e,n,s,r,o,a){return null==n&&(n=e),i(t,"x",e,s,o,a),i(t,"y",n,r,o,a)}}),r("iNcUv",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("joPJC");t.exports=function(t,e,n,s,r){return i(t,"y",e,n,s,r)}}),r("irnRf",function(t,e){t.exports=function(t,e,i,n){void 0===i&&(i=0),void 0===n&&(n=6.28);for(var s=i,r=(n-i)/t.length,o=0;o<t.length;o++)t[o].x=e.x+e.radius*Math.cos(s),t[o].y=e.y+e.radius*Math.sin(s),s+=r;return t}}),r("jYzIo",function(t,e){t.exports=function(t,e,i,n){void 0===i&&(i=0),void 0===n&&(n=6.28);for(var s=i,r=(n-i)/t.length,o=e.width/2,a=e.height/2,h=0;h<t.length;h++)t[h].x=e.x+o*Math.cos(s),t[h].y=e.y+a*Math.sin(s),s+=r;return t}}),r("fTyAf",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("fYnml");t.exports=function(t,e){for(var n=i(e,t.length),s=0;s<t.length;s++){var r=t[s],o=n[s];r.x=o.x,r.y=o.y}return t}}),r("kQ8Yy",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ktcgp"),n=s("jq6lX"),r=s("7ZIew");t.exports=function(t,e,s){void 0===s&&(s=0);var o=i(e,!1,t.length);s>0?n(o,s):s<0&&r(o,Math.abs(s));for(var a=0;a<t.length;a++)t[a].x=o[a].x,t[a].y=o[a].y;return t}}),r("ktcgp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ltSp2"),n=s("cSEB9");t.exports=function(t,e,s,r){if(void 0===r&&(r=[]),!e&&!s)return r;e?s=Math.round(i(t)/e):e=i(t)/s;//  Loop across each face of the rectangle
for(var o=t.x,a=t.y,h=0,l=0;l<s;l++)switch(r.push(new n(o,a)),h){//  Top face
case 0:(o+=e)>=t.right&&(h=1,a+=o-t.right,o=t.right);break;//  Right face
case 1:(a+=e)>=t.bottom&&(h=2,o-=a-t.bottom,a=t.bottom);break;//  Bottom face
case 2:(o-=e)<=t.left&&(h=3,a-=t.left-o,o=t.left);break;//  Left face
case 3:(a-=e)<=t.top&&(h=0,a=t.top)}return r}}),r("jq6lX",function(t,e){t.exports=function(t,e){void 0===e&&(e=1);for(var i=null,n=0;n<e;n++)i=t.shift(),t.push(i);return i}}),r("7ZIew",function(t,e){t.exports=function(t,e){void 0===e&&(e=1);for(var i=null,n=0;n<e;n++)i=t.pop(),t.unshift(i);return i}}),r("3aDNv",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7M14o");t.exports=function(t,e,n){var s=i({x1:e.x1,y1:e.y1,x2:e.x2,y2:e.y2},n),r=i({x1:e.x2,y1:e.y2,x2:e.x3,y2:e.y3},n),o=i({x1:e.x3,y1:e.y3,x2:e.x1,y2:e.y1},n);//  Remove overlaps
s.pop(),r.pop(),o.pop();for(var a=(s=s.concat(r,o)).length/t.length,h=0,l=0;l<t.length;l++){var u=t[l],c=s[Math.floor(h)];u.x=c.x,u.y=c.y,h+=a}return t}}),r("7M14o",function(t,e){t.exports=function(t,e,i){void 0===e&&(e=1),void 0===i&&(i=[]);var n=Math.round(t.x1),s=Math.round(t.y1),r=Math.round(t.x2),o=Math.round(t.y2),a=Math.abs(r-n),h=Math.abs(o-s),l=n<r?1:-1,u=s<o?1:-1,c=a-h;i.push({x:n,y:s});for(var d=1;!(n===r&&s===o);){var f=c<<1;f>-h&&(c-=h,n+=l),f<a&&(c+=a,s+=u),d%e==0&&i.push({x:n,y:s}),d++}return i}}),r("58n2H",function(t,e){t.exports=function(t,e,i){for(var n=0;n<t.length;n++)t[n].anims.play(e,i);return t}}),r("2Alx8",function(t,e){t.exports=function(t,e,i,n,s,r){void 0===n&&(n=0),void 0===s&&(s=0),void 0===r&&(r=1);var o,a=0,h=t.length;if(1===r)for(o=s;o<h;o++)t[o][e]=i+a*n,a++;else for(o=s;o>=0;o--)t[o][e]=i+a*n,a++;return t}}),r("feu3e",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("9zIIl");t.exports=function(t,e){for(var n=0;n<t.length;n++)i(e,t[n]);return t}}),r("4RfvK",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("fH1i1");t.exports=function(t,e){for(var n=0;n<t.length;n++)i(e,t[n]);return t}}),r("fH1i1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e){void 0===e&&(e=new i);var n=Math.random()*Math.PI*2,s=Math.sqrt(Math.random());return e.x=t.x+s*Math.cos(n)*t.width/2,e.y=t.y+s*Math.sin(n)*t.height/2,e}}),r("8FwLE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1Ap5d");t.exports=function(t,e){for(var n=0;n<t.length;n++)i(e,t[n]);return t}}),r("km9Vj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("xap54");t.exports=function(t,e){for(var n=0;n<t.length;n++)i(e,t[n]);return t}}),r("hQxDo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2MADn");t.exports=function(t,e){for(var n=0;n<t.length;n++)i(e,t[n]);return t}}),r("2MADn",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e){void 0===e&&(e=new i);//  Basis vectors
var n=t.x2-t.x1,s=t.y2-t.y1,r=t.x3-t.x1,o=t.y3-t.y1,a=Math.random(),h=Math.random();return a+h>=1&&(a=1-a,h=1-h),e.x=t.x1+(n*a+r*h),e.y=t.y1+(s*a+o*h),e}}),r("k3Z7N",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("joPJC");t.exports=function(t,e,n,s,r){return i(t,"rotation",e,n,s,r)}}),r("1iEaG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("k8Nlz"),n=s("bwLQh");t.exports=function(t,e,s){for(var r=e.x,o=e.y,a=0;a<t.length;a++){var h=t[a];i(h,r,o,s,Math.max(1,n(h.x,h.y,r,o)))}return t}}),r("k8Nlz",function(t,e){t.exports=function(t,e,i,n,s){var r=n+Math.atan2(t.y-i,t.x-e);return t.x=e+s*Math.cos(r),t.y=i+s*Math.sin(r),t}}),r("bwLQh",function(t,e){t.exports=function(t,e,i,n){var s=t-i,r=e-n;return Math.sqrt(s*s+r*r)}}),r("jtzCa",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("k8Nlz");t.exports=function(t,e,n,s){var r=e.x,o=e.y;//  There's nothing to do
if(0===s)return t;for(var a=0;a<t.length;a++)i(t[a],r,o,n,s);return t}}),r("dElyt",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("joPJC");t.exports=function(t,e,n,s,r){return i(t,"scaleX",e,n,s,r)}}),r("fF8WC",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("joPJC");t.exports=function(t,e,n,s,r,o,a){return null==n&&(n=e),i(t,"scaleX",e,s,o,a),i(t,"scaleY",n,r,o,a)}}),r("c6II7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("joPJC");t.exports=function(t,e,n,s,r){return i(t,"scaleY",e,n,s,r)}}),r("kM3Np",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r){return i(t,"alpha",e,n,s,r)}}),r("gYMnB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s){return i(t,"blendMode",e,0,n,s)}}),r("7Nva9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r){return i(t,"depth",e,n,s,r)}}),r("128Rk",function(t,e){t.exports=function(t,e,i){for(var n=0;n<t.length;n++)t[n].setInteractive(e,i);return t}}),r("fvIPU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r,o,a){return null==n&&(n=e),i(t,"originX",e,s,o,a),i(t,"originY",n,r,o,a)}}),r("dvgoG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r){return i(t,"rotation",e,n,s,r)}}),r("43tcD",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r,o,a){return null==n&&(n=e),i(t,"scaleX",e,s,o,a),i(t,"scaleY",n,r,o,a)}}),r("dajVg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r){return i(t,"scaleX",e,n,s,r)}}),r("eqA15",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r){return i(t,"scaleY",e,n,s,r)}}),r("Horko",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r,o,a){return null==n&&(n=e),i(t,"scrollFactorX",e,s,o,a),i(t,"scrollFactorY",n,r,o,a)}}),r("8uqg5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r){return i(t,"scrollFactorX",e,n,s,r)}}),r("k9PTE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r){return i(t,"scrollFactorY",e,n,s,r)}}),r("eXuqB",function(t,e){t.exports=function(t,e,i,n,s){for(var r=0;r<t.length;r++)t[r].setTint(e,i,n,s);return t}}),r("j9xSq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s){return i(t,"visible",e,0,n,s)}}),r("2IEMX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r){return i(t,"x",e,n,s,r)}}),r("Wq1BO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r,o,a){return null==n&&(n=e),i(t,"x",e,s,o,a),i(t,"y",n,r,o,a)}}),r("7yy0q",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Alx8");t.exports=function(t,e,n,s,r){return i(t,"y",e,n,s,r)}}),r("7FJHd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7SBSk");t.exports=function(t,e,n,s,r){if(void 0===s&&(s=0),void 0===r&&(r=new i),t.length>1){if(0===s){//  Bottom to Top
var o,a,h,l,u,c,d=t.length-1;for(o=t[d].x,a=t[d].y,h=d-1;h>=0;h--)//  Get current item x/y, to be passed to the next item in the list
l=//  Current item
(c=t[h]).x,u=c.y,//  Set current item to the previous items x/y
c.x=o,c.y=a,//  Set current as previous
o=l,a=u;//  Update the head item to the new x/y coordinates
t[d].x=e,t[d].y=n}else{for(h=1,//  Top to Bottom
o=t[0].x,a=t[0].y;h<t.length;h++)//  Get current item x/y, to be passed to the next item in the list
l=//  Current item
(c=t[h]).x,u=c.y,//  Set current item to the previous items x/y
c.x=o,c.y=a,//  Set current as previous
o=l,a=u;//  Update the head item to the new x/y coordinates
t[0].x=e,t[0].y=n}}else o=t[0].x,a=t[0].y,t[0].x=e,t[0].y=n;return(//  Return the final set of coordinates as they're effectively lost from the shift and may be needed
r.x=o,r.y=a,r)}}),r("cTZaX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("Na5BX");t.exports=function(t){return i(t)}}),r("Na5BX",function(t,e){t.exports=function(t){for(var e=t.length-1;e>0;e--){var i=Math.floor(Math.random()*(e+1)),n=t[e];t[e]=t[i],t[i]=n}return t}}),r("33Qfe",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1YVfA");t.exports=function(t,e,n,s,r){void 0===r&&(r=!1);var o,a=Math.abs(s-n)/t.length;if(r)for(o=0;o<t.length;o++)t[o][e]+=i(o*a,n,s);else for(o=0;o<t.length;o++)t[o][e]=i(o*a,n,s);return t}}),r("1YVfA",function(t,e){t.exports=function(t,e,i){return(t=Math.max(0,Math.min(1,(t-e)/(i-e))))*t*t*(t*(6*t-15)+10)}}),r("4e9ty",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("363Nu");t.exports=function(t,e,n,s,r){void 0===r&&(r=!1);var o,a=Math.abs(s-n)/t.length;if(r)for(o=0;o<t.length;o++)t[o][e]+=i(o*a,n,s);else for(o=0;o<t.length;o++)t[o][e]=i(o*a,n,s);return t}}),r("363Nu",function(t,e){t.exports=function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*(3-2*t)}}),r("e3WPZ",function(t,e){t.exports=function(t,e,i,n,s){void 0===s&&(s=!1);var r,o=Math.abs(n-i)/t.length;if(s)for(r=0;r<t.length;r++)t[r][e]+=r*o+i;else for(r=0;r<t.length;r++)t[r][e]=r*o+i;return t}}),r("f7rup",function(t,e){t.exports=function(t){for(var e=0;e<t.length;e++)t[e].visible=!t[e].visible;return t}}),r("2Oe4l",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       samme <samme.npm@gmail.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("8qWuA");t.exports=function(t,e,n){void 0===n&&(n=0);for(var s=0;s<t.length;s++){var r=t[s];r.x=i(r.x,e.left-n,e.right+n),r.y=i(r.y,e.top-n,e.bottom+n)}return t}}),r("gc8vS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Animations
 */t.exports={Animation:s("6gscN"),AnimationFrame:s("cDvmt"),AnimationManager:s("dq46t"),Events:s("61xd9")}}),r("dq46t",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6gscN"),n=s("jwj1g"),r=s("ddl2W"),o=s("3vRz3"),a=s("61xd9"),h=s("aqcI1"),l=s("5pMDk"),u=s("7y2Q8"),c=new n({Extends:o,initialize:function(t){o.call(this),/**
         * A reference to the Phaser.Game instance.
         *
         * @name Phaser.Animations.AnimationManager#game
         * @type {Phaser.Game}
         * @protected
         * @since 3.0.0
         */this.game=t,/**
         * A reference to the Texture Manager.
         *
         * @name Phaser.Animations.AnimationManager#textureManager
         * @type {Phaser.Textures.TextureManager}
         * @protected
         * @since 3.0.0
         */this.textureManager=null,/**
         * The global time scale of the Animation Manager.
         *
         * This scales the time delta between two frames, thus influencing the speed of time for the Animation Manager.
         *
         * @name Phaser.Animations.AnimationManager#globalTimeScale
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.globalTimeScale=1,/**
         * The Animations registered in the Animation Manager.
         *
         * This map should be modified with the {@link #add} and {@link #create} methods of the Animation Manager.
         *
         * @name Phaser.Animations.AnimationManager#anims
         * @type {Phaser.Structs.Map.<string, Phaser.Animations.Animation>}
         * @protected
         * @since 3.0.0
         */this.anims=new r,/**
         * Whether the Animation Manager is paused along with all of its Animations.
         *
         * @name Phaser.Animations.AnimationManager#paused
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.paused=!1,/**
         * The name of this Animation Manager.
         *
         * @name Phaser.Animations.AnimationManager#name
         * @type {string}
         * @since 3.0.0
         */this.name="AnimationManager",t.events.once(h.BOOT,this.boot,this)},/**
     * Registers event listeners after the Game boots.
     *
     * @method Phaser.Animations.AnimationManager#boot
     * @listens Phaser.Core.Events#DESTROY
     * @since 3.0.0
     */boot:function(){this.textureManager=this.game.textures,this.game.events.once(h.DESTROY,this.destroy,this)},/**
     * Adds an existing Animation to the Animation Manager.
     *
     * @method Phaser.Animations.AnimationManager#add
     * @fires Phaser.Animations.Events#ADD_ANIMATION
     * @since 3.0.0
     *
     * @param {string} key - The key under which the Animation should be added. The Animation will be updated with it. Must be unique.
     * @param {Phaser.Animations.Animation} animation - The Animation which should be added to the Animation Manager.
     *
     * @return {this} This Animation Manager.
     */add:function(t,e){return this.anims.has(t)?console.warn("Animation key exists: "+t):(e.key=t,this.anims.set(t,e),this.emit(a.ADD_ANIMATION,t,e)),this},/**
     * Checks to see if the given key is already in use within the Animation Manager or not.
     * 
     * Animations are global. Keys created in one scene can be used from any other Scene in your game. They are not Scene specific.
     *
     * @method Phaser.Animations.AnimationManager#exists
     * @since 3.16.0
     *
     * @param {string} key - The key of the Animation to check.
     *
     * @return {boolean} `true` if the Animation already exists in the Animation Manager, or `false` if the key is available.
     */exists:function(t){return this.anims.has(t)},/**
     * Creates a new Animation and adds it to the Animation Manager.
     * 
     * Animations are global. Once created, you can use them in any Scene in your game. They are not Scene specific.
     * 
     * If an invalid key is given this method will return `false`.
     * 
     * If you pass the key of an animation that already exists in the Animation Manager, that animation will be returned.
     * 
     * A brand new animation is only created if the key is valid and not already in use.
     * 
     * If you wish to re-use an existing key, call `AnimationManager.remove` first, then this method.
     *
     * @method Phaser.Animations.AnimationManager#create
     * @fires Phaser.Animations.Events#ADD_ANIMATION
     * @since 3.0.0
     *
     * @param {Phaser.Types.Animations.Animation} config - The configuration settings for the Animation.
     *
     * @return {(Phaser.Animations.Animation|false)} The Animation that was created, or `false` is the key is already in use.
     */create:function(t){var e=t.key,n=!1;return!e||(n=this.get(e))||(n=new i(this,e,t),this.anims.set(e,n),this.emit(a.ADD_ANIMATION,e,n)),n},/**
     * Loads this Animation Manager's Animations and settings from a JSON object.
     *
     * @method Phaser.Animations.AnimationManager#fromJSON
     * @since 3.0.0
     *
     * @param {(string|Phaser.Types.Animations.JSONAnimations|Phaser.Types.Animations.JSONAnimation)} data - The JSON object to parse.
     * @param {boolean} [clearCurrentAnimations=false] - If set to `true`, the current animations will be removed (`anims.clear()`). If set to `false` (default), the animations in `data` will be added.
     *
     * @return {Phaser.Animations.Animation[]} An array containing all of the Animation objects that were created as a result of this call.
     */fromJSON:function(t,e){void 0===e&&(e=!1),e&&this.anims.clear(),"string"==typeof t&&(t=JSON.parse(t));var i=[];//  Array of animations, or a single animation?
if(t.hasOwnProperty("anims")&&Array.isArray(t.anims)){for(var n=0;n<t.anims.length;n++)i.push(this.create(t.anims[n]));t.hasOwnProperty("globalTimeScale")&&(this.globalTimeScale=t.globalTimeScale)}else t.hasOwnProperty("key")&&"frame"===t.type&&i.push(this.create(t));return i},/**
     * Generate an array of {@link Phaser.Types.Animations.AnimationFrame} objects from a texture key and configuration object.
     *
     * Generates objects with string based frame names, as configured by the given {@link Phaser.Types.Animations.GenerateFrameNames}.
     * 
     * It's a helper method, designed to make it easier for you to extract all of the frame names from texture atlases.
     * If you're working with a sprite sheet, see the `generateFrameNumbers` method instead.
     * 
     * Example:
     * 
     * If you have a texture atlases loaded called `gems` and it contains 6 frames called `ruby_0001`, `ruby_0002`, and so on,
     * then you can call this method using: `this.anims.generateFrameNames('gems', { prefix: 'ruby_', end: 6, zeroPad: 4 })`.
     * 
     * The `end` value tells it to look for 6 frames, incrementally numbered, all starting with the prefix `ruby_`. The `zeroPad`
     * value tells it how many zeroes pad out the numbers. To create an animation using this method, you can do:
     * 
     * ```javascript
     * this.anims.create({
     *   key: 'ruby',
     *   repeat: -1,
     *   frames: this.anims.generateFrameNames('gems', {
     *     prefix: 'ruby_',
     *     end: 6,
     *     zeroPad: 4
     *   })
     * });
     * ```
     * 
     * Please see the animation examples for further details.
     *
     * @method Phaser.Animations.AnimationManager#generateFrameNames
     * @since 3.0.0
     *
     * @param {string} key - The key for the texture containing the animation frames.
     * @param {Phaser.Types.Animations.GenerateFrameNames} [config] - The configuration object for the animation frame names.
     *
     * @return {Phaser.Types.Animations.AnimationFrame[]} The array of {@link Phaser.Types.Animations.AnimationFrame} objects.
     */generateFrameNames:function(t,e){var i,n,s=l(e,"prefix",""),r=l(e,"start",0),o=l(e,"end",0),a=l(e,"suffix",""),h=l(e,"zeroPad",0),c=l(e,"outputArray",[]),d=l(e,"frames",!1),f=this.textureManager.get(t);if(!f)return c;var p=r<o?1:-1;if(//  Adjust because we use i !== end in the for loop
o+=p,e){if(Array.isArray(d))for(i=0;i<d.length;i++)n=s+u(d[i],h,"0",1)+a,f.has(n)&&c.push({key:t,frame:n});else for(i=r;i!==o;i+=p)n=s+u(i,h,"0",1)+a,f.has(n)&&c.push({key:t,frame:n})}else for(i=0,//  Use every frame in the atlas?
d=f.getFrameNames();i<d.length;i++)c.push({key:t,frame:d[i]});return c},/**
     * Generate an array of {@link Phaser.Types.Animations.AnimationFrame} objects from a texture key and configuration object.
     *
     * Generates objects with numbered frame names, as configured by the given {@link Phaser.Types.Animations.GenerateFrameNumbers}.
     * 
     * If you're working with a texture atlas, see the `generateFrameNames` method instead.
     *
     * @method Phaser.Animations.AnimationManager#generateFrameNumbers
     * @since 3.0.0
     *
     * @param {string} key - The key for the texture containing the animation frames.
     * @param {Phaser.Types.Animations.GenerateFrameNumbers} config - The configuration object for the animation frames.
     *
     * @return {Phaser.Types.Animations.AnimationFrame[]} The array of {@link Phaser.Types.Animations.AnimationFrame} objects.
     */generateFrameNumbers:function(t,e){var i,n=l(e,"start",0),s=l(e,"end",-1),r=l(e,"first",!1),o=l(e,"outputArray",[]),a=l(e,"frames",!1),h=this.textureManager.get(t);if(!h)return o;//  Have they provided their own custom frame sequence array?
if(r&&h.has(r)&&o.push({key:t,frame:r}),Array.isArray(a))for(i=0;i<a.length;i++)h.has(a[i])&&o.push({key:t,frame:a[i]});else{-1===s&&(s=h.frameTotal);var u=n<s?1:-1;for(//  Adjust because we use i !== end in the for loop
s+=u,i=n;i!==s;i+=u)h.has(i)&&o.push({key:t,frame:i})}return o},/**
     * Get an Animation.
     *
     * @method Phaser.Animations.AnimationManager#get
     * @since 3.0.0
     *
     * @param {string} key - The key of the Animation to retrieve.
     *
     * @return {Phaser.Animations.Animation} The Animation.
     */get:function(t){return this.anims.get(t)},/**
     * Load an Animation into a Game Object's Animation Component.
     *
     * @method Phaser.Animations.AnimationManager#load
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object to load the animation into.
     * @param {string} key - The key of the animation to load.
     * @param {(string|integer)} [startFrame] - The name of a start frame to set on the loaded animation.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object with the animation loaded into it.
     */load:function(t,e,i){var n=this.get(e);return n?n.load(t,i):console.warn("Missing animation: "+e),t},/**
     * Pause all animations.
     *
     * @method Phaser.Animations.AnimationManager#pauseAll
     * @fires Phaser.Animations.Events#PAUSE_ALL
     * @since 3.0.0
     *
     * @return {this} This Animation Manager.
     */pauseAll:function(){return this.paused||(this.paused=!0,this.emit(a.PAUSE_ALL)),this},/**
     * Play an animation on the given Game Objects that have an Animation Component.
     *
     * @method Phaser.Animations.AnimationManager#play
     * @since 3.0.0
     *
     * @param {string} key - The key of the animation to play on the Game Object.
     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Objects to play the animation on.
     *
     * @return {this} This Animation Manager.
     */play:function(t,e){if(Array.isArray(e)||(e=[e]),!this.get(t))return this;for(var i=0;i<e.length;i++)e[i].anims.play(t);return this},/**
     * Removes an Animation from this Animation Manager, based on the given key.
     * 
     * This is a global action. Once an Animation has been removed, no Game Objects
     * can carry on using it.
     *
     * @method Phaser.Animations.AnimationManager#remove
     * @fires Phaser.Animations.Events#REMOVE_ANIMATION
     * @since 3.0.0
     *
     * @param {string} key - The key of the animation to remove.
     *
     * @return {Phaser.Animations.Animation} The Animation instance that was removed from the Animation Manager.
     */remove:function(t){var e=this.get(t);return e&&(this.emit(a.REMOVE_ANIMATION,t,e),this.anims.delete(t)),e},/**
     * Resume all paused animations.
     *
     * @method Phaser.Animations.AnimationManager#resumeAll
     * @fires Phaser.Animations.Events#RESUME_ALL
     * @since 3.0.0
     *
     * @return {this} This Animation Manager.
     */resumeAll:function(){return this.paused&&(this.paused=!1,this.emit(a.RESUME_ALL)),this},/**
     * Takes an array of Game Objects that have an Animation Component and then
     * starts the given animation playing on them, each one offset by the
     * `stagger` amount given to this method.
     *
     * @method Phaser.Animations.AnimationManager#staggerPlay
     * @since 3.0.0
     *
     * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]
     *
     * @param {string} key - The key of the animation to play on the Game Objects.
     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} children - An array of Game Objects to play the animation on. They must have an Animation Component.
     * @param {number} [stagger=0] - The amount of time, in milliseconds, to offset each play time by.
     *
     * @return {this} This Animation Manager.
     */staggerPlay:function(t,e,i){if(void 0===i&&(i=0),Array.isArray(e)||(e=[e]),!this.get(t))return this;for(var n=0;n<e.length;n++)e[n].anims.delayedPlay(i*n,t);return this},/**
     * Returns the Animation data as JavaScript object based on the given key.
     * Or, if not key is defined, it will return the data of all animations as array of objects.
     *
     * @method Phaser.Animations.AnimationManager#toJSON
     * @since 3.0.0
     *
     * @param {string} [key] - The animation to get the JSONAnimation data from. If not provided, all animations are returned as an array.
     *
     * @return {Phaser.Types.Animations.JSONAnimations} The resulting JSONAnimations formatted object.
     */toJSON:function(t){var e={anims:[],globalTimeScale:this.globalTimeScale};return void 0!==t&&""!==t?e.anims.push(this.anims.get(t).toJSON()):this.anims.each(function(t,i){e.anims.push(i.toJSON())}),e},/**
     * Destroy this Animation Manager and clean up animation definitions and references to other objects.
     * This method should not be called directly. It will be called automatically as a response to a `destroy` event from the Phaser.Game instance.
     *
     * @method Phaser.Animations.AnimationManager#destroy
     * @since 3.0.0
     */destroy:function(){this.anims.clear(),this.textureManager=null,this.game=null}});t.exports=c}),r("ddl2W",function(t,e){/**
 * @callback EachMapCallback<E>
 *
 * @param {string} key - The key of the Map entry.
 * @param {E} entry - The value of the Map entry.
 *
 * @return {?boolean} The callback result.
 *//**
 * @classdesc
 * The keys of a Map can be arbitrary values.
 * 
 * ```javascript
 * var map = new Map([
 *    [ 1, 'one' ],
 *    [ 2, 'two' ],
 *    [ 3, 'three' ]
 * ]);
 * ```
 *
 * @class Map
 * @memberof Phaser.Structs
 * @constructor
 * @since 3.0.0
 *
 * @generic K
 * @generic V
 * @genericUse {V[]} - [elements]
 *
 * @param {Array.<*>} elements - An optional array of key-value pairs to populate this Map with.
 */var i=new(s("jwj1g"))({initialize:function(t){if(/**
         * The entries in this Map.
         *
         * @genericUse {Object.<string, V>} - [$type]
         *
         * @name Phaser.Structs.Map#entries
         * @type {Object.<string, *>}
         * @default {}
         * @since 3.0.0
         */this.entries={},/**
         * The number of key / value pairs in this Map.
         *
         * @name Phaser.Structs.Map#size
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.size=0,Array.isArray(t))for(var e=0;e<t.length;e++)this.set(t[e][0],t[e][1])},/**
     * Adds an element with a specified `key` and `value` to this Map.
     * If the `key` already exists, the value will be replaced.
     *
     * @method Phaser.Structs.Map#set
     * @since 3.0.0
     *
     * @genericUse {K} - [key]
     * @genericUse {V} - [value]
     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]
     *
     * @param {string} key - The key of the element to be added to this Map.
     * @param {*} value - The value of the element to be added to this Map.
     *
     * @return {Phaser.Structs.Map} This Map object.
     */set:function(t,e){return!this.has(t)&&this.size++,this.entries[t]=e,this},/**
     * Returns the value associated to the `key`, or `undefined` if there is none.
     *
     * @method Phaser.Structs.Map#get
     * @since 3.0.0
     *
     * @genericUse {K} - [key]
     * @genericUse {V} - [$return]
     *
     * @param {string} key - The key of the element to return from the `Map` object.
     *
     * @return {*} The element associated with the specified key or `undefined` if the key can't be found in this Map object.
     */get:function(t){if(this.has(t))return this.entries[t]},/**
     * Returns an `Array` of all the values stored in this Map.
     *
     * @method Phaser.Structs.Map#getArray
     * @since 3.0.0
     *
     * @genericUse {V[]} - [$return]
     *
     * @return {Array.<*>} An array of the values stored in this Map.
     */getArray:function(){var t=[],e=this.entries;for(var i in e)t.push(e[i]);return t},/**
     * Returns a boolean indicating whether an element with the specified key exists or not.
     *
     * @method Phaser.Structs.Map#has
     * @since 3.0.0
     *
     * @genericUse {K} - [key]
     *
     * @param {string} key - The key of the element to test for presence of in this Map.
     *
     * @return {boolean} Returns `true` if an element with the specified key exists in this Map, otherwise `false`.
     */has:function(t){return this.entries.hasOwnProperty(t)},/**
     * Delete the specified element from this Map.
     *
     * @method Phaser.Structs.Map#delete
     * @since 3.0.0
     *
     * @genericUse {K} - [key]
     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]
     *
     * @param {string} key - The key of the element to delete from this Map.
     *
     * @return {Phaser.Structs.Map} This Map object.
     */delete:function(t){return this.has(t)&&(delete this.entries[t],this.size--),this},/**
     * Delete all entries from this Map.
     *
     * @method Phaser.Structs.Map#clear
     * @since 3.0.0
     *
     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]
     *
     * @return {Phaser.Structs.Map} This Map object.
     */clear:function(){return Object.keys(this.entries).forEach(function(t){delete this.entries[t]},this),this.size=0,this},/**
     * Returns all entries keys in this Map.
     *
     * @method Phaser.Structs.Map#keys
     * @since 3.0.0
     *
     * @genericUse {K[]} - [$return]
     *
     * @return {string[]} Array containing entries' keys.
     */keys:function(){return Object.keys(this.entries)},/**
     * Returns an `Array` of all entries.
     *
     * @method Phaser.Structs.Map#values
     * @since 3.0.0
     *
     * @genericUse {V[]} - [$return]
     *
     * @return {Array.<*>} An `Array` of entries.
     */values:function(){var t=[],e=this.entries;for(var i in e)t.push(e[i]);return t},/**
     * Dumps the contents of this Map to the console via `console.group`.
     *
     * @method Phaser.Structs.Map#dump
     * @since 3.0.0
     */dump:function(){var t=this.entries;for(var e in // eslint-disable-next-line no-console
console.group("Map"),t)console.log(e,t[e]);// eslint-disable-next-line no-console
console.groupEnd()},/**
     * Passes all entries in this Map to the given callback.
     *
     * @method Phaser.Structs.Map#each
     * @since 3.0.0
     *
     * @genericUse {EachMapCallback.<V>} - [callback]
     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]
     *
     * @param {EachMapCallback} callback - The callback which will receive the keys and entries held in this Map.
     *
     * @return {Phaser.Structs.Map} This Map object.
     */each:function(t){var e=this.entries;for(var i in e)if(!1===t(i,e[i]))break;return this},/**
     * Returns `true` if the value exists within this Map. Otherwise, returns `false`.
     *
     * @method Phaser.Structs.Map#contains
     * @since 3.0.0
     *
     * @genericUse {V} - [value]
     *
     * @param {*} value - The value to search for.
     *
     * @return {boolean} `true` if the value is found, otherwise `false`.
     */contains:function(t){var e=this.entries;for(var i in e)if(e[i]===t)return!0;return!1},/**
     * Merges all new keys from the given Map into this one.
     * If it encounters a key that already exists it will be skipped unless override is set to `true`.
     *
     * @method Phaser.Structs.Map#merge
     * @since 3.0.0
     *
     * @genericUse {Phaser.Structs.Map.<K, V>} - [map,$return]
     *
     * @param {Phaser.Structs.Map} map - The Map to merge in to this Map.
     * @param {boolean} [override=false] - Set to `true` to replace values in this Map with those from the source map, or `false` to skip them.
     *
     * @return {Phaser.Structs.Map} This Map object.
     */merge:function(t,e){void 0===e&&(e=!1);var i=this.entries,n=t.entries;for(var s in n)i.hasOwnProperty(s)&&e?i[s]=n[s]:this.set(s,n[s]);return this}});t.exports=i}),r("7y2Q8",function(t,e){t.exports=function(t,e,i,n){void 0===e&&(e=0),void 0===i&&(i=" "),void 0===n&&(n=3);var s=0;if(e+1>=(t=t.toString()).length)switch(n){case 1:t=Array(e+1-t.length).join(i)+t;break;case 3:var r=Math.ceil((s=e-t.length)/2);t=Array(s-r+1).join(i)+t+Array(r+1).join(i);break;default:t+=Array(e+1-t.length).join(i)}return t}}),r("dRHWx",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Cache
 */t.exports={BaseCache:s("8eDED"),CacheManager:s("083aW"),Events:s("3SnAO")}}),r("8eDED",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("ddl2W"),r=s("3vRz3"),o=s("3SnAO"),a=new i({initialize:function(){/**
         * The Map in which the cache objects are stored.
         *
         * You can query the Map directly or use the BaseCache methods.
         *
         * @name Phaser.Cache.BaseCache#entries
         * @type {Phaser.Structs.Map.<String, *>}
         * @since 3.0.0
         */this.entries=new n,/**
         * An instance of EventEmitter used by the cache to emit related events.
         *
         * @name Phaser.Cache.BaseCache#events
         * @type {Phaser.Events.EventEmitter}
         * @since 3.0.0
         */this.events=new r},/**
     * Adds an item to this cache. The item is referenced by a unique string, which you are responsible
     * for setting and keeping track of. The item can only be retrieved by using this string.
     *
     * @method Phaser.Cache.BaseCache#add
     * @fires Phaser.Cache.Events#ADD
     * @since 3.0.0
     *
     * @param {string} key - The unique key by which the data added to the cache will be referenced.
     * @param {*} data - The data to be stored in the cache.
     *
     * @return {this} This BaseCache object.
     */add:function(t,e){return this.entries.set(t,e),this.events.emit(o.ADD,this,t,e),this},/**
     * Checks if this cache contains an item matching the given key.
     * This performs the same action as `BaseCache.exists`.
     *
     * @method Phaser.Cache.BaseCache#has
     * @since 3.0.0
     *
     * @param {string} key - The unique key of the item to be checked in this cache.
     *
     * @return {boolean} Returns `true` if the cache contains an item matching the given key, otherwise `false`.
     */has:function(t){return this.entries.has(t)},/**
     * Checks if this cache contains an item matching the given key.
     * This performs the same action as `BaseCache.has` and is called directly by the Loader.
     *
     * @method Phaser.Cache.BaseCache#exists
     * @since 3.7.0
     *
     * @param {string} key - The unique key of the item to be checked in this cache.
     *
     * @return {boolean} Returns `true` if the cache contains an item matching the given key, otherwise `false`.
     */exists:function(t){return this.entries.has(t)},/**
     * Gets an item from this cache based on the given key.
     *
     * @method Phaser.Cache.BaseCache#get
     * @since 3.0.0
     *
     * @param {string} key - The unique key of the item to be retrieved from this cache.
     *
     * @return {*} The item in the cache, or `null` if no item matching the given key was found.
     */get:function(t){return this.entries.get(t)},/**
     * Removes and item from this cache based on the given key.
     *
     * If an entry matching the key is found it is removed from the cache and a `remove` event emitted.
     * No additional checks are done on the item removed. If other systems or parts of your game code
     * are relying on this item, it is up to you to sever those relationships prior to removing the item.
     *
     * @method Phaser.Cache.BaseCache#remove
     * @fires Phaser.Cache.Events#REMOVE
     * @since 3.0.0
     *
     * @param {string} key - The unique key of the item to remove from the cache.
     *
     * @return {this} This BaseCache object.
     */remove:function(t){var e=this.get(t);return e&&(this.entries.delete(t),this.events.emit(o.REMOVE,this,t,e.data)),this},/**
     * Returns all keys in use in this cache.
     *
     * @method Phaser.Cache.BaseCache#getKeys
     * @since 3.17.0
     *
     * @return {string[]} Array containing all the keys.
     */getKeys:function(){return this.entries.keys()},/**
     * Destroys this cache and all items within it.
     *
     * @method Phaser.Cache.BaseCache#destroy
     * @since 3.0.0
     */destroy:function(){this.entries.clear(),this.events.removeAllListeners(),this.entries=null,this.events=null}});t.exports=a}),r("3SnAO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Cache.Events
 */t.exports={ADD:s("4S5QK"),REMOVE:s("2FrIq")}}),r("4S5QK",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Cache Add Event.
 * 
 * This event is dispatched by any Cache that extends the BaseCache each time a new object is added to it.
 *
 * @event Phaser.Cache.Events#ADD
 * @since 3.0.0
 * 
 * @param {Phaser.Cache.BaseCache} cache - The cache to which the object was added.
 * @param {string} key - The key of the object added to the cache.
 * @param {*} object - A reference to the object that was added to the cache.
 */t.exports="add"}),r("2FrIq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Cache Remove Event.
 * 
 * This event is dispatched by any Cache that extends the BaseCache each time an object is removed from it.
 *
 * @event Phaser.Cache.Events#REMOVE
 * @since 3.0.0
 * 
 * @param {Phaser.Cache.BaseCache} cache - The cache from which the object was removed.
 * @param {string} key - The key of the object removed from the cache.
 * @param {*} object - A reference to the object that was removed from the cache.
 */t.exports="remove"}),r("083aW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("8eDED"),n=s("jwj1g"),r=s("aqcI1"),o=new n({initialize:function(t){/**
         * A reference to the Phaser.Game instance that owns this CacheManager.
         *
         * @name Phaser.Cache.CacheManager#game
         * @type {Phaser.Game}
         * @protected
         * @since 3.0.0
         */this.game=t,/**
         * A Cache storing all binary files, typically added via the Loader.
         *
         * @name Phaser.Cache.CacheManager#binary
         * @type {Phaser.Cache.BaseCache}
         * @since 3.0.0
         */this.binary=new i,/**
         * A Cache storing all bitmap font data files, typically added via the Loader.
         * Only the font data is stored in this cache, the textures are part of the Texture Manager.
         *
         * @name Phaser.Cache.CacheManager#bitmapFont
         * @type {Phaser.Cache.BaseCache}
         * @since 3.0.0
         */this.bitmapFont=new i,/**
         * A Cache storing all JSON data files, typically added via the Loader.
         *
         * @name Phaser.Cache.CacheManager#json
         * @type {Phaser.Cache.BaseCache}
         * @since 3.0.0
         */this.json=new i,/**
         * A Cache storing all physics data files, typically added via the Loader.
         *
         * @name Phaser.Cache.CacheManager#physics
         * @type {Phaser.Cache.BaseCache}
         * @since 3.0.0
         */this.physics=new i,/**
         * A Cache storing all shader source files, typically added via the Loader.
         *
         * @name Phaser.Cache.CacheManager#shader
         * @type {Phaser.Cache.BaseCache}
         * @since 3.0.0
         */this.shader=new i,/**
         * A Cache storing all non-streaming audio files, typically added via the Loader.
         *
         * @name Phaser.Cache.CacheManager#audio
         * @type {Phaser.Cache.BaseCache}
         * @since 3.0.0
         */this.audio=new i,/**
         * A Cache storing all non-streaming video files, typically added via the Loader.
         *
         * @name Phaser.Cache.CacheManager#video
         * @type {Phaser.Cache.BaseCache}
         * @since 3.20.0
         */this.video=new i,/**
         * A Cache storing all text files, typically added via the Loader.
         *
         * @name Phaser.Cache.CacheManager#text
         * @type {Phaser.Cache.BaseCache}
         * @since 3.0.0
         */this.text=new i,/**
         * A Cache storing all html files, typically added via the Loader.
         *
         * @name Phaser.Cache.CacheManager#html
         * @type {Phaser.Cache.BaseCache}
         * @since 3.12.0
         */this.html=new i,/**
         * A Cache storing all WaveFront OBJ files, typically added via the Loader.
         *
         * @name Phaser.Cache.CacheManager#obj
         * @type {Phaser.Cache.BaseCache}
         * @since 3.0.0
         */this.obj=new i,/**
         * A Cache storing all tilemap data files, typically added via the Loader.
         * Only the data is stored in this cache, the textures are part of the Texture Manager.
         *
         * @name Phaser.Cache.CacheManager#tilemap
         * @type {Phaser.Cache.BaseCache}
         * @since 3.0.0
         */this.tilemap=new i,/**
         * A Cache storing all xml data files, typically added via the Loader.
         *
         * @name Phaser.Cache.CacheManager#xml
         * @type {Phaser.Cache.BaseCache}
         * @since 3.0.0
         */this.xml=new i,/**
         * An object that contains your own custom BaseCache entries.
         * Add to this via the `addCustom` method.
         *
         * @name Phaser.Cache.CacheManager#custom
         * @type {Object.<Phaser.Cache.BaseCache>}
         * @since 3.0.0
         */this.custom={},this.game.events.once(r.DESTROY,this.destroy,this)},/**
     * Add your own custom Cache for storing your own files.
     * The cache will be available under `Cache.custom.key`.
     * The cache will only be created if the key is not already in use.
     *
     * @method Phaser.Cache.CacheManager#addCustom
     * @since 3.0.0
     *
     * @param {string} key - The unique key of your custom cache.
     *
     * @return {Phaser.Cache.BaseCache} A reference to the BaseCache that was created. If the key was already in use, a reference to the existing cache is returned instead.
     */addCustom:function(t){return this.custom.hasOwnProperty(t)||(this.custom[t]=new i),this.custom[t]},/**
     * Removes all entries from all BaseCaches and destroys all custom caches.
     *
     * @method Phaser.Cache.CacheManager#destroy
     * @since 3.0.0
     */destroy:function(){for(var t=["binary","bitmapFont","json","physics","shader","audio","video","text","html","obj","tilemap","xml"],e=0;e<t.length;e++)this[t[e]].destroy(),this[t[e]]=null;for(var i in this.custom)this.custom[i].destroy();this.custom=null,this.game=null}});t.exports=o}),r("cjvhk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Cameras
 *//**
 * @namespace Phaser.Types.Cameras
 */t.exports={Controls:s("2Vvpd"),Scene2D:s("2yWR5")}}),r("2Vvpd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Cameras.Controls
 */t.exports={FixedKeyControl:s("l9veA"),SmoothedKeyControl:s("78F6p")}}),r("l9veA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("5pMDk"),r=new i({initialize:function(t){/**
         * The Camera that this Control will update.
         *
         * @name Phaser.Cameras.Controls.FixedKeyControl#camera
         * @type {?Phaser.Cameras.Scene2D.Camera}
         * @default null
         * @since 3.0.0
         */this.camera=n(t,"camera",null),/**
         * The Key to be pressed that will move the Camera left.
         *
         * @name Phaser.Cameras.Controls.FixedKeyControl#left
         * @type {?Phaser.Input.Keyboard.Key}
         * @default null
         * @since 3.0.0
         */this.left=n(t,"left",null),/**
         * The Key to be pressed that will move the Camera right.
         *
         * @name Phaser.Cameras.Controls.FixedKeyControl#right
         * @type {?Phaser.Input.Keyboard.Key}
         * @default null
         * @since 3.0.0
         */this.right=n(t,"right",null),/**
         * The Key to be pressed that will move the Camera up.
         *
         * @name Phaser.Cameras.Controls.FixedKeyControl#up
         * @type {?Phaser.Input.Keyboard.Key}
         * @default null
         * @since 3.0.0
         */this.up=n(t,"up",null),/**
         * The Key to be pressed that will move the Camera down.
         *
         * @name Phaser.Cameras.Controls.FixedKeyControl#down
         * @type {?Phaser.Input.Keyboard.Key}
         * @default null
         * @since 3.0.0
         */this.down=n(t,"down",null),/**
         * The Key to be pressed that will zoom the Camera in.
         *
         * @name Phaser.Cameras.Controls.FixedKeyControl#zoomIn
         * @type {?Phaser.Input.Keyboard.Key}
         * @default null
         * @since 3.0.0
         */this.zoomIn=n(t,"zoomIn",null),/**
         * The Key to be pressed that will zoom the Camera out.
         *
         * @name Phaser.Cameras.Controls.FixedKeyControl#zoomOut
         * @type {?Phaser.Input.Keyboard.Key}
         * @default null
         * @since 3.0.0
         */this.zoomOut=n(t,"zoomOut",null),/**
         * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.
         *
         * @name Phaser.Cameras.Controls.FixedKeyControl#zoomSpeed
         * @type {number}
         * @default 0.01
         * @since 3.0.0
         */this.zoomSpeed=n(t,"zoomSpeed",.01),/**
         * The horizontal speed the camera will move.
         *
         * @name Phaser.Cameras.Controls.FixedKeyControl#speedX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.speedX=0,/**
         * The vertical speed the camera will move.
         *
         * @name Phaser.Cameras.Controls.FixedKeyControl#speedY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.speedY=0;var e=n(t,"speed",null);"number"==typeof e?(this.speedX=e,this.speedY=e):(this.speedX=n(t,"speed.x",0),this.speedY=n(t,"speed.y",0)),/**
         * Internal property to track the current zoom level.
         *
         * @name Phaser.Cameras.Controls.FixedKeyControl#_zoom
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._zoom=0,/**
         * A flag controlling if the Controls will update the Camera or not.
         *
         * @name Phaser.Cameras.Controls.FixedKeyControl#active
         * @type {boolean}
         * @since 3.0.0
         */this.active=null!==this.camera},/**
     * Starts the Key Control running, providing it has been linked to a camera.
     *
     * @method Phaser.Cameras.Controls.FixedKeyControl#start
     * @since 3.0.0
     *
     * @return {this} This Key Control instance.
     */start:function(){return this.active=null!==this.camera,this},/**
     * Stops this Key Control from running. Call `start` to start it again.
     *
     * @method Phaser.Cameras.Controls.FixedKeyControl#stop
     * @since 3.0.0
     *
     * @return {this} This Key Control instance.
     */stop:function(){return this.active=!1,this},/**
     * Binds this Key Control to a camera.
     *
     * @method Phaser.Cameras.Controls.FixedKeyControl#setCamera
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera to bind this Key Control to.
     *
     * @return {this} This Key Control instance.
     */setCamera:function(t){return this.camera=t,this},/**
     * Applies the results of pressing the control keys to the Camera.
     *
     * You must call this every step, it is not called automatically.
     *
     * @method Phaser.Cameras.Controls.FixedKeyControl#update
     * @since 3.0.0
     *
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     */update:function(t){if(this.active){void 0===t&&(t=1);var e=this.camera;this.up&&this.up.isDown?e.scrollY-=this.speedY*t|0:this.down&&this.down.isDown&&(e.scrollY+=this.speedY*t|0),this.left&&this.left.isDown?e.scrollX-=this.speedX*t|0:this.right&&this.right.isDown&&(e.scrollX+=this.speedX*t|0),this.zoomIn&&this.zoomIn.isDown?(e.zoom-=this.zoomSpeed,e.zoom<.1&&(e.zoom=.1)):this.zoomOut&&this.zoomOut.isDown&&(e.zoom+=this.zoomSpeed)}},/**
     * Destroys this Key Control.
     *
     * @method Phaser.Cameras.Controls.FixedKeyControl#destroy
     * @since 3.0.0
     */destroy:function(){this.camera=null,this.left=null,this.right=null,this.up=null,this.down=null,this.zoomIn=null,this.zoomOut=null}});t.exports=r}),r("78F6p",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("5pMDk"),r=new i({initialize:function(t){/**
         * The Camera that this Control will update.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#camera
         * @type {?Phaser.Cameras.Scene2D.Camera}
         * @default null
         * @since 3.0.0
         */this.camera=n(t,"camera",null),/**
         * The Key to be pressed that will move the Camera left.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#left
         * @type {?Phaser.Input.Keyboard.Key}
         * @default null
         * @since 3.0.0
         */this.left=n(t,"left",null),/**
         * The Key to be pressed that will move the Camera right.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#right
         * @type {?Phaser.Input.Keyboard.Key}
         * @default null
         * @since 3.0.0
         */this.right=n(t,"right",null),/**
         * The Key to be pressed that will move the Camera up.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#up
         * @type {?Phaser.Input.Keyboard.Key}
         * @default null
         * @since 3.0.0
         */this.up=n(t,"up",null),/**
         * The Key to be pressed that will move the Camera down.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#down
         * @type {?Phaser.Input.Keyboard.Key}
         * @default null
         * @since 3.0.0
         */this.down=n(t,"down",null),/**
         * The Key to be pressed that will zoom the Camera in.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#zoomIn
         * @type {?Phaser.Input.Keyboard.Key}
         * @default null
         * @since 3.0.0
         */this.zoomIn=n(t,"zoomIn",null),/**
         * The Key to be pressed that will zoom the Camera out.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#zoomOut
         * @type {?Phaser.Input.Keyboard.Key}
         * @default null
         * @since 3.0.0
         */this.zoomOut=n(t,"zoomOut",null),/**
         * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#zoomSpeed
         * @type {number}
         * @default 0.01
         * @since 3.0.0
         */this.zoomSpeed=n(t,"zoomSpeed",.01),/**
         * The horizontal acceleration the camera will move.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#accelX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.accelX=0,/**
         * The vertical acceleration the camera will move.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#accelY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.accelY=0;var e=n(t,"acceleration",null);"number"==typeof e?(this.accelX=e,this.accelY=e):(this.accelX=n(t,"acceleration.x",0),this.accelY=n(t,"acceleration.y",0)),/**
         * The horizontal drag applied to the camera when it is moving.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#dragX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.dragX=0,/**
         * The vertical drag applied to the camera when it is moving.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#dragY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.dragY=0;var i=n(t,"drag",null);"number"==typeof i?(this.dragX=i,this.dragY=i):(this.dragX=n(t,"drag.x",0),this.dragY=n(t,"drag.y",0)),/**
         * The maximum horizontal speed the camera will move.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#maxSpeedX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.maxSpeedX=0,/**
         * The maximum vertical speed the camera will move.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#maxSpeedY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.maxSpeedY=0;var s=n(t,"maxSpeed",null);"number"==typeof s?(this.maxSpeedX=s,this.maxSpeedY=s):(this.maxSpeedX=n(t,"maxSpeed.x",0),this.maxSpeedY=n(t,"maxSpeed.y",0)),/**
         * Internal property to track the speed of the control.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#_speedX
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._speedX=0,/**
         * Internal property to track the speed of the control.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#_speedY
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._speedY=0,/**
         * Internal property to track the zoom of the control.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#_zoom
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._zoom=0,/**
         * A flag controlling if the Controls will update the Camera or not.
         *
         * @name Phaser.Cameras.Controls.SmoothedKeyControl#active
         * @type {boolean}
         * @since 3.0.0
         */this.active=null!==this.camera},/**
     * Starts the Key Control running, providing it has been linked to a camera.
     *
     * @method Phaser.Cameras.Controls.SmoothedKeyControl#start
     * @since 3.0.0
     *
     * @return {this} This Key Control instance.
     */start:function(){return this.active=null!==this.camera,this},/**
     * Stops this Key Control from running. Call `start` to start it again.
     *
     * @method Phaser.Cameras.Controls.SmoothedKeyControl#stop
     * @since 3.0.0
     *
     * @return {this} This Key Control instance.
     */stop:function(){return this.active=!1,this},/**
     * Binds this Key Control to a camera.
     *
     * @method Phaser.Cameras.Controls.SmoothedKeyControl#setCamera
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera to bind this Key Control to.
     *
     * @return {this} This Key Control instance.
     */setCamera:function(t){return this.camera=t,this},/**
     * Applies the results of pressing the control keys to the Camera.
     *
     * You must call this every step, it is not called automatically.
     *
     * @method Phaser.Cameras.Controls.SmoothedKeyControl#update
     * @since 3.0.0
     *
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     */update:function(t){if(this.active){void 0===t&&(t=1);var e=this.camera;this._speedX>0?(this._speedX-=this.dragX*t,this._speedX<0&&(this._speedX=0)):this._speedX<0&&(this._speedX+=this.dragX*t,this._speedX>0&&(this._speedX=0)),this._speedY>0?(this._speedY-=this.dragY*t,this._speedY<0&&(this._speedY=0)):this._speedY<0&&(this._speedY+=this.dragY*t,this._speedY>0&&(this._speedY=0)),this.up&&this.up.isDown?(this._speedY+=this.accelY,this._speedY>this.maxSpeedY&&(this._speedY=this.maxSpeedY)):this.down&&this.down.isDown&&(this._speedY-=this.accelY,this._speedY<-this.maxSpeedY&&(this._speedY=-this.maxSpeedY)),this.left&&this.left.isDown?(this._speedX+=this.accelX,this._speedX>this.maxSpeedX&&(this._speedX=this.maxSpeedX)):this.right&&this.right.isDown&&(this._speedX-=this.accelX,this._speedX<-this.maxSpeedX&&(this._speedX=-this.maxSpeedX)),this.zoomIn&&this.zoomIn.isDown?this._zoom=-this.zoomSpeed:this.zoomOut&&this.zoomOut.isDown?this._zoom=this.zoomSpeed:this._zoom=0,0!==this._speedX&&(e.scrollX-=this._speedX*t|0),0!==this._speedY&&(e.scrollY-=this._speedY*t|0),0!==this._zoom&&(e.zoom+=this._zoom,e.zoom<.001&&(e.zoom=.001))}},/**
     * Destroys this Key Control.
     *
     * @method Phaser.Cameras.Controls.SmoothedKeyControl#destroy
     * @since 3.0.0
     */destroy:function(){this.camera=null,this.left=null,this.right=null,this.up=null,this.down=null,this.zoomIn=null,this.zoomOut=null}});t.exports=r}),r("2yWR5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Cameras.Scene2D
 */t.exports={Camera:s("eAXHP"),BaseCamera:s("2LSzx"),CameraManager:s("bJjUa"),Effects:s("u1TTd"),Events:s("3xxp2")}}),r("eAXHP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2LSzx"),n=s("kKoer"),r=s("ilLbF"),o=s("iEUUO"),a=s("jwj1g"),h=s("4FF1v"),l=s("u1TTd"),u=s("fDkZ4"),c=s("cwr8X"),d=s("7SBSk"),f=new a({Extends:i,Mixins:[h.Flip,h.Tint],initialize:function(t,e,n,s){i.call(this,t,e,n,s),/**
         * Does this Camera allow the Game Objects it renders to receive input events?
         *
         * @name Phaser.Cameras.Scene2D.Camera#inputEnabled
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.inputEnabled=!0,/**
         * The Camera Fade effect handler.
         * To fade this camera see the `Camera.fade` methods.
         *
         * @name Phaser.Cameras.Scene2D.Camera#fadeEffect
         * @type {Phaser.Cameras.Scene2D.Effects.Fade}
         * @since 3.5.0
         */this.fadeEffect=new l.Fade(this),/**
         * The Camera Flash effect handler.
         * To flash this camera see the `Camera.flash` method.
         *
         * @name Phaser.Cameras.Scene2D.Camera#flashEffect
         * @type {Phaser.Cameras.Scene2D.Effects.Flash}
         * @since 3.5.0
         */this.flashEffect=new l.Flash(this),/**
         * The Camera Shake effect handler.
         * To shake this camera see the `Camera.shake` method.
         *
         * @name Phaser.Cameras.Scene2D.Camera#shakeEffect
         * @type {Phaser.Cameras.Scene2D.Effects.Shake}
         * @since 3.5.0
         */this.shakeEffect=new l.Shake(this),/**
         * The Camera Pan effect handler.
         * To pan this camera see the `Camera.pan` method.
         *
         * @name Phaser.Cameras.Scene2D.Camera#panEffect
         * @type {Phaser.Cameras.Scene2D.Effects.Pan}
         * @since 3.11.0
         */this.panEffect=new l.Pan(this),/**
         * The Camera Rotate To effect handler.
         * To rotate this camera see the `Camera.rotateTo` method.
         *
         * @name Phaser.Cameras.Scene2D.Camera#rotateToEffect
         * @type {Phaser.Cameras.Scene2D.Effects.RotateTo}
         * @since 3.23.0
         */this.rotateToEffect=new l.RotateTo(this),/**
         * The Camera Zoom effect handler.
         * To zoom this camera see the `Camera.zoom` method.
         *
         * @name Phaser.Cameras.Scene2D.Camera#zoomEffect
         * @type {Phaser.Cameras.Scene2D.Effects.Zoom}
         * @since 3.11.0
         */this.zoomEffect=new l.Zoom(this),/**
         * The linear interpolation value to use when following a target.
         *
         * Can also be set via `setLerp` or as part of the `startFollow` call.
         *
         * The default values of 1 means the camera will instantly snap to the target coordinates.
         * A lower value, such as 0.1 means the camera will more slowly track the target, giving
         * a smooth transition. You can set the horizontal and vertical values independently, and also
         * adjust this value in real-time during your game.
         *
         * Be sure to keep the value between 0 and 1. A value of zero will disable tracking on that axis.
         *
         * @name Phaser.Cameras.Scene2D.Camera#lerp
         * @type {Phaser.Math.Vector2}
         * @since 3.9.0
         */this.lerp=new d(1,1),/**
         * The values stored in this property are subtracted from the Camera targets position, allowing you to
         * offset the camera from the actual target x/y coordinates by this amount.
         * Can also be set via `setFollowOffset` or as part of the `startFollow` call.
         *
         * @name Phaser.Cameras.Scene2D.Camera#followOffset
         * @type {Phaser.Math.Vector2}
         * @since 3.9.0
         */this.followOffset=new d,/**
         * The Camera dead zone.
         *
         * The deadzone is only used when the camera is following a target.
         *
         * It defines a rectangular region within which if the target is present, the camera will not scroll.
         * If the target moves outside of this area, the camera will begin scrolling in order to follow it.
         *
         * The `lerp` values that you can set for a follower target also apply when using a deadzone.
         *
         * You can directly set this property to be an instance of a Rectangle. Or, you can use the
         * `setDeadzone` method for a chainable approach.
         *
         * The rectangle you provide can have its dimensions adjusted dynamically, however, please
         * note that its position is updated every frame, as it is constantly re-centered on the cameras mid point.
         *
         * Calling `setDeadzone` with no arguments will reset an active deadzone, as will setting this property
         * to `null`.
         *
         * @name Phaser.Cameras.Scene2D.Camera#deadzone
         * @type {?Phaser.Geom.Rectangle}
         * @since 3.11.0
         */this.deadzone=null,/**
         * Internal follow target reference.
         *
         * @name Phaser.Cameras.Scene2D.Camera#_follow
         * @type {?any}
         * @private
         * @default null
         * @since 3.0.0
         */this._follow=null,/**
         * Is this Camera rendering directly to the canvas or to a texture?
         *
         * Enable rendering to texture with the method `setRenderToTexture` (just enabling this boolean won't be enough)
         *
         * Once enabled you can toggle it by switching this property.
         *
         * To properly remove a render texture you should call the `clearRenderToTexture()` method.
         *
         * @name Phaser.Cameras.Scene2D.Camera#renderToTexture
         * @type {boolean}
         * @default false
         * @since 3.13.0
         */this.renderToTexture=!1,/**
         * If this Camera is rendering to a texture (via `setRenderToTexture`) then you
         * have the option to control if it should also render to the Game canvas as well.
         * 
         * By default, a Camera will render both to its texture and to the Game canvas.
         * 
         * However, if you set ths property to `false` it will only render to the texture
         * and skip rendering to the Game canvas.
         * 
         * Setting this property if the Camera isn't rendering to a texture has no effect.
         *
         * @name Phaser.Cameras.Scene2D.Camera#renderToGame
         * @type {boolean}
         * @default true
         * @since 3.23.0
         */this.renderToGame=!0,/**
         * If this Camera has been set to render to a texture then this holds a reference
         * to the HTML Canvas Element that the Camera is drawing to.
         *
         * Enable texture rendering using the method `setRenderToTexture`.
         *
         * This is only populated if Phaser is running with the Canvas Renderer.
         *
         * @name Phaser.Cameras.Scene2D.Camera#canvas
         * @type {HTMLCanvasElement}
         * @since 3.13.0
         */this.canvas=null,/**
         * If this Camera has been set to render to a texture then this holds a reference
         * to the Rendering Context belonging to the Canvas element the Camera is drawing to.
         *
         * Enable texture rendering using the method `setRenderToTexture`.
         *
         * This is only populated if Phaser is running with the Canvas Renderer.
         *
         * @name Phaser.Cameras.Scene2D.Camera#context
         * @type {CanvasRenderingContext2D}
         * @since 3.13.0
         */this.context=null,/**
         * If this Camera has been set to render to a texture then this holds a reference
         * to the GL Texture belonging the Camera is drawing to.
         *
         * Enable texture rendering using the method `setRenderToTexture`.
         *
         * This is only set if Phaser is running with the WebGL Renderer.
         *
         * @name Phaser.Cameras.Scene2D.Camera#glTexture
         * @type {?WebGLTexture}
         * @since 3.13.0
         */this.glTexture=null,/**
         * If this Camera has been set to render to a texture then this holds a reference
         * to the GL Frame Buffer belonging the Camera is drawing to.
         *
         * Enable texture rendering using the method `setRenderToTexture`.
         *
         * This is only set if Phaser is running with the WebGL Renderer.
         *
         * @name Phaser.Cameras.Scene2D.Camera#framebuffer
         * @type {?WebGLFramebuffer}
         * @since 3.13.0
         */this.framebuffer=null,/**
         * If this Camera has been set to render to a texture and to use a custom pipeline,
         * then this holds a reference to the pipeline the Camera is drawing with.
         *
         * Enable texture rendering using the method `setRenderToTexture`.
         *
         * This is only set if Phaser is running with the WebGL Renderer.
         *
         * @name Phaser.Cameras.Scene2D.Camera#pipeline
         * @type {any}
         * @since 3.13.0
         */this.pipeline=null},/**
     * Sets the Camera to render to a texture instead of to the main canvas.
     *
     * The Camera will redirect all Game Objects it's asked to render to this texture.
     *
     * During the render sequence, the texture itself will then be rendered to the main canvas.
     *
     * Doing this gives you the ability to modify the texture before this happens,
     * allowing for special effects such as Camera specific shaders, or post-processing
     * on the texture.
     *
     * If running under Canvas the Camera will render to its `canvas` property.
     *
     * If running under WebGL the Camera will create a frame buffer, which is stored in its `framebuffer` and `glTexture` properties.
     *
     * If you set a camera to render to a texture then it will emit 2 events during the render loop:
     *
     * First, it will emit the event `prerender`. This happens right before any Game Object's are drawn to the Camera texture.
     *
     * Then, it will emit the event `postrender`. This happens after all Game Object's have been drawn, but right before the
     * Camera texture is rendered to the main game canvas. It's the final point at which you can manipulate the texture before
     * it appears in-game.
     *
     * You should not enable this unless you plan on actually using the texture it creates
     * somehow, otherwise you're just doubling the work required to render your game.
     * 
     * If you only require the Camera to render to a texture, and not also to the Game,
     * them set the `renderToGame` parameter to `false`.
     *
     * To temporarily disable rendering to a texture, toggle the `renderToTexture` boolean.
     *
     * If you no longer require the Camera to render to a texture, call the `clearRenderToTexture` method,
     * which will delete the respective textures and free-up resources.
     *
     * @method Phaser.Cameras.Scene2D.Camera#setRenderToTexture
     * @since 3.13.0
     *
     * @param {(string|Phaser.Renderer.WebGL.WebGLPipeline)} [pipeline] - An optional WebGL Pipeline to render with, can be either a string which is the name of the pipeline, or a pipeline reference.
     * @param {boolean} [renderToGame=true] - If you do not need the Camera to still render to the Game, set this parameter to `false`.
     *
     * @return {this} This Camera instance.
     */setRenderToTexture:function(t,e){void 0===e&&(e=!0);var i=this.scene.sys.game.renderer;return i.gl?(this.glTexture=i.createTextureFromSource(null,this.width,this.height,0),this.framebuffer=i.createFramebuffer(this.width,this.height,this.glTexture,!1)):(this.canvas=n.create2D(this,this.width,this.height),this.context=this.canvas.getContext("2d")),this.renderToTexture=!0,this.renderToGame=e,t&&this.setPipeline(t),this},/**
     * Sets the WebGL pipeline this Camera is using when rendering to a texture.
     *
     * You can pass either the string-based name of the pipeline, or a reference to the pipeline itself.
     *
     * Call this method with no arguments to clear any previously set pipeline.
     *
     * @method Phaser.Cameras.Scene2D.Camera#setPipeline
     * @since 3.13.0
     *
     * @param {(string|Phaser.Renderer.WebGL.WebGLPipeline)} [pipeline] - The WebGL Pipeline to render with, can be either a string which is the name of the pipeline, or a pipeline reference. Or if left empty it will clear the pipeline.
     *
     * @return {this} This Camera instance.
     */setPipeline:function(t){if("string"==typeof t){var e=this.scene.sys.game.renderer;e.gl&&e.hasPipeline(t)&&(this.pipeline=e.getPipeline(t))}else this.pipeline=t;return this},/**
     * If this Camera was set to render to a texture, this will clear the resources it was using and
     * redirect it to render back to the primary Canvas again.
     *
     * If you only wish to temporarily disable rendering to a texture then you can toggle the
     * property `renderToTexture` instead.
     *
     * @method Phaser.Cameras.Scene2D.Camera#clearRenderToTexture
     * @since 3.13.0
     *
     * @return {this} This Camera instance.
     */clearRenderToTexture:function(){if(this.scene){var t=this.scene.sys.game.renderer;if(t)return t.gl?(this.framebuffer&&t.deleteFramebuffer(this.framebuffer),this.glTexture&&t.deleteTexture(this.glTexture),this.framebuffer=null,this.glTexture=null,this.pipeline=null):(n.remove(this),this.canvas=null,this.context=null),this.renderToTexture=!1,this}},/**
     * Sets the Camera dead zone.
     *
     * The deadzone is only used when the camera is following a target.
     *
     * It defines a rectangular region within which if the target is present, the camera will not scroll.
     * If the target moves outside of this area, the camera will begin scrolling in order to follow it.
     *
     * The deadzone rectangle is re-positioned every frame so that it is centered on the mid-point
     * of the camera. This allows you to use the object for additional game related checks, such as
     * testing if an object is within it or not via a Rectangle.contains call.
     *
     * The `lerp` values that you can set for a follower target also apply when using a deadzone.
     *
     * Calling this method with no arguments will reset an active deadzone.
     *
     * @method Phaser.Cameras.Scene2D.Camera#setDeadzone
     * @since 3.11.0
     *
     * @param {number} [width] - The width of the deadzone rectangle in pixels. If not specified the deadzone is removed.
     * @param {number} [height] - The height of the deadzone rectangle in pixels.
     *
     * @return {this} This Camera instance.
     */setDeadzone:function(t,e){if(void 0===t)this.deadzone=null;else{if(this.deadzone?(this.deadzone.width=t,this.deadzone.height=e):this.deadzone=new c(0,0,t,e),this._follow){var i=this.width/2,n=this.height/2,s=this._follow.x-this.followOffset.x,o=this._follow.y-this.followOffset.y;this.midPoint.set(s,o),this.scrollX=s-i,this.scrollY=o-n}r(this.deadzone,this.midPoint.x,this.midPoint.y)}return this},/**
     * Fades the Camera in from the given color over the duration specified.
     *
     * @method Phaser.Cameras.Scene2D.Camera#fadeIn
     * @fires Phaser.Cameras.Scene2D.Events#FADE_IN_START
     * @fires Phaser.Cameras.Scene2D.Events#FADE_IN_COMPLETE
     * @since 3.3.0
     *
     * @param {integer} [duration=1000] - The duration of the effect in milliseconds.
     * @param {integer} [red=0] - The amount to fade the red channel towards. A value between 0 and 255.
     * @param {integer} [green=0] - The amount to fade the green channel towards. A value between 0 and 255.
     * @param {integer} [blue=0] - The amount to fade the blue channel towards. A value between 0 and 255.
     * @param {function} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {this} This Camera instance.
     */fadeIn:function(t,e,i,n,s,r){return this.fadeEffect.start(!1,t,e,i,n,!0,s,r)},/**
     * Fades the Camera out to the given color over the duration specified.
     * This is an alias for Camera.fade that forces the fade to start, regardless of existing fades.
     *
     * @method Phaser.Cameras.Scene2D.Camera#fadeOut
     * @fires Phaser.Cameras.Scene2D.Events#FADE_OUT_START
     * @fires Phaser.Cameras.Scene2D.Events#FADE_OUT_COMPLETE
     * @since 3.3.0
     *
     * @param {integer} [duration=1000] - The duration of the effect in milliseconds.
     * @param {integer} [red=0] - The amount to fade the red channel towards. A value between 0 and 255.
     * @param {integer} [green=0] - The amount to fade the green channel towards. A value between 0 and 255.
     * @param {integer} [blue=0] - The amount to fade the blue channel towards. A value between 0 and 255.
     * @param {function} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {this} This Camera instance.
     */fadeOut:function(t,e,i,n,s,r){return this.fadeEffect.start(!0,t,e,i,n,!0,s,r)},/**
     * Fades the Camera from the given color to transparent over the duration specified.
     *
     * @method Phaser.Cameras.Scene2D.Camera#fadeFrom
     * @fires Phaser.Cameras.Scene2D.Events#FADE_IN_START
     * @fires Phaser.Cameras.Scene2D.Events#FADE_IN_COMPLETE
     * @since 3.5.0
     *
     * @param {integer} [duration=1000] - The duration of the effect in milliseconds.
     * @param {integer} [red=0] - The amount to fade the red channel towards. A value between 0 and 255.
     * @param {integer} [green=0] - The amount to fade the green channel towards. A value between 0 and 255.
     * @param {integer} [blue=0] - The amount to fade the blue channel towards. A value between 0 and 255.
     * @param {boolean} [force=false] - Force the effect to start immediately, even if already running.
     * @param {function} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {this} This Camera instance.
     */fadeFrom:function(t,e,i,n,s,r,o){return this.fadeEffect.start(!1,t,e,i,n,s,r,o)},/**
     * Fades the Camera from transparent to the given color over the duration specified.
     *
     * @method Phaser.Cameras.Scene2D.Camera#fade
     * @fires Phaser.Cameras.Scene2D.Events#FADE_OUT_START
     * @fires Phaser.Cameras.Scene2D.Events#FADE_OUT_COMPLETE
     * @since 3.0.0
     *
     * @param {integer} [duration=1000] - The duration of the effect in milliseconds.
     * @param {integer} [red=0] - The amount to fade the red channel towards. A value between 0 and 255.
     * @param {integer} [green=0] - The amount to fade the green channel towards. A value between 0 and 255.
     * @param {integer} [blue=0] - The amount to fade the blue channel towards. A value between 0 and 255.
     * @param {boolean} [force=false] - Force the effect to start immediately, even if already running.
     * @param {function} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {this} This Camera instance.
     */fade:function(t,e,i,n,s,r,o){return this.fadeEffect.start(!0,t,e,i,n,s,r,o)},/**
     * Flashes the Camera by setting it to the given color immediately and then fading it away again quickly over the duration specified.
     *
     * @method Phaser.Cameras.Scene2D.Camera#flash
     * @fires Phaser.Cameras.Scene2D.Events#FLASH_START
     * @fires Phaser.Cameras.Scene2D.Events#FLASH_COMPLETE
     * @since 3.0.0
     *
     * @param {integer} [duration=250] - The duration of the effect in milliseconds.
     * @param {integer} [red=255] - The amount to fade the red channel towards. A value between 0 and 255.
     * @param {integer} [green=255] - The amount to fade the green channel towards. A value between 0 and 255.
     * @param {integer} [blue=255] - The amount to fade the blue channel towards. A value between 0 and 255.
     * @param {boolean} [force=false] - Force the effect to start immediately, even if already running.
     * @param {function} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {this} This Camera instance.
     */flash:function(t,e,i,n,s,r,o){return this.flashEffect.start(t,e,i,n,s,r,o)},/**
     * Shakes the Camera by the given intensity over the duration specified.
     *
     * @method Phaser.Cameras.Scene2D.Camera#shake
     * @fires Phaser.Cameras.Scene2D.Events#SHAKE_START
     * @fires Phaser.Cameras.Scene2D.Events#SHAKE_COMPLETE
     * @since 3.0.0
     *
     * @param {integer} [duration=100] - The duration of the effect in milliseconds.
     * @param {(number|Phaser.Math.Vector2)} [intensity=0.05] - The intensity of the shake.
     * @param {boolean} [force=false] - Force the shake effect to start immediately, even if already running.
     * @param {function} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {this} This Camera instance.
     */shake:function(t,e,i,n,s){return this.shakeEffect.start(t,e,i,n,s)},/**
     * This effect will scroll the Camera so that the center of its viewport finishes at the given destination,
     * over the duration and with the ease specified.
     *
     * @method Phaser.Cameras.Scene2D.Camera#pan
     * @fires Phaser.Cameras.Scene2D.Events#PAN_START
     * @fires Phaser.Cameras.Scene2D.Events#PAN_COMPLETE
     * @since 3.11.0
     *
     * @param {number} x - The destination x coordinate to scroll the center of the Camera viewport to.
     * @param {number} y - The destination y coordinate to scroll the center of the Camera viewport to.
     * @param {integer} [duration=1000] - The duration of the effect in milliseconds.
     * @param {(string|function)} [ease='Linear'] - The ease to use for the pan. Can be any of the Phaser Easing constants or a custom function.
     * @param {boolean} [force=false] - Force the pan effect to start immediately, even if already running.
     * @param {Phaser.Types.Cameras.Scene2D.CameraPanCallback} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
     * the current camera scroll x coordinate and the current camera scroll y coordinate.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {this} This Camera instance.
     */pan:function(t,e,i,n,s,r,o){return this.panEffect.start(t,e,i,n,s,r,o)},/**
     * This effect will rotate the Camera so that the viewport finishes at the given angle in radians,
     * over the duration and with the ease specified.
     *
     * @method Phaser.Cameras.Scene2D.Camera#rotateTo
     * @since 3.23.0
     *
     * @param {number} radians - The destination angle in radians to rotate the Camera viewport to. If the angle is positive then the rotation is clockwise else anticlockwise
     * @param {boolean} [shortestPath=false] - If shortest path is set to true the camera will rotate in the quickest direction clockwise or anti-clockwise.
     * @param {integer} [duration=1000] - The duration of the effect in milliseconds.
     * @param {(string|function)} [ease='Linear'] - The ease to use for the rotation. Can be any of the Phaser Easing constants or a custom function.
     * @param {boolean} [force=false] - Force the rotation effect to start immediately, even if already running.
     * @param {CameraRotateCallback} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
     * the current camera rotation angle in radians.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.
     */rotateTo:function(t,e,i,n,s,r,o){return this.rotateToEffect.start(t,e,i,n,s,r,o)},/**
     * This effect will zoom the Camera to the given scale, over the duration and with the ease specified.
     *
     * @method Phaser.Cameras.Scene2D.Camera#zoomTo
     * @fires Phaser.Cameras.Scene2D.Events#ZOOM_START
     * @fires Phaser.Cameras.Scene2D.Events#ZOOM_COMPLETE
     * @since 3.11.0
     *
     * @param {number} zoom - The target Camera zoom value.
     * @param {integer} [duration=1000] - The duration of the effect in milliseconds.
     * @param {(string|function)} [ease='Linear'] - The ease to use for the pan. Can be any of the Phaser Easing constants or a custom function.
     * @param {boolean} [force=false] - Force the pan effect to start immediately, even if already running.
     * @param {Phaser.Types.Cameras.Scene2D.CameraPanCallback} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
     * the current camera scroll x coordinate and the current camera scroll y coordinate.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {this} This Camera instance.
     */zoomTo:function(t,e,i,n,s,r){return this.zoomEffect.start(t,e,i,n,s,r)},/**
     * Internal preRender step.
     *
     * @method Phaser.Cameras.Scene2D.Camera#preRender
     * @protected
     * @since 3.0.0
     *
     * @param {number} resolution - The game resolution, as set in the Scale Manager.
     */preRender:function(t){var e=this.width,i=this.height,n=this.zoom*t,s=this.matrix,o=e*this.originX,a=i*this.originY,h=this._follow,l=this.deadzone,c=this.scrollX,d=this.scrollY;if(l&&r(l,this.midPoint.x,this.midPoint.y),h&&!this.panEffect.isRunning){var f=h.x-this.followOffset.x,p=h.y-this.followOffset.y;l?(f<l.x?c=u(c,c-(l.x-f),this.lerp.x):f>l.right&&(c=u(c,c+(f-l.right),this.lerp.x)),p<l.y?d=u(d,d-(l.y-p),this.lerp.y):p>l.bottom&&(d=u(d,d+(p-l.bottom),this.lerp.y))):(c=u(c,f-o,this.lerp.x),d=u(d,p-a,this.lerp.y))}this.useBounds&&(c=this.clampX(c),d=this.clampY(d)),this.roundPixels&&(o=Math.round(o),a=Math.round(a)),//  Values are in pixels and not impacted by zooming the Camera
this.scrollX=c,this.scrollY=d;var g=c+.5*e,v=d+.5*i;//  The center of the camera, in world space, so taking zoom into account
//  Basically the pixel value of what it's looking at in the middle of the cam
this.midPoint.set(g,v);var m=e/n,y=i/n;this.worldView.setTo(g-m/2,v-y/2,m,y),s.applyITRS(this.x+o,this.y+a,this.rotation,n,n),s.translate(-o,-a),this.shakeEffect.preRender()},/**
     * Sets the linear interpolation value to use when following a target.
     *
     * The default values of 1 means the camera will instantly snap to the target coordinates.
     * A lower value, such as 0.1 means the camera will more slowly track the target, giving
     * a smooth transition. You can set the horizontal and vertical values independently, and also
     * adjust this value in real-time during your game.
     *
     * Be sure to keep the value between 0 and 1. A value of zero will disable tracking on that axis.
     *
     * @method Phaser.Cameras.Scene2D.Camera#setLerp
     * @since 3.9.0
     *
     * @param {number} [x=1] - The amount added to the horizontal linear interpolation of the follow target.
     * @param {number} [y=1] - The amount added to the vertical linear interpolation of the follow target.
     *
     * @return {this} This Camera instance.
     */setLerp:function(t,e){return void 0===t&&(t=1),void 0===e&&(e=t),this.lerp.set(t,e),this},/**
     * Sets the horizontal and vertical offset of the camera from its follow target.
     * The values are subtracted from the targets position during the Cameras update step.
     *
     * @method Phaser.Cameras.Scene2D.Camera#setFollowOffset
     * @since 3.9.0
     *
     * @param {number} [x=0] - The horizontal offset from the camera follow target.x position.
     * @param {number} [y=0] - The vertical offset from the camera follow target.y position.
     *
     * @return {this} This Camera instance.
     */setFollowOffset:function(t,e){return void 0===t&&(t=0),void 0===e&&(e=0),this.followOffset.set(t,e),this},/**
     * Sets the Camera to follow a Game Object.
     *
     * When enabled the Camera will automatically adjust its scroll position to keep the target Game Object
     * in its center.
     *
     * You can set the linear interpolation value used in the follow code.
     * Use low lerp values (such as 0.1) to automatically smooth the camera motion.
     *
     * If you find you're getting a slight "jitter" effect when following an object it's probably to do with sub-pixel
     * rendering of the targets position. This can be rounded by setting the `roundPixels` argument to `true` to
     * force full pixel rounding rendering. Note that this can still be broken if you have specified a non-integer zoom
     * value on the camera. So be sure to keep the camera zoom to integers.
     *
     * @method Phaser.Cameras.Scene2D.Camera#startFollow
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|object)} target - The target for the Camera to follow.
     * @param {boolean} [roundPixels=false] - Round the camera position to whole integers to avoid sub-pixel rendering?
     * @param {number} [lerpX=1] - A value between 0 and 1. This value specifies the amount of linear interpolation to use when horizontally tracking the target. The closer the value to 1, the faster the camera will track.
     * @param {number} [lerpY=1] - A value between 0 and 1. This value specifies the amount of linear interpolation to use when vertically tracking the target. The closer the value to 1, the faster the camera will track.
     * @param {number} [offsetX=0] - The horizontal offset from the camera follow target.x position.
     * @param {number} [offsetY=0] - The vertical offset from the camera follow target.y position.
     *
     * @return {this} This Camera instance.
     */startFollow:function(t,e,i,n,s,r){void 0===e&&(e=!1),void 0===i&&(i=1),void 0===n&&(n=i),void 0===s&&(s=0),void 0===r&&(r=s),this._follow=t,this.roundPixels=e,i=o(i,0,1),n=o(n,0,1),this.lerp.set(i,n),this.followOffset.set(s,r);var a=this.width/2,h=this.height/2,l=t.x-s,u=t.y-r;return this.midPoint.set(l,u),this.scrollX=l-a,this.scrollY=u-h,this.useBounds&&(this.scrollX=this.clampX(this.scrollX),this.scrollY=this.clampY(this.scrollY)),this},/**
     * Stops a Camera from following a Game Object, if previously set via `Camera.startFollow`.
     *
     * @method Phaser.Cameras.Scene2D.Camera#stopFollow
     * @since 3.0.0
     *
     * @return {this} This Camera instance.
     */stopFollow:function(){return this._follow=null,this},/**
     * Resets any active FX, such as a fade, flash or shake. Useful to call after a fade in order to
     * remove the fade.
     *
     * @method Phaser.Cameras.Scene2D.Camera#resetFX
     * @since 3.0.0
     *
     * @return {this} This Camera instance.
     */resetFX:function(){return this.rotateToEffect.reset(),this.panEffect.reset(),this.shakeEffect.reset(),this.flashEffect.reset(),this.fadeEffect.reset(),this},/**
     * Internal method called automatically by the Camera Manager.
     *
     * @method Phaser.Cameras.Scene2D.Camera#update
     * @protected
     * @since 3.0.0
     *
     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */update:function(t,e){this.visible&&(this.rotateToEffect.update(t,e),this.panEffect.update(t,e),this.zoomEffect.update(t,e),this.shakeEffect.update(t,e),this.flashEffect.update(t,e),this.fadeEffect.update(t,e))},/**
     * Destroys this Camera instance. You rarely need to call this directly.
     *
     * Called by the Camera Manager. If you wish to destroy a Camera please use `CameraManager.remove` as
     * cameras are stored in a pool, ready for recycling later, and calling this directly will prevent that.
     *
     * @method Phaser.Cameras.Scene2D.Camera#destroy
     * @fires Phaser.Cameras.Scene2D.Events#DESTROY
     * @since 3.0.0
     */destroy:function(){this.clearRenderToTexture(),this.resetFX(),i.prototype.destroy.call(this),this._follow=null,this.deadzone=null}});t.exports=f}),r("2LSzx",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("2zqSA"),o=s("3vRz3"),a=s("3xxp2"),h=s("cwr8X"),l=s("azs1m"),u=s("iYnst"),c=s("7SBSk"),d=new i({Extends:o,Mixins:[n.Alpha,n.Visible],initialize:function(t,e,i,n){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=0),o.call(this),/**
         * A reference to the Scene this camera belongs to.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene,/**
         * A reference to the Game Scene Manager.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#sceneManager
         * @type {Phaser.Scenes.SceneManager}
         * @since 3.12.0
         */this.sceneManager,/**
         * A reference to the Game Scale Manager.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#scaleManager
         * @type {Phaser.Scale.ScaleManager}
         * @since 3.16.0
         */this.scaleManager,/**
         * A reference to the Scene's Camera Manager to which this Camera belongs.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#cameraManager
         * @type {Phaser.Cameras.Scene2D.CameraManager}
         * @since 3.17.0
         */this.cameraManager,/**
         * The Camera ID. Assigned by the Camera Manager and used to handle camera exclusion.
         * This value is a bitmask.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#id
         * @type {integer}
         * @readonly
         * @since 3.11.0
         */this.id=0,/**
         * The name of the Camera. This is left empty for your own use.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#name
         * @type {string}
         * @default ''
         * @since 3.0.0
         */this.name="",/**
         * This property is un-used in v3.16.
         * 
         * The resolution of the Game, used in most Camera calculations.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#resolution
         * @type {number}
         * @readonly
         * @deprecated
         * @since 3.12.0
         */this.resolution=1,/**
         * Should this camera round its pixel values to integers?
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#roundPixels
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.roundPixels=!1,/**
         * Is this Camera visible or not?
         *
         * A visible camera will render and perform input tests.
         * An invisible camera will not render anything and will skip input tests.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#visible
         * @type {boolean}
         * @default true
         * @since 3.10.0
         *//**
         * Is this Camera using a bounds to restrict scrolling movement?
         *
         * Set this property along with the bounds via `Camera.setBounds`.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#useBounds
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.useBounds=!1,/**
         * The World View is a Rectangle that defines the area of the 'world' the Camera is currently looking at.
         * This factors in the Camera viewport size, zoom and scroll position and is updated in the Camera preRender step.
         * If you have enabled Camera bounds the worldview will be clamped to those bounds accordingly.
         * You can use it for culling or intersection checks.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#worldView
         * @type {Phaser.Geom.Rectangle}
         * @readonly
         * @since 3.11.0
         */this.worldView=new h,/**
         * Is this Camera dirty?
         * 
         * A dirty Camera has had either its viewport size, bounds, scroll, rotation or zoom levels changed since the last frame.
         * 
         * This flag is cleared during the `postRenderCamera` method of the renderer.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#dirty
         * @type {boolean}
         * @default true
         * @since 3.11.0
         */this.dirty=!0,/**
         * The x position of the Camera viewport, relative to the top-left of the game canvas.
         * The viewport is the area into which the camera renders.
         * To adjust the position the camera is looking at in the game world, see the `scrollX` value.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#x
         * @type {number}
         * @private
         * @since 3.0.0
         */this._x=t,/**
         * The y position of the Camera, relative to the top-left of the game canvas.
         * The viewport is the area into which the camera renders.
         * To adjust the position the camera is looking at in the game world, see the `scrollY` value.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#y
         * @type {number}
         * @private
         * @since 3.0.0
         */this._y=e,/**
         * Internal Camera X value multiplied by the resolution.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_cx
         * @type {number}
         * @private
         * @since 3.12.0
         */this._cx=0,/**
         * Internal Camera Y value multiplied by the resolution.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_cy
         * @type {number}
         * @private
         * @since 3.12.0
         */this._cy=0,/**
         * Internal Camera Width value multiplied by the resolution.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_cw
         * @type {number}
         * @private
         * @since 3.12.0
         */this._cw=0,/**
         * Internal Camera Height value multiplied by the resolution.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_ch
         * @type {number}
         * @private
         * @since 3.12.0
         */this._ch=0,/**
         * The width of the Camera viewport, in pixels.
         *
         * The viewport is the area into which the Camera renders. Setting the viewport does
         * not restrict where the Camera can scroll to.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_width
         * @type {number}
         * @private
         * @since 3.11.0
         */this._width=i,/**
         * The height of the Camera viewport, in pixels.
         *
         * The viewport is the area into which the Camera renders. Setting the viewport does
         * not restrict where the Camera can scroll to.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_height
         * @type {number}
         * @private
         * @since 3.11.0
         */this._height=n,/**
         * The bounds the camera is restrained to during scrolling.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_bounds
         * @type {Phaser.Geom.Rectangle}
         * @private
         * @since 3.0.0
         */this._bounds=new h,/**
         * The horizontal scroll position of this Camera.
         *
         * Change this value to cause the Camera to scroll around your Scene.
         *
         * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,
         * will automatically adjust the Camera scroll values accordingly.
         *
         * You can set the bounds within which the Camera can scroll via the `setBounds` method.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_scrollX
         * @type {number}
         * @private
         * @default 0
         * @since 3.11.0
         */this._scrollX=0,/**
         * The vertical scroll position of this Camera.
         *
         * Change this value to cause the Camera to scroll around your Scene.
         *
         * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,
         * will automatically adjust the Camera scroll values accordingly.
         *
         * You can set the bounds within which the Camera can scroll via the `setBounds` method.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_scrollY
         * @type {number}
         * @private
         * @default 0
         * @since 3.11.0
         */this._scrollY=0,/**
         * The Camera zoom value. Change this value to zoom in, or out of, a Scene.
         *
         * A value of 0.5 would zoom the Camera out, so you can now see twice as much
         * of the Scene as before. A value of 2 would zoom the Camera in, so every pixel
         * now takes up 2 pixels when rendered.
         *
         * Set to 1 to return to the default zoom level.
         *
         * Be careful to never set this value to zero.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_zoom
         * @type {number}
         * @private
         * @default 1
         * @since 3.11.0
         */this._zoom=1,/**
         * The rotation of the Camera in radians.
         *
         * Camera rotation always takes place based on the Camera viewport. By default, rotation happens
         * in the center of the viewport. You can adjust this with the `originX` and `originY` properties.
         *
         * Rotation influences the rendering of _all_ Game Objects visible by this Camera. However, it does not
         * rotate the Camera viewport itself, which always remains an axis-aligned rectangle.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_rotation
         * @type {number}
         * @private
         * @default 0
         * @since 3.11.0
         */this._rotation=0,/**
         * A local transform matrix used for internal calculations.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#matrix
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @private
         * @since 3.0.0
         */this.matrix=new l,/**
         * Does this Camera have a transparent background?
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#transparent
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.transparent=!0,/**
         * The background color of this Camera. Only used if `transparent` is `false`.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#backgroundColor
         * @type {Phaser.Display.Color}
         * @since 3.0.0
         */this.backgroundColor=u("rgba(0,0,0,0)"),/**
         * The Camera alpha value. Setting this property impacts every single object that this Camera
         * renders. You can either set the property directly, i.e. via a Tween, to fade a Camera in or out,
         * or via the chainable `setAlpha` method instead.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#alpha
         * @type {number}
         * @default 1
         * @since 3.11.0
         *//**
         * Should the camera cull Game Objects before checking them for input hit tests?
         * In some special cases it may be beneficial to disable this.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#disableCull
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.disableCull=!1,/**
         * A temporary array of culled objects.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#culledObjects
         * @type {Phaser.GameObjects.GameObject[]}
         * @default []
         * @private
         * @since 3.0.0
         */this.culledObjects=[],/**
         * The mid-point of the Camera in 'world' coordinates.
         *
         * Use it to obtain exactly where in the world the center of the camera is currently looking.
         *
         * This value is updated in the preRender method, after the scroll values and follower
         * have been processed.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#midPoint
         * @type {Phaser.Math.Vector2}
         * @readonly
         * @since 3.11.0
         */this.midPoint=new c(i/2,n/2),/**
         * The horizontal origin of rotation for this Camera.
         *
         * By default the camera rotates around the center of the viewport.
         *
         * Changing the origin allows you to adjust the point in the viewport from which rotation happens.
         * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.
         *
         * See `setOrigin` to set both origins in a single, chainable call.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#originX
         * @type {number}
         * @default 0.5
         * @since 3.11.0
         */this.originX=.5,/**
         * The vertical origin of rotation for this Camera.
         *
         * By default the camera rotates around the center of the viewport.
         *
         * Changing the origin allows you to adjust the point in the viewport from which rotation happens.
         * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.
         *
         * See `setOrigin` to set both origins in a single, chainable call.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#originY
         * @type {number}
         * @default 0.5
         * @since 3.11.0
         */this.originY=.5,/**
         * Does this Camera have a custom viewport?
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_customViewport
         * @type {boolean}
         * @private
         * @default false
         * @since 3.12.0
         */this._customViewport=!1,/**
         * The Mask this Camera is using during render.
         * Set the mask using the `setMask` method. Remove the mask using the `clearMask` method.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#mask
         * @type {?(Phaser.Display.Masks.BitmapMask|Phaser.Display.Masks.GeometryMask)}
         * @since 3.17.0
         */this.mask=null,/**
         * The Camera that this Camera uses for translation during masking.
         * 
         * If the mask is fixed in position this will be a reference to
         * the CameraManager.default instance. Otherwise, it'll be a reference
         * to itself.
         *
         * @name Phaser.Cameras.Scene2D.BaseCamera#_maskCamera
         * @type {?Phaser.Cameras.Scene2D.BaseCamera}
         * @private
         * @since 3.17.0
         */this._maskCamera=null},/**
     * Set the Alpha level of this Camera. The alpha controls the opacity of the Camera as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setAlpha
     * @since 3.11.0
     *
     * @param {number} [value=1] - The Camera alpha value.
     *
     * @return {this} This Camera instance.
     *//**
     * Sets the rotation origin of this Camera.
     *
     * The values are given in the range 0 to 1 and are only used when calculating Camera rotation.
     *
     * By default the camera rotates around the center of the viewport.
     *
     * Changing the origin allows you to adjust the point in the viewport from which rotation happens.
     * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setOrigin
     * @since 3.11.0
     *
     * @param {number} [x=0.5] - The horizontal origin value.
     * @param {number} [y=x] - The vertical origin value. If not defined it will be set to the value of `x`.
     *
     * @return {this} This Camera instance.
     */setOrigin:function(t,e){return void 0===t&&(t=.5),void 0===e&&(e=t),this.originX=t,this.originY=e,this},/**
     * Calculates what the Camera.scrollX and scrollY values would need to be in order to move
     * the Camera so it is centered on the given x and y coordinates, without actually moving
     * the Camera there. The results are clamped based on the Camera bounds, if set.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#getScroll
     * @since 3.11.0
     *
     * @param {number} x - The horizontal coordinate to center on.
     * @param {number} y - The vertical coordinate to center on.
     * @param {Phaser.Math.Vector2} [out] - A Vector2 to store the values in. If not given a new Vector2 is created.
     *
     * @return {Phaser.Math.Vector2} The scroll coordinates stored in the `x` and `y` properties.
     */getScroll:function(t,e,i){void 0===i&&(i=new c);var n=.5*this.width,s=.5*this.height;return i.x=t-n,i.y=e-s,this.useBounds&&(i.x=this.clampX(i.x),i.y=this.clampY(i.y)),i},/**
     * Moves the Camera horizontally so that it is centered on the given x coordinate, bounds allowing.
     * Calling this does not change the scrollY value.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#centerOnX
     * @since 3.16.0
     *
     * @param {number} x - The horizontal coordinate to center on.
     *
     * @return {this} This Camera instance.
     */centerOnX:function(t){var e=.5*this.width;return this.midPoint.x=t,this.scrollX=t-e,this.useBounds&&(this.scrollX=this.clampX(this.scrollX)),this},/**
     * Moves the Camera vertically so that it is centered on the given y coordinate, bounds allowing.
     * Calling this does not change the scrollX value.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#centerOnY
     * @since 3.16.0
     *
     * @param {number} y - The vertical coordinate to center on.
     *
     * @return {this} This Camera instance.
     */centerOnY:function(t){var e=.5*this.height;return this.midPoint.y=t,this.scrollY=t-e,this.useBounds&&(this.scrollY=this.clampY(this.scrollY)),this},/**
     * Moves the Camera so that it is centered on the given coordinates, bounds allowing.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#centerOn
     * @since 3.11.0
     *
     * @param {number} x - The horizontal coordinate to center on.
     * @param {number} y - The vertical coordinate to center on.
     *
     * @return {this} This Camera instance.
     */centerOn:function(t,e){return this.centerOnX(t),this.centerOnY(e),this},/**
     * Moves the Camera so that it is looking at the center of the Camera Bounds, if enabled.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#centerToBounds
     * @since 3.0.0
     *
     * @return {this} This Camera instance.
     */centerToBounds:function(){if(this.useBounds){var t=this._bounds,e=.5*this.width,i=.5*this.height;this.midPoint.set(t.centerX,t.centerY),this.scrollX=t.centerX-e,this.scrollY=t.centerY-i}return this},/**
     * Moves the Camera so that it is re-centered based on its viewport size.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#centerToSize
     * @since 3.0.0
     *
     * @return {this} This Camera instance.
     */centerToSize:function(){return this.scrollX=.5*this.width,this.scrollY=.5*this.height,this},/**
     * Takes an array of Game Objects and returns a new array featuring only those objects
     * visible by this camera.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#cull
     * @since 3.0.0
     *
     * @generic {Phaser.GameObjects.GameObject[]} G - [renderableObjects,$return]
     *
     * @param {Phaser.GameObjects.GameObject[]} renderableObjects - An array of Game Objects to cull.
     *
     * @return {Phaser.GameObjects.GameObject[]} An array of Game Objects visible to this Camera.
     */cull:function(t){if(this.disableCull)return t;var e=this.matrix.matrix,i=e[0],n=e[1],s=e[2],r=e[3],o=i*r-n*s;if(!o)return t;var a=e[4],h=e[5],l=this.scrollX,u=this.scrollY,c=this.width,d=this.height,f=this.culledObjects,p=t.length;o=1/o,f.length=0;for(var g=0;g<p;++g){var v=t[g];if(!v.hasOwnProperty("width")||v.parentContainer){f.push(v);continue}var m=v.width,y=v.height,x=v.x-l*v.scrollFactorX-m*v.originX,w=v.y-u*v.scrollFactorY-y*v.originY,T=x*i+w*s+a,b=x*n+w*r+h,S=(x+m)*i+(w+y)*s+a,A=(x+m)*n+(w+y)*r+h,E=this.y,_=E+d,C=this.x,M=C+c;S>C&&T<M&&A>E&&b<_&&f.push(v)}return f},/**
     * Converts the given `x` and `y` coordinates into World space, based on this Cameras transform.
     * You can optionally provide a Vector2, or similar object, to store the results in.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#getWorldPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [output,$return]
     *
     * @param {number} x - The x position to convert to world space.
     * @param {number} y - The y position to convert to world space.
     * @param {(object|Phaser.Math.Vector2)} [output] - An optional object to store the results in. If not provided a new Vector2 will be created.
     *
     * @return {Phaser.Math.Vector2} An object holding the converted values in its `x` and `y` properties.
     */getWorldPoint:function(t,e,i){void 0===i&&(i=new c);var n=this.matrix.matrix,s=n[0],r=n[1],o=n[2],a=n[3],h=n[4],l=n[5],u=s*a-r*o;if(!u)return i.x=t,i.y=e,i;var d=a*(u=1/u),f=-r*u,p=-o*u,g=s*u,v=(o*l-a*h)*u,m=(r*h-s*l)*u,y=Math.cos(this.rotation),x=Math.sin(this.rotation),w=this.zoom,T=this.resolution,b=this.scrollX,S=this.scrollY,A=t+(b*y-S*x)*w,E=e+(b*x+S*y)*w;return(//  Apply transform to point
i.x=(A*d+E*p)*T+v,i.y=(A*f+E*g)*T+m,i)},/**
     * Given a Game Object, or an array of Game Objects, it will update all of their camera filter settings
     * so that they are ignored by this Camera. This means they will not be rendered by this Camera.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#ignore
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group)} entries - The Game Object, or array of Game Objects, to be ignored by this Camera.
     *
     * @return {this} This Camera instance.
     */ignore:function(t){var e=this.id;Array.isArray(t)||(t=[t]);for(var i=0;i<t.length;i++){var n=t[i];Array.isArray(n)?this.ignore(n):n.isParent?this.ignore(n.getChildren()):n.cameraFilter|=e}return this},/**
     * Internal preRender step.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#preRender
     * @protected
     * @since 3.0.0
     *
     * @param {number} resolution - The game resolution, as set in the Scale Manager.
     */preRender:function(t){var e=this.width,i=this.height,n=this.zoom*t,s=this.matrix,r=e*this.originX,o=i*this.originY,a=this.scrollX,h=this.scrollY;this.useBounds&&(a=this.clampX(a),h=this.clampY(h)),this.roundPixels&&(r=Math.round(r),o=Math.round(o)),//  Values are in pixels and not impacted by zooming the Camera
this.scrollX=a,this.scrollY=h;var l=a+.5*e,u=h+.5*i;//  The center of the camera, in world space, so taking zoom into account
//  Basically the pixel value of what it's looking at in the middle of the cam
this.midPoint.set(l,u);var c=e/n,d=i/n;this.worldView.setTo(l-c/2,u-d/2,c,d),s.applyITRS(this.x+r,this.y+o,this.rotation,n,n),s.translate(-r,-o)},/**
     * Takes an x value and checks it's within the range of the Camera bounds, adjusting if required.
     * Do not call this method if you are not using camera bounds.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#clampX
     * @since 3.11.0
     *
     * @param {number} x - The value to horizontally scroll clamp.
     *
     * @return {number} The adjusted value to use as scrollX.
     */clampX:function(t){var e=this._bounds,i=this.displayWidth,n=e.x+(i-this.width)/2,s=Math.max(n,n+e.width-i);return t<n?t=n:t>s&&(t=s),t},/**
     * Takes a y value and checks it's within the range of the Camera bounds, adjusting if required.
     * Do not call this method if you are not using camera bounds.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#clampY
     * @since 3.11.0
     *
     * @param {number} y - The value to vertically scroll clamp.
     *
     * @return {number} The adjusted value to use as scrollY.
     */clampY:function(t){var e=this._bounds,i=this.displayHeight,n=e.y+(i-this.height)/2,s=Math.max(n,n+e.height-i);return t<n?t=n:t>s&&(t=s),t},/*
        var gap = this._zoomInversed;
        return gap * Math.round((src.x - this.scrollX * src.scrollFactorX) / gap);
    *//**
     * If this Camera has previously had movement bounds set on it, this will remove them.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#removeBounds
     * @since 3.0.0
     *
     * @return {this} This Camera instance.
     */removeBounds:function(){return this.useBounds=!1,this.dirty=!0,this._bounds.setEmpty(),this},/**
     * Set the rotation of this Camera. This causes everything it renders to appear rotated.
     *
     * Rotating a camera does not rotate the viewport itself, it is applied during rendering.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setAngle
     * @since 3.0.0
     *
     * @param {number} [value=0] - The cameras angle of rotation, given in degrees.
     *
     * @return {this} This Camera instance.
     */setAngle:function(t){return void 0===t&&(t=0),this.rotation=r(t),this},/**
     * Sets the background color for this Camera.
     *
     * By default a Camera has a transparent background but it can be given a solid color, with any level
     * of transparency, via this method.
     *
     * The color value can be specified using CSS color notation, hex or numbers.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setBackgroundColor
     * @since 3.0.0
     *
     * @param {(string|number|Phaser.Types.Display.InputColorObject)} [color='rgba(0,0,0,0)'] - The color value. In CSS, hex or numeric color notation.
     *
     * @return {this} This Camera instance.
     */setBackgroundColor:function(t){return void 0===t&&(t="rgba(0,0,0,0)"),this.backgroundColor=u(t),this.transparent=0===this.backgroundColor.alpha,this},/**
     * Set the bounds of the Camera. The bounds are an axis-aligned rectangle.
     * 
     * The Camera bounds controls where the Camera can scroll to, stopping it from scrolling off the
     * edges and into blank space. It does not limit the placement of Game Objects, or where
     * the Camera viewport can be positioned.
     * 
     * Temporarily disable the bounds by changing the boolean `Camera.useBounds`.
     * 
     * Clear the bounds entirely by calling `Camera.removeBounds`.
     * 
     * If you set bounds that are smaller than the viewport it will stop the Camera from being
     * able to scroll. The bounds can be positioned where-ever you wish. By default they are from
     * 0x0 to the canvas width x height. This means that the coordinate 0x0 is the top left of
     * the Camera bounds. However, you can position them anywhere. So if you wanted a game world
     * that was 2048x2048 in size, with 0x0 being the center of it, you can set the bounds x/y
     * to be -1024, -1024, with a width and height of 2048. Depending on your game you may find
     * it easier for 0x0 to be the top-left of the bounds, or you may wish 0x0 to be the middle.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setBounds
     * @since 3.0.0
     *
     * @param {integer} x - The top-left x coordinate of the bounds.
     * @param {integer} y - The top-left y coordinate of the bounds.
     * @param {integer} width - The width of the bounds, in pixels.
     * @param {integer} height - The height of the bounds, in pixels.
     * @param {boolean} [centerOn=false] - If `true` the Camera will automatically be centered on the new bounds.
     *
     * @return {this} This Camera instance.
     */setBounds:function(t,e,i,n,s){return void 0===s&&(s=!1),this._bounds.setTo(t,e,i,n),this.dirty=!0,this.useBounds=!0,s?this.centerToBounds():(this.scrollX=this.clampX(this.scrollX),this.scrollY=this.clampY(this.scrollY)),this},/**
     * Returns a rectangle containing the bounds of the Camera.
     * 
     * If the Camera does not have any bounds the rectangle will be empty.
     * 
     * The rectangle is a copy of the bounds, so is safe to modify.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#getBounds
     * @since 3.16.0
     *
     * @param {Phaser.Geom.Rectangle} [out] - An optional Rectangle to store the bounds in. If not given, a new Rectangle will be created.
     *
     * @return {Phaser.Geom.Rectangle} A rectangle containing the bounds of this Camera.
     */getBounds:function(t){void 0===t&&(t=new h);var e=this._bounds;return t.setTo(e.x,e.y,e.width,e.height),t},/**
     * Sets the name of this Camera.
     * This value is for your own use and isn't used internally.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setName
     * @since 3.0.0
     *
     * @param {string} [value=''] - The name of the Camera.
     *
     * @return {this} This Camera instance.
     */setName:function(t){return void 0===t&&(t=""),this.name=t,this},/**
     * Set the position of the Camera viewport within the game.
     *
     * This does not change where the camera is 'looking'. See `setScroll` to control that.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setPosition
     * @since 3.0.0
     *
     * @param {number} x - The top-left x coordinate of the Camera viewport.
     * @param {number} [y=x] - The top-left y coordinate of the Camera viewport.
     *
     * @return {this} This Camera instance.
     */setPosition:function(t,e){return void 0===e&&(e=t),this.x=t,this.y=e,this},/**
     * Set the rotation of this Camera. This causes everything it renders to appear rotated.
     *
     * Rotating a camera does not rotate the viewport itself, it is applied during rendering.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setRotation
     * @since 3.0.0
     *
     * @param {number} [value=0] - The rotation of the Camera, in radians.
     *
     * @return {this} This Camera instance.
     */setRotation:function(t){return void 0===t&&(t=0),this.rotation=t,this},/**
     * Should the Camera round pixel values to whole integers when rendering Game Objects?
     * 
     * In some types of game, especially with pixel art, this is required to prevent sub-pixel aliasing.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setRoundPixels
     * @since 3.0.0
     *
     * @param {boolean} value - `true` to round Camera pixels, `false` to not.
     *
     * @return {this} This Camera instance.
     */setRoundPixels:function(t){return this.roundPixels=t,this},/**
     * Sets the Scene the Camera is bound to.
     * 
     * Also populates the `resolution` property and updates the internal size values.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setScene
     * @since 3.0.0
     *
     * @param {Phaser.Scene} scene - The Scene the camera is bound to.
     *
     * @return {this} This Camera instance.
     */setScene:function(t){this.scene&&this._customViewport&&this.sceneManager.customViewports--,this.scene=t;var e=t.sys;this.sceneManager=e.game.scene,this.scaleManager=e.scale,this.cameraManager=e.cameras;var i=this.scaleManager.resolution;return this.resolution=i,this._cx=this._x*i,this._cy=this._y*i,this._cw=this._width*i,this._ch=this._height*i,this.updateSystem(),this},/**
     * Set the position of where the Camera is looking within the game.
     * You can also modify the properties `Camera.scrollX` and `Camera.scrollY` directly.
     * Use this method, or the scroll properties, to move your camera around the game world.
     *
     * This does not change where the camera viewport is placed. See `setPosition` to control that.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setScroll
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate of the Camera in the game world.
     * @param {number} [y=x] - The y coordinate of the Camera in the game world.
     *
     * @return {this} This Camera instance.
     */setScroll:function(t,e){return void 0===e&&(e=t),this.scrollX=t,this.scrollY=e,this},/**
     * Set the size of the Camera viewport.
     *
     * By default a Camera is the same size as the game, but can be made smaller via this method,
     * allowing you to create mini-cam style effects by creating and positioning a smaller Camera
     * viewport within your game.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setSize
     * @since 3.0.0
     *
     * @param {integer} width - The width of the Camera viewport.
     * @param {integer} [height=width] - The height of the Camera viewport.
     *
     * @return {this} This Camera instance.
     */setSize:function(t,e){return void 0===e&&(e=t),this.width=t,this.height=e,this},/**
     * This method sets the position and size of the Camera viewport in a single call.
     *
     * If you're trying to change where the Camera is looking at in your game, then see
     * the method `Camera.setScroll` instead. This method is for changing the viewport
     * itself, not what the camera can see.
     *
     * By default a Camera is the same size as the game, but can be made smaller via this method,
     * allowing you to create mini-cam style effects by creating and positioning a smaller Camera
     * viewport within your game.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setViewport
     * @since 3.0.0
     *
     * @param {number} x - The top-left x coordinate of the Camera viewport.
     * @param {number} y - The top-left y coordinate of the Camera viewport.
     * @param {integer} width - The width of the Camera viewport.
     * @param {integer} [height=width] - The height of the Camera viewport.
     *
     * @return {this} This Camera instance.
     */setViewport:function(t,e,i,n){return this.x=t,this.y=e,this.width=i,this.height=n,this},/**
     * Set the zoom value of the Camera.
     *
     * Changing to a smaller value, such as 0.5, will cause the camera to 'zoom out'.
     * Changing to a larger value, such as 2, will cause the camera to 'zoom in'.
     *
     * A value of 1 means 'no zoom' and is the default.
     *
     * Changing the zoom does not impact the Camera viewport in any way, it is only applied during rendering.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setZoom
     * @since 3.0.0
     *
     * @param {number} [value=1] - The zoom value of the Camera. The minimum it can be is 0.001.
     *
     * @return {this} This Camera instance.
     */setZoom:function(t){return void 0===t&&(t=1),0===t&&(t=.001),this.zoom=t,this},/**
     * Sets the mask to be applied to this Camera during rendering.
     *
     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
     * 
     * Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
     *
     * If a mask is already set on this Camera it will be immediately replaced.
     * 
     * Masks have no impact on physics or input detection. They are purely a rendering component
     * that allows you to limit what is visible during the render pass.
     * 
     * Note: You cannot mask a Camera that has `renderToTexture` set.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setMask
     * @since 3.17.0
     *
     * @param {(Phaser.Display.Masks.BitmapMask|Phaser.Display.Masks.GeometryMask)} mask - The mask this Camera will use when rendering.
     * @param {boolean} [fixedPosition=true] - Should the mask translate along with the Camera, or be fixed in place and not impacted by the Cameras transform?
     *
     * @return {this} This Camera instance.
     */setMask:function(t,e){return void 0===e&&(e=!0),this.mask=t,this._maskCamera=e?this.cameraManager.default:this,this},/**
     * Clears the mask that this Camera was using.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#clearMask
     * @since 3.17.0
     *
     * @param {boolean} [destroyMask=false] - Destroy the mask before clearing it?
     *
     * @return {this} This Camera instance.
     */clearMask:function(t){return void 0===t&&(t=!1),t&&this.mask&&this.mask.destroy(),this.mask=null,this},/**
     * Sets the visibility of this Camera.
     *
     * An invisible Camera will skip rendering and input tests of everything it can see.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#setVisible
     * @since 3.10.0
     *
     * @param {boolean} value - The visible state of the Camera.
     *
     * @return {this} This Camera instance.
     *//**
     * Returns an Object suitable for JSON storage containing all of the Camera viewport and rendering properties.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.Cameras.Scene2D.JSONCamera} A well-formed object suitable for conversion to JSON.
     */toJSON:function(){var t={name:this.name,x:this.x,y:this.y,width:this.width,height:this.height,zoom:this.zoom,rotation:this.rotation,roundPixels:this.roundPixels,scrollX:this.scrollX,scrollY:this.scrollY,backgroundColor:this.backgroundColor.rgba};return this.useBounds&&(t.bounds={x:this._bounds.x,y:this._bounds.y,width:this._bounds.width,height:this._bounds.height}),t},/**
     * Internal method called automatically by the Camera Manager.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#update
     * @protected
     * @since 3.0.0
     *
     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */update:function(){//  NOOP
},/**
     * Internal method called automatically when the viewport changes.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#updateSystem
     * @private
     * @since 3.12.0
     */updateSystem:function(){if(this.scaleManager){var t=0!==this._x||0!==this._y||this.scaleManager.width!==this._width||this.scaleManager.height!==this._height,e=this.sceneManager;t&&!this._customViewport?e.customViewports++:!t&&this._customViewport&&e.customViewports--,this.dirty=!0,this._customViewport=t}},/**
     * Destroys this Camera instance and its internal properties and references.
     * Once destroyed you cannot use this Camera again, even if re-added to a Camera Manager.
     * 
     * This method is called automatically by `CameraManager.remove` if that methods `runDestroy` argument is `true`, which is the default.
     * 
     * Unless you have a specific reason otherwise, always use `CameraManager.remove` and allow it to handle the camera destruction,
     * rather than calling this method directly.
     *
     * @method Phaser.Cameras.Scene2D.BaseCamera#destroy
     * @fires Phaser.Cameras.Scene2D.Events#DESTROY
     * @since 3.0.0
     */destroy:function(){this.emit(a.DESTROY,this),this.removeAllListeners(),this.matrix.destroy(),this.culledObjects=[],this._customViewport&&this.sceneManager.customViewports--,this._bounds=null,this.scene=null,this.scaleManager=null,this.sceneManager=null,this.cameraManager=null},/**
     * The x position of the Camera viewport, relative to the top-left of the game canvas.
     * The viewport is the area into which the camera renders.
     * To adjust the position the camera is looking at in the game world, see the `scrollX` value.
     *
     * @name Phaser.Cameras.Scene2D.BaseCamera#x
     * @type {number}
     * @since 3.0.0
     */x:{get:function(){return this._x},set:function(t){this._x=t,this._cx=t*this.resolution,this.updateSystem()}},/**
     * The y position of the Camera viewport, relative to the top-left of the game canvas.
     * The viewport is the area into which the camera renders.
     * To adjust the position the camera is looking at in the game world, see the `scrollY` value.
     *
     * @name Phaser.Cameras.Scene2D.BaseCamera#y
     * @type {number}
     * @since 3.0.0
     */y:{get:function(){return this._y},set:function(t){this._y=t,this._cy=t*this.resolution,this.updateSystem()}},/**
     * The width of the Camera viewport, in pixels.
     *
     * The viewport is the area into which the Camera renders. Setting the viewport does
     * not restrict where the Camera can scroll to.
     *
     * @name Phaser.Cameras.Scene2D.BaseCamera#width
     * @type {number}
     * @since 3.0.0
     */width:{get:function(){return this._width},set:function(t){this._width=t,this._cw=t*this.resolution,this.updateSystem()}},/**
     * The height of the Camera viewport, in pixels.
     *
     * The viewport is the area into which the Camera renders. Setting the viewport does
     * not restrict where the Camera can scroll to.
     *
     * @name Phaser.Cameras.Scene2D.BaseCamera#height
     * @type {number}
     * @since 3.0.0
     */height:{get:function(){return this._height},set:function(t){this._height=t,this._ch=t*this.resolution,this.updateSystem()}},/**
     * The horizontal scroll position of this Camera.
     *
     * Change this value to cause the Camera to scroll around your Scene.
     *
     * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,
     * will automatically adjust the Camera scroll values accordingly.
     *
     * You can set the bounds within which the Camera can scroll via the `setBounds` method.
     *
     * @name Phaser.Cameras.Scene2D.BaseCamera#scrollX
     * @type {number}
     * @default 0
     * @since 3.0.0
     */scrollX:{get:function(){return this._scrollX},set:function(t){this._scrollX=t,this.dirty=!0}},/**
     * The vertical scroll position of this Camera.
     *
     * Change this value to cause the Camera to scroll around your Scene.
     *
     * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,
     * will automatically adjust the Camera scroll values accordingly.
     *
     * You can set the bounds within which the Camera can scroll via the `setBounds` method.
     *
     * @name Phaser.Cameras.Scene2D.BaseCamera#scrollY
     * @type {number}
     * @default 0
     * @since 3.0.0
     */scrollY:{get:function(){return this._scrollY},set:function(t){this._scrollY=t,this.dirty=!0}},/**
     * The Camera zoom value. Change this value to zoom in, or out of, a Scene.
     *
     * A value of 0.5 would zoom the Camera out, so you can now see twice as much
     * of the Scene as before. A value of 2 would zoom the Camera in, so every pixel
     * now takes up 2 pixels when rendered.
     *
     * Set to 1 to return to the default zoom level.
     *
     * Be careful to never set this value to zero.
     *
     * @name Phaser.Cameras.Scene2D.BaseCamera#zoom
     * @type {number}
     * @default 1
     * @since 3.0.0
     */zoom:{get:function(){return this._zoom},set:function(t){this._zoom=t,this.dirty=!0}},/**
     * The rotation of the Camera in radians.
     *
     * Camera rotation always takes place based on the Camera viewport. By default, rotation happens
     * in the center of the viewport. You can adjust this with the `originX` and `originY` properties.
     *
     * Rotation influences the rendering of _all_ Game Objects visible by this Camera. However, it does not
     * rotate the Camera viewport itself, which always remains an axis-aligned rectangle.
     *
     * @name Phaser.Cameras.Scene2D.BaseCamera#rotation
     * @type {number}
     * @private
     * @default 0
     * @since 3.11.0
     */rotation:{get:function(){return this._rotation},set:function(t){this._rotation=t,this.dirty=!0}},/**
     * The horizontal position of the center of the Camera's viewport, relative to the left of the game canvas.
     *
     * @name Phaser.Cameras.Scene2D.BaseCamera#centerX
     * @type {number}
     * @readonly
     * @since 3.10.0
     */centerX:{get:function(){return this.x+.5*this.width}},/**
     * The vertical position of the center of the Camera's viewport, relative to the top of the game canvas.
     *
     * @name Phaser.Cameras.Scene2D.BaseCamera#centerY
     * @type {number}
     * @readonly
     * @since 3.10.0
     */centerY:{get:function(){return this.y+.5*this.height}},/**
     * The displayed width of the camera viewport, factoring in the camera zoom level.
     *
     * If a camera has a viewport width of 800 and a zoom of 0.5 then its display width
     * would be 1600, as it's displaying twice as many pixels as zoom level 1.
     *
     * Equally, a camera with a width of 800 and zoom of 2 would have a display width
     * of 400 pixels.
     *
     * @name Phaser.Cameras.Scene2D.BaseCamera#displayWidth
     * @type {number}
     * @readonly
     * @since 3.11.0
     */displayWidth:{get:function(){return this.width/this.zoom}},/**
     * The displayed height of the camera viewport, factoring in the camera zoom level.
     *
     * If a camera has a viewport height of 600 and a zoom of 0.5 then its display height
     * would be 1200, as it's displaying twice as many pixels as zoom level 1.
     *
     * Equally, a camera with a height of 600 and zoom of 2 would have a display height
     * of 300 pixels.
     *
     * @name Phaser.Cameras.Scene2D.BaseCamera#displayHeight
     * @type {number}
     * @readonly
     * @since 3.11.0
     */displayHeight:{get:function(){return this.height/this.zoom}}});t.exports=d}),r("3xxp2",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Cameras.Scene2D.Events
 */t.exports={DESTROY:s("6gQSS"),FADE_IN_COMPLETE:s("8uqmg"),FADE_IN_START:s("9i9XH"),FADE_OUT_COMPLETE:s("fZjMj"),FADE_OUT_START:s("bzGzo"),FLASH_COMPLETE:s("l5C5P"),FLASH_START:s("ksqlR"),PAN_COMPLETE:s("cH2M7"),PAN_START:s("7kPyY"),POST_RENDER:s("hyxn6"),PRE_RENDER:s("32t1X"),ROTATE_COMPLETE:s("9NyMd"),ROTATE_START:s("hLiUc"),SHAKE_COMPLETE:s("5PluY"),SHAKE_START:s("7IcGB"),ZOOM_COMPLETE:s("2wQfp"),ZOOM_START:s("cMBby")}}),r("6gQSS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Destroy Camera Event.
 * 
 * This event is dispatched by a Camera instance when it is destroyed by the Camera Manager.
 *
 * @event Phaser.Cameras.Scene2D.Events#DESTROY
 * @since 3.0.0
 * 
 * @param {Phaser.Cameras.Scene2D.BaseCamera} camera - The camera that was destroyed.
 */t.exports="cameradestroy"}),r("8uqmg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Fade In Complete Event.
 * 
 * This event is dispatched by a Camera instance when the Fade In Effect completes.
 * 
 * Listen to it from a Camera instance using `Camera.on('camerafadeincomplete', listener)`.
 *
 * @event Phaser.Cameras.Scene2D.Events#FADE_IN_COMPLETE
 * @since 3.3.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.Fade} effect - A reference to the effect instance.
 */t.exports="camerafadeincomplete"}),r("9i9XH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Fade In Start Event.
 * 
 * This event is dispatched by a Camera instance when the Fade In Effect starts.
 * 
 * Listen to it from a Camera instance using `Camera.on('camerafadeinstart', listener)`.
 *
 * @event Phaser.Cameras.Scene2D.Events#FADE_IN_START
 * @since 3.3.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.Fade} effect - A reference to the effect instance.
 * @param {integer} duration - The duration of the effect.
 * @param {integer} red - The red color channel value.
 * @param {integer} green - The green color channel value.
 * @param {integer} blue - The blue color channel value.
 */t.exports="camerafadeinstart"}),r("fZjMj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Fade Out Complete Event.
 * 
 * This event is dispatched by a Camera instance when the Fade Out Effect completes.
 * 
 * Listen to it from a Camera instance using `Camera.on('camerafadeoutcomplete', listener)`.
 *
 * @event Phaser.Cameras.Scene2D.Events#FADE_OUT_COMPLETE
 * @since 3.3.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.Fade} effect - A reference to the effect instance.
 */t.exports="camerafadeoutcomplete"}),r("bzGzo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Fade Out Start Event.
 * 
 * This event is dispatched by a Camera instance when the Fade Out Effect starts.
 * 
 * Listen to it from a Camera instance using `Camera.on('camerafadeoutstart', listener)`.
 *
 * @event Phaser.Cameras.Scene2D.Events#FADE_OUT_START
 * @since 3.3.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.Fade} effect - A reference to the effect instance.
 * @param {integer} duration - The duration of the effect.
 * @param {integer} red - The red color channel value.
 * @param {integer} green - The green color channel value.
 * @param {integer} blue - The blue color channel value.
 */t.exports="camerafadeoutstart"}),r("l5C5P",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Flash Complete Event.
 * 
 * This event is dispatched by a Camera instance when the Flash Effect completes.
 *
 * @event Phaser.Cameras.Scene2D.Events#FLASH_COMPLETE
 * @since 3.3.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.Flash} effect - A reference to the effect instance.
 */t.exports="cameraflashcomplete"}),r("ksqlR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Flash Start Event.
 * 
 * This event is dispatched by a Camera instance when the Flash Effect starts.
 *
 * @event Phaser.Cameras.Scene2D.Events#FLASH_START
 * @since 3.3.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.Flash} effect - A reference to the effect instance.
 * @param {integer} duration - The duration of the effect.
 * @param {integer} red - The red color channel value.
 * @param {integer} green - The green color channel value.
 * @param {integer} blue - The blue color channel value.
 */t.exports="cameraflashstart"}),r("cH2M7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Pan Complete Event.
 * 
 * This event is dispatched by a Camera instance when the Pan Effect completes.
 *
 * @event Phaser.Cameras.Scene2D.Events#PAN_COMPLETE
 * @since 3.3.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.Pan} effect - A reference to the effect instance.
 */t.exports="camerapancomplete"}),r("7kPyY",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Pan Start Event.
 * 
 * This event is dispatched by a Camera instance when the Pan Effect starts.
 *
 * @event Phaser.Cameras.Scene2D.Events#PAN_START
 * @since 3.3.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.Pan} effect - A reference to the effect instance.
 * @param {integer} duration - The duration of the effect.
 * @param {number} x - The destination scroll x coordinate.
 * @param {number} y - The destination scroll y coordinate.
 */t.exports="camerapanstart"}),r("hyxn6",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Post-Render Event.
 * 
 * This event is dispatched by a Camera instance after is has finished rendering.
 * It is only dispatched if the Camera is rendering to a texture.
 * 
 * Listen to it from a Camera instance using: `camera.on('postrender', listener)`.
 *
 * @event Phaser.Cameras.Scene2D.Events#POST_RENDER
 * @since 3.0.0
 * 
 * @param {Phaser.Cameras.Scene2D.BaseCamera} camera - The camera that has finished rendering to a texture.
 */t.exports="postrender"}),r("32t1X",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Pre-Render Event.
 * 
 * This event is dispatched by a Camera instance when it is about to render.
 * It is only dispatched if the Camera is rendering to a texture.
 * 
 * Listen to it from a Camera instance using: `camera.on('prerender', listener)`.
 *
 * @event Phaser.Cameras.Scene2D.Events#PRE_RENDER
 * @since 3.0.0
 * 
 * @param {Phaser.Cameras.Scene2D.BaseCamera} camera - The camera that is about to render to a texture.
 */t.exports="prerender"}),r("9NyMd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Rotate Complete Event.
 * 
 * This event is dispatched by a Camera instance when the Rotate Effect completes.
 *
 * @event Phaser.Cameras.Scene2D.Events#ROTATE_COMPLETE
 * @since 3.23.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.RotateTo} effect - A reference to the effect instance.
 */t.exports="camerarotatecomplete"}),r("hLiUc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Rotate Start Event.
 * 
 * This event is dispatched by a Camera instance when the Rotate Effect starts.
 *
 * @event Phaser.Cameras.Scene2D.Events#ROTATE_START
 * @since 3.23.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.RotateTo} effect - A reference to the effect instance.
 * @param {integer} duration - The duration of the effect.
 * @param {number} destination - The destination value.
 */t.exports="camerarotatestart"}),r("5PluY",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Shake Complete Event.
 * 
 * This event is dispatched by a Camera instance when the Shake Effect completes.
 *
 * @event Phaser.Cameras.Scene2D.Events#SHAKE_COMPLETE
 * @since 3.3.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.Shake} effect - A reference to the effect instance.
 */t.exports="camerashakecomplete"}),r("7IcGB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Shake Start Event.
 * 
 * This event is dispatched by a Camera instance when the Shake Effect starts.
 *
 * @event Phaser.Cameras.Scene2D.Events#SHAKE_START
 * @since 3.3.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.Shake} effect - A reference to the effect instance.
 * @param {integer} duration - The duration of the effect.
 * @param {number} intensity - The intensity of the effect.
 */t.exports="camerashakestart"}),r("2wQfp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Zoom Complete Event.
 * 
 * This event is dispatched by a Camera instance when the Zoom Effect completes.
 *
 * @event Phaser.Cameras.Scene2D.Events#ZOOM_COMPLETE
 * @since 3.3.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.Zoom} effect - A reference to the effect instance.
 */t.exports="camerazoomcomplete"}),r("cMBby",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Camera Zoom Start Event.
 * 
 * This event is dispatched by a Camera instance when the Zoom Effect starts.
 *
 * @event Phaser.Cameras.Scene2D.Events#ZOOM_START
 * @since 3.3.0
 * 
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.
 * @param {Phaser.Cameras.Scene2D.Effects.Zoom} effect - A reference to the effect instance.
 * @param {integer} duration - The duration of the effect.
 * @param {number} zoom - The destination zoom value.
 */t.exports="camerazoomstart"}),r("iYnst",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("geCzd"),n=s("bAeWh"),r=s("1xsnc"),o=s("8lcCL");t.exports=function(t){switch(typeof t){case"string":if("rgb"===t.substr(0,3).toLowerCase())return o(t);return i(t);case"number":return n(t);case"object":return r(t)}}}),r("geCzd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("pqNJR");t.exports=function(t){var e=new i;// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
t=t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i,function(t,e,i,n){return e+e+i+i+n+n});var n=/^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);if(n){var s=parseInt(n[1],16),r=parseInt(n[2],16),o=parseInt(n[3],16);e.setTo(s,r,o)}return e}}),r("pqNJR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("hqJVB"),r=s("cEpdV"),o=s("1jgzS"),a=s("hM4Fo"),h=new i({initialize:function(t,e,i,n){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=255),/**
         * The internal red color value.
         *
         * @name Phaser.Display.Color#r
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this.r=0,/**
         * The internal green color value.
         *
         * @name Phaser.Display.Color#g
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this.g=0,/**
         * The internal blue color value.
         *
         * @name Phaser.Display.Color#b
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this.b=0,/**
         * The internal alpha color value.
         *
         * @name Phaser.Display.Color#a
         * @type {number}
         * @private
         * @default 255
         * @since 3.0.0
         */this.a=255,/**
         * The hue color value. A number between 0 and 1.
         * This is the base color.
         *
         * @name Phaser.Display.Color#_h
         * @type {number}
         * @default 0
         * @private
         * @since 3.13.0
         */this._h=0,/**
         * The saturation color value. A number between 0 and 1.
         * This controls how much of the hue will be in the final color, where 1 is fully saturated and 0 will give you white.
         *
         * @name Phaser.Display.Color#_s
         * @type {number}
         * @default 0
         * @private
         * @since 3.13.0
         */this._s=0,/**
         * The lightness color value. A number between 0 and 1.
         * This controls how dark the color is. Where 1 is as bright as possible and 0 is black.
         *
         * @name Phaser.Display.Color#_v
         * @type {number}
         * @default 0
         * @private
         * @since 3.13.0
         */this._v=0,/**
         * Is this color update locked?
         *
         * @name Phaser.Display.Color#_locked
         * @type {boolean}
         * @private
         * @since 3.13.0
         */this._locked=!1,/**
         * An array containing the calculated color values for WebGL use.
         *
         * @name Phaser.Display.Color#gl
         * @type {number[]}
         * @since 3.0.0
         */this.gl=[0,0,0,1],/**
         * Pre-calculated internal color value.
         *
         * @name Phaser.Display.Color#_color
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._color=0,/**
         * Pre-calculated internal color32 value.
         *
         * @name Phaser.Display.Color#_color32
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._color32=0,/**
         * Pre-calculated internal color rgb string value.
         *
         * @name Phaser.Display.Color#_rgba
         * @type {string}
         * @private
         * @default ''
         * @since 3.0.0
         */this._rgba="",this.setTo(t,e,i,n)},/**
     * Sets this color to be transparent. Sets all values to zero.
     *
     * @method Phaser.Display.Color#transparent
     * @since 3.0.0
     *
     * @return {Phaser.Display.Color} This Color object.
     */transparent:function(){return this._locked=!0,this.red=0,this.green=0,this.blue=0,this.alpha=0,this._locked=!1,this.update(!0)},/**
     * Sets the color of this Color component.
     *
     * @method Phaser.Display.Color#setTo
     * @since 3.0.0
     *
     * @param {integer} red - The red color value. A number between 0 and 255.
     * @param {integer} green - The green color value. A number between 0 and 255.
     * @param {integer} blue - The blue color value. A number between 0 and 255.
     * @param {integer} [alpha=255] - The alpha value. A number between 0 and 255.
     * @param {boolean} [updateHSV=true] - Update the HSV values after setting the RGB values?
     *
     * @return {Phaser.Display.Color} This Color object.
     */setTo:function(t,e,i,n,s){return void 0===n&&(n=255),void 0===s&&(s=!0),this._locked=!0,this.red=t,this.green=e,this.blue=i,this.alpha=n,this._locked=!1,this.update(s)},/**
     * Sets the red, green, blue and alpha GL values of this Color component.
     *
     * @method Phaser.Display.Color#setGLTo
     * @since 3.0.0
     *
     * @param {number} red - The red color value. A number between 0 and 1.
     * @param {number} green - The green color value. A number between 0 and 1.
     * @param {number} blue - The blue color value. A number between 0 and 1.
     * @param {number} [alpha=1] - The alpha value. A number between 0 and 1.
     *
     * @return {Phaser.Display.Color} This Color object.
     */setGLTo:function(t,e,i,n){return void 0===n&&(n=1),this._locked=!0,this.redGL=t,this.greenGL=e,this.blueGL=i,this.alphaGL=n,this._locked=!1,this.update(!0)},/**
     * Sets the color based on the color object given.
     *
     * @method Phaser.Display.Color#setFromRGB
     * @since 3.0.0
     *
     * @param {Phaser.Types.Display.InputColorObject} color - An object containing `r`, `g`, `b` and optionally `a` values in the range 0 to 255.
     *
     * @return {Phaser.Display.Color} This Color object.
     */setFromRGB:function(t){return this._locked=!0,this.red=t.r,this.green=t.g,this.blue=t.b,t.hasOwnProperty("a")&&(this.alpha=t.a),this._locked=!1,this.update(!0)},/**
     * Sets the color based on the hue, saturation and lightness values given.
     *
     * @method Phaser.Display.Color#setFromHSV
     * @since 3.13.0
     *
     * @param {number} h - The hue, in the range 0 - 1. This is the base color.
     * @param {number} s - The saturation, in the range 0 - 1. This controls how much of the hue will be in the final color, where 1 is fully saturated and 0 will give you white.
     * @param {number} v - The value, in the range 0 - 1. This controls how dark the color is. Where 1 is as bright as possible and 0 is black.
     *
     * @return {Phaser.Display.Color} This Color object.
     */setFromHSV:function(t,e,i){return o(t,e,i,this)},/**
     * Updates the internal cache values.
     *
     * @method Phaser.Display.Color#update
     * @private
     * @since 3.0.0
     *
     * @return {Phaser.Display.Color} This Color object.
     */update:function(t){if(void 0===t&&(t=!1),this._locked)return this;var e=this.r,i=this.g,s=this.b,o=this.a;return this._color=n(e,i,s),this._color32=r(e,i,s,o),this._rgba="rgba("+e+","+i+","+s+","+o/255+")",t&&a(e,i,s,this),this},/**
     * Updates the internal hsv cache values.
     *
     * @method Phaser.Display.Color#updateHSV
     * @private
     * @since 3.13.0
     *
     * @return {Phaser.Display.Color} This Color object.
     */updateHSV:function(){return a(this.r,this.g,this.b,this),this},/**
     * Returns a new Color component using the values from this one.
     *
     * @method Phaser.Display.Color#clone
     * @since 3.0.0
     *
     * @return {Phaser.Display.Color} A new Color object.
     */clone:function(){return new h(this.r,this.g,this.b,this.a)},/**
     * Sets this Color object to be grayscaled based on the shade value given.
     *
     * @method Phaser.Display.Color#gray
     * @since 3.13.0
     * 
     * @param {integer} shade - A value between 0 and 255.
     *
     * @return {Phaser.Display.Color} This Color object.
     */gray:function(t){return this.setTo(t,t,t)},/**
     * Sets this Color object to be a random color between the `min` and `max` values given.
     *
     * @method Phaser.Display.Color#random
     * @since 3.13.0
     * 
     * @param {integer} [min=0] - The minimum random color value. Between 0 and 255.
     * @param {integer} [max=255] - The maximum random color value. Between 0 and 255.
     *
     * @return {Phaser.Display.Color} This Color object.
     */random:function(t,e){void 0===t&&(t=0),void 0===e&&(e=255);var i=Math.floor(t+Math.random()*(e-t)),n=Math.floor(t+Math.random()*(e-t)),s=Math.floor(t+Math.random()*(e-t));return this.setTo(i,n,s)},/**
     * Sets this Color object to be a random grayscale color between the `min` and `max` values given.
     *
     * @method Phaser.Display.Color#randomGray
     * @since 3.13.0
     * 
     * @param {integer} [min=0] - The minimum random color value. Between 0 and 255.
     * @param {integer} [max=255] - The maximum random color value. Between 0 and 255.
     *
     * @return {Phaser.Display.Color} This Color object.
     */randomGray:function(t,e){void 0===t&&(t=0),void 0===e&&(e=255);var i=Math.floor(t+Math.random()*(e-t));return this.setTo(i,i,i)},/**
     * Increase the saturation of this Color by the percentage amount given.
     * The saturation is the amount of the base color in the hue.
     *
     * @method Phaser.Display.Color#saturate
     * @since 3.13.0
     * 
     * @param {integer} amount - The percentage amount to change this color by. A value between 0 and 100.
     *
     * @return {Phaser.Display.Color} This Color object.
     */saturate:function(t){return this.s+=t/100,this},/**
     * Decrease the saturation of this Color by the percentage amount given.
     * The saturation is the amount of the base color in the hue.
     *
     * @method Phaser.Display.Color#desaturate
     * @since 3.13.0
     * 
     * @param {integer} amount - The percentage amount to change this color by. A value between 0 and 100.
     *
     * @return {Phaser.Display.Color} This Color object.
     */desaturate:function(t){return this.s-=t/100,this},/**
     * Increase the lightness of this Color by the percentage amount given.
     *
     * @method Phaser.Display.Color#lighten
     * @since 3.13.0
     * 
     * @param {integer} amount - The percentage amount to change this color by. A value between 0 and 100.
     *
     * @return {Phaser.Display.Color} This Color object.
     */lighten:function(t){return this.v+=t/100,this},/**
     * Decrease the lightness of this Color by the percentage amount given.
     *
     * @method Phaser.Display.Color#darken
     * @since 3.13.0
     * 
     * @param {integer} amount - The percentage amount to change this color by. A value between 0 and 100.
     *
     * @return {Phaser.Display.Color} This Color object.
     */darken:function(t){return this.v-=t/100,this},/**
     * Brighten this Color by the percentage amount given.
     *
     * @method Phaser.Display.Color#brighten
     * @since 3.13.0
     * 
     * @param {integer} amount - The percentage amount to change this color by. A value between 0 and 100.
     *
     * @return {Phaser.Display.Color} This Color object.
     */brighten:function(t){var e=this.r,i=this.g,n=this.b;return e=Math.max(0,Math.min(255,e-Math.round(-(255*(t/100))))),i=Math.max(0,Math.min(255,i-Math.round(-(255*(t/100))))),n=Math.max(0,Math.min(255,n-Math.round(-(255*(t/100))))),this.setTo(e,i,n)},/**
     * The color of this Color component, not including the alpha channel.
     *
     * @name Phaser.Display.Color#color
     * @type {number}
     * @readonly
     * @since 3.0.0
     */color:{get:function(){return this._color}},/**
     * The color of this Color component, including the alpha channel.
     *
     * @name Phaser.Display.Color#color32
     * @type {number}
     * @readonly
     * @since 3.0.0
     */color32:{get:function(){return this._color32}},/**
     * The color of this Color component as a string which can be used in CSS color values.
     *
     * @name Phaser.Display.Color#rgba
     * @type {string}
     * @readonly
     * @since 3.0.0
     */rgba:{get:function(){return this._rgba}},/**
     * The red color value, normalized to the range 0 to 1.
     *
     * @name Phaser.Display.Color#redGL
     * @type {number}
     * @since 3.0.0
     */redGL:{get:function(){return this.gl[0]},set:function(t){this.gl[0]=Math.min(Math.abs(t),1),this.r=Math.floor(255*this.gl[0]),this.update(!0)}},/**
     * The green color value, normalized to the range 0 to 1.
     *
     * @name Phaser.Display.Color#greenGL
     * @type {number}
     * @since 3.0.0
     */greenGL:{get:function(){return this.gl[1]},set:function(t){this.gl[1]=Math.min(Math.abs(t),1),this.g=Math.floor(255*this.gl[1]),this.update(!0)}},/**
     * The blue color value, normalized to the range 0 to 1.
     *
     * @name Phaser.Display.Color#blueGL
     * @type {number}
     * @since 3.0.0
     */blueGL:{get:function(){return this.gl[2]},set:function(t){this.gl[2]=Math.min(Math.abs(t),1),this.b=Math.floor(255*this.gl[2]),this.update(!0)}},/**
     * The alpha color value, normalized to the range 0 to 1.
     *
     * @name Phaser.Display.Color#alphaGL
     * @type {number}
     * @since 3.0.0
     */alphaGL:{get:function(){return this.gl[3]},set:function(t){this.gl[3]=Math.min(Math.abs(t),1),this.a=Math.floor(255*this.gl[3]),this.update()}},/**
     * The red color value, normalized to the range 0 to 255.
     *
     * @name Phaser.Display.Color#red
     * @type {number}
     * @since 3.0.0
     */red:{get:function(){return this.r},set:function(t){t=Math.floor(Math.abs(t)),this.r=Math.min(t,255),this.gl[0]=t/255,this.update(!0)}},/**
     * The green color value, normalized to the range 0 to 255.
     *
     * @name Phaser.Display.Color#green
     * @type {number}
     * @since 3.0.0
     */green:{get:function(){return this.g},set:function(t){t=Math.floor(Math.abs(t)),this.g=Math.min(t,255),this.gl[1]=t/255,this.update(!0)}},/**
     * The blue color value, normalized to the range 0 to 255.
     *
     * @name Phaser.Display.Color#blue
     * @type {number}
     * @since 3.0.0
     */blue:{get:function(){return this.b},set:function(t){t=Math.floor(Math.abs(t)),this.b=Math.min(t,255),this.gl[2]=t/255,this.update(!0)}},/**
     * The alpha color value, normalized to the range 0 to 255.
     *
     * @name Phaser.Display.Color#alpha
     * @type {number}
     * @since 3.0.0
     */alpha:{get:function(){return this.a},set:function(t){t=Math.floor(Math.abs(t)),this.a=Math.min(t,255),this.gl[3]=t/255,this.update()}},/**
     * The hue color value. A number between 0 and 1.
     * This is the base color.
     *
     * @name Phaser.Display.Color#h
     * @type {number}
     * @since 3.13.0
     */h:{get:function(){return this._h},set:function(t){this._h=t,o(t,this._s,this._v,this)}},/**
     * The saturation color value. A number between 0 and 1.
     * This controls how much of the hue will be in the final color, where 1 is fully saturated and 0 will give you white.
     *
     * @name Phaser.Display.Color#s
     * @type {number}
     * @since 3.13.0
     */s:{get:function(){return this._s},set:function(t){this._s=t,o(this._h,t,this._v,this)}},/**
     * The lightness color value. A number between 0 and 1.
     * This controls how dark the color is. Where 1 is as bright as possible and 0 is black.
     *
     * @name Phaser.Display.Color#v
     * @type {number}
     * @since 3.13.0
     */v:{get:function(){return this._v},set:function(t){this._v=t,o(this._h,this._s,t,this)}}});t.exports=h}),r("hqJVB",function(t,e){t.exports=function(t,e,i){return t<<16|e<<8|i}}),r("cEpdV",function(t,e){t.exports=function(t,e,i,n){return n<<24|t<<16|e<<8|i}}),r("1jgzS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hqJVB");t.exports=function(t,e,n,s){void 0===e&&(e=1),void 0===n&&(n=1);var r=Math.floor(6*t),o=6*t-r,a=Math.floor(n*(1-e)*255),h=Math.floor(n*(1-o*e)*255),l=Math.floor(n*(1-(1-o)*e)*255),u=n=Math.floor(n*=255),c=n,d=n,f=r%6;return(0===f?(c=l,d=a):1===f?(u=h,d=a):2===f?(u=a,d=l):3===f?(u=a,c=h):4===f?(u=l,c=a):5===f&&(c=a,d=h),s)?s.setTo?s.setTo(u,c,d,s.alpha,!1):(s.r=u,s.g=c,s.b=d,s.color=i(u,c,d),s):{r:u,g:c,b:d,color:i(u,c,d)}}}),r("hM4Fo",function(t,e){t.exports=function(t,e,i,n){void 0===n&&(n={h:0,s:0,v:0});var s=Math.min(t/=255,e/=255,i/=255),r=Math.max(t,e,i),o=r-s,a=0,h=0===r?0:o/r;return r!==s&&(r===t?a=(e-i)/o+(e<i?6:0):r===e?a=(i-t)/o+2:r===i&&(a=(t-e)/o+4),a/=6),n.hasOwnProperty("_h")?(n._h=a,n._s=h,n._v=r):(n.h=a,n.s=h,n.v=r),n}}),r("bAeWh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("pqNJR"),n=s("3sQbm");t.exports=function(t){var e=n(t);return new i(e.r,e.g,e.b,e.a)}}),r("3sQbm",function(t,e){t.exports=function(t){return t>16777215?{a:t>>>24,r:t>>16&255,g:t>>8&255,b:255&t}:{a:255,r:t>>16&255,g:t>>8&255,b:255&t}}}),r("1xsnc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("pqNJR");t.exports=function(t){return new i(t.r,t.g,t.b,t.a)}}),r("8lcCL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("pqNJR");t.exports=function(t){var e=new i,n=/^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t.toLowerCase());if(n){var s=parseInt(n[1],10),r=parseInt(n[2],10),o=parseInt(n[3],10),a=void 0!==n[4]?parseFloat(n[4]):1;e.setTo(s,r,o,255*a)}return e}}),r("kKoer",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i,n,r,o=s("bRAqZ"),a=s("g0MK9"),h=[],l=!1;//  If we export the called function here, it'll only be invoked once (not every time it's required).
t.exports=(i=function(t,e,i,s,r){void 0===e&&(e=1),void 0===i&&(i=1),void 0===s&&(s=o.CANVAS),void 0===r&&(r=!1);var u,c=n(s);return null===c?(c={parent:t,canvas:document.createElement("canvas"),type:s},s===o.CANVAS&&h.push(c)):c.parent=t,u=c.canvas,r&&(c.parent=u),u.width=e,u.height=i,l&&s===o.CANVAS&&a.disable(u.getContext("2d")),u},n=function(t){if(void 0===t&&(t=o.CANVAS),t===o.WEBGL)return null;for(var e=0;e<h.length;e++){var i=h[e];if(!i.parent&&i.type===t)return i}return null},r=function(){var t=0;return h.forEach(function(e){e.parent&&t++}),t},{create2D:function(t,e,n){return i(t,e,n,o.CANVAS)},create:i,createWebGL:function(t,e,n){return i(t,e,n,o.WEBGL)},disableSmoothing:function(){l=!0},enableSmoothing:function(){l=!1},first:n,free:function(){return h.length-r()},pool:h,remove:function(t){//  Check to see if the parent is a canvas object
var e=t instanceof HTMLCanvasElement;h.forEach(function(i){(e&&i.canvas===t||!e&&i.parent===t)&&(i.parent=null,i.canvas.width=1,i.canvas.height=1)})},total:r})}),r("bRAqZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * Global constants.
 * 
 * @ignore
 */var i={/**
     * Phaser Release Version
     * 
     * @name Phaser.VERSION
     * @const
     * @type {string}
     * @since 3.0.0
     */VERSION:"3.23.0",BlendModes:s("3qUcC"),ScaleModes:s("1iebW"),/**
     * AUTO Detect Renderer.
     * 
     * @name Phaser.AUTO
     * @const
     * @type {integer}
     * @since 3.0.0
     */AUTO:0,/**
     * Canvas Renderer.
     * 
     * @name Phaser.CANVAS
     * @const
     * @type {integer}
     * @since 3.0.0
     */CANVAS:1,/**
     * WebGL Renderer.
     * 
     * @name Phaser.WEBGL
     * @const
     * @type {integer}
     * @since 3.0.0
     */WEBGL:2,/**
     * Headless Renderer.
     * 
     * @name Phaser.HEADLESS
     * @const
     * @type {integer}
     * @since 3.0.0
     */HEADLESS:3,/**
     * In Phaser the value -1 means 'forever' in lots of cases, this const allows you to use it instead
     * to help you remember what the value is doing in your code.
     * 
     * @name Phaser.FOREVER
     * @const
     * @type {integer}
     * @since 3.0.0
     */FOREVER:-1,/**
     * Direction constant.
     * 
     * @name Phaser.NONE
     * @const
     * @type {integer}
     * @since 3.0.0
     */NONE:4,/**
     * Direction constant.
     * 
     * @name Phaser.UP
     * @const
     * @type {integer}
     * @since 3.0.0
     */UP:5,/**
     * Direction constant.
     * 
     * @name Phaser.DOWN
     * @const
     * @type {integer}
     * @since 3.0.0
     */DOWN:6,/**
     * Direction constant.
     * 
     * @name Phaser.LEFT
     * @const
     * @type {integer}
     * @since 3.0.0
     */LEFT:7,/**
     * Direction constant.
     * 
     * @name Phaser.RIGHT
     * @const
     * @type {integer}
     * @since 3.0.0
     */RIGHT:8};t.exports=i}),r("g0MK9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  Browser specific prefix, so not going to change between contexts, only between browsers
var i,n="";t.exports={disable:function(t){return""===n&&(n=i(t)),n&&(t[n]=!1),t},enable:function(t){return""===n&&(n=i(t)),n&&(t[n]=!0),t},getPrefix:i=function(t){for(var e=["i","webkitI","msI","mozI","oI"],i=0;i<e.length;i++){var n=e[i]+"mageSmoothingEnabled";if(n in t)return n}return null},isEnabled:function(t){return null!==n?t[n]:null}}}),r("ilLbF",function(t,e){t.exports=function(t,e,i){return t.x=e-t.width/2,t.y=i-t.height/2,t}}),r("u1TTd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Cameras.Scene2D.Effects
 */t.exports={Fade:s("dd81i"),Flash:s("bBkIL"),Pan:s("bxzLN"),Shake:s("gQwPG"),RotateTo:s("7jxKn"),Zoom:s("03SWf")}}),r("dd81i",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iEUUO"),n=s("jwj1g"),r=s("3xxp2"),o=new n({initialize:function(t){/**
         * The Camera this effect belongs to.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#camera
         * @type {Phaser.Cameras.Scene2D.Camera}
         * @readonly
         * @since 3.5.0
         */this.camera=t,/**
         * Is this effect actively running?
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#isRunning
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.5.0
         */this.isRunning=!1,/**
         * Has this effect finished running?
         *
         * This is different from `isRunning` because it remains set to `true` when the effect is over,
         * until the effect is either reset or started again.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#isComplete
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.5.0
         */this.isComplete=!1,/**
         * The direction of the fade.
         * `true` = fade out (transparent to color), `false` = fade in (color to transparent)
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#direction
         * @type {boolean}
         * @readonly
         * @since 3.5.0
         */this.direction=!0,/**
         * The duration of the effect, in milliseconds.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#duration
         * @type {integer}
         * @readonly
         * @default 0
         * @since 3.5.0
         */this.duration=0,/**
         * The value of the red color channel the camera will use for the fade effect.
         * A value between 0 and 255.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#red
         * @type {integer}
         * @private
         * @since 3.5.0
         */this.red=0,/**
         * The value of the green color channel the camera will use for the fade effect.
         * A value between 0 and 255.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#green
         * @type {integer}
         * @private
         * @since 3.5.0
         */this.green=0,/**
         * The value of the blue color channel the camera will use for the fade effect.
         * A value between 0 and 255.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#blue
         * @type {integer}
         * @private
         * @since 3.5.0
         */this.blue=0,/**
         * The value of the alpha channel used during the fade effect.
         * A value between 0 and 1.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#alpha
         * @type {number}
         * @private
         * @since 3.5.0
         */this.alpha=0,/**
         * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#progress
         * @type {number}
         * @since 3.5.0
         */this.progress=0,/**
         * Effect elapsed timer.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#_elapsed
         * @type {number}
         * @private
         * @since 3.5.0
         */this._elapsed=0,/**
         * This callback is invoked every frame for the duration of the effect.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#_onUpdate
         * @type {?Phaser.Types.Cameras.Scene2D.CameraFadeCallback}
         * @private
         * @default null
         * @since 3.5.0
         */this._onUpdate,/**
         * On Complete callback scope.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Fade#_onUpdateScope
         * @type {any}
         * @private
         * @since 3.5.0
         */this._onUpdateScope},/**
     * Fades the Camera to or from the given color over the duration specified.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Fade#start
     * @fires Phaser.Cameras.Scene2D.Events#FADE_IN_START
     * @fires Phaser.Cameras.Scene2D.Events#FADE_OUT_START
     * @since 3.5.0
     *
     * @param {boolean} [direction=true] - The direction of the fade. `true` = fade out (transparent to color), `false` = fade in (color to transparent)
     * @param {integer} [duration=1000] - The duration of the effect in milliseconds.
     * @param {integer} [red=0] - The amount to fade the red channel towards. A value between 0 and 255.
     * @param {integer} [green=0] - The amount to fade the green channel towards. A value between 0 and 255.
     * @param {integer} [blue=0] - The amount to fade the blue channel towards. A value between 0 and 255.
     * @param {boolean} [force=false] - Force the effect to start immediately, even if already running.
     * @param {Phaser.Types.Cameras.Scene2D.CameraFadeCallback} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {Phaser.Cameras.Scene2D.Camera} The Camera on which the effect was started.
     */start:function(t,e,i,n,s,o,a,h){if(void 0===t&&(t=!0),void 0===e&&(e=1e3),void 0===i&&(i=0),void 0===n&&(n=0),void 0===s&&(s=0),void 0===o&&(o=!1),void 0===a&&(a=null),void 0===h&&(h=this.camera.scene),!o&&this.isRunning)return this.camera;this.isRunning=!0,this.isComplete=!1,this.duration=e,this.direction=t,this.progress=0,this.red=i,this.green=n,this.blue=s,this.alpha=t?Number.MIN_VALUE:1,this._elapsed=0,this._onUpdate=a,this._onUpdateScope=h;var l=t?r.FADE_OUT_START:r.FADE_IN_START;return this.camera.emit(l,this.camera,this,e,i,n,s),this.camera},/**
     * The main update loop for this effect. Called automatically by the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Fade#update
     * @since 3.5.0
     *
     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */update:function(t,e){this.isRunning&&(this._elapsed+=e,this.progress=i(this._elapsed/this.duration,0,1),this._onUpdate&&this._onUpdate.call(this._onUpdateScope,this.camera,this.progress),this._elapsed<this.duration?this.alpha=this.direction?this.progress:1-this.progress:(this.alpha=this.direction?1:0,this.effectComplete()))},/**
     * Called internally by the Canvas Renderer.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Fade#postRenderCanvas
     * @since 3.5.0
     *
     * @param {CanvasRenderingContext2D} ctx - The Canvas context to render to.
     *
     * @return {boolean} `true` if the effect drew to the renderer, otherwise `false`.
     */postRenderCanvas:function(t){if(!this.isRunning&&!this.isComplete)return!1;var e=this.camera;return t.fillStyle="rgba("+this.red+","+this.green+","+this.blue+","+this.alpha+")",t.fillRect(e._cx,e._cy,e._cw,e._ch),!0},/**
     * Called internally by the WebGL Renderer.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Fade#postRenderWebGL
     * @since 3.5.0
     *
     * @param {Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline} pipeline - The WebGL Pipeline to render to.
     * @param {function} getTintFunction - A function that will return the gl safe tint colors.
     *
     * @return {boolean} `true` if the effect drew to the renderer, otherwise `false`.
     */postRenderWebGL:function(t,e){if(!this.isRunning&&!this.isComplete)return!1;var i=this.camera,n=this.red/255,s=this.blue/255,r=this.green/255;return t.drawFillRect(i._cx,i._cy,i._cw,i._ch,e(n,r,s,1),this.alpha),!0},/**
     * Called internally when the effect completes.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Fade#effectComplete
     * @fires Phaser.Cameras.Scene2D.Events#FADE_IN_COMPLETE
     * @fires Phaser.Cameras.Scene2D.Events#FADE_OUT_COMPLETE
     * @since 3.5.0
     */effectComplete:function(){this._onUpdate=null,this._onUpdateScope=null,this.isRunning=!1,this.isComplete=!0;var t=this.direction?r.FADE_OUT_COMPLETE:r.FADE_IN_COMPLETE;this.camera.emit(t,this.camera,this)},/**
     * Resets this camera effect.
     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Fade#reset
     * @since 3.5.0
     */reset:function(){this.isRunning=!1,this.isComplete=!1,this._onUpdate=null,this._onUpdateScope=null},/**
     * Destroys this effect, releasing it from the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Fade#destroy
     * @since 3.5.0
     */destroy:function(){this.reset(),this.camera=null}});t.exports=o}),r("bBkIL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iEUUO"),n=s("jwj1g"),r=s("3xxp2"),o=new n({initialize:function(t){/**
         * The Camera this effect belongs to.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Flash#camera
         * @type {Phaser.Cameras.Scene2D.Camera}
         * @readonly
         * @since 3.5.0
         */this.camera=t,/**
         * Is this effect actively running?
         *
         * @name Phaser.Cameras.Scene2D.Effects.Flash#isRunning
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.5.0
         */this.isRunning=!1,/**
         * The duration of the effect, in milliseconds.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Flash#duration
         * @type {integer}
         * @readonly
         * @default 0
         * @since 3.5.0
         */this.duration=0,/**
         * The value of the red color channel the camera will use for the fade effect.
         * A value between 0 and 255.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Flash#red
         * @type {integer}
         * @private
         * @since 3.5.0
         */this.red=0,/**
         * The value of the green color channel the camera will use for the fade effect.
         * A value between 0 and 255.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Flash#green
         * @type {integer}
         * @private
         * @since 3.5.0
         */this.green=0,/**
         * The value of the blue color channel the camera will use for the fade effect.
         * A value between 0 and 255.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Flash#blue
         * @type {integer}
         * @private
         * @since 3.5.0
         */this.blue=0,/**
         * The value of the alpha channel used during the fade effect.
         * A value between 0 and 1.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Flash#alpha
         * @type {number}
         * @private
         * @since 3.5.0
         */this.alpha=0,/**
         * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Flash#progress
         * @type {number}
         * @since 3.5.0
         */this.progress=0,/**
         * Effect elapsed timer.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Flash#_elapsed
         * @type {number}
         * @private
         * @since 3.5.0
         */this._elapsed=0,/**
         * This callback is invoked every frame for the duration of the effect.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Flash#_onUpdate
         * @type {?Phaser.Types.Cameras.Scene2D.CameraFlashCallback}
         * @private
         * @default null
         * @since 3.5.0
         */this._onUpdate,/**
         * On Complete callback scope.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Flash#_onUpdateScope
         * @type {any}
         * @private
         * @since 3.5.0
         */this._onUpdateScope},/**
     * Flashes the Camera to or from the given color over the duration specified.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Flash#start
     * @fires Phaser.Cameras.Scene2D.Events#FLASH_START
     * @fires Phaser.Cameras.Scene2D.Events#FLASH_COMPLETE
     * @since 3.5.0
     *
     * @param {integer} [duration=250] - The duration of the effect in milliseconds.
     * @param {integer} [red=255] - The amount to fade the red channel towards. A value between 0 and 255.
     * @param {integer} [green=255] - The amount to fade the green channel towards. A value between 0 and 255.
     * @param {integer} [blue=255] - The amount to fade the blue channel towards. A value between 0 and 255.
     * @param {boolean} [force=false] - Force the effect to start immediately, even if already running.
     * @param {Phaser.Types.Cameras.Scene2D.CameraFlashCallback} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {Phaser.Cameras.Scene2D.Camera} The Camera on which the effect was started.
     */start:function(t,e,i,n,s,o,a){return void 0===t&&(t=250),void 0===e&&(e=255),void 0===i&&(i=255),void 0===n&&(n=255),void 0===s&&(s=!1),void 0===o&&(o=null),void 0===a&&(a=this.camera.scene),!s&&this.isRunning||(this.isRunning=!0,this.duration=t,this.progress=0,this.red=e,this.green=i,this.blue=n,this.alpha=1,this._elapsed=0,this._onUpdate=o,this._onUpdateScope=a,this.camera.emit(r.FLASH_START,this.camera,this,t,e,i,n)),this.camera},/**
     * The main update loop for this effect. Called automatically by the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Flash#update
     * @since 3.5.0
     *
     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */update:function(t,e){this.isRunning&&(this._elapsed+=e,this.progress=i(this._elapsed/this.duration,0,1),this._onUpdate&&this._onUpdate.call(this._onUpdateScope,this.camera,this.progress),this._elapsed<this.duration?this.alpha=1-this.progress:this.effectComplete())},/**
     * Called internally by the Canvas Renderer.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Flash#postRenderCanvas
     * @since 3.5.0
     *
     * @param {CanvasRenderingContext2D} ctx - The Canvas context to render to.
     *
     * @return {boolean} `true` if the effect drew to the renderer, otherwise `false`.
     */postRenderCanvas:function(t){if(!this.isRunning)return!1;var e=this.camera;return t.fillStyle="rgba("+this.red+","+this.green+","+this.blue+","+this.alpha+")",t.fillRect(e._cx,e._cy,e._cw,e._ch),!0},/**
     * Called internally by the WebGL Renderer.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Flash#postRenderWebGL
     * @since 3.5.0
     *
     * @param {Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline} pipeline - The WebGL Pipeline to render to.
     * @param {function} getTintFunction - A function that will return the gl safe tint colors.
     *
     * @return {boolean} `true` if the effect drew to the renderer, otherwise `false`.
     */postRenderWebGL:function(t,e){if(!this.isRunning)return!1;var i=this.camera,n=this.red/255,s=this.blue/255,r=this.green/255;return t.drawFillRect(i._cx,i._cy,i._cw,i._ch,e(n,r,s,1),this.alpha),!0},/**
     * Called internally when the effect completes.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Flash#effectComplete
     * @fires Phaser.Cameras.Scene2D.Events#FLASH_COMPLETE
     * @since 3.5.0
     */effectComplete:function(){this._onUpdate=null,this._onUpdateScope=null,this.isRunning=!1,this.camera.emit(r.FLASH_COMPLETE,this.camera,this)},/**
     * Resets this camera effect.
     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Flash#reset
     * @since 3.5.0
     */reset:function(){this.isRunning=!1,this._onUpdate=null,this._onUpdateScope=null},/**
     * Destroys this effect, releasing it from the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Flash#destroy
     * @since 3.5.0
     */destroy:function(){this.reset(),this.camera=null}});t.exports=o}),r("bxzLN",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iEUUO"),n=s("jwj1g"),r=s("cV9mL"),o=s("3xxp2"),a=s("7SBSk"),h=new n({initialize:function(t){/**
         * The Camera this effect belongs to.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Pan#camera
         * @type {Phaser.Cameras.Scene2D.Camera}
         * @readonly
         * @since 3.11.0
         */this.camera=t,/**
         * Is this effect actively running?
         *
         * @name Phaser.Cameras.Scene2D.Effects.Pan#isRunning
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.11.0
         */this.isRunning=!1,/**
         * The duration of the effect, in milliseconds.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Pan#duration
         * @type {integer}
         * @readonly
         * @default 0
         * @since 3.11.0
         */this.duration=0,/**
         * The starting scroll coordinates to pan the camera from.
         * 
         * @name Phaser.Cameras.Scene2D.Effects.Pan#source
         * @type {Phaser.Math.Vector2}
         * @since 3.11.0
         */this.source=new a,/**
         * The constantly updated value based on zoom.
         * 
         * @name Phaser.Cameras.Scene2D.Effects.Pan#current
         * @type {Phaser.Math.Vector2}
         * @since 3.11.0
         */this.current=new a,/**
         * The destination scroll coordinates to pan the camera to.
         * 
         * @name Phaser.Cameras.Scene2D.Effects.Pan#destination
         * @type {Phaser.Math.Vector2}
         * @since 3.11.0
         */this.destination=new a,/**
         * The ease function to use during the pan.
         * 
         * @name Phaser.Cameras.Scene2D.Effects.Pan#ease
         * @type {function}
         * @since 3.11.0
         */this.ease,/**
         * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Pan#progress
         * @type {number}
         * @since 3.11.0
         */this.progress=0,/**
         * Effect elapsed timer.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Pan#_elapsed
         * @type {number}
         * @private
         * @since 3.11.0
         */this._elapsed=0,/**
         * This callback is invoked every frame for the duration of the effect.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Pan#_onUpdate
         * @type {?Phaser.Types.Cameras.Scene2D.CameraPanCallback}
         * @private
         * @default null
         * @since 3.11.0
         */this._onUpdate,/**
         * On Complete callback scope.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Pan#_onUpdateScope
         * @type {any}
         * @private
         * @since 3.11.0
         */this._onUpdateScope},/**
     * This effect will scroll the Camera so that the center of its viewport finishes at the given destination,
     * over the duration and with the ease specified.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Pan#start
     * @fires Phaser.Cameras.Scene2D.Events#PAN_START
     * @fires Phaser.Cameras.Scene2D.Events#PAN_COMPLETE
     * @since 3.11.0
     *
     * @param {number} x - The destination x coordinate to scroll the center of the Camera viewport to.
     * @param {number} y - The destination y coordinate to scroll the center of the Camera viewport to.
     * @param {integer} [duration=1000] - The duration of the effect in milliseconds.
     * @param {(string|function)} [ease='Linear'] - The ease to use for the pan. Can be any of the Phaser Easing constants or a custom function.
     * @param {boolean} [force=false] - Force the pan effect to start immediately, even if already running.
     * @param {Phaser.Types.Cameras.Scene2D.CameraPanCallback} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
     * the current camera scroll x coordinate and the current camera scroll y coordinate.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {Phaser.Cameras.Scene2D.Camera} The Camera on which the effect was started.
     */start:function(t,e,i,n,s,a,h){void 0===i&&(i=1e3),void 0===n&&(n=r.Linear),void 0===s&&(s=!1),void 0===a&&(a=null),void 0===h&&(h=this.camera.scene);var l=this.camera;return!s&&this.isRunning||(this.isRunning=!0,this.duration=i,this.progress=0,//  Starting from
this.source.set(l.scrollX,l.scrollY),//  Destination
this.destination.set(t,e),//  Zoom factored version
l.getScroll(t,e,this.current),"string"==typeof n&&r.hasOwnProperty(n)?this.ease=r[n]:"function"==typeof n&&(this.ease=n),this._elapsed=0,this._onUpdate=a,this._onUpdateScope=h,this.camera.emit(o.PAN_START,this.camera,this,i,t,e)),l},/**
     * The main update loop for this effect. Called automatically by the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Pan#update
     * @since 3.11.0
     *
     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */update:function(t,e){if(this.isRunning){this._elapsed+=e;var n=i(this._elapsed/this.duration,0,1);this.progress=n;var s=this.camera;if(this._elapsed<this.duration){var r=this.ease(n);s.getScroll(this.destination.x,this.destination.y,this.current);var o=this.source.x+(this.current.x-this.source.x)*r,a=this.source.y+(this.current.y-this.source.y)*r;s.setScroll(o,a),this._onUpdate&&this._onUpdate.call(this._onUpdateScope,s,n,o,a)}else s.centerOn(this.destination.x,this.destination.y),this._onUpdate&&this._onUpdate.call(this._onUpdateScope,s,n,s.scrollX,s.scrollY),this.effectComplete()}},/**
     * Called internally when the effect completes.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Pan#effectComplete
     * @fires Phaser.Cameras.Scene2D.Events#PAN_COMPLETE
     * @since 3.11.0
     */effectComplete:function(){this._onUpdate=null,this._onUpdateScope=null,this.isRunning=!1,this.camera.emit(o.PAN_COMPLETE,this.camera,this)},/**
     * Resets this camera effect.
     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Pan#reset
     * @since 3.11.0
     */reset:function(){this.isRunning=!1,this._onUpdate=null,this._onUpdateScope=null},/**
     * Destroys this effect, releasing it from the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Pan#destroy
     * @since 3.11.0
     */destroy:function(){this.reset(),this.camera=null,this.source=null,this.destination=null}});t.exports=h}),r("cV9mL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("GYEL3"),n=s("1RSgF"),r=s("8s9Sd"),o=s("aG266"),a=s("jDd1d"),h=s("gZBzc"),l=s("hBgCe"),u=s("c4phQ"),c=s("czPB4"),d=s("2NYh6"),f=s("filII"),p=s("dfXsE");//  EaseMap
t.exports={Power0:l,Power1:u.Out,Power2:o.Out,Power3:c.Out,Power4:d.Out,Linear:l,Quad:u.Out,Cubic:o.Out,Quart:c.Out,Quint:d.Out,Sine:f.Out,Expo:h.Out,Circ:r.Out,Elastic:a.Out,Back:i.Out,Bounce:n.Out,Stepped:p,"Quad.easeIn":u.In,"Cubic.easeIn":o.In,"Quart.easeIn":c.In,"Quint.easeIn":d.In,"Sine.easeIn":f.In,"Expo.easeIn":h.In,"Circ.easeIn":r.In,"Elastic.easeIn":a.In,"Back.easeIn":i.In,"Bounce.easeIn":n.In,"Quad.easeOut":u.Out,"Cubic.easeOut":o.Out,"Quart.easeOut":c.Out,"Quint.easeOut":d.Out,"Sine.easeOut":f.Out,"Expo.easeOut":h.Out,"Circ.easeOut":r.Out,"Elastic.easeOut":a.Out,"Back.easeOut":i.Out,"Bounce.easeOut":n.Out,"Quad.easeInOut":u.InOut,"Cubic.easeInOut":o.InOut,"Quart.easeInOut":c.InOut,"Quint.easeInOut":d.InOut,"Sine.easeInOut":f.InOut,"Expo.easeInOut":h.InOut,"Circ.easeInOut":r.InOut,"Elastic.easeInOut":a.InOut,"Back.easeInOut":i.InOut,"Bounce.easeInOut":n.InOut}}),r("GYEL3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Easing.Back
 */t.exports={In:s("9spRF"),Out:s("a46ti"),InOut:s("iGiC8")}}),r("9spRF",function(t,e){t.exports=function(t,e){return void 0===e&&(e=1.70158),t*t*((e+1)*t-e)}}),r("a46ti",function(t,e){t.exports=function(t,e){return void 0===e&&(e=1.70158),--t*t*((e+1)*t+e)+1}}),r("iGiC8",function(t,e){t.exports=function(t,e){void 0===e&&(e=1.70158);var i=1.525*e;return(t*=2)<1?.5*(t*t*((i+1)*t-i)):.5*((t-=2)*t*((i+1)*t+i)+2)}}),r("1RSgF",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Easing.Bounce
 */t.exports={In:s("3L65E"),Out:s("lsJca"),InOut:s("2l0Bo")}}),r("3L65E",function(t,e){t.exports=function(t){return(t=1-t)<1/2.75?1-7.5625*t*t:t<2/2.75?1-(7.5625*(t-=1.5/2.75)*t+.75):t<2.5/2.75?1-(7.5625*(t-=2.25/2.75)*t+.9375):1-(7.5625*(t-=2.625/2.75)*t+.984375)}}),r("lsJca",function(t,e){t.exports=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}}),r("2l0Bo",function(t,e){t.exports=function(t){var e=!1;return(t<.5?(t=1-2*t,e=!0):t=2*t-1,t=t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375,e)?(1-t)*.5:.5*t+.5}}),r("8s9Sd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Easing.Circular
 */t.exports={In:s("63dis"),Out:s("6picE"),InOut:s("iT7wR")}}),r("63dis",function(t,e){t.exports=function(t){return 1-Math.sqrt(1-t*t)}}),r("6picE",function(t,e){t.exports=function(t){return Math.sqrt(1- --t*t)}}),r("iT7wR",function(t,e){t.exports=function(t){return(t*=2)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)}}),r("aG266",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Easing.Cubic
 */t.exports={In:s("hX2vA"),Out:s("46Nrr"),InOut:s("eg0YD")}}),r("hX2vA",function(t,e){t.exports=function(t){return t*t*t}}),r("46Nrr",function(t,e){t.exports=function(t){return--t*t*t+1}}),r("eg0YD",function(t,e){t.exports=function(t){return(t*=2)<1?.5*t*t*t:.5*((t-=2)*t*t+2)}}),r("jDd1d",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Easing.Elastic
 */t.exports={In:s("eE9kO"),Out:s("5ASGW"),InOut:s("bdwic")}}),r("eE9kO",function(t,e){t.exports=function(t,e,i){if(void 0===e&&(e=.1),void 0===i&&(i=.1),0===t)return 0;if(1===t)return 1;var n=i/4;return e<1?e=1:n=i*Math.asin(1/e)/(2*Math.PI),-(e*Math.pow(2,10*(t-=1))*Math.sin((t-n)*(2*Math.PI)/i))}}),r("5ASGW",function(t,e){t.exports=function(t,e,i){if(void 0===e&&(e=.1),void 0===i&&(i=.1),0===t)return 0;if(1===t)return 1;var n=i/4;return e<1?e=1:n=i*Math.asin(1/e)/(2*Math.PI),e*Math.pow(2,-10*t)*Math.sin((t-n)*(2*Math.PI)/i)+1}}),r("bdwic",function(t,e){t.exports=function(t,e,i){if(void 0===e&&(e=.1),void 0===i&&(i=.1),0===t)return 0;if(1===t)return 1;var n=i/4;return(e<1?e=1:n=i*Math.asin(1/e)/(2*Math.PI),(t*=2)<1)?-.5*(e*Math.pow(2,10*(t-=1))*Math.sin((t-n)*(2*Math.PI)/i)):e*Math.pow(2,-10*(t-=1))*Math.sin((t-n)*(2*Math.PI)/i)*.5+1}}),r("gZBzc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Easing.Expo
 */t.exports={In:s("dF0PL"),Out:s("5OkCs"),InOut:s("hHyCF")}}),r("dF0PL",function(t,e){t.exports=function(t){return Math.pow(2,10*(t-1))-.001}}),r("5OkCs",function(t,e){t.exports=function(t){return 1-Math.pow(2,-10*t)}}),r("hHyCF",function(t,e){t.exports=function(t){return(t*=2)<1?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*(t-1)))}}),r("hBgCe",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */t.exports=s("4yFp2")}),r("4yFp2",function(t,e){t.exports=function(t){return t}}),r("c4phQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Easing.Quadratic
 */t.exports={In:s("jfeqJ"),Out:s("b1jC2"),InOut:s("kxuux")}}),r("jfeqJ",function(t,e){t.exports=function(t){return t*t}}),r("b1jC2",function(t,e){t.exports=function(t){return t*(2-t)}}),r("kxuux",function(t,e){t.exports=function(t){return(t*=2)<1?.5*t*t:-.5*(--t*(t-2)-1)}}),r("czPB4",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Easing.Quartic
 */t.exports={In:s("lCzpM"),Out:s("5Sj7h"),InOut:s("76x8L")}}),r("lCzpM",function(t,e){t.exports=function(t){return t*t*t*t}}),r("5Sj7h",function(t,e){t.exports=function(t){return 1- --t*t*t*t}}),r("76x8L",function(t,e){t.exports=function(t){return(t*=2)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)}}),r("2NYh6",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Easing.Quintic
 */t.exports={In:s("8AT7r"),Out:s("i2cb2"),InOut:s("9vyIZ")}}),r("8AT7r",function(t,e){t.exports=function(t){return t*t*t*t*t}}),r("i2cb2",function(t,e){t.exports=function(t){return--t*t*t*t*t+1}}),r("9vyIZ",function(t,e){t.exports=function(t){return(t*=2)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)}}),r("filII",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Easing.Sine
 */t.exports={In:s("haOm3"),Out:s("43ZzW"),InOut:s("474j8")}}),r("haOm3",function(t,e){t.exports=function(t){return 0===t?0:1===t?1:1-Math.cos(t*Math.PI/2)}}),r("43ZzW",function(t,e){t.exports=function(t){return 0===t?0:1===t?1:Math.sin(t*Math.PI/2)}}),r("474j8",function(t,e){t.exports=function(t){return 0===t?0:1===t?1:.5*(1-Math.cos(Math.PI*t))}}),r("dfXsE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Easing.Stepped
 */t.exports=s("fLL1R")}),r("fLL1R",function(t,e){t.exports=function(t,e){return(void 0===e&&(e=1),t<=0)?0:t>=1?1:((e*t|0)+1)*(1/e)}}),r("gQwPG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iEUUO"),n=s("jwj1g"),r=s("3xxp2"),o=s("7SBSk"),a=new n({initialize:function(t){/**
         * The Camera this effect belongs to.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Shake#camera
         * @type {Phaser.Cameras.Scene2D.Camera}
         * @readonly
         * @since 3.5.0
         */this.camera=t,/**
         * Is this effect actively running?
         *
         * @name Phaser.Cameras.Scene2D.Effects.Shake#isRunning
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.5.0
         */this.isRunning=!1,/**
         * The duration of the effect, in milliseconds.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Shake#duration
         * @type {integer}
         * @readonly
         * @default 0
         * @since 3.5.0
         */this.duration=0,/**
         * The intensity of the effect. Use small float values. The default when the effect starts is 0.05.
         * This is a Vector2 object, allowing you to control the shake intensity independently across x and y.
         * You can modify this value while the effect is active to create more varied shake effects.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Shake#intensity
         * @type {Phaser.Math.Vector2}
         * @since 3.5.0
         */this.intensity=new o,/**
         * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Shake#progress
         * @type {number}
         * @since 3.5.0
         */this.progress=0,/**
         * Effect elapsed timer.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Shake#_elapsed
         * @type {number}
         * @private
         * @since 3.5.0
         */this._elapsed=0,/**
         * How much to offset the camera by horizontally.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Shake#_offsetX
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._offsetX=0,/**
         * How much to offset the camera by vertically.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Shake#_offsetY
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._offsetY=0,/**
         * This callback is invoked every frame for the duration of the effect.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Shake#_onUpdate
         * @type {?Phaser.Types.Cameras.Scene2D.CameraShakeCallback}
         * @private
         * @default null
         * @since 3.5.0
         */this._onUpdate,/**
         * On Complete callback scope.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Shake#_onUpdateScope
         * @type {any}
         * @private
         * @since 3.5.0
         */this._onUpdateScope},/**
     * Shakes the Camera by the given intensity over the duration specified.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Shake#start
     * @fires Phaser.Cameras.Scene2D.Events#SHAKE_START
     * @fires Phaser.Cameras.Scene2D.Events#SHAKE_COMPLETE
     * @since 3.5.0
     *
     * @param {integer} [duration=100] - The duration of the effect in milliseconds.
     * @param {(number|Phaser.Math.Vector2)} [intensity=0.05] - The intensity of the shake.
     * @param {boolean} [force=false] - Force the shake effect to start immediately, even if already running.
     * @param {Phaser.Types.Cameras.Scene2D.CameraShakeCallback} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {Phaser.Cameras.Scene2D.Camera} The Camera on which the effect was started.
     */start:function(t,e,i,n,s){return void 0===t&&(t=100),void 0===e&&(e=.05),void 0===i&&(i=!1),void 0===n&&(n=null),void 0===s&&(s=this.camera.scene),!i&&this.isRunning||(this.isRunning=!0,this.duration=t,this.progress=0,"number"==typeof e?this.intensity.set(e):this.intensity.set(e.x,e.y),this._elapsed=0,this._offsetX=0,this._offsetY=0,this._onUpdate=n,this._onUpdateScope=s,this.camera.emit(r.SHAKE_START,this.camera,this,t,e)),this.camera},/**
     * The pre-render step for this effect. Called automatically by the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Shake#preRender
     * @since 3.5.0
     */preRender:function(){this.isRunning&&this.camera.matrix.translate(this._offsetX,this._offsetY)},/**
     * The main update loop for this effect. Called automatically by the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Shake#update
     * @since 3.5.0
     *
     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */update:function(t,e){if(this.isRunning){if(this._elapsed+=e,this.progress=i(this._elapsed/this.duration,0,1),this._onUpdate&&this._onUpdate.call(this._onUpdateScope,this.camera,this.progress),this._elapsed<this.duration){var n=this.intensity,s=this.camera._cw,r=this.camera._ch,o=this.camera.zoom;this._offsetX=(Math.random()*n.x*s*2-n.x*s)*o,this._offsetY=(Math.random()*n.y*r*2-n.y*r)*o,this.camera.roundPixels&&(this._offsetX=Math.round(this._offsetX),this._offsetY=Math.round(this._offsetY))}else this.effectComplete()}},/**
     * Called internally when the effect completes.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Shake#effectComplete
     * @fires Phaser.Cameras.Scene2D.Events#SHAKE_COMPLETE
     * @since 3.5.0
     */effectComplete:function(){this._offsetX=0,this._offsetY=0,this._onUpdate=null,this._onUpdateScope=null,this.isRunning=!1,this.camera.emit(r.SHAKE_COMPLETE,this.camera,this)},/**
     * Resets this camera effect.
     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Shake#reset
     * @since 3.5.0
     */reset:function(){this.isRunning=!1,this._offsetX=0,this._offsetY=0,this._onUpdate=null,this._onUpdateScope=null},/**
     * Destroys this effect, releasing it from the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Shake#destroy
     * @since 3.5.0
     */destroy:function(){this.reset(),this.camera=null,this.intensity=null}});t.exports=a}),r("7jxKn",function(t,e){/**
 * @author       Jason Nicholls <nicholls.jason@gmail.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */var i=s("iEUUO"),n=s("jwj1g"),r=s("3xxp2"),o=s("cV9mL"),a=new n({initialize:function(t){/**
         * The Camera this effect belongs to.
         *
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#camera
         * @type {Phaser.Cameras.Scene2D.Camera}
         * @readonly
         * @since 3.23.0
         */this.camera=t,/**
         * Is this effect actively running?
         *
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#isRunning
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.23.0
         */this.isRunning=!1,/**
         * The duration of the effect, in milliseconds.
         *
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#duration
         * @type {integer}
         * @readonly
         * @default 0
         * @since 3.23.0
         */this.duration=0,/**
         * The starting angle to rotate the camera from.
         * 
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#source
         * @type {number}
         * @since 3.23.0
         */this.source=0,/**
         * The constantly updated value based on the force.
         * 
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#current
         * @type {number}
         * @since 3.23.0
         */this.current=0,/**
         * The destination angle in radians to rotate the camera to.
         * 
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#destination
         * @type {number}
         * @since 3.23.0
         */this.destination=0,/**
         * The ease function to use during the Rotate.
         * 
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#ease
         * @type {function}
         * @since 3.23.0
         */this.ease,/**
         * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
         *
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#progress
         * @type {number}
         * @since 3.23.0
         */this.progress=0,/**
         * Effect elapsed timer.
         *
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#_elapsed
         * @type {number}
         * @private
         * @since 3.23.0
         */this._elapsed=0,/**
         * @callback CameraRotateCallback
         *
         * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera on which the effect is running.
         * @param {number} progress - The progress of the effect. A value between 0 and 1.
         * @param {number} angle - The Camera's new angle in radians.
         *//**
         * This callback is invoked every frame for the duration of the effect.
         *
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#_onUpdate
         * @type {?CameraRotateCallback}
         * @private
         * @default null
         * @since 3.23.0
         */this._onUpdate,/**
         * On Complete callback scope.
         *
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#_onUpdateScope
         * @type {any}
         * @private
         * @since 3.23.0
         */this._onUpdateScope,/**
         * The direction of the rotation.
         * 
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#clockwise
         * @type {boolean}
         * @since 3.23.0
         */this.clockwise=!0,/**
         * The shortest direction to the target rotation.
         * 
         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#shortestPath
         * @type {boolean}
         * @since 3.23.0
         */this.shortestPath=!1},/**
     * This effect will scroll the Camera so that the center of its viewport finishes at the given angle,
     * over the duration and with the ease specified.
     *
     * @method Phaser.Cameras.Scene2D.Effects.RotateTo#start
     * @fires Phaser.Cameras.Scene2D.Events#ROTATE_START
     * @fires Phaser.Cameras.Scene2D.Events#ROTATE_COMPLETE
     * @since 3.23.0
     *
     * @param {number} radians - The destination angle in radians to rotate the Camera viewport to. If the angle is positive then the rotation is clockwise else anticlockwise
     * @param {boolean} [shortestPath=false] - If shortest path is set to true the camera will rotate in the quickest direction clockwise or anti-clockwise.
     * @param {integer} [duration=1000] - The duration of the effect in milliseconds.
     * @param {(string|function)} [ease='Linear'] - The ease to use for the Rotate. Can be any of the Phaser Easing constants or a custom function.
     * @param {boolean} [force=false] - Force the rotation effect to start immediately, even if already running.
     * @param {CameraRotateCallback} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
     * the current camera scroll x coordinate and the current camera scroll y coordinate.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {Phaser.Cameras.Scene2D.Camera} The Camera on which the effect was started.
     */start:function(t,e,i,n,s,a,h){void 0===i&&(i=1e3),void 0===n&&(n=o.Linear),void 0===s&&(s=!1),void 0===a&&(a=null),void 0===h&&(h=this.camera.scene),void 0===e&&(e=!1),this.shortestPath=e;var l=t;t<0?(l=-1*t,this.clockwise=!1):this.clockwise=!0;var u=360*Math.PI/180;l-=Math.floor(l/u)*u;var c=this.camera;if(!s&&this.isRunning)return c;if(this.isRunning=!0,this.duration=i,this.progress=0,//  Starting from
this.source=c.rotation,//  Destination
this.destination=l,"string"==typeof n&&o.hasOwnProperty(n)?this.ease=o[n]:"function"==typeof n&&(this.ease=n),this._elapsed=0,this._onUpdate=a,this._onUpdateScope=h,this.shortestPath){// The shortest path is true so calculate the quickest direction
var d=0,f=0;(d=this.destination>this.source?Math.abs(this.destination-this.source):Math.abs(this.destination+u)-this.source)<(f=this.source>this.destination?Math.abs(this.source-this.destination):Math.abs(this.source+u)-this.destination)?this.clockwise=!0:d>f&&(this.clockwise=!1)}return this.camera.emit(r.ROTATE_START,this.camera,this,i,l),c},/**
     * The main update loop for this effect. Called automatically by the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.RotateTo#update
     * @since 3.23.0
     *
     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */update:function(t,e){if(this.isRunning){this._elapsed+=e;var n=i(this._elapsed/this.duration,0,1);this.progress=n;var s=this.camera;if(this._elapsed<this.duration){var r=this.ease(n);this.current=s.rotation;var o=0,a=360*Math.PI/180,h=this.destination,l=this.current;!1===this.clockwise&&(h=this.current,l=this.destination),o=h>=l?Math.abs(h-l):Math.abs(h+a)-l;var u=0;u=this.clockwise?s.rotation+o*r:s.rotation-o*r,s.rotation=u,this._onUpdate&&this._onUpdate.call(this._onUpdateScope,s,n,u)}else s.rotation=this.destination,this._onUpdate&&this._onUpdate.call(this._onUpdateScope,s,n,this.destination),this.effectComplete()}},/**
     * Called internally when the effect completes.
     *
     * @method Phaser.Cameras.Scene2D.Effects.RotateTo#effectComplete
     * @since 3.23.0
     */effectComplete:function(){this._onUpdate=null,this._onUpdateScope=null,this.isRunning=!1,this.camera.emit(r.ROTATE_COMPLETE,this.camera,this)},/**
     * Resets this camera effect.
     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
     *
     * @method Phaser.Cameras.Scene2D.Effects.RotateTo#reset
     * @since 3.23.0
     */reset:function(){this.isRunning=!1,this._onUpdate=null,this._onUpdateScope=null},/**
     * Destroys this effect, releasing it from the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.RotateTo#destroy
     * @since 3.23.0
     */destroy:function(){this.reset(),this.camera=null,this.source=null,this.destination=null}});t.exports=a}),r("03SWf",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iEUUO"),n=s("jwj1g"),r=s("cV9mL"),o=s("3xxp2"),a=new n({initialize:function(t){/**
         * The Camera this effect belongs to.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Zoom#camera
         * @type {Phaser.Cameras.Scene2D.Camera}
         * @readonly
         * @since 3.11.0
         */this.camera=t,/**
         * Is this effect actively running?
         *
         * @name Phaser.Cameras.Scene2D.Effects.Zoom#isRunning
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.11.0
         */this.isRunning=!1,/**
         * The duration of the effect, in milliseconds.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Zoom#duration
         * @type {integer}
         * @readonly
         * @default 0
         * @since 3.11.0
         */this.duration=0,/**
         * The starting zoom value;
         *
         * @name Phaser.Cameras.Scene2D.Effects.Zoom#source
         * @type {number}
         * @since 3.11.0
         */this.source=1,/**
         * The destination zoom value.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Zoom#destination
         * @type {number}
         * @since 3.11.0
         */this.destination=1,/**
         * The ease function to use during the zoom.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Zoom#ease
         * @type {function}
         * @since 3.11.0
         */this.ease,/**
         * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Zoom#progress
         * @type {number}
         * @since 3.11.0
         */this.progress=0,/**
         * Effect elapsed timer.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Zoom#_elapsed
         * @type {number}
         * @private
         * @since 3.11.0
         */this._elapsed=0,/**
         * This callback is invoked every frame for the duration of the effect.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Zoom#_onUpdate
         * @type {?Phaser.Types.Cameras.Scene2D.CameraZoomCallback}
         * @private
         * @default null
         * @since 3.11.0
         */this._onUpdate,/**
         * On Complete callback scope.
         *
         * @name Phaser.Cameras.Scene2D.Effects.Zoom#_onUpdateScope
         * @type {any}
         * @private
         * @since 3.11.0
         */this._onUpdateScope},/**
     * This effect will zoom the Camera to the given scale, over the duration and with the ease specified.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Zoom#start
     * @fires Phaser.Cameras.Scene2D.Events#ZOOM_START
     * @fires Phaser.Cameras.Scene2D.Events#ZOOM_COMPLETE
     * @since 3.11.0
     *
     * @param {number} zoom - The target Camera zoom value.
     * @param {integer} [duration=1000] - The duration of the effect in milliseconds.
     * @param {(string|function)} [ease='Linear'] - The ease to use for the Zoom. Can be any of the Phaser Easing constants or a custom function.
     * @param {boolean} [force=false] - Force the zoom effect to start immediately, even if already running.
     * @param {Phaser.Types.Cameras.Scene2D.CameraZoomCallback} [callback] - This callback will be invoked every frame for the duration of the effect.
     * It is sent three arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
     * and the current camera zoom value.
     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
     *
     * @return {Phaser.Cameras.Scene2D.Camera} The Camera on which the effect was started.
     */start:function(t,e,i,n,s,a){void 0===e&&(e=1e3),void 0===i&&(i=r.Linear),void 0===n&&(n=!1),void 0===s&&(s=null),void 0===a&&(a=this.camera.scene);var h=this.camera;return!n&&this.isRunning||(this.isRunning=!0,this.duration=e,this.progress=0,//  Starting from
this.source=h.zoom,//  Zooming to
this.destination=t,"string"==typeof i&&r.hasOwnProperty(i)?this.ease=r[i]:"function"==typeof i&&(this.ease=i),this._elapsed=0,this._onUpdate=s,this._onUpdateScope=a,this.camera.emit(o.ZOOM_START,this.camera,this,e,t)),h},/**
     * The main update loop for this effect. Called automatically by the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Zoom#update
     * @since 3.11.0
     *
     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */update:function(t,e){this.isRunning&&(this._elapsed+=e,this.progress=i(this._elapsed/this.duration,0,1),this._elapsed<this.duration?(this.camera.zoom=this.source+(this.destination-this.source)*this.ease(this.progress),this._onUpdate&&this._onUpdate.call(this._onUpdateScope,this.camera,this.progress,this.camera.zoom)):(this.camera.zoom=this.destination,this._onUpdate&&this._onUpdate.call(this._onUpdateScope,this.camera,this.progress,this.destination),this.effectComplete()))},/**
     * Called internally when the effect completes.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Zoom#effectComplete
     * @fires Phaser.Cameras.Scene2D.Events#ZOOM_COMPLETE
     * @since 3.11.0
     */effectComplete:function(){this._onUpdate=null,this._onUpdateScope=null,this.isRunning=!1,this.camera.emit(o.ZOOM_COMPLETE,this.camera,this)},/**
     * Resets this camera effect.
     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Zoom#reset
     * @since 3.11.0
     */reset:function(){this.isRunning=!1,this._onUpdate=null,this._onUpdateScope=null},/**
     * Destroys this effect, releasing it from the Camera.
     *
     * @method Phaser.Cameras.Scene2D.Effects.Zoom#destroy
     * @since 3.11.0
     */destroy:function(){this.reset(),this.camera=null}});t.exports=a}),r("fDkZ4",function(t,e){t.exports=function(t,e,i){return(e-t)*i+t}}),r("bJjUa",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eAXHP"),n=s("jwj1g"),r=s("7BSWl"),o=s("7AzQW"),a=s("6pEze"),h=s("jPI3B"),l=s("4rtgc"),u=new n({initialize:function(t){/**
         * The Scene that owns the Camera Manager plugin.
         *
         * @name Phaser.Cameras.Scene2D.CameraManager#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * A reference to the Scene.Systems handler for the Scene that owns the Camera Manager.
         *
         * @name Phaser.Cameras.Scene2D.CameraManager#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,/**
         * All Cameras created by, or added to, this Camera Manager, will have their `roundPixels`
         * property set to match this value. By default it is set to match the value set in the
         * game configuration, but can be changed at any point. Equally, individual cameras can
         * also be changed as needed.
         *
         * @name Phaser.Cameras.Scene2D.CameraManager#roundPixels
         * @type {boolean}
         * @since 3.11.0
         */this.roundPixels=t.sys.game.config.roundPixels,/**
         * An Array of the Camera objects being managed by this Camera Manager.
         * The Cameras are updated and rendered in the same order in which they appear in this array.
         * Do not directly add or remove entries to this array. However, you can move the contents
         * around the array should you wish to adjust the display order.
         *
         * @name Phaser.Cameras.Scene2D.CameraManager#cameras
         * @type {Phaser.Cameras.Scene2D.Camera[]}
         * @since 3.0.0
         */this.cameras=[],/**
         * A handy reference to the 'main' camera. By default this is the first Camera the
         * Camera Manager creates. You can also set it directly, or use the `makeMain` argument
         * in the `add` and `addExisting` methods. It allows you to access it from your game:
         * 
         * ```javascript
         * var cam = this.cameras.main;
         * ```
         * 
         * Also see the properties `camera1`, `camera2` and so on.
         *
         * @name Phaser.Cameras.Scene2D.CameraManager#main
         * @type {Phaser.Cameras.Scene2D.Camera}
         * @since 3.0.0
         */this.main,/**
         * A default un-transformed Camera that doesn't exist on the camera list and doesn't
         * count towards the total number of cameras being managed. It exists for other
         * systems, as well as your own code, should they require a basic un-transformed
         * camera instance from which to calculate a view matrix.
         *
         * @name Phaser.Cameras.Scene2D.CameraManager#default
         * @type {Phaser.Cameras.Scene2D.Camera}
         * @since 3.17.0
         */this.default,t.sys.events.once(l.BOOT,this.boot,this),t.sys.events.on(l.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#boot
     * @private
     * @listens Phaser.Scenes.Events#DESTROY
     * @since 3.5.1
     */boot:function(){var t=this.systems;t.settings.cameras?this.fromJSON(t.settings.cameras):this.add(),this.main=this.cameras[0],//  Create a default camera
this.default=new i(0,0,t.scale.width,t.scale.height).setScene(this.scene),t.game.scale.on(h.RESIZE,this.onResize,this),this.systems.events.once(l.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#start
     * @private
     * @listens Phaser.Scenes.Events#UPDATE
     * @listens Phaser.Scenes.Events#SHUTDOWN
     * @since 3.5.0
     */start:function(){if(!this.main){var t=this.systems;t.settings.cameras?this.fromJSON(t.settings.cameras):this.add(),this.main=this.cameras[0]}var e=this.systems.events;e.on(l.UPDATE,this.update,this),e.once(l.SHUTDOWN,this.shutdown,this)},/**
     * Adds a new Camera into the Camera Manager. The Camera Manager can support up to 31 different Cameras.
     * 
     * Each Camera has its own viewport, which controls the size of the Camera and its position within the canvas.
     * 
     * Use the `Camera.scrollX` and `Camera.scrollY` properties to change where the Camera is looking, or the
     * Camera methods such as `centerOn`. Cameras also have built in special effects, such as fade, flash, shake,
     * pan and zoom.
     * 
     * By default Cameras are transparent and will render anything that they can see based on their `scrollX`
     * and `scrollY` values. Game Objects can be set to be ignored by a Camera by using the `Camera.ignore` method.
     * 
     * The Camera will have its `roundPixels` property set to whatever `CameraManager.roundPixels` is. You can change
     * it after creation if required.
     * 
     * See the Camera class documentation for more details.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#add
     * @since 3.0.0
     *
     * @param {integer} [x=0] - The horizontal position of the Camera viewport.
     * @param {integer} [y=0] - The vertical position of the Camera viewport.
     * @param {integer} [width] - The width of the Camera viewport. If not given it'll be the game config size.
     * @param {integer} [height] - The height of the Camera viewport. If not given it'll be the game config size.
     * @param {boolean} [makeMain=false] - Set this Camera as being the 'main' camera. This just makes the property `main` a reference to it.
     * @param {string} [name=''] - The name of the Camera.
     *
     * @return {Phaser.Cameras.Scene2D.Camera} The newly created Camera.
     */add:function(t,e,n,s,r,o){void 0===t&&(t=0),void 0===e&&(e=0),void 0===n&&(n=this.scene.sys.scale.width),void 0===s&&(s=this.scene.sys.scale.height),void 0===r&&(r=!1),void 0===o&&(o="");var a=new i(t,e,n,s);return a.setName(o),a.setScene(this.scene),a.setRoundPixels(this.roundPixels),a.id=this.getNextID(),this.cameras.push(a),r&&(this.main=a),a},/**
     * Adds an existing Camera into the Camera Manager.
     * 
     * The Camera should either be a `Phaser.Cameras.Scene2D.Camera` instance, or a class that extends from it.
     * 
     * The Camera will have its `roundPixels` property set to whatever `CameraManager.roundPixels` is. You can change
     * it after addition if required.
     * 
     * The Camera will be assigned an ID, which is used for Game Object exclusion and then added to the
     * manager. As long as it doesn't already exist in the manager it will be added then returned.
     * 
     * If this method returns `null` then the Camera already exists in this Camera Manager.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#addExisting
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to be added to the Camera Manager.
     * @param {boolean} [makeMain=false] - Set this Camera as being the 'main' camera. This just makes the property `main` a reference to it.
     *
     * @return {?Phaser.Cameras.Scene2D.Camera} The Camera that was added to the Camera Manager, or `null` if it couldn't be added.
     */addExisting:function(t,e){return(void 0===e&&(e=!1),-1===this.cameras.indexOf(t))?(t.id=this.getNextID(),t.setRoundPixels(this.roundPixels),this.cameras.push(t),e&&(this.main=t),t):null},/**
     * Gets the next available Camera ID number.
     * 
     * The Camera Manager supports up to 31 unique cameras, after which the ID returned will always be zero.
     * You can create additional cameras beyond 31, but they cannot be used for Game Object exclusion.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#getNextID
     * @private
     * @since 3.11.0
     *
     * @return {number} The next available Camera ID, or 0 if they're all already in use.
     */getNextID:function(){//  Find the first free camera ID we can use
for(var t=this.cameras,e=1,i=0;i<32;i++){for(var n=!1,s=0;s<t.length;s++){var r=t[s];if(r&&r.id===e){n=!0;continue}}if(!n)return e;e<<=1}return 0},/**
     * Gets the total number of Cameras in this Camera Manager.
     * 
     * If the optional `isVisible` argument is set it will only count Cameras that are currently visible.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#getTotal
     * @since 3.11.0
     * 
     * @param {boolean} [isVisible=false] - Set the `true` to only include visible Cameras in the total.
     *
     * @return {integer} The total number of Cameras in this Camera Manager.
     */getTotal:function(t){void 0===t&&(t=!1);for(var e=0,i=this.cameras,n=0;n<i.length;n++){var s=i[n];(!t||t&&s.visible)&&e++}return e},/**
     * Populates this Camera Manager based on the given configuration object, or an array of config objects.
     * 
     * See the `Phaser.Types.Cameras.Scene2D.CameraConfig` documentation for details of the object structure.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#fromJSON
     * @since 3.0.0
     *
     * @param {(Phaser.Types.Cameras.Scene2D.CameraConfig|Phaser.Types.Cameras.Scene2D.CameraConfig[])} config - A Camera configuration object, or an array of them, to be added to this Camera Manager.
     *
     * @return {this} This Camera Manager instance.
     */fromJSON:function(t){Array.isArray(t)||(t=[t]);for(var e=this.scene.sys.scale.width,i=this.scene.sys.scale.height,n=0;n<t.length;n++){var s=t[n],o=r(s,"x",0),a=r(s,"y",0),h=r(s,"width",e),l=r(s,"height",i),u=this.add(o,a,h,l);//  Direct properties
u.name=r(s,"name",""),u.zoom=r(s,"zoom",1),u.rotation=r(s,"rotation",0),u.scrollX=r(s,"scrollX",0),u.scrollY=r(s,"scrollY",0),u.roundPixels=r(s,"roundPixels",!1),u.visible=r(s,"visible",!0);// Background Color
var c=r(s,"backgroundColor",!1);c&&u.setBackgroundColor(c);//  Bounds
var d=r(s,"bounds",null);if(d){var f=r(d,"x",0),p=r(d,"y",0),g=r(d,"width",e),v=r(d,"height",i);u.setBounds(f,p,g,v)}}return this},/**
     * Gets a Camera based on its name.
     * 
     * Camera names are optional and don't have to be set, so this method is only of any use if you
     * have given your Cameras unique names.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#getCamera
     * @since 3.0.0
     *
     * @param {string} name - The name of the Camera.
     *
     * @return {?Phaser.Cameras.Scene2D.Camera} The first Camera with a name matching the given string, otherwise `null`.
     */getCamera:function(t){for(var e=this.cameras,i=0;i<e.length;i++)if(e[i].name===t)return e[i];return null},/**
     * Returns an array of all cameras below the given Pointer.
     * 
     * The first camera in the array is the top-most camera in the camera list.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#getCamerasBelowPointer
     * @since 3.10.0
     *
     * @param {Phaser.Input.Pointer} pointer - The Pointer to check against.
     *
     * @return {Phaser.Cameras.Scene2D.Camera[]} An array of cameras below the Pointer.
     */getCamerasBelowPointer:function(t){for(var e=this.cameras,i=t.x,n=t.y,s=[],r=0;r<e.length;r++){var o=e[r];o.visible&&o.inputEnabled&&a(o,i,n)&&s.unshift(o)}return s},/**
     * Removes the given Camera, or an array of Cameras, from this Camera Manager.
     * 
     * If found in the Camera Manager it will be immediately removed from the local cameras array.
     * If also currently the 'main' camera, 'main' will be reset to be camera 0.
     * 
     * The removed Cameras are automatically destroyed if the `runDestroy` argument is `true`, which is the default.
     * If you wish to re-use the cameras then set this to `false`, but know that they will retain their references
     * and internal data until destroyed or re-added to a Camera Manager.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#remove
     * @since 3.0.0
     *
     * @param {(Phaser.Cameras.Scene2D.Camera|Phaser.Cameras.Scene2D.Camera[])} camera - The Camera, or an array of Cameras, to be removed from this Camera Manager.
     * @param {boolean} [runDestroy=true] - Automatically call `Camera.destroy` on each Camera removed from this Camera Manager.
     * 
     * @return {integer} The total number of Cameras removed.
     */remove:function(t,e){void 0===e&&(e=!0),Array.isArray(t)||(t=[t]);for(var i=0,n=this.cameras,s=0;s<t.length;s++){var r=n.indexOf(t[s]);-1!==r&&(e&&n[r].destroy(),n.splice(r,1),i++)}return!this.main&&n[0]&&(this.main=n[0]),i},/**
     * The internal render method. This is called automatically by the Scene and should not be invoked directly.
     * 
     * It will iterate through all local cameras and render them in turn, as long as they're visible and have
     * an alpha level > 0.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#render
     * @protected
     * @since 3.0.0
     *
     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The Renderer that will render the children to this camera.
     * @param {Phaser.GameObjects.GameObject[]} children - An array of renderable Game Objects.
     * @param {number} interpolation - Interpolation value. Reserved for future use.
     */render:function(t,e,i){for(var n=this.scene,s=this.cameras,r=0;r<this.cameras.length;r++){var o=s[r];o.visible&&o.alpha>0&&(//  Hard-coded to 1 for now
o.preRender(1),t.render(n,e,i,o))}},/**
     * Resets this Camera Manager.
     * 
     * This will iterate through all current Cameras, destroying them all, then it will reset the
     * cameras array, reset the ID counter and create 1 new single camera using the default values.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#resetAll
     * @since 3.0.0
     *
     * @return {Phaser.Cameras.Scene2D.Camera} The freshly created main Camera.
     */resetAll:function(){for(var t=0;t<this.cameras.length;t++)this.cameras[t].destroy();return this.cameras=[],this.main=this.add(),this.main},/**
     * The main update loop. Called automatically when the Scene steps.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#update
     * @protected
     * @since 3.0.0
     *
     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */update:function(t,e){for(var i=0;i<this.cameras.length;i++)this.cameras[i].update(t,e)},/**
     * The event handler that manages the `resize` event dispatched by the Scale Manager.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#onResize
     * @since 3.18.0
     *
     * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.
     * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.
     */onResize:function(t,e,i,n,s,r){for(var o=0;o<this.cameras.length;o++){var a=this.cameras[o];//  if camera is at 0x0 and was the size of the previous game size, then we can safely assume it
//  should be updated to match the new game size too
0===a._x&&0===a._y&&a._width===s&&a._height===r&&a.setSize(e.width,e.height)}},/**
     * Resizes all cameras to the given dimensions.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#resize
     * @since 3.2.0
     *
     * @param {number} width - The new width of the camera.
     * @param {number} height - The new height of the camera.
     */resize:function(t,e){for(var i=0;i<this.cameras.length;i++)this.cameras[i].setSize(t,e)},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#shutdown
     * @private
     * @since 3.0.0
     */shutdown:function(){this.main=void 0;for(var t=0;t<this.cameras.length;t++)this.cameras[t].destroy();this.cameras=[];var e=this.systems.events;e.off(l.UPDATE,this.update,this),e.off(l.SHUTDOWN,this.shutdown,this)},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.Cameras.Scene2D.CameraManager#destroy
     * @private
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.default.destroy(),this.scene.sys.events.off(l.START,this.start,this),this.scene=null,this.systems=null}});o.register("CameraManager",u,"cameras"),t.exports=u}),r("7AzQW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  Contains the plugins that Phaser uses globally and locally.
//  These are the source objects, not instantiated.
var i={},n={},s={};/**
 * @namespace Phaser.Plugins.PluginCache
 *//**
 * Static method called directly by the Core internal Plugins.
 * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)
 * Plugin is the object to instantiate to create the plugin
 * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)
 *
 * @method Phaser.Plugins.PluginCache.register
 * @since 3.8.0
 * 
 * @param {string} key - A reference used to get this plugin from the plugin cache.
 * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.
 * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.
 * @param {boolean} [custom=false] - Core Scene plugin or a Custom Scene plugin?
 */s.register=function(t,e,n,s){void 0===s&&(s=!1),i[t]={plugin:e,mapping:n,custom:s}},/**
 * Stores a custom plugin in the global plugin cache.
 * The key must be unique, within the scope of the cache.
 *
 * @method Phaser.Plugins.PluginCache.registerCustom
 * @since 3.8.0
 * 
 * @param {string} key - A reference used to get this plugin from the plugin cache.
 * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.
 * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.
 * @param {?any} data - A value to be passed to the plugin's `init` method.
 */s.registerCustom=function(t,e,i,s){n[t]={plugin:e,mapping:i,data:s}},/**
 * Checks if the given key is already being used in the core plugin cache.
 *
 * @method Phaser.Plugins.PluginCache.hasCore
 * @since 3.8.0
 * 
 * @param {string} key - The key to check for.
 *
 * @return {boolean} `true` if the key is already in use in the core cache, otherwise `false`.
 */s.hasCore=function(t){return i.hasOwnProperty(t)},/**
 * Checks if the given key is already being used in the custom plugin cache.
 *
 * @method Phaser.Plugins.PluginCache.hasCustom
 * @since 3.8.0
 * 
 * @param {string} key - The key to check for.
 *
 * @return {boolean} `true` if the key is already in use in the custom cache, otherwise `false`.
 */s.hasCustom=function(t){return n.hasOwnProperty(t)},/**
 * Returns the core plugin object from the cache based on the given key.
 *
 * @method Phaser.Plugins.PluginCache.getCore
 * @since 3.8.0
 * 
 * @param {string} key - The key of the core plugin to get.
 *
 * @return {Phaser.Types.Plugins.CorePluginContainer} The core plugin object.
 */s.getCore=function(t){return i[t]},/**
 * Returns the custom plugin object from the cache based on the given key.
 *
 * @method Phaser.Plugins.PluginCache.getCustom
 * @since 3.8.0
 * 
 * @param {string} key - The key of the custom plugin to get.
 *
 * @return {Phaser.Types.Plugins.CustomPluginContainer} The custom plugin object.
 */s.getCustom=function(t){return n[t]},/**
 * Returns an object from the custom cache based on the given key that can be instantiated.
 *
 * @method Phaser.Plugins.PluginCache.getCustomClass
 * @since 3.8.0
 * 
 * @param {string} key - The key of the custom plugin to get.
 *
 * @return {function} The custom plugin object.
 */s.getCustomClass=function(t){return n.hasOwnProperty(t)?n[t].plugin:null},/**
 * Removes a core plugin based on the given key.
 *
 * @method Phaser.Plugins.PluginCache.remove
 * @since 3.8.0
 * 
 * @param {string} key - The key of the core plugin to remove.
 */s.remove=function(t){i.hasOwnProperty(t)&&delete i[t]},/**
 * Removes a custom plugin based on the given key.
 *
 * @method Phaser.Plugins.PluginCache.removeCustom
 * @since 3.8.0
 * 
 * @param {string} key - The key of the custom plugin to remove.
 */s.removeCustom=function(t){n.hasOwnProperty(t)&&delete n[t]},/**
 * Removes all Core Plugins.
 * 
 * This includes all of the internal system plugins that Phaser needs, like the Input Plugin and Loader Plugin.
 * So be sure you only call this if you do not wish to run Phaser again.
 *
 * @method Phaser.Plugins.PluginCache.destroyCorePlugins
 * @since 3.12.0
 */s.destroyCorePlugins=function(){for(var t in i)i.hasOwnProperty(t)&&delete i[t]},/**
 * Removes all Custom Plugins.
 *
 * @method Phaser.Plugins.PluginCache.destroyCustomPlugins
 * @since 3.12.0
 */s.destroyCustomPlugins=function(){for(var t in n)n.hasOwnProperty(t)&&delete n[t]},t.exports=s}),r("jPI3B",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Scale.Events
 */t.exports={ENTER_FULLSCREEN:s("eLhfG"),FULLSCREEN_FAILED:s("jvHSU"),FULLSCREEN_UNSUPPORTED:s("iWr36"),LEAVE_FULLSCREEN:s("5jmco"),ORIENTATION_CHANGE:s("j7QiY"),RESIZE:s("gfeXq")}}),r("eLhfG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scale Manager has successfully entered fullscreen mode.
 *
 * @event Phaser.Scale.Events#ENTER_FULLSCREEN
 * @since 3.16.1
 */t.exports="enterfullscreen"}),r("jvHSU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scale Manager tried to enter fullscreen mode but failed.
 *
 * @event Phaser.Scale.Events#FULLSCREEN_FAILED
 * @since 3.17.0
 */t.exports="fullscreenfailed"}),r("iWr36",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scale Manager tried to enter fullscreen mode, but it is unsupported by the browser.
 *
 * @event Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED
 * @since 3.16.1
 */t.exports="fullscreenunsupported"}),r("5jmco",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scale Manager was in fullscreen mode, but has since left, either directly via game code,
 * or via a user gestured, such as pressing the ESC key.
 *
 * @event Phaser.Scale.Events#LEAVE_FULLSCREEN
 * @since 3.16.1
 */t.exports="leavefullscreen"}),r("j7QiY",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scale Manager Orientation Change Event.
 *
 * @event Phaser.Scale.Events#ORIENTATION_CHANGE
 * @since 3.16.1
 * 
 * @param {string} orientation - 
 */t.exports="orientationchange"}),r("gfeXq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scale Manager Resize Event.
 * 
 * This event is dispatched whenever the Scale Manager detects a resize event from the browser.
 * It sends three parameters to the callback, each of them being Size components. You can read
 * the `width`, `height`, `aspectRatio` and other properties of these components to help with
 * scaling your own game content.
 *
 * @event Phaser.Scale.Events#RESIZE
 * @since 3.16.1
 * 
 * @param {Phaser.Structs.Size} gameSize - A reference to the Game Size component. This is the un-scaled size of your game canvas.
 * @param {Phaser.Structs.Size} baseSize - A reference to the Base Size component. This is the game size multiplied by resolution.
 * @param {Phaser.Structs.Size} displaySize - A reference to the Display Size component. This is the scaled canvas size, after applying zoom and scale mode.
 * @param {number} resolution - The current resolution. Defaults to 1 at the moment.
 * @param {number} previousWidth - If the `gameSize` has changed, this value contains its previous width, otherwise it contains the current width.
 * @param {number} previousHeight - If the `gameSize` has changed, this value contains its previous height, otherwise it contains the current height.
 */t.exports="resize"}),r("4rtgc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Scenes.Events
 */t.exports={BOOT:s("gbawY"),CREATE:s("a01bj"),DESTROY:s("dCqgX"),PAUSE:s("aLMBP"),POST_UPDATE:s("5n3eX"),PRE_UPDATE:s("aFxIg"),READY:s("3l5wy"),RENDER:s("dhZDe"),RESUME:s("byujQ"),SHUTDOWN:s("7BJnZ"),SLEEP:s("cCEAa"),START:s("aQCLI"),TRANSITION_COMPLETE:s("2o7oE"),TRANSITION_INIT:s("42wKn"),TRANSITION_OUT:s("3pHsg"),TRANSITION_START:s("ryW1Q"),TRANSITION_WAKE:s("leHRQ"),UPDATE:s("FqnNo"),WAKE:s("45hbh")}}),r("gbawY",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Boot Event.
 * 
 * This event is dispatched by a Scene during the Scene Systems boot process. Primarily used by Scene Plugins.
 * 
 * Listen to it from a Scene using `this.scene.events.on('boot', listener)`.
 * 
 * @event Phaser.Scenes.Events#BOOT
 * @since 3.0.0
 * 
 * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.
 */t.exports="boot"}),r("a01bj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Create Event.
 * 
 * This event is dispatched by a Scene after it has been created by the Scene Manager.
 * 
 * If a Scene has a `create` method then this event is emitted _after_ that has run.
 * 
 * If there is a transition, this event will be fired after the `TRANSITION_START` event.
 * 
 * Listen to it from a Scene using `this.scene.events.on('create', listener)`.
 * 
 * @event Phaser.Scenes.Events#CREATE
 * @since 3.17.0
 * 
 * @param {Phaser.Scene} scene - A reference to the Scene that emitted this event.
 */t.exports="create"}),r("dCqgX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Destroy Event.
 * 
 * This event is dispatched by a Scene during the Scene Systems destroy process.
 * 
 * Listen to it from a Scene using `this.scene.events.on('destroy', listener)`.
 * 
 * You should destroy any resources that may be in use by your Scene in this event handler.
 * 
 * @event Phaser.Scenes.Events#DESTROY
 * @since 3.0.0
 * 
 * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.
 */t.exports="destroy"}),r("aLMBP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Pause Event.
 * 
 * This event is dispatched by a Scene when it is paused, either directly via the `pause` method, or as an
 * action from another Scene.
 * 
 * Listen to it from a Scene using `this.scene.events.on('pause', listener)`.
 * 
 * @event Phaser.Scenes.Events#PAUSE
 * @since 3.0.0
 * 
 * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.
 * @param {any} [data] - An optional data object that was passed to this Scene when it was paused.
 */t.exports="pause"}),r("5n3eX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Post Update Event.
 * 
 * This event is dispatched by a Scene during the main game loop step.
 * 
 * The event flow for a single step of a Scene is as follows:
 * 
 * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}
 * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}
 * 3. The `Scene.update` method is called, if it exists
 * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}
 * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}
 * 
 * Listen to it from a Scene using `this.scene.events.on('postupdate', listener)`.
 * 
 * A Scene will only run its step if it is active.
 * 
 * @event Phaser.Scenes.Events#POST_UPDATE
 * @since 3.0.0
 * 
 * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.
 * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
 * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
 */t.exports="postupdate"}),r("aFxIg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Pre Update Event.
 * 
 * This event is dispatched by a Scene during the main game loop step.
 * 
 * The event flow for a single step of a Scene is as follows:
 * 
 * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}
 * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}
 * 3. The `Scene.update` method is called, if it exists
 * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}
 * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}
 * 
 * Listen to it from a Scene using `this.scene.events.on('preupdate', listener)`.
 * 
 * A Scene will only run its step if it is active.
 * 
 * @event Phaser.Scenes.Events#PRE_UPDATE
 * @since 3.0.0
 * 
 * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.
 * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
 * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
 */t.exports="preupdate"}),r("3l5wy",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Ready Event.
 * 
 * This event is dispatched by a Scene during the Scene Systems start process.
 * By this point in the process the Scene is now fully active and rendering.
 * This event is meant for your game code to use, as all plugins have responded to the earlier 'start' event.
 * 
 * Listen to it from a Scene using `this.scene.events.on('ready', listener)`.
 * 
 * @event Phaser.Scenes.Events#READY
 * @since 3.0.0
 * 
 * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.
 * @param {any} [data] - An optional data object that was passed to this Scene when it was started.
 */t.exports="ready"}),r("dhZDe",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Render Event.
 * 
 * This event is dispatched by a Scene during the main game loop step.
 * 
 * The event flow for a single step of a Scene is as follows:
 * 
 * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}
 * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}
 * 3. The `Scene.update` method is called, if it exists
 * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}
 * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}
 * 
 * Listen to it from a Scene using `this.scene.events.on('render', listener)`.
 * 
 * A Scene will only render if it is visible and active.
 * By the time this event is dispatched, the Scene will have already been rendered.
 * 
 * @event Phaser.Scenes.Events#RENDER
 * @since 3.0.0
 * 
 * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer that rendered the Scene.
 */t.exports="render"}),r("byujQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Resume Event.
 * 
 * This event is dispatched by a Scene when it is resumed from a paused state, either directly via the `resume` method,
 * or as an action from another Scene.
 * 
 * Listen to it from a Scene using `this.scene.events.on('resume', listener)`.
 * 
 * @event Phaser.Scenes.Events#RESUME
 * @since 3.0.0
 * 
 * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.
 * @param {any} [data] - An optional data object that was passed to this Scene when it was resumed.
 */t.exports="resume"}),r("7BJnZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Shutdown Event.
 * 
 * This event is dispatched by a Scene during the Scene Systems shutdown process.
 * 
 * Listen to it from a Scene using `this.scene.events.on('shutdown', listener)`.
 * 
 * You should free-up any resources that may be in use by your Scene in this event handler, on the understanding
 * that the Scene may, at any time, become active again. A shutdown Scene is not 'destroyed', it's simply not
 * currently active. Use the [DESTROY]{@linkcode Phaser.Scenes.Events#event:DESTROY} event to completely clear resources.
 * 
 * @event Phaser.Scenes.Events#SHUTDOWN
 * @since 3.0.0
 * 
 * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.
 * @param {any} [data] - An optional data object that was passed to this Scene when it was shutdown.
 */t.exports="shutdown"}),r("cCEAa",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Sleep Event.
 * 
 * This event is dispatched by a Scene when it is sent to sleep, either directly via the `sleep` method,
 * or as an action from another Scene.
 * 
 * Listen to it from a Scene using `this.scene.events.on('sleep', listener)`.
 * 
 * @event Phaser.Scenes.Events#SLEEP
 * @since 3.0.0
 * 
 * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.
 * @param {any} [data] - An optional data object that was passed to this Scene when it was sent to sleep.
 */t.exports="sleep"}),r("aQCLI",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Start Event.
 * 
 * This event is dispatched by a Scene during the Scene Systems start process. Primarily used by Scene Plugins.
 * 
 * Listen to it from a Scene using `this.scene.events.on('start', listener)`.
 * 
 * @event Phaser.Scenes.Events#START
 * @since 3.0.0
 * 
 * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.
 */t.exports="start"}),r("2o7oE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Transition Complete Event.
 * 
 * This event is dispatched by the Target Scene of a transition.
 * 
 * It happens when the transition process has completed. This occurs when the duration timer equals or exceeds the duration
 * of the transition.
 * 
 * Listen to it from a Scene using `this.scene.events.on('transitioncomplete', listener)`.
 * 
 * The Scene Transition event flow is as follows:
 * 
 * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.
 * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.
 * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...
 * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.
 * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.
 * 
 * @event Phaser.Scenes.Events#TRANSITION_COMPLETE
 * @since 3.5.0
 * 
 * @param {Phaser.Scene} scene -The Scene on which the transitioned completed.
 */t.exports="transitioncomplete"}),r("42wKn",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Transition Init Event.
 * 
 * This event is dispatched by the Target Scene of a transition.
 * 
 * It happens immediately after the `Scene.init` method is called. If the Scene does not have an `init` method,
 * this event is not dispatched.
 * 
 * Listen to it from a Scene using `this.scene.events.on('transitioninit', listener)`.
 * 
 * The Scene Transition event flow is as follows:
 * 
 * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.
 * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.
 * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...
 * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.
 * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.
 * 
 * @event Phaser.Scenes.Events#TRANSITION_INIT
 * @since 3.5.0
 * 
 * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.
 * @param {number} duration - The duration of the transition in ms.
 */t.exports="transitioninit"}),r("3pHsg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Transition Out Event.
 * 
 * This event is dispatched by a Scene when it initiates a transition to another Scene.
 * 
 * Listen to it from a Scene using `this.scene.events.on('transitionout', listener)`.
 * 
 * The Scene Transition event flow is as follows:
 * 
 * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.
 * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.
 * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...
 * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.
 * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.
 * 
 * @event Phaser.Scenes.Events#TRANSITION_OUT
 * @since 3.5.0
 * 
 * @param {Phaser.Scene} target - A reference to the Scene that is being transitioned to.
 * @param {number} duration - The duration of the transition in ms.
 */t.exports="transitionout"}),r("ryW1Q",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Transition Start Event.
 * 
 * This event is dispatched by the Target Scene of a transition, only if that Scene was not asleep.
 * 
 * It happens immediately after the `Scene.create` method is called. If the Scene does not have a `create` method,
 * this event is dispatched anyway.
 * 
 * If the Target Scene was sleeping then the [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} event is
 * dispatched instead of this event.
 * 
 * Listen to it from a Scene using `this.scene.events.on('transitionstart', listener)`.
 * 
 * The Scene Transition event flow is as follows:
 * 
 * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.
 * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.
 * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...
 * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.
 * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.
 * 
 * @event Phaser.Scenes.Events#TRANSITION_START
 * @since 3.5.0
 * 
 * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.
 * @param {number} duration - The duration of the transition in ms.
 */t.exports="transitionstart"}),r("leHRQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Transition Wake Event.
 * 
 * This event is dispatched by the Target Scene of a transition, only if that Scene was asleep before
 * the transition began. If the Scene was not asleep the [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} event is dispatched instead.
 * 
 * Listen to it from a Scene using `this.scene.events.on('transitionwake', listener)`.
 * 
 * The Scene Transition event flow is as follows:
 * 
 * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.
 * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.
 * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...
 * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.
 * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.
 * 
 * @event Phaser.Scenes.Events#TRANSITION_WAKE
 * @since 3.5.0
 * 
 * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.
 * @param {number} duration - The duration of the transition in ms.
 */t.exports="transitionwake"}),r("FqnNo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Update Event.
 * 
 * This event is dispatched by a Scene during the main game loop step.
 * 
 * The event flow for a single step of a Scene is as follows:
 * 
 * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}
 * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}
 * 3. The `Scene.update` method is called, if it exists
 * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}
 * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}
 * 
 * Listen to it from a Scene using `this.scene.events.on('update', listener)`.
 * 
 * A Scene will only run its step if it is active.
 * 
 * @event Phaser.Scenes.Events#UPDATE
 * @since 3.0.0
 * 
 * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.
 * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
 * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
 */t.exports="update"}),r("45hbh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Scene Systems Wake Event.
 * 
 * This event is dispatched by a Scene when it is woken from sleep, either directly via the `wake` method,
 * or as an action from another Scene.
 * 
 * Listen to it from a Scene using `this.scene.events.on('wake', listener)`.
 * 
 * @event Phaser.Scenes.Events#WAKE
 * @since 3.0.0
 * 
 * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.
 * @param {any} [data] - An optional data object that was passed to this Scene when it was woken up.
 */t.exports="wake"}),r("b8jwN",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Core
 */t.exports={Config:s("cIuDW"),CreateRenderer:s("dFILV"),DebugHeader:s("aGYvp"),Events:s("aqcI1"),TimeStep:s("bc6Xj"),VisibilityHandler:s("cEGtP")}}),r("cIuDW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("bRAqZ"),r=s("eii8B"),o=s("7BSWl"),a=s("5pMDk"),h=s("jC9MQ"),l=s("5OyGi"),u=s("13GYA"),c=s("488fh"),d=s("iYnst"),f=new i({initialize:function(t){void 0===t&&(t={}),/**
         * @const {(integer|string)} Phaser.Core.Config#width - The width of the underlying canvas, in pixels.
         */this.width=a(t,"width",1024),/**
         * @const {(integer|string)} Phaser.Core.Config#height - The height of the underlying canvas, in pixels.
         */this.height=a(t,"height",768),/**
         * @const {(Phaser.Scale.ZoomType|integer)} Phaser.Core.Config#zoom - The zoom factor, as used by the Scale Manager.
         */this.zoom=a(t,"zoom",1),/**
         * @const {number} Phaser.Core.Config#resolution - The canvas device pixel resolution. Currently un-used.
         */this.resolution=a(t,"resolution",1),/**
         * @const {?*} Phaser.Core.Config#parent - A parent DOM element into which the canvas created by the renderer will be injected.
         */this.parent=a(t,"parent",void 0),/**
         * @const {Phaser.Scale.ScaleModeType} Phaser.Core.Config#scaleMode - The scale mode as used by the Scale Manager. The default is zero, which is no scaling.
         */this.scaleMode=a(t,"scaleMode",0),/**
         * @const {boolean} Phaser.Core.Config#expandParent - Is the Scale Manager allowed to adjust the CSS height property of the parent to be 100%?
         */this.expandParent=a(t,"expandParent",!0),/**
         * @const {integer} Phaser.Core.Config#autoRound - Automatically round the display and style sizes of the canvas. This can help with performance in lower-powered devices.
         */this.autoRound=a(t,"autoRound",!1),/**
         * @const {Phaser.Scale.CenterType} Phaser.Core.Config#autoCenter - Automatically center the canvas within the parent?
         */this.autoCenter=a(t,"autoCenter",0),/**
         * @const {integer} Phaser.Core.Config#resizeInterval - How many ms should elapse before checking if the browser size has changed?
         */this.resizeInterval=a(t,"resizeInterval",500),/**
         * @const {?(HTMLElement|string)} Phaser.Core.Config#fullscreenTarget - The DOM element that will be sent into full screen mode, or its `id`. If undefined Phaser will create its own div and insert the canvas into it when entering fullscreen mode.
         */this.fullscreenTarget=a(t,"fullscreenTarget",null),/**
         * @const {integer} Phaser.Core.Config#minWidth - The minimum width, in pixels, the canvas will scale down to. A value of zero means no minimum.
         */this.minWidth=a(t,"minWidth",0),/**
         * @const {integer} Phaser.Core.Config#maxWidth - The maximum width, in pixels, the canvas will scale up to. A value of zero means no maximum.
         */this.maxWidth=a(t,"maxWidth",0),/**
         * @const {integer} Phaser.Core.Config#minHeight - The minimum height, in pixels, the canvas will scale down to. A value of zero means no minimum.
         */this.minHeight=a(t,"minHeight",0),/**
         * @const {integer} Phaser.Core.Config#maxHeight - The maximum height, in pixels, the canvas will scale up to. A value of zero means no maximum.
         */this.maxHeight=a(t,"maxHeight",0);//  Scale Manager - Anything set in here over-rides anything set above
var e=a(t,"scale",null);e&&(this.width=a(e,"width",this.width),this.height=a(e,"height",this.height),this.zoom=a(e,"zoom",this.zoom),this.resolution=a(e,"resolution",this.resolution),this.parent=a(e,"parent",this.parent),this.scaleMode=a(e,"mode",this.scaleMode),this.expandParent=a(e,"expandParent",this.expandParent),this.autoRound=a(e,"autoRound",this.autoRound),this.autoCenter=a(e,"autoCenter",this.autoCenter),this.resizeInterval=a(e,"resizeInterval",this.resizeInterval),this.fullscreenTarget=a(e,"fullscreenTarget",this.fullscreenTarget),this.minWidth=a(e,"min.width",this.minWidth),this.maxWidth=a(e,"max.width",this.maxWidth),this.minHeight=a(e,"min.height",this.minHeight),this.maxHeight=a(e,"max.height",this.maxHeight)),/**
         * @const {number} Phaser.Core.Config#renderType - Force Phaser to use a specific renderer. Can be `CONST.CANVAS`, `CONST.WEBGL`, `CONST.HEADLESS` or `CONST.AUTO` (default)
         */this.renderType=a(t,"type",n.AUTO),/**
         * @const {?HTMLCanvasElement} Phaser.Core.Config#canvas - Force Phaser to use your own Canvas element instead of creating one.
         */this.canvas=a(t,"canvas",null),/**
         * @const {?(CanvasRenderingContext2D|WebGLRenderingContext)} Phaser.Core.Config#context - Force Phaser to use your own Canvas context instead of creating one.
         */this.context=a(t,"context",null),/**
         * @const {?string} Phaser.Core.Config#canvasStyle - Optional CSS attributes to be set on the canvas object created by the renderer.
         */this.canvasStyle=a(t,"canvasStyle",null),/**
         * @const {boolean} Phaser.Core.Config#customEnvironment - Is Phaser running under a custom (non-native web) environment? If so, set this to `true` to skip internal Feature detection. If `true` the `renderType` cannot be left as `AUTO`.
         */this.customEnvironment=a(t,"customEnvironment",!1),/**
         * @const {?object} Phaser.Core.Config#sceneConfig - The default Scene configuration object.
         */this.sceneConfig=a(t,"scene",null),/**
         * @const {string[]} Phaser.Core.Config#seed - A seed which the Random Data Generator will use. If not given, a dynamic seed based on the time is used.
         */this.seed=a(t,"seed",[(Date.now()*Math.random()).toString()]),l.RND=new l.RandomDataGenerator(this.seed),/**
         * @const {string} Phaser.Core.Config#gameTitle - The title of the game.
         */this.gameTitle=a(t,"title",""),/**
         * @const {string} Phaser.Core.Config#gameURL - The URL of the game.
         */this.gameURL=a(t,"url","https://phaser.io"),/**
         * @const {string} Phaser.Core.Config#gameVersion - The version of the game.
         */this.gameVersion=a(t,"version",""),/**
         * @const {boolean} Phaser.Core.Config#autoFocus - If `true` the window will automatically be given focus immediately and on any future mousedown event.
         */this.autoFocus=a(t,"autoFocus",!0),//  DOM Element Container
/**
         * @const {?boolean} Phaser.Core.Config#domCreateContainer - Should the game create a div element to act as a DOM Container? Only enable if you're using DOM Element objects. You must provide a parent object if you use this feature.
         */this.domCreateContainer=a(t,"dom.createContainer",!1),/**
         * @const {?boolean} Phaser.Core.Config#domBehindCanvas - Should the DOM Container that is created (if `dom.createContainer` is true) be positioned behind (true) or over the top (false, the default) of the game canvas?
         */this.domBehindCanvas=a(t,"dom.behindCanvas",!1),//  Input
/**
         * @const {boolean} Phaser.Core.Config#inputKeyboard - Enable the Keyboard Plugin. This can be disabled in games that don't need keyboard input.
         */this.inputKeyboard=a(t,"input.keyboard",!0),/**
         * @const {*} Phaser.Core.Config#inputKeyboardEventTarget - The DOM Target to listen for keyboard events on. Defaults to `window` if not specified.
         */this.inputKeyboardEventTarget=a(t,"input.keyboard.target",window),/**
         * @const {?integer[]} Phaser.Core.Config#inputKeyboardCapture - `preventDefault` will be called on every non-modified key which has a key code in this array. By default, it is empty.
         */this.inputKeyboardCapture=a(t,"input.keyboard.capture",[]),/**
         * @const {(boolean|object)} Phaser.Core.Config#inputMouse - Enable the Mouse Plugin. This can be disabled in games that don't need mouse input.
         */this.inputMouse=a(t,"input.mouse",!0),/**
         * @const {?*} Phaser.Core.Config#inputMouseEventTarget - The DOM Target to listen for mouse events on. Defaults to the game canvas if not specified.
         */this.inputMouseEventTarget=a(t,"input.mouse.target",null),/**
         * @const {boolean} Phaser.Core.Config#inputMouseCapture - Should mouse events be captured? I.e. have prevent default called on them.
         */this.inputMouseCapture=a(t,"input.mouse.capture",!0),/**
         * @const {boolean} Phaser.Core.Config#inputTouch - Enable the Touch Plugin. This can be disabled in games that don't need touch input.
         */this.inputTouch=a(t,"input.touch",r.input.touch),/**
         * @const {?*} Phaser.Core.Config#inputTouchEventTarget - The DOM Target to listen for touch events on. Defaults to the game canvas if not specified.
         */this.inputTouchEventTarget=a(t,"input.touch.target",null),/**
         * @const {boolean} Phaser.Core.Config#inputTouchCapture - Should touch events be captured? I.e. have prevent default called on them.
         */this.inputTouchCapture=a(t,"input.touch.capture",!0),/**
         * @const {integer} Phaser.Core.Config#inputActivePointers - The number of Pointer objects created by default. In a mouse-only, or non-multi touch game, you can leave this as 1.
         */this.inputActivePointers=a(t,"input.activePointers",1),/**
         * @const {integer} Phaser.Core.Config#inputSmoothFactor - The smoothing factor to apply during Pointer movement. See {@link Phaser.Input.Pointer#smoothFactor}.
         */this.inputSmoothFactor=a(t,"input.smoothFactor",0),/**
         * @const {boolean} Phaser.Core.Config#inputWindowEvents - Should Phaser listen for input events on the Window? If you disable this, events like 'POINTER_UP_OUTSIDE' will no longer fire.
         */this.inputWindowEvents=a(t,"input.windowEvents",!0),/**
         * @const {boolean} Phaser.Core.Config#inputGamepad - Enable the Gamepad Plugin. This can be disabled in games that don't need gamepad input.
         */this.inputGamepad=a(t,"input.gamepad",!1),/**
         * @const {*} Phaser.Core.Config#inputGamepadEventTarget - The DOM Target to listen for gamepad events on. Defaults to `window` if not specified.
         */this.inputGamepadEventTarget=a(t,"input.gamepad.target",window),/**
         * @const {boolean} Phaser.Core.Config#disableContextMenu - Set to `true` to disable the right-click context menu.
         */this.disableContextMenu=a(t,"disableContextMenu",!1),/**
         * @const {Phaser.Types.Core.AudioConfig} Phaser.Core.Config#audio - The Audio Configuration object.
         */this.audio=a(t,"audio"),//  If you do: { banner: false } it won't display any banner at all
/**
         * @const {boolean} Phaser.Core.Config#hideBanner - Don't write the banner line to the console.log.
         */this.hideBanner=!1===a(t,"banner",null),/**
         * @const {boolean} Phaser.Core.Config#hidePhaser - Omit Phaser's name and version from the banner.
         */this.hidePhaser=a(t,"banner.hidePhaser",!1),/**
         * @const {string} Phaser.Core.Config#bannerTextColor - The color of the banner text.
         */this.bannerTextColor=a(t,"banner.text","#ffffff"),/**
         * @const {string[]} Phaser.Core.Config#bannerBackgroundColor - The background colors of the banner.
         */this.bannerBackgroundColor=a(t,"banner.background",["#ff0000","#ffff00","#00ff00","#00ffff","#000000"]),""===this.gameTitle&&this.hidePhaser&&(this.hideBanner=!0),/**
         * @const {?Phaser.Types.Core.FPSConfig} Phaser.Core.Config#fps - The Frame Rate Configuration object, as parsed by the Timestep class.
         */this.fps=a(t,"fps",null);//  Renderer Settings
//  These can either be in a `render` object within the Config, or specified on their own
var i=a(t,"render",t);/**
         * @const {boolean} Phaser.Core.Config#antialias - When set to `true`, WebGL uses linear interpolation to draw scaled or rotated textures, giving a smooth appearance. When set to `false`, WebGL uses nearest-neighbor interpolation, giving a crisper appearance. `false` also disables antialiasing of the game canvas itself, if the browser supports it, when the game canvas is scaled.
         */this.antialias=a(i,"antialias",!0),/**
         * @const {boolean} Phaser.Core.Config#antialiasGL - Sets the `antialias` property when the WebGL context is created. Setting this value does not impact any subsequent textures that are created, or the canvas style attributes.
         */this.antialiasGL=a(i,"antialiasGL",!0),/**
         * @const {string} Phaser.Core.Config#mipmapFilter - Sets the `mipmapFilter` property when the WebGL renderer is created.
         */this.mipmapFilter=a(i,"mipmapFilter","LINEAR"),/**
         * @const {boolean} Phaser.Core.Config#desynchronized - When set to `true` it will create a desynchronized context for both 2D and WebGL. See https://developers.google.com/web/updates/2019/05/desynchronized for details.
         */this.desynchronized=a(i,"desynchronized",!1),/**
         * @const {boolean} Phaser.Core.Config#roundPixels - Draw texture-based Game Objects at only whole-integer positions. Game Objects without textures, like Graphics, ignore this property.
         */this.roundPixels=a(i,"roundPixels",!1),/**
         * @const {boolean} Phaser.Core.Config#pixelArt - Prevent pixel art from becoming blurred when scaled. It will remain crisp (tells the WebGL renderer to automatically create textures using a linear filter mode).
         */this.pixelArt=a(i,"pixelArt",1!==this.zoom),this.pixelArt&&(this.antialias=!1,this.roundPixels=!0),/**
         * @const {boolean} Phaser.Core.Config#transparent - Whether the game canvas will have a transparent background.
         */this.transparent=a(i,"transparent",!1),/**
         * @const {boolean} Phaser.Core.Config#clearBeforeRender - Whether the game canvas will be cleared between each rendering frame. You can disable this if you have a full-screen background image or game object.
         */this.clearBeforeRender=a(i,"clearBeforeRender",!0),/**
         * @const {boolean} Phaser.Core.Config#premultipliedAlpha - In WebGL mode, sets the drawing buffer to contain colors with pre-multiplied alpha.
         */this.premultipliedAlpha=a(i,"premultipliedAlpha",!0),/**
         * @const {boolean} Phaser.Core.Config#failIfMajorPerformanceCaveat - Let the browser abort creating a WebGL context if it judges performance would be unacceptable.
         */this.failIfMajorPerformanceCaveat=a(i,"failIfMajorPerformanceCaveat",!1),/**
         * @const {string} Phaser.Core.Config#powerPreference - "high-performance", "low-power" or "default". A hint to the browser on how much device power the game might use.
         */this.powerPreference=a(i,"powerPreference","default"),/**
         * @const {integer} Phaser.Core.Config#batchSize - The default WebGL Batch size.
         */this.batchSize=a(i,"batchSize",2e3),/**
         * @const {integer} Phaser.Core.Config#maxLights - The maximum number of lights allowed to be visible within range of a single Camera in the LightManager.
         */this.maxLights=a(i,"maxLights",10);var s=a(t,"backgroundColor",0);/**
         * @const {Phaser.Display.Color} Phaser.Core.Config#backgroundColor - The background color of the game canvas. The default is black. This value is ignored if `transparent` is set to `true`.
         */this.backgroundColor=d(s),0===s&&this.transparent&&(this.backgroundColor.alpha=0),/**
         * @const {Phaser.Types.Core.BootCallback} Phaser.Core.Config#preBoot - Called before Phaser boots. Useful for initializing anything not related to Phaser that Phaser may require while booting.
         */this.preBoot=a(t,"callbacks.preBoot",u),/**
         * @const {Phaser.Types.Core.BootCallback} Phaser.Core.Config#postBoot - A function to run at the end of the boot sequence. At this point, all the game systems have started and plugins have been loaded.
         */this.postBoot=a(t,"callbacks.postBoot",u),/**
         * @const {Phaser.Types.Core.PhysicsConfig} Phaser.Core.Config#physics - The Physics Configuration object.
         */this.physics=a(t,"physics",{}),/**
         * @const {(boolean|string)} Phaser.Core.Config#defaultPhysicsSystem - The default physics system. It will be started for each scene. Either 'arcade', 'impact' or 'matter'.
         */this.defaultPhysicsSystem=a(this.physics,"default",!1),/**
         * @const {string} Phaser.Core.Config#loaderBaseURL - A URL used to resolve paths given to the loader. Example: 'http://labs.phaser.io/assets/'.
         */this.loaderBaseURL=a(t,"loader.baseURL",""),/**
         * @const {string} Phaser.Core.Config#loaderPath - A URL path used to resolve relative paths given to the loader. Example: 'images/sprites/'.
         */this.loaderPath=a(t,"loader.path",""),/**
         * @const {integer} Phaser.Core.Config#loaderMaxParallelDownloads - Maximum parallel downloads allowed for resources (Default to 32).
         */this.loaderMaxParallelDownloads=a(t,"loader.maxParallelDownloads",32),/**
         * @const {(string|undefined)} Phaser.Core.Config#loaderCrossOrigin - 'anonymous', 'use-credentials', or `undefined`. If you're not making cross-origin requests, leave this as `undefined`. See {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes}.
         */this.loaderCrossOrigin=a(t,"loader.crossOrigin",void 0),/**
         * @const {string} Phaser.Core.Config#loaderResponseType - The response type of the XHR request, e.g. `blob`, `text`, etc.
         */this.loaderResponseType=a(t,"loader.responseType",""),/**
         * @const {boolean} Phaser.Core.Config#loaderAsync - Should the XHR request use async or not?
         */this.loaderAsync=a(t,"loader.async",!0),/**
         * @const {string} Phaser.Core.Config#loaderUser - Optional username for all XHR requests.
         */this.loaderUser=a(t,"loader.user",""),/**
         * @const {string} Phaser.Core.Config#loaderPassword - Optional password for all XHR requests.
         */this.loaderPassword=a(t,"loader.password",""),/**
         * @const {integer} Phaser.Core.Config#loaderTimeout - Optional XHR timeout value, in ms.
         */this.loaderTimeout=a(t,"loader.timeout",0),/**
         * @const {boolean} Phaser.Core.Config#loaderWithCredentials - Optional XHR withCredentials value.
         */this.loaderWithCredentials=a(t,"loader.withCredentials",!1),/*
         * Allows `plugins` property to either be an array, in which case it just replaces
         * the default plugins like previously, or a config object.
         *
         * plugins: {
         *    global: [
         *        { key: 'TestPlugin', plugin: TestPlugin, start: true, data: { msg: 'The plugin is alive' } },
         *    ],
         *    scene: [
         *        { key: 'WireFramePlugin', plugin: WireFramePlugin, systemKey: 'wireFramePlugin', sceneKey: 'wireframe' }
         *    ],
         *    default: [], OR
         *    defaultMerge: [
         *        'ModPlayer'
         *    ]
         * }
         *//**
         * @const {any} Phaser.Core.Config#installGlobalPlugins - An array of global plugins to be installed.
         */this.installGlobalPlugins=[],/**
         * @const {any} Phaser.Core.Config#installScenePlugins - An array of Scene level plugins to be installed.
         */this.installScenePlugins=[];var f=a(t,"plugins",null),p=c.DefaultScene;f&&(Array.isArray(f)?this.defaultPlugins=f:h(f)&&(this.installGlobalPlugins=o(f,"global",[]),this.installScenePlugins=o(f,"scene",[]),Array.isArray(f.default)?p=f.default:Array.isArray(f.defaultMerge)&&(p=p.concat(f.defaultMerge)))),/**
         * @const {any} Phaser.Core.Config#defaultPlugins - The plugins installed into every Scene (in addition to CoreScene and Global).
         */this.defaultPlugins=p;//  Default / Missing Images
var g="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg";/**
         * @const {string} Phaser.Core.Config#defaultImage - A base64 encoded PNG that will be used as the default blank texture.
         */this.defaultImage=a(t,"images.default",g+"AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg=="),/**
         * @const {string} Phaser.Core.Config#missingImage - A base64 encoded PNG that will be used as the default texture when a texture is assigned that is missing or not loaded.
         */this.missingImage=a(t,"images.missing",g+"CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg=="),window&&(window.FORCE_WEBGL?this.renderType=n.WEBGL:window.FORCE_CANVAS&&(this.renderType=n.CANVAS))}});t.exports=f}),r("eii8B",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games can share it,
//  without having to re-poll the device all over again
/**
 * @namespace Phaser.Device
 * @since 3.0.0
 *//**
 * @typedef {object} Phaser.DeviceConf
 *
 * @property {Phaser.Device.OS} os - The OS Device functions.
 * @property {Phaser.Device.Browser} browser - The Browser Device functions.
 * @property {Phaser.Device.Features} features - The Features Device functions.
 * @property {Phaser.Device.Input} input - The Input Device functions.
 * @property {Phaser.Device.Audio} audio - The Audio Device functions.
 * @property {Phaser.Device.Video} video - The Video Device functions.
 * @property {Phaser.Device.Fullscreen} fullscreen - The Fullscreen Device functions.
 * @property {Phaser.Device.CanvasFeatures} canvasFeatures - The Canvas Device functions.
 */t.exports={os:s("1SePj"),browser:s("2wzxo"),features:s("9t9UB"),input:s("7NL8P"),audio:s("5pvsp"),video:s("cKO6v"),fullscreen:s("hKXoV"),canvasFeatures:s("lz57b")}}),r("1SePj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * Determines the operating system of the device running this Phaser Game instance.
 * These values are read-only and populated during the boot sequence of the game.
 * They are then referenced by internal game systems and are available for you to access
 * via `this.sys.game.device.os` from within any Scene.
 *
 * @typedef {object} Phaser.Device.OS
 * @since 3.0.0
 *
 * @property {boolean} android - Is running on android?
 * @property {boolean} chromeOS - Is running on chromeOS?
 * @property {boolean} cordova - Is the game running under Apache Cordova?
 * @property {boolean} crosswalk - Is the game running under the Intel Crosswalk XDK?
 * @property {boolean} desktop - Is running on a desktop?
 * @property {boolean} ejecta - Is the game running under Ejecta?
 * @property {boolean} electron - Is the game running under GitHub Electron?
 * @property {boolean} iOS - Is running on iOS?
 * @property {boolean} iPad - Is running on iPad?
 * @property {boolean} iPhone - Is running on iPhone?
 * @property {boolean} kindle - Is running on an Amazon Kindle?
 * @property {boolean} linux - Is running on linux?
 * @property {boolean} macOS - Is running on macOS?
 * @property {boolean} node - Is the game running under Node.js?
 * @property {boolean} nodeWebkit - Is the game running under Node-Webkit?
 * @property {boolean} webApp - Set to true if running as a WebApp, i.e. within a WebView
 * @property {boolean} windows - Is running on windows?
 * @property {boolean} windowsPhone - Is running on a Windows Phone?
 * @property {number} iOSVersion - If running in iOS this will contain the major version number.
 * @property {number} pixelRatio - PixelRatio of the host device?
 */var i,n,r=s("hPtJY"),o={android:!1,chromeOS:!1,cordova:!1,crosswalk:!1,desktop:!1,ejecta:!1,electron:!1,iOS:!1,iOSVersion:0,iPad:!1,iPhone:!1,kindle:!1,linux:!1,macOS:!1,node:!1,nodeWebkit:!1,pixelRatio:1,webApp:!1,windows:!1,windowsPhone:!1};t.exports=(i=navigator.userAgent,/Windows/.test(i)?o.windows=!0:/Mac OS/.test(i)&&!/like Mac OS/.test(i)?o.macOS=!0:/Android/.test(i)?o.android=!0:/Linux/.test(i)?o.linux=!0:/iP[ao]d|iPhone/i.test(i)?(o.iOS=!0,navigator.appVersion.match(/OS (\d+)/),o.iOSVersion=parseInt(RegExp.$1,10),o.iPhone=-1!==i.toLowerCase().indexOf("iphone"),o.iPad=-1!==i.toLowerCase().indexOf("ipad")):/Kindle/.test(i)||/\bKF[A-Z][A-Z]+/.test(i)||/Silk.*Mobile Safari/.test(i)?o.kindle=!0:/CrOS/.test(i)&&(o.chromeOS=!0),(/Windows Phone/i.test(i)||/IEMobile/i.test(i))&&(o.android=!1,o.iOS=!1,o.macOS=!1,o.windows=!0,o.windowsPhone=!0),n=/Silk/.test(i),(o.windows||o.macOS||o.linux&&!n||o.chromeOS)&&(o.desktop=!0),(o.windowsPhone||/Windows NT/i.test(i)&&/Touch/i.test(i))&&(o.desktop=!1),navigator.standalone&&(o.webApp=!0),void 0!==window.cordova&&(o.cordova=!0),void 0!==r&&r.versions&&r.versions.node&&(o.node=!0),o.node&&"object"==typeof r.versions&&(o.nodeWebkit=!!r.versions["node-webkit"],o.electron=!!r.versions.electron),void 0!==window.ejecta&&(o.ejecta=!0),/Crosswalk/.test(i)&&(o.crosswalk=!0),o.pixelRatio=window.devicePixelRatio||1,o)}),r("hPtJY",function(t,e){// shim for using process in browser
var i,n,s,r=t.exports={};function o(){throw Error("setTimeout has not been defined")}function a(){throw Error("clearTimeout has not been defined")}function h(t){if(i===setTimeout)return setTimeout(t,0);// if setTimeout wasn't available but was latter defined
if((i===o||!i)&&setTimeout)return i=setTimeout,setTimeout(t,0);try{// when when somebody has screwed with setTimeout but no I.E. maddness
return i(t,0)}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
return i.call(null,t,0)}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
return i.call(this,t,0)}}}!function(){try{i="function"==typeof setTimeout?setTimeout:o}catch(t){i=o}try{n="function"==typeof clearTimeout?clearTimeout:a}catch(t){n=a}}();var l=[],u=!1,c=-1;function d(){u&&s&&(u=!1,s.length?l=s.concat(l):c=-1,l.length&&f())}function f(){if(!u){var t=h(d);u=!0;for(var e=l.length;e;){for(s=l,l=[];++c<e;)s&&s[c].run();c=-1,e=l.length}s=null,u=!1,function(t){if(n===clearTimeout)return clearTimeout(t);// if clearTimeout wasn't available but was latter defined
if((n===a||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(t);try{// when when somebody has screwed with setTimeout but no I.E. maddness
n(t)}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
return n.call(null,t)}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
// Some versions of I.E. have different rules for clearTimeout vs setTimeout
return n.call(this,t)}}}(t)}}// v8 likes predictible objects
function p(t,e){this.fun=t,this.array=e}function g(){}r.nextTick=function(t){var e=Array(arguments.length-1);if(arguments.length>1)for(var i=1;i<arguments.length;i++)e[i-1]=arguments[i];l.push(new p(t,e)),1!==l.length||u||h(f)},p.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=g,r.addListener=g,r.once=g,r.off=g,r.removeListener=g,r.removeAllListeners=g,r.emit=g,r.prependListener=g,r.prependOnceListener=g,r.listeners=function(t){return[]},r.binding=function(t){throw Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(t){throw Error("process.chdir is not supported")},r.umask=function(){return 0}}),r("2wzxo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i,n=s("1SePj"),r={chrome:!1,chromeVersion:0,edge:!1,firefox:!1,firefoxVersion:0,ie:!1,ieVersion:0,mobileSafari:!1,opera:!1,safari:!1,safariVersion:0,silk:!1,trident:!1,tridentVersion:0};t.exports=(i=navigator.userAgent,/Edge\/\d+/.test(i)?r.edge=!0:/Chrome\/(\d+)/.test(i)&&!n.windowsPhone?(r.chrome=!0,r.chromeVersion=parseInt(RegExp.$1,10)):/Firefox\D+(\d+)/.test(i)?(r.firefox=!0,r.firefoxVersion=parseInt(RegExp.$1,10)):/AppleWebKit/.test(i)&&n.iOS?r.mobileSafari=!0:/MSIE (\d+\.\d+);/.test(i)?(r.ie=!0,r.ieVersion=parseInt(RegExp.$1,10)):/Opera/.test(i)?r.opera=!0:/Safari/.test(i)&&!n.windowsPhone?r.safari=!0:/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(i)&&(r.ie=!0,r.trident=!0,r.tridentVersion=parseInt(RegExp.$1,10),r.ieVersion=parseInt(RegExp.$3,10)),/Silk/.test(i)&&(r.silk=!0),r)}),r("9t9UB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1SePj"),n=s("2wzxo"),r=s("kKoer"),o={canvas:!1,canvasBitBltShift:null,file:!1,fileSystem:!1,getUserMedia:!0,littleEndian:!1,localStorage:!1,pointerLock:!1,support32bit:!1,vibration:!1,webGL:!1,worker:!1};t.exports=function(){o.canvas=!!window.CanvasRenderingContext2D;try{o.localStorage=!!localStorage.getItem}catch(t){o.localStorage=!1}o.file=!!window.File&&!!window.FileReader&&!!window.FileList&&!!window.Blob,o.fileSystem=!!window.requestFileSystem;var t,e,s,a=!1;return o.webGL=function(){if(window.WebGLRenderingContext)try{var t=r.createWebGL(this),e=t.getContext("webgl")||t.getContext("experimental-webgl"),i=r.create2D(this);return(//  Test to see if ImageData uses CanvasPixelArray or Uint8ClampedArray.
//  @author Matt DesLauriers (@mattdesl)
a=i.getContext("2d").createImageData(1,1).data instanceof Uint8ClampedArray,r.remove(t),r.remove(i),!!e)}catch(t){}return!1}(),o.worker=!!window.Worker,o.pointerLock="pointerLockElement"in document||"mozPointerLockElement"in document||"webkitPointerLockElement"in document,navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia||navigator.oGetUserMedia,window.URL=window.URL||window.webkitURL||window.mozURL||window.msURL,o.getUserMedia=o.getUserMedia&&!!navigator.getUserMedia&&!!window.URL,n.firefox&&n.firefoxVersion<21&&(o.getUserMedia=!1),!i.iOS&&(n.ie||n.firefox||n.chrome)&&(o.canvasBitBltShift=!0),(n.safari||n.mobileSafari)&&(o.canvasBitBltShift=!1),navigator.vibrate=navigator.vibrate||navigator.webkitVibrate||navigator.mozVibrate||navigator.msVibrate,navigator.vibrate&&(o.vibration=!0),"undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint32Array&&(o.littleEndian=(t=new ArrayBuffer(4),e=new Uint8Array(t),s=new Uint32Array(t),e[0]=161,e[1]=178,e[2]=195,e[3]=212,3569595041===s[0]||2712847316!==s[0]&&null)),o.support32bit="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof Int32Array&&null!==o.littleEndian&&a,o}()}),r("7NL8P",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2wzxo"),n={gamepads:!1,mspointer:!1,touch:!1,wheelEvent:null};t.exports=(("ontouchstart"in document.documentElement||navigator.maxTouchPoints&&navigator.maxTouchPoints>=1)&&(n.touch=!0),(navigator.msPointerEnabled||navigator.pointerEnabled)&&(n.mspointer=!0),navigator.getGamepads&&(n.gamepads=!0),"onwheel"in window||i.ie&&"WheelEvent"in window?n.wheelEvent="wheel":"onmousewheel"in window?n.wheelEvent="mousewheel":i.firefox&&"MouseScrollEvent"in window&&(n.wheelEvent="DOMMouseScroll"),n)}),r("5pvsp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2wzxo"),n={audioData:!1,dolby:!1,m4a:!1,mp3:!1,ogg:!1,opus:!1,wav:!1,webAudio:!1,webm:!1};t.exports=function(){n.audioData=!!window.Audio,n.webAudio=!!(window.AudioContext||window.webkitAudioContext);var t=document.createElement("audio"),e=!!t.canPlayType;try{if(e&&(t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,"")&&(n.ogg=!0),(t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/,"")||t.canPlayType("audio/opus;").replace(/^no$/,""))&&(n.opus=!0),t.canPlayType("audio/mpeg;").replace(/^no$/,"")&&(n.mp3=!0),t.canPlayType('audio/wav; codecs="1"').replace(/^no$/,"")&&(n.wav=!0),(t.canPlayType("audio/x-m4a;")||t.canPlayType("audio/aac;").replace(/^no$/,""))&&(n.m4a=!0),t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,"")&&(n.webm=!0),""!==t.canPlayType('audio/mp4;codecs="ec-3"'))){if(i.edge)n.dolby=!0;else if(i.safari&&i.safariVersion>=9&&/Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)){var s=parseInt(RegExp.$1,10),r=parseInt(RegExp.$2,10);(10===s&&r>=11||s>10)&&(n.dolby=!0)}}}catch(t){//  Nothing to do here
}return n}()}),r("cKO6v",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * Determines the video support of the browser running this Phaser Game instance.
 * These values are read-only and populated during the boot sequence of the game.
 * They are then referenced by internal game systems and are available for you to access
 * via `this.sys.game.device.video` from within any Scene.
 * 
 * In Phaser 3.20 the properties were renamed to drop the 'Video' suffix.
 * 
 * @typedef {object} Phaser.Device.Video
 * @since 3.0.0
 * 
 * @property {boolean} h264 - Can this device play h264 mp4 video files?
 * @property {boolean} hls - Can this device play hls video files?
 * @property {boolean} mp4 - Can this device play h264 mp4 video files?
 * @property {boolean} ogg - Can this device play ogg video files?
 * @property {boolean} vp9 - Can this device play vp9 video files?
 * @property {boolean} webm - Can this device play webm video files?
 */var i={h264:!1,hls:!1,mp4:!1,ogg:!1,vp9:!1,webm:!1};t.exports=function(){var t=document.createElement("video"),e=!!t.canPlayType;try{e&&(t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/,"")&&(i.ogg=!0),t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/,"")&&(// Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
i.h264=!0,i.mp4=!0),t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/,"")&&(i.webm=!0),t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/,"")&&(i.vp9=!0),t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/,"")&&(i.hls=!0))}catch(t){//  Nothing to do
}return i}()}),r("hKXoV",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * Determines the full screen support of the browser running this Phaser Game instance.
 * These values are read-only and populated during the boot sequence of the game.
 * They are then referenced by internal game systems and are available for you to access
 * via `this.sys.game.device.fullscreen` from within any Scene.
 * 
 * @typedef {object} Phaser.Device.Fullscreen
 * @since 3.0.0
 * 
 * @property {boolean} available - Does the browser support the Full Screen API?
 * @property {boolean} keyboard - Does the browser support access to the Keyboard during Full Screen mode?
 * @property {string} cancel - If the browser supports the Full Screen API this holds the call you need to use to cancel it.
 * @property {string} request - If the browser supports the Full Screen API this holds the call you need to use to activate it.
 */var i={available:!1,cancel:"",keyboard:!1,request:""};t.exports=/**
* Checks for support of the Full Screen API.
* 
* @ignore
*/function(){var t,e="Fullscreen",n="FullScreen",s=["request"+e,"request"+n,"webkitRequest"+e,"webkitRequest"+n,"msRequest"+e,"msRequest"+n,"mozRequest"+n,"mozRequest"+e];for(t=0;t<s.length;t++)if(document.documentElement[s[t]]){i.available=!0,i.request=s[t];break}var r=["cancel"+n,"exit"+e,"webkitCancel"+n,"webkitExit"+e,"msCancel"+n,"msExit"+e,"mozCancel"+n,"mozExit"+e];if(i.available){for(t=0;t<r.length;t++)if(document[r[t]]){i.cancel=r[t];break}}return window.Element&&Element.ALLOW_KEYBOARD_INPUT&&!/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent)&&(i.keyboard=!0),Object.defineProperty(i,"active",{get:function(){return!!(document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.msFullscreenElement)}}),i}()}),r("lz57b",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kKoer"),n={supportInverseAlpha:!1,supportNewBlendModes:!1};t.exports=function(){if(void 0!==document){var t,e,s;n.supportNewBlendModes=(t="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",e="AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",(s=new Image).onload=function(){var r=new Image;r.onload=function(){var t=i.create(r,6,1).getContext("2d");if(t.globalCompositeOperation="multiply",t.drawImage(s,0,0),t.drawImage(r,2,0),!t.getImageData(2,0,1,1))return!1;var e=t.getImageData(2,0,1,1).data;i.remove(r),n.supportNewBlendModes=255===e[0]&&0===e[1]&&0===e[2]},r.src=t+"/wCKxvRF"+e},s.src=t+"AP804Oa6"+e,!1),n.supportInverseAlpha=function(){var t=i.create(this,2,1).getContext("2d");t.fillStyle="rgba(10, 20, 30, 0.5)",//  Draw a single pixel
t.fillRect(0,0,1,1);//  Get the color values
var e=t.getImageData(0,0,1,1);if(null===e)return!1;//  Plot them to x2
t.putImageData(e,1,0);//  Get those values
var n=t.getImageData(1,0,1,1);//  Compare and return
return n.data[0]===e.data[0]&&n.data[1]===e.data[1]&&n.data[2]===e.data[2]&&n.data[3]===e.data[3]}()}return n}()}),r("5OyGi",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bNtDi"),n=s("hVk4C"),r={//  Collections of functions
Angle:s("4E77s"),Distance:s("e8x5Y"),Easing:s("llvIY"),Fuzzy:s("iBe1F"),Interpolation:s("9DXii"),Pow2:s("6uljX"),Snap:s("5cdku"),//  Expose the RNG Class
RandomDataGenerator:s("kZvwz"),//  Single functions
Average:s("kljIP"),Bernstein:s("iV0zT"),Between:s("2EBZh"),CatmullRom:s("4pkLE"),CeilTo:s("aUMR7"),Clamp:s("iEUUO"),DegToRad:s("2zqSA"),Difference:s("aAJEh"),Factorial:s("4Aff2"),FloatBetween:s("ilYgh"),FloorTo:s("7i50Z"),FromPercent:s("hqfaz"),GetSpeed:s("41iYH"),IsEven:s("9nYPL"),IsEvenStrict:s("ln03h"),Linear:s("fDkZ4"),MaxAdd:s("7Rizn"),MinSub:s("3tkM7"),Percent:s("90CDP"),RadToDeg:s("dcSyA"),RandomXY:s("7tDIc"),RandomXYZ:s("aBiCH"),RandomXYZW:s("5ojVH"),Rotate:s("kaMwv"),RotateAround:s("5Ntai"),RotateAroundDistance:s("k8Nlz"),RoundAwayFromZero:s("dzVSZ"),RoundTo:s("d5xgb"),SinCosTableGenerator:s("cHvgN"),SmootherStep:s("1YVfA"),SmoothStep:s("363Nu"),ToXY:s("kCBVf"),TransformXY:s("coTXE"),Within:s("fIwMQ"),Wrap:s("8qWuA"),//  Vector classes
Vector2:s("7SBSk"),Vector3:s("gbKIZ"),Vector4:s("27QVG"),Matrix3:s("gX42i"),Matrix4:s("hD0DV"),Quaternion:s("jzUY5"),RotateVec3:s("iV7dk")};//   Merge in the consts
r=n(!1,r,i),//  Export it
t.exports=r}),r("4E77s",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Angle
 */t.exports={Between:s("n95vh"),BetweenPoints:s("hhiaI"),BetweenPointsY:s("fa5Av"),BetweenY:s("9B6ty"),CounterClockwise:s("a91kL"),Normalize:s("lqGs2"),Random:s("9yd3b"),RandomDegrees:s("efIqc"),Reverse:s("eWA62"),RotateTo:s("cyWaM"),ShortestBetween:s("7V7Oj"),Wrap:s("1W59j"),WrapDegrees:s("dokq5")}}),r("n95vh",function(t,e){t.exports=function(t,e,i,n){return Math.atan2(n-e,i-t)}}),r("hhiaI",function(t,e){t.exports=function(t,e){return Math.atan2(e.y-t.y,e.x-t.x)}}),r("fa5Av",function(t,e){t.exports=function(t,e){return Math.atan2(e.x-t.x,e.y-t.y)}}),r("9B6ty",function(t,e){t.exports=function(t,e,i,n){return Math.atan2(i-t,n-e)}}),r("a91kL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bNtDi");t.exports=function(t){return t>Math.PI&&(t-=i.PI2),Math.abs(((t+i.TAU)%i.PI2-i.PI2)%i.PI2)}}),r("lqGs2",function(t,e){t.exports=function(t){return(t%=2*Math.PI)>=0?t:t+2*Math.PI}}),r("9yd3b",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       @samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ilYgh");t.exports=function(){return i(-Math.PI,Math.PI)}}),r("ilYgh",function(t,e){t.exports=function(t,e){return Math.random()*(e-t)+t}}),r("efIqc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       @samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ilYgh");t.exports=function(){return i(-180,180)}}),r("eWA62",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("lqGs2");t.exports=function(t){return i(t+Math.PI)}}),r("cyWaM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bNtDi");t.exports=function(t,e,n){return void 0===n&&(n=.05),t===e||(Math.abs(e-t)<=n||Math.abs(e-t)>=i.PI2-n?t=e:(Math.abs(e-t)>Math.PI&&(e<t?e+=i.PI2:e-=i.PI2),e>t?t+=n:e<t&&(t-=n))),t}}),r("7V7Oj",function(t,e){t.exports=function(t,e){var i=e-t;if(0===i)return 0;var n=Math.floor((i- -180)/360);return i-360*n}}),r("e8x5Y",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Distance
 */t.exports={Between:s("bwLQh"),BetweenPoints:s("ljUB8"),BetweenPointsSquared:s("7uDHS"),Chebyshev:s("l8Nsx"),Power:s("axhHp"),Snake:s("6AzPM"),Squared:s("gMODW")}}),r("ljUB8",function(t,e){t.exports=function(t,e){var i=t.x-e.x,n=t.y-e.y;return Math.sqrt(i*i+n*n)}}),r("7uDHS",function(t,e){t.exports=function(t,e){var i=t.x-e.x,n=t.y-e.y;return i*i+n*n}}),r("l8Nsx",function(t,e){t.exports=function(t,e,i,n){return Math.max(Math.abs(t-i),Math.abs(e-n))}}),r("axhHp",function(t,e){t.exports=function(t,e,i,n,s){return void 0===s&&(s=2),Math.sqrt(Math.pow(i-t,s)+Math.pow(n-e,s))}}),r("6AzPM",function(t,e){t.exports=function(t,e,i,n){return Math.abs(t-i)+Math.abs(e-n)}}),r("gMODW",function(t,e){t.exports=function(t,e,i,n){var s=t-i,r=e-n;return s*s+r*r}}),r("llvIY",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Easing
 */t.exports={Back:s("GYEL3"),Bounce:s("1RSgF"),Circular:s("8s9Sd"),Cubic:s("aG266"),Elastic:s("jDd1d"),Expo:s("gZBzc"),Linear:s("hBgCe"),Quadratic:s("c4phQ"),Quartic:s("czPB4"),Quintic:s("2NYh6"),Sine:s("filII"),Stepped:s("dfXsE")}}),r("iBe1F",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Fuzzy
 */t.exports={Ceil:s("7z8Vi"),Equal:s("4cohD"),Floor:s("7qkzk"),GreaterThan:s("4wJN7"),LessThan:s("ccP8g")}}),r("7z8Vi",function(t,e){t.exports=function(t,e){return void 0===e&&(e=1e-4),Math.ceil(t-e)}}),r("7qkzk",function(t,e){t.exports=function(t,e){return void 0===e&&(e=1e-4),Math.floor(t+e)}}),r("4wJN7",function(t,e){t.exports=function(t,e,i){return void 0===i&&(i=1e-4),t>e-i}}),r("ccP8g",function(t,e){t.exports=function(t,e,i){return void 0===i&&(i=1e-4),t<e+i}}),r("9DXii",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Interpolation
 */t.exports={Bezier:s("gdOTp"),CatmullRom:s("jKp6L"),CubicBezier:s("2OzPP"),Linear:s("fTwhC"),QuadraticBezier:s("lNAp3"),SmoothStep:s("gLlh1"),SmootherStep:s("geoiv")}}),r("gdOTp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iV0zT");t.exports=function(t,e){for(var n=0,s=t.length-1,r=0;r<=s;r++)n+=Math.pow(1-e,s-r)*Math.pow(e,r)*t[r]*i(s,r);return n}}),r("iV0zT",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("4Aff2");t.exports=function(t,e){return i(t)/i(e)/i(t-e)}}),r("4Aff2",function(t,e){t.exports=function(t){if(0===t)return 1;for(var e=t;--t;)e*=t;return e}}),r("jKp6L",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("4pkLE");t.exports=function(t,e){var n=t.length-1,s=n*e,r=Math.floor(s);return t[0]===t[n]?(e<0&&(r=Math.floor(s=n*(1+e))),i(s-r,t[(r-1+n)%n],t[r],t[(r+1)%n],t[(r+2)%n])):e<0?t[0]-(i(-s,t[0],t[0],t[1],t[1])-t[0]):e>1?t[n]-(i(s-n,t[n],t[n],t[n-1],t[n-1])-t[n]):i(s-r,t[r?r-1:0],t[r],t[n<r+1?n:r+1],t[n<r+2?n:r+2])}}),r("4pkLE",function(t,e){t.exports=function(t,e,i,n,s){var r=(n-e)*.5,o=(s-i)*.5,a=t*t;return(2*i-2*n+r+o)*(t*a)+(-3*i+3*n-2*r-o)*a+r*t+i}}),r("2OzPP",function(t,e){t.exports=function(t,e,i,n,s){var r,o;return(r=1-t)*r*r*e+3*(o=1-t)*o*t*i+3*(1-t)*t*t*n+t*t*t*s}}),r("fTwhC",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("fDkZ4");t.exports=function(t,e){var n=t.length-1,s=n*e,r=Math.floor(s);return e<0?i(t[0],t[1],s):e>1?i(t[n],t[n-1],n-s):i(t[r],t[r+1>n?n:r+1],s-r)}}),r("lNAp3",function(t,e){t.exports=function(t,e,i,n){var s;return(s=1-t)*s*e+2*(1-t)*t*i+t*t*n}}),r("gLlh1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("363Nu");t.exports=function(t,e,n){return e+(n-e)*i(t,0,1)}}),r("geoiv",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1YVfA");t.exports=function(t,e,n){return e+(n-e)*i(t,0,1)}}),r("6uljX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Pow2
 */t.exports={GetNext:s("6QpKi"),IsSize:s("gV9Y0"),IsValue:s("6XmFv")}}),r("6QpKi",function(t,e){t.exports=function(t){return 1<<Math.ceil(Math.log(t)/.6931471805599453)}}),r("gV9Y0",function(t,e){t.exports=function(t,e){return t>0&&(t&t-1)==0&&e>0&&(e&e-1)==0}}),r("6XmFv",function(t,e){t.exports=function(t){return t>0&&(t&t-1)==0}}),r("5cdku",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Math.Snap
 */t.exports={Ceil:s("lpfsR"),Floor:s("jcIaO"),To:s("ehniC")}}),r("lpfsR",function(t,e){t.exports=function(t,e,i,n){return(void 0===i&&(i=0),0===e)?t:(t-=i,t=e*Math.ceil(t/e),n?(i+t)/e:i+t)}}),r("jcIaO",function(t,e){t.exports=function(t,e,i,n){return(void 0===i&&(i=0),0===e)?t:(t-=i,t=e*Math.floor(t/e),n?(i+t)/e:i+t)}}),r("ehniC",function(t,e){t.exports=function(t,e,i,n){return(void 0===i&&(i=0),0===e)?t:(t-=i,t=e*Math.round(t/e),n?(i+t)/e:i+t)}}),r("kZvwz",function(t,e){/**
 * @classdesc
 * A seeded Random Data Generator.
 * 
 * Access via `Phaser.Math.RND` which is an instance of this class pre-defined
 * by Phaser. Or, create your own instance to use as you require.
 * 
 * The `Math.RND` generator is seeded by the Game Config property value `seed`.
 * If no such config property exists, a random number is used.
 * 
 * If you create your own instance of this class you should provide a seed for it.
 * If no seed is given it will use a 'random' one based on Date.now.
 *
 * @class RandomDataGenerator
 * @memberof Phaser.Math
 * @constructor
 * @since 3.0.0
 *
 * @param {(string|string[])} [seeds] - The seeds to use for the random number generator.
 */var i=new(s("jwj1g"))({initialize:function(t){void 0===t&&(t=[(Date.now()*Math.random()).toString()]),/**
         * Internal var.
         *
         * @name Phaser.Math.RandomDataGenerator#c
         * @type {number}
         * @default 1
         * @private
         * @since 3.0.0
         */this.c=1,/**
         * Internal var.
         *
         * @name Phaser.Math.RandomDataGenerator#s0
         * @type {number}
         * @default 0
         * @private
         * @since 3.0.0
         */this.s0=0,/**
         * Internal var.
         *
         * @name Phaser.Math.RandomDataGenerator#s1
         * @type {number}
         * @default 0
         * @private
         * @since 3.0.0
         */this.s1=0,/**
         * Internal var.
         *
         * @name Phaser.Math.RandomDataGenerator#s2
         * @type {number}
         * @default 0
         * @private
         * @since 3.0.0
         */this.s2=0,/**
         * Internal var.
         *
         * @name Phaser.Math.RandomDataGenerator#n
         * @type {number}
         * @default 0
         * @private
         * @since 3.2.0
         */this.n=0,/**
         * Signs to choose from.
         *
         * @name Phaser.Math.RandomDataGenerator#signs
         * @type {number[]}
         * @since 3.0.0
         */this.signs=[-1,1],t&&this.init(t)},/**
     * Private random helper.
     *
     * @method Phaser.Math.RandomDataGenerator#rnd
     * @since 3.0.0
     * @private
     *
     * @return {number} A random number.
     */rnd:function(){var t=2091639*this.s0+23283064365386963e-26*this.c;// 2^-32
return this.c=0|t,this.s0=this.s1,this.s1=this.s2,this.s2=t-this.c,this.s2},/**
     * Internal method that creates a seed hash.
     *
     * @method Phaser.Math.RandomDataGenerator#hash
     * @since 3.0.0
     * @private
     *
     * @param {string} data - The value to hash.
     *
     * @return {number} The hashed value.
     */hash:function(t){var e,i=this.n;t=t.toString();for(var n=0;n<t.length;n++)i+=t.charCodeAt(n),i=(e=.02519603282416938*i)>>>0,e-=i,e*=i,i=e>>>0,e-=i,i+=4294967296*e;return this.n=i,(i>>>0)*23283064365386963e-26;// 2^-32
},/**
     * Initialize the state of the random data generator.
     *
     * @method Phaser.Math.RandomDataGenerator#init
     * @since 3.0.0
     *
     * @param {(string|string[])} seeds - The seeds to initialize the random data generator with.
     */init:function(t){"string"==typeof t?this.state(t):this.sow(t)},/**
     * Reset the seed of the random data generator.
     *
     * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.
     *
     * @method Phaser.Math.RandomDataGenerator#sow
     * @since 3.0.0
     *
     * @param {string[]} seeds - The array of seeds: the `toString()` of each value is used.
     */sow:function(t){if(// Always reset to default seed
this.n=4022871197,this.s0=this.hash(" "),this.s1=this.hash(" "),this.s2=this.hash(" "),this.c=1,t)// Apply any seeds
for(var e=0;e<t.length&&null!=t[e];e++){var i=t[e];this.s0-=this.hash(i),this.s0+=~~(this.s0<0),this.s1-=this.hash(i),this.s1+=~~(this.s1<0),this.s2-=this.hash(i),this.s2+=~~(this.s2<0)}},/**
     * Returns a random integer between 0 and 2^32.
     *
     * @method Phaser.Math.RandomDataGenerator#integer
     * @since 3.0.0
     *
     * @return {number} A random integer between 0 and 2^32.
     */integer:function(){// 2^32
return 4294967296*this.rnd()},/**
     * Returns a random real number between 0 and 1.
     *
     * @method Phaser.Math.RandomDataGenerator#frac
     * @since 3.0.0
     *
     * @return {number} A random real number between 0 and 1.
     */frac:function(){// 2^-53
return this.rnd()+(2097152*this.rnd()|0)*11102230246251565e-32},/**
     * Returns a random real number between 0 and 2^32.
     *
     * @method Phaser.Math.RandomDataGenerator#real
     * @since 3.0.0
     *
     * @return {number} A random real number between 0 and 2^32.
     */real:function(){return this.integer()+this.frac()},/**
     * Returns a random integer between and including min and max.
     *
     * @method Phaser.Math.RandomDataGenerator#integerInRange
     * @since 3.0.0
     *
     * @param {number} min - The minimum value in the range.
     * @param {number} max - The maximum value in the range.
     *
     * @return {number} A random number between min and max.
     */integerInRange:function(t,e){return Math.floor(this.realInRange(0,e-t+1)+t)},/**
     * Returns a random integer between and including min and max.
     * This method is an alias for RandomDataGenerator.integerInRange.
     *
     * @method Phaser.Math.RandomDataGenerator#between
     * @since 3.0.0
     *
     * @param {number} min - The minimum value in the range.
     * @param {number} max - The maximum value in the range.
     *
     * @return {number} A random number between min and max.
     */between:function(t,e){return Math.floor(this.realInRange(0,e-t+1)+t)},/**
     * Returns a random real number between min and max.
     *
     * @method Phaser.Math.RandomDataGenerator#realInRange
     * @since 3.0.0
     *
     * @param {number} min - The minimum value in the range.
     * @param {number} max - The maximum value in the range.
     *
     * @return {number} A random number between min and max.
     */realInRange:function(t,e){return this.frac()*(e-t)+t},/**
     * Returns a random real number between -1 and 1.
     *
     * @method Phaser.Math.RandomDataGenerator#normal
     * @since 3.0.0
     *
     * @return {number} A random real number between -1 and 1.
     */normal:function(){return 1-2*this.frac()},/**
     * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
     *
     * @method Phaser.Math.RandomDataGenerator#uuid
     * @since 3.0.0
     *
     * @return {string} A valid RFC4122 version4 ID hex string
     */uuid:function(){var t="",e="";for(e=t="";t++<36;e+=~t%5|3*t&4?(15^t?8^this.frac()*(20^t?16:4):4).toString(16):"-");return e},/**
     * Returns a random element from within the given array.
     *
     * @method Phaser.Math.RandomDataGenerator#pick
     * @since 3.0.0
     * 
     * @generic T
     * @genericUse {T[]} - [array]
     * @genericUse {T} - [$return]
     *
     * @param {T[]} array - The array to pick a random element from.
     *
     * @return {T} A random member of the array.
     */pick:function(t){return t[this.integerInRange(0,t.length-1)]},/**
     * Returns a sign to be used with multiplication operator.
     *
     * @method Phaser.Math.RandomDataGenerator#sign
     * @since 3.0.0
     *
     * @return {number} -1 or +1.
     */sign:function(){return this.pick(this.signs)},/**
     * Returns a random element from within the given array, favoring the earlier entries.
     *
     * @method Phaser.Math.RandomDataGenerator#weightedPick
     * @since 3.0.0
     *
     * @generic T
     * @genericUse {T[]} - [array]
     * @genericUse {T} - [$return]
     *
     * @param {T[]} array - The array to pick a random element from.
     *
     * @return {T} A random member of the array.
     */weightedPick:function(t){return t[~~(Math.pow(this.frac(),2)*(t.length-1)+.5)]},/**
     * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
     *
     * @method Phaser.Math.RandomDataGenerator#timestamp
     * @since 3.0.0
     *
     * @param {number} min - The minimum value in the range.
     * @param {number} max - The maximum value in the range.
     *
     * @return {number} A random timestamp between min and max.
     */timestamp:function(t,e){return this.realInRange(t||9466848e5,e||1577862e6)},/**
     * Returns a random angle between -180 and 180.
     *
     * @method Phaser.Math.RandomDataGenerator#angle
     * @since 3.0.0
     *
     * @return {number} A random number between -180 and 180.
     */angle:function(){return this.integerInRange(-180,180)},/**
     * Returns a random rotation in radians, between -3.141 and 3.141
     *
     * @method Phaser.Math.RandomDataGenerator#rotation
     * @since 3.0.0
     *
     * @return {number} A random number between -3.141 and 3.141
     */rotation:function(){return this.realInRange(-3.1415926,3.1415926)},/**
     * Gets or Sets the state of the generator. This allows you to retain the values
     * that the generator is using between games, i.e. in a game save file.
     *
     * To seed this generator with a previously saved state you can pass it as the
     * `seed` value in your game config, or call this method directly after Phaser has booted.
     *
     * Call this method with no parameters to return the current state.
     *
     * If providing a state it should match the same format that this method
     * returns, which is a string with a header `!rnd` followed by the `c`,
     * `s0`, `s1` and `s2` values respectively, each comma-delimited.
     *
     * @method Phaser.Math.RandomDataGenerator#state
     * @since 3.0.0
     *
     * @param {string} [state] - Generator state to be set.
     *
     * @return {string} The current state of the generator.
     */state:function(t){return"string"==typeof t&&t.match(/^!rnd/)&&(t=t.split(","),this.c=parseFloat(t[1]),this.s0=parseFloat(t[2]),this.s1=parseFloat(t[3]),this.s2=parseFloat(t[4])),["!rnd",this.c,this.s0,this.s1,this.s2].join(",")},/**
     * Shuffles the given array, using the current seed.
     *
     * @method Phaser.Math.RandomDataGenerator#shuffle
     * @since 3.7.0
     *
     * @generic T
     * @genericUse {T[]} - [array,$return]
     *
     * @param {T[]} [array] - The array to be shuffled.
     *
     * @return {T[]} The shuffled array.
     */shuffle:function(t){for(var e=t.length-1,i=e;i>0;i--){var n=Math.floor(this.frac()*(i+1)),s=t[n];t[n]=t[i],t[i]=s}return t}});t.exports=i}),r("kljIP",function(t,e){t.exports=function(t){for(var e=0,i=0;i<t.length;i++)e+=+t[i];return e/t.length}}),r("2EBZh",function(t,e){t.exports=function(t,e){return Math.floor(Math.random()*(e-t+1)+t)}}),r("aUMR7",function(t,e){t.exports=function(t,e,i){void 0===e&&(e=0),void 0===i&&(i=10);var n=Math.pow(i,-e);return Math.ceil(t*n)/n}}),r("aAJEh",function(t,e){t.exports=function(t,e){return Math.abs(t-e)}}),r("7i50Z",function(t,e){t.exports=function(t,e,i){void 0===e&&(e=0),void 0===i&&(i=10);var n=Math.pow(i,-e);return Math.floor(t*n)/n}}),r("41iYH",function(t,e){t.exports=function(t,e){return t/e/1e3}}),r("9nYPL",function(t,e){t.exports=function(t){// Use abstract equality == for "is number" test
// eslint-disable-next-line eqeqeq
return t==parseFloat(t)?!(t%2):void 0}}),r("ln03h",function(t,e){t.exports=function(t){// Use strict equality === for "is number" test
return t===parseFloat(t)?!(t%2):void 0}}),r("7Rizn",function(t,e){t.exports=function(t,e,i){return Math.min(t+e,i)}}),r("3tkM7",function(t,e){t.exports=function(t,e,i){return Math.max(t-e,i)}}),r("90CDP",function(t,e){t.exports=function(t,e,i,n){void 0===i&&(i=e+1);var s=(t-e)/(i-e);return s>1?void 0!==n?(s=(n-t)/(n-i))<0&&(s=0):s=1:s<0&&(s=0),s}}),r("dcSyA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bNtDi");t.exports=function(t){return t*i.RAD_TO_DEG}}),r("7tDIc",function(t,e){t.exports=function(t,e){void 0===e&&(e=1);var i=2*Math.random()*Math.PI;return t.x=Math.cos(i)*e,t.y=Math.sin(i)*e,t}}),r("aBiCH",function(t,e){t.exports=function(t,e){void 0===e&&(e=1);var i=2*Math.random()*Math.PI,n=2*Math.random()-1,s=Math.sqrt(1-n*n)*e;return t.x=Math.cos(i)*s,t.y=Math.sin(i)*s,t.z=n*e,t}}),r("5ojVH",function(t,e){t.exports=function(t,e){return void 0===e&&(e=1),// TODO: Not spherical; should fix this for more uniform distribution
t.x=(2*Math.random()-1)*e,t.y=(2*Math.random()-1)*e,t.z=(2*Math.random()-1)*e,t.w=(2*Math.random()-1)*e,t}}),r("kaMwv",function(t,e){t.exports=function(t,e){var i=t.x,n=t.y;return t.x=i*Math.cos(e)-n*Math.sin(e),t.y=i*Math.sin(e)+n*Math.cos(e),t}}),r("dzVSZ",function(t,e){t.exports=function(t){// "Opposite" of truncate.
return t>0?Math.ceil(t):Math.floor(t)}}),r("d5xgb",function(t,e){t.exports=function(t,e,i){void 0===e&&(e=0),void 0===i&&(i=10);var n=Math.pow(i,-e);return Math.round(t*n)/n}}),r("cHvgN",function(t,e){t.exports=function(t,e,i,n){void 0===e&&(e=1),void 0===i&&(i=1),void 0===n&&(n=1),n*=Math.PI/t;for(var s=[],r=[],o=0;o<t;o++)i-=e*n,e+=i*n,s[o]=i,r[o]=e;return{sin:r,cos:s,length:t}}}),r("kCBVf",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7SBSk");t.exports=function(t,e,n,s){void 0===s&&(s=new i);var r=0,o=0;return t>0&&t<=e*n&&(t>e-1?(o=Math.floor(t/e),r=t-o*e):r=t,s.set(r,o)),s}}),r("coTXE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7SBSk");t.exports=function(t,e,n,s,r,o,a,h){void 0===h&&(h=new i);var l=Math.sin(r),u=Math.cos(r),c=u*o,d=l*o,f=-l*a,p=u*a,g=1/(c*p+-(f*d));return h.x=p*g*t+-f*g*e+(s*f-n*p)*g,h.y=c*g*e+-d*g*t+(-s*c+n*d)*g,h}}),r("fIwMQ",function(t,e){t.exports=function(t,e,i){return Math.abs(t-e)<=i}}),r("gbKIZ",function(t,e){/**
 * @classdesc
 * A representation of a vector in 3D space.
 *
 * A three-component vector.
 *
 * @class Vector3
 * @memberof Phaser.Math
 * @constructor
 * @since 3.0.0
 *
 * @param {number} [x] - The x component.
 * @param {number} [y] - The y component.
 * @param {number} [z] - The z component.
 */var i=new(s("jwj1g"))({initialize:function(t,e,i){/**
         * The x component of this Vector.
         *
         * @name Phaser.Math.Vector3#x
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.x=0,/**
         * The y component of this Vector.
         *
         * @name Phaser.Math.Vector3#y
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.y=0,/**
         * The z component of this Vector.
         *
         * @name Phaser.Math.Vector3#z
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.z=0,"object"==typeof t?(this.x=t.x||0,this.y=t.y||0,this.z=t.z||0):(this.x=t||0,this.y=e||0,this.z=i||0)},/**
     * Set this Vector to point up.
     *
     * Sets the y component of the vector to 1, and the others to 0.
     *
     * @method Phaser.Math.Vector3#up
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */up:function(){return this.x=0,this.y=1,this.z=0,this},/**
     * Make a clone of this Vector3.
     *
     * @method Phaser.Math.Vector3#clone
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector3} A new Vector3 object containing this Vectors values.
     */clone:function(){return new i(this.x,this.y,this.z)},/**
     * Calculate the cross (vector) product of two given Vectors.
     *
     * @method Phaser.Math.Vector3#crossVectors
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} a - The first Vector to multiply.
     * @param {Phaser.Math.Vector3} b - The second Vector to multiply.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */crossVectors:function(t,e){var i=t.x,n=t.y,s=t.z,r=e.x,o=e.y,a=e.z;return this.x=n*a-s*o,this.y=s*r-i*a,this.z=i*o-n*r,this},/**
     * Check whether this Vector is equal to a given Vector.
     *
     * Performs a strict equality check against each Vector's components.
     *
     * @method Phaser.Math.Vector3#equals
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} v - The Vector3 to compare against.
     *
     * @return {boolean} True if the two vectors strictly match, otherwise false.
     */equals:function(t){return this.x===t.x&&this.y===t.y&&this.z===t.z},/**
     * Copy the components of a given Vector into this Vector.
     *
     * @method Phaser.Math.Vector3#copy
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} src - The Vector to copy the components from.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */copy:function(t){return this.x=t.x,this.y=t.y,this.z=t.z||0,this},/**
     * Set the `x`, `y`, and `z` components of this Vector to the given `x`, `y`, and `z` values.
     *
     * @method Phaser.Math.Vector3#set
     * @since 3.0.0
     *
     * @param {(number|object)} x - The x value to set for this Vector, or an object containing x, y and z components.
     * @param {number} [y] - The y value to set for this Vector.
     * @param {number} [z] - The z value to set for this Vector.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */set:function(t,e,i){return"object"==typeof t?(this.x=t.x||0,this.y=t.y||0,this.z=t.z||0):(this.x=t||0,this.y=e||0,this.z=i||0),this},/**
     * Add a given Vector to this Vector. Addition is component-wise.
     *
     * @method Phaser.Math.Vector3#add
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to add to this Vector.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */add:function(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z||0,this},/**
     * Subtract the given Vector from this Vector. Subtraction is component-wise.
     *
     * @method Phaser.Math.Vector3#subtract
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to subtract from this Vector.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */subtract:function(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z||0,this},/**
     * Perform a component-wise multiplication between this Vector and the given Vector.
     *
     * Multiplies this Vector by the given Vector.
     *
     * @method Phaser.Math.Vector3#multiply
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to multiply this Vector by.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */multiply:function(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z||1,this},/**
     * Scale this Vector by the given value.
     *
     * @method Phaser.Math.Vector3#scale
     * @since 3.0.0
     *
     * @param {number} scale - The value to scale this Vector by.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */scale:function(t){return isFinite(t)?(this.x*=t,this.y*=t,this.z*=t):(this.x=0,this.y=0,this.z=0),this},/**
     * Perform a component-wise division between this Vector and the given Vector.
     *
     * Divides this Vector by the given Vector.
     *
     * @method Phaser.Math.Vector3#divide
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to divide this Vector by.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */divide:function(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z||1,this},/**
     * Negate the `x`, `y` and `z` components of this Vector.
     *
     * @method Phaser.Math.Vector3#negate
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this},/**
     * Calculate the distance between this Vector and the given Vector.
     *
     * @method Phaser.Math.Vector3#distance
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to calculate the distance to.
     *
     * @return {number} The distance from this Vector to the given Vector.
     */distance:function(t){var e=t.x-this.x,i=t.y-this.y,n=t.z-this.z||0;return Math.sqrt(e*e+i*i+n*n)},/**
     * Calculate the distance between this Vector and the given Vector, squared.
     *
     * @method Phaser.Math.Vector3#distanceSq
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to calculate the distance to.
     *
     * @return {number} The distance from this Vector to the given Vector, squared.
     */distanceSq:function(t){var e=t.x-this.x,i=t.y-this.y,n=t.z-this.z||0;return e*e+i*i+n*n},/**
     * Calculate the length (or magnitude) of this Vector.
     *
     * @method Phaser.Math.Vector3#length
     * @since 3.0.0
     *
     * @return {number} The length of this Vector.
     */length:function(){var t=this.x,e=this.y,i=this.z;return Math.sqrt(t*t+e*e+i*i)},/**
     * Calculate the length of this Vector squared.
     *
     * @method Phaser.Math.Vector3#lengthSq
     * @since 3.0.0
     *
     * @return {number} The length of this Vector, squared.
     */lengthSq:function(){var t=this.x,e=this.y,i=this.z;return t*t+e*e+i*i},/**
     * Normalize this Vector.
     *
     * Makes the vector a unit length vector (magnitude of 1) in the same direction.
     *
     * @method Phaser.Math.Vector3#normalize
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */normalize:function(){var t=this.x,e=this.y,i=this.z,n=t*t+e*e+i*i;return n>0&&(n=1/Math.sqrt(n),this.x=t*n,this.y=e*n,this.z=i*n),this},/**
     * Calculate the dot product of this Vector and the given Vector.
     *
     * @method Phaser.Math.Vector3#dot
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} v - The Vector3 to dot product with this Vector3.
     *
     * @return {number} The dot product of this Vector and `v`.
     */dot:function(t){return this.x*t.x+this.y*t.y+this.z*t.z},/**
     * Calculate the cross (vector) product of this Vector (which will be modified) and the given Vector.
     *
     * @method Phaser.Math.Vector3#cross
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} v - The Vector to cross product with.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */cross:function(t){var e=this.x,i=this.y,n=this.z,s=t.x,r=t.y,o=t.z;return this.x=i*o-n*r,this.y=n*s-e*o,this.z=e*r-i*s,this},/**
     * Linearly interpolate between this Vector and the given Vector.
     *
     * Interpolates this Vector towards the given Vector.
     *
     * @method Phaser.Math.Vector3#lerp
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} v - The Vector3 to interpolate towards.
     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */lerp:function(t,e){void 0===e&&(e=0);var i=this.x,n=this.y,s=this.z;return this.x=i+e*(t.x-i),this.y=n+e*(t.y-n),this.z=s+e*(t.z-s),this},/**
     * Transform this Vector with the given Matrix.
     *
     * @method Phaser.Math.Vector3#transformMat3
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector3 with.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */transformMat3:function(t){var e=this.x,i=this.y,n=this.z,s=t.val;return this.x=e*s[0]+i*s[3]+n*s[6],this.y=e*s[1]+i*s[4]+n*s[7],this.z=e*s[2]+i*s[5]+n*s[8],this},/**
     * Transform this Vector with the given Matrix.
     *
     * @method Phaser.Math.Vector3#transformMat4
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector3 with.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */transformMat4:function(t){var e=this.x,i=this.y,n=this.z,s=t.val;return this.x=s[0]*e+s[4]*i+s[8]*n+s[12],this.y=s[1]*e+s[5]*i+s[9]*n+s[13],this.z=s[2]*e+s[6]*i+s[10]*n+s[14],this},/**
     * Transforms the coordinates of this Vector3 with the given Matrix4.
     *
     * @method Phaser.Math.Vector3#transformCoordinates
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector3 with.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */transformCoordinates:function(t){var e=this.x,i=this.y,n=this.z,s=t.val,r=e*s[0]+i*s[4]+n*s[8]+s[12],o=e*s[1]+i*s[5]+n*s[9]+s[13],a=e*s[2]+i*s[6]+n*s[10]+s[14],h=e*s[3]+i*s[7]+n*s[11]+s[15];return this.x=r/h,this.y=o/h,this.z=a/h,this},/**
     * Transform this Vector with the given Quaternion.
     *
     * @method Phaser.Math.Vector3#transformQuat
     * @since 3.0.0
     *
     * @param {Phaser.Math.Quaternion} q - The Quaternion to transform this Vector with.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */transformQuat:function(t){// benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
var e=this.x,i=this.y,n=this.z,s=t.x,r=t.y,o=t.z,a=t.w,h=a*e+r*n-o*i,l=a*i+o*e-s*n,u=a*n+s*i-r*e,c=-s*e-r*i-o*n;return(// calculate result * inverse quat
this.x=h*a+-(c*s)+-(l*o)- -(u*r),this.y=l*a+-(c*r)+-(u*s)- -(h*o),this.z=u*a+-(c*o)+-(h*r)- -(l*s),this)},/**
     * Multiplies this Vector3 by the specified matrix, applying a W divide. This is useful for projection,
     * e.g. unprojecting a 2D point into 3D space.
     *
     * @method Phaser.Math.Vector3#project
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to multiply this Vector3 with.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */project:function(t){var e=this.x,i=this.y,n=this.z,s=t.val,r=s[0],o=s[1],a=s[2],h=s[3],l=s[4],u=s[5],c=s[6],d=s[7],f=s[8],p=s[9],g=s[10],v=s[11],m=s[12],y=s[13],x=s[14],w=1/(e*h+i*d+n*v+s[15]);return this.x=(e*r+i*l+n*f+m)*w,this.y=(e*o+i*u+n*p+y)*w,this.z=(e*a+i*c+n*g+x)*w,this},/**
     * Unproject this point from 2D space to 3D space.
     * The point should have its x and y properties set to
     * 2D screen space, and the z either at 0 (near plane)
     * or 1 (far plane). The provided matrix is assumed to already
     * be combined, i.e. projection * view * model.
     *
     * After this operation, this vector's (x, y, z) components will
     * represent the unprojected 3D coordinate.
     *
     * @method Phaser.Math.Vector3#unproject
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector4} viewport - Screen x, y, width and height in pixels.
     * @param {Phaser.Math.Matrix4} invProjectionView - Combined projection and view matrix.
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */unproject:function(t,e){var i=t.x,n=t.y,s=t.z,r=t.w,o=this.x-i,a=r-this.y-1-n,h=this.z;return this.x=2*o/s-1,this.y=2*a/r-1,this.z=2*h-1,this.project(e)},/**
     * Make this Vector the zero vector (0, 0, 0).
     *
     * @method Phaser.Math.Vector3#reset
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector3} This Vector3.
     */reset:function(){return this.x=0,this.y=0,this.z=0,this}});/**
 * A static zero Vector3 for use by reference.
 * 
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector3.ZERO
 * @type {Phaser.Math.Vector3}
 * @since 3.16.0
 */i.ZERO=new i,/**
 * A static right Vector3 for use by reference.
 * 
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector3.RIGHT
 * @type {Phaser.Math.Vector3}
 * @since 3.16.0
 */i.RIGHT=new i(1,0,0),/**
 * A static left Vector3 for use by reference.
 * 
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector3.LEFT
 * @type {Phaser.Math.Vector3}
 * @since 3.16.0
 */i.LEFT=new i(-1,0,0),/**
 * A static up Vector3 for use by reference.
 * 
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector3.UP
 * @type {Phaser.Math.Vector3}
 * @since 3.16.0
 */i.UP=new i(0,-1,0),/**
 * A static down Vector3 for use by reference.
 * 
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector3.DOWN
 * @type {Phaser.Math.Vector3}
 * @since 3.16.0
 */i.DOWN=new i(0,1,0),/**
 * A static forward Vector3 for use by reference.
 * 
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector3.FORWARD
 * @type {Phaser.Math.Vector3}
 * @since 3.16.0
 */i.FORWARD=new i(0,0,1),/**
 * A static back Vector3 for use by reference.
 * 
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector3.BACK
 * @type {Phaser.Math.Vector3}
 * @since 3.16.0
 */i.BACK=new i(0,0,-1),/**
 * A static one Vector3 for use by reference.
 * 
 * This constant is meant for comparison operations and should not be modified directly.
 *
 * @constant
 * @name Phaser.Math.Vector3.ONE
 * @type {Phaser.Math.Vector3}
 * @since 3.16.0
 */i.ONE=new i(1,1,1),t.exports=i}),r("27QVG",function(t,e){/**
 * @classdesc
 * A representation of a vector in 4D space.
 *
 * A four-component vector.
 *
 * @class Vector4
 * @memberof Phaser.Math
 * @constructor
 * @since 3.0.0
 *
 * @param {number} [x] - The x component.
 * @param {number} [y] - The y component.
 * @param {number} [z] - The z component.
 * @param {number} [w] - The w component.
 */var i=new(s("jwj1g"))({initialize:function(t,e,i,n){/**
         * The x component of this Vector.
         *
         * @name Phaser.Math.Vector4#x
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.x=0,/**
         * The y component of this Vector.
         *
         * @name Phaser.Math.Vector4#y
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.y=0,/**
         * The z component of this Vector.
         *
         * @name Phaser.Math.Vector4#z
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.z=0,/**
         * The w component of this Vector.
         *
         * @name Phaser.Math.Vector4#w
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.w=0,"object"==typeof t?(this.x=t.x||0,this.y=t.y||0,this.z=t.z||0,this.w=t.w||0):(this.x=t||0,this.y=e||0,this.z=i||0,this.w=n||0)},/**
     * Make a clone of this Vector4.
     *
     * @method Phaser.Math.Vector4#clone
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector4} A clone of this Vector4.
     */clone:function(){return new i(this.x,this.y,this.z,this.w)},/**
     * Copy the components of a given Vector into this Vector.
     *
     * @method Phaser.Math.Vector4#copy
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector4} src - The Vector to copy the components from.
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */copy:function(t){return this.x=t.x,this.y=t.y,this.z=t.z||0,this.w=t.w||0,this},/**
     * Check whether this Vector is equal to a given Vector.
     *
     * Performs a strict quality check against each Vector's components.
     *
     * @method Phaser.Math.Vector4#equals
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector4} v - The vector to check equality with.
     *
     * @return {boolean} A boolean indicating whether the two Vectors are equal or not.
     */equals:function(t){return this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w},/**
     * Set the `x`, `y`, `z` and `w` components of the this Vector to the given `x`, `y`, `z` and `w` values.
     *
     * @method Phaser.Math.Vector4#set
     * @since 3.0.0
     *
     * @param {(number|object)} x - The x value to set for this Vector, or an object containing x, y, z and w components.
     * @param {number} y - The y value to set for this Vector.
     * @param {number} z - The z value to set for this Vector.
     * @param {number} w - The z value to set for this Vector.
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */set:function(t,e,i,n){return"object"==typeof t?(this.x=t.x||0,this.y=t.y||0,this.z=t.z||0,this.w=t.w||0):(this.x=t||0,this.y=e||0,this.z=i||0,this.w=n||0),this},/**
     * Add a given Vector to this Vector. Addition is component-wise.
     *
     * @method Phaser.Math.Vector4#add
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to add to this Vector.
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */add:function(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z||0,this.w+=t.w||0,this},/**
     * Subtract the given Vector from this Vector. Subtraction is component-wise.
     *
     * @method Phaser.Math.Vector4#subtract
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to subtract from this Vector.
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */subtract:function(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z||0,this.w-=t.w||0,this},/**
     * Scale this Vector by the given value.
     *
     * @method Phaser.Math.Vector4#scale
     * @since 3.0.0
     *
     * @param {number} scale - The value to scale this Vector by.
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */scale:function(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this},/**
     * Calculate the length (or magnitude) of this Vector.
     *
     * @method Phaser.Math.Vector4#length
     * @since 3.0.0
     *
     * @return {number} The length of this Vector.
     */length:function(){var t=this.x,e=this.y,i=this.z,n=this.w;return Math.sqrt(t*t+e*e+i*i+n*n)},/**
     * Calculate the length of this Vector squared.
     *
     * @method Phaser.Math.Vector4#lengthSq
     * @since 3.0.0
     *
     * @return {number} The length of this Vector, squared.
     */lengthSq:function(){var t=this.x,e=this.y,i=this.z,n=this.w;return t*t+e*e+i*i+n*n},/**
     * Normalize this Vector.
     *
     * Makes the vector a unit length vector (magnitude of 1) in the same direction.
     *
     * @method Phaser.Math.Vector4#normalize
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */normalize:function(){var t=this.x,e=this.y,i=this.z,n=this.w,s=t*t+e*e+i*i+n*n;return s>0&&(s=1/Math.sqrt(s),this.x=t*s,this.y=e*s,this.z=i*s,this.w=n*s),this},/**
     * Calculate the dot product of this Vector and the given Vector.
     *
     * @method Phaser.Math.Vector4#dot
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector4} v - The Vector4 to dot product with this Vector4.
     *
     * @return {number} The dot product of this Vector and the given Vector.
     */dot:function(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w},/**
     * Linearly interpolate between this Vector and the given Vector.
     *
     * Interpolates this Vector towards the given Vector.
     *
     * @method Phaser.Math.Vector4#lerp
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector4} v - The Vector4 to interpolate towards.
     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */lerp:function(t,e){void 0===e&&(e=0);var i=this.x,n=this.y,s=this.z,r=this.w;return this.x=i+e*(t.x-i),this.y=n+e*(t.y-n),this.z=s+e*(t.z-s),this.w=r+e*(t.w-r),this},/**
     * Perform a component-wise multiplication between this Vector and the given Vector.
     *
     * Multiplies this Vector by the given Vector.
     *
     * @method Phaser.Math.Vector4#multiply
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to multiply this Vector by.
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */multiply:function(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z||1,this.w*=t.w||1,this},/**
     * Perform a component-wise division between this Vector and the given Vector.
     *
     * Divides this Vector by the given Vector.
     *
     * @method Phaser.Math.Vector4#divide
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to divide this Vector by.
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */divide:function(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z||1,this.w/=t.w||1,this},/**
     * Calculate the distance between this Vector and the given Vector.
     *
     * @method Phaser.Math.Vector4#distance
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.
     *
     * @return {number} The distance from this Vector to the given Vector.
     */distance:function(t){var e=t.x-this.x,i=t.y-this.y,n=t.z-this.z||0,s=t.w-this.w||0;return Math.sqrt(e*e+i*i+n*n+s*s)},/**
     * Calculate the distance between this Vector and the given Vector, squared.
     *
     * @method Phaser.Math.Vector4#distanceSq
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.
     *
     * @return {number} The distance from this Vector to the given Vector, squared.
     */distanceSq:function(t){var e=t.x-this.x,i=t.y-this.y,n=t.z-this.z||0,s=t.w-this.w||0;return e*e+i*i+n*n+s*s},/**
     * Negate the `x`, `y`, `z` and `w` components of this Vector.
     *
     * @method Phaser.Math.Vector4#negate
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this},/**
     * Transform this Vector with the given Matrix.
     *
     * @method Phaser.Math.Vector4#transformMat4
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector4 with.
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */transformMat4:function(t){var e=this.x,i=this.y,n=this.z,s=this.w,r=t.val;return this.x=r[0]*e+r[4]*i+r[8]*n+r[12]*s,this.y=r[1]*e+r[5]*i+r[9]*n+r[13]*s,this.z=r[2]*e+r[6]*i+r[10]*n+r[14]*s,this.w=r[3]*e+r[7]*i+r[11]*n+r[15]*s,this},/**
     * Transform this Vector with the given Quaternion.
     *
     * @method Phaser.Math.Vector4#transformQuat
     * @since 3.0.0
     *
     * @param {Phaser.Math.Quaternion} q - The Quaternion to transform this Vector with.
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */transformQuat:function(t){// TODO: is this really the same as Vector3?
// Also, what about this: http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/
// benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
var e=this.x,i=this.y,n=this.z,s=t.x,r=t.y,o=t.z,a=t.w,h=a*e+r*n-o*i,l=a*i+o*e-s*n,u=a*n+s*i-r*e,c=-s*e-r*i-o*n;return(// calculate result * inverse quat
this.x=h*a+-(c*s)+-(l*o)- -(u*r),this.y=l*a+-(c*r)+-(u*s)- -(h*o),this.z=u*a+-(c*o)+-(h*r)- -(l*s),this)},/**
     * Make this Vector the zero vector (0, 0, 0, 0).
     *
     * @method Phaser.Math.Vector4#reset
     * @since 3.0.0
     *
     * @return {Phaser.Math.Vector4} This Vector4.
     */reset:function(){return this.x=0,this.y=0,this.z=0,this.w=0,this}});//  TODO: Check if these are required internally, if not, remove.
i.prototype.sub=i.prototype.subtract,i.prototype.mul=i.prototype.multiply,i.prototype.div=i.prototype.divide,i.prototype.dist=i.prototype.distance,i.prototype.distSq=i.prototype.distanceSq,i.prototype.len=i.prototype.length,i.prototype.lenSq=i.prototype.lengthSq,t.exports=i}),r("gX42i",function(t,e){/**
 * @classdesc
 * A three-dimensional matrix.
 *
 * Defaults to the identity matrix when instantiated.
 *
 * @class Matrix3
 * @memberof Phaser.Math
 * @constructor
 * @since 3.0.0
 *
 * @param {Phaser.Math.Matrix3} [m] - Optional Matrix3 to copy values from.
 */var i=new(s("jwj1g"))({initialize:function(t){/**
         * The matrix values.
         *
         * @name Phaser.Math.Matrix3#val
         * @type {Float32Array}
         * @since 3.0.0
         */this.val=new Float32Array(9),t?this.copy(t):this.identity()},/**
     * Make a clone of this Matrix3.
     *
     * @method Phaser.Math.Matrix3#clone
     * @since 3.0.0
     *
     * @return {Phaser.Math.Matrix3} A clone of this Matrix3.
     */clone:function(){return new i(this)},/**
     * This method is an alias for `Matrix3.copy`.
     *
     * @method Phaser.Math.Matrix3#set
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix3} src - The Matrix to set the values of this Matrix's from.
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */set:function(t){return this.copy(t)},/**
     * Copy the values of a given Matrix into this Matrix.
     *
     * @method Phaser.Math.Matrix3#copy
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix3} src - The Matrix to copy the values from.
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */copy:function(t){var e=this.val,i=t.val;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this},/**
     * Copy the values of a given Matrix4 into this Matrix3.
     *
     * @method Phaser.Math.Matrix3#fromMat4
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix4} m - The Matrix4 to copy the values from.
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */fromMat4:function(t){var e=t.val,i=this.val;return i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[4],i[4]=e[5],i[5]=e[6],i[6]=e[8],i[7]=e[9],i[8]=e[10],this},/**
     * Set the values of this Matrix from the given array.
     *
     * @method Phaser.Math.Matrix3#fromArray
     * @since 3.0.0
     *
     * @param {array} a - The array to copy the values from.
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */fromArray:function(t){var e=this.val;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],this},/**
     * Reset this Matrix to an identity (default) matrix.
     *
     * @method Phaser.Math.Matrix3#identity
     * @since 3.0.0
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */identity:function(){var t=this.val;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,this},/**
     * Transpose this Matrix.
     *
     * @method Phaser.Math.Matrix3#transpose
     * @since 3.0.0
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */transpose:function(){var t=this.val,e=t[1],i=t[2],n=t[5];return t[1]=t[3],t[2]=t[6],t[3]=e,t[5]=t[7],t[6]=i,t[7]=n,this},/**
     * Invert this Matrix.
     *
     * @method Phaser.Math.Matrix3#invert
     * @since 3.0.0
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */invert:function(){var t=this.val,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],o=t[5],a=t[6],h=t[7],l=t[8],u=l*r-o*h,c=-l*s+o*a,d=h*s-r*a,f=e*u+i*c+n*d;return f?(f=1/f,t[0]=u*f,t[1]=(-l*i+n*h)*f,t[2]=(o*i-n*r)*f,t[3]=c*f,t[4]=(l*e-n*a)*f,t[5]=(-o*e+n*s)*f,t[6]=d*f,t[7]=(-h*e+i*a)*f,t[8]=(r*e-i*s)*f,this):null},/**
     * Calculate the adjoint, or adjugate, of this Matrix.
     *
     * @method Phaser.Math.Matrix3#adjoint
     * @since 3.0.0
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */adjoint:function(){var t=this.val,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],o=t[5],a=t[6],h=t[7],l=t[8];return t[0]=r*l-o*h,t[1]=n*h-i*l,t[2]=i*o-n*r,t[3]=o*a-s*l,t[4]=e*l-n*a,t[5]=n*s-e*o,t[6]=s*h-r*a,t[7]=i*a-e*h,t[8]=e*r-i*s,this},/**
     * Calculate the determinant of this Matrix.
     *
     * @method Phaser.Math.Matrix3#determinant
     * @since 3.0.0
     *
     * @return {number} The determinant of this Matrix.
     */determinant:function(){var t=this.val,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],o=t[5],a=t[6],h=t[7],l=t[8];return e*(l*r-o*h)+i*(-l*s+o*a)+n*(h*s-r*a)},/**
     * Multiply this Matrix by the given Matrix.
     *
     * @method Phaser.Math.Matrix3#multiply
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix3} src - The Matrix to multiply this Matrix by.
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */multiply:function(t){var e=this.val,i=e[0],n=e[1],s=e[2],r=e[3],o=e[4],a=e[5],h=e[6],l=e[7],u=e[8],c=t.val,d=c[0],f=c[1],p=c[2],g=c[3],v=c[4],m=c[5],y=c[6],x=c[7],w=c[8];return e[0]=d*i+f*r+p*h,e[1]=d*n+f*o+p*l,e[2]=d*s+f*a+p*u,e[3]=g*i+v*r+m*h,e[4]=g*n+v*o+m*l,e[5]=g*s+v*a+m*u,e[6]=y*i+x*r+w*h,e[7]=y*n+x*o+w*l,e[8]=y*s+x*a+w*u,this},/**
     * Translate this Matrix using the given Vector.
     *
     * @method Phaser.Math.Matrix3#translate
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to translate this Matrix with.
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */translate:function(t){var e=this.val,i=t.x,n=t.y;return e[6]=i*e[0]+n*e[3]+e[6],e[7]=i*e[1]+n*e[4]+e[7],e[8]=i*e[2]+n*e[5]+e[8],this},/**
     * Apply a rotation transformation to this Matrix.
     *
     * @method Phaser.Math.Matrix3#rotate
     * @since 3.0.0
     *
     * @param {number} rad - The angle in radians to rotate by.
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */rotate:function(t){var e=this.val,i=e[0],n=e[1],s=e[2],r=e[3],o=e[4],a=e[5],h=Math.sin(t),l=Math.cos(t);return e[0]=l*i+h*r,e[1]=l*n+h*o,e[2]=l*s+h*a,e[3]=l*r-h*i,e[4]=l*o-h*n,e[5]=l*a-h*s,this},/**
     * Apply a scale transformation to this Matrix.
     *
     * Uses the `x` and `y` components of the given Vector to scale the Matrix.
     *
     * @method Phaser.Math.Matrix3#scale
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to scale this Matrix with.
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */scale:function(t){var e=this.val,i=t.x,n=t.y;return e[0]=i*e[0],e[1]=i*e[1],e[2]=i*e[2],e[3]=n*e[3],e[4]=n*e[4],e[5]=n*e[5],this},/**
     * Set the values of this Matrix from the given Quaternion.
     *
     * @method Phaser.Math.Matrix3#fromQuat
     * @since 3.0.0
     *
     * @param {Phaser.Math.Quaternion} q - The Quaternion to set the values of this Matrix from.
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */fromQuat:function(t){var e=t.x,i=t.y,n=t.z,s=t.w,r=e+e,o=i+i,a=n+n,h=e*r,l=e*o,u=e*a,c=i*o,d=i*a,f=n*a,p=s*r,g=s*o,v=s*a,m=this.val;return m[0]=1-(c+f),m[3]=l+v,m[6]=u-g,m[1]=l-v,m[4]=1-(h+f),m[7]=d+p,m[2]=u+g,m[5]=d-p,m[8]=1-(h+c),this},/**
     * Set the values of this Matrix3 to be normalized from the given Matrix4.
     *
     * @method Phaser.Math.Matrix3#normalFromMat4
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix4} m - The Matrix4 to normalize the values from.
     *
     * @return {Phaser.Math.Matrix3} This Matrix3.
     */normalFromMat4:function(t){var e=t.val,i=this.val,n=e[0],s=e[1],r=e[2],o=e[3],a=e[4],h=e[5],l=e[6],u=e[7],c=e[8],d=e[9],f=e[10],p=e[11],g=e[12],v=e[13],m=e[14],y=e[15],x=n*h-s*a,w=n*l-r*a,T=n*u-o*a,b=s*l-r*h,S=s*u-o*h,A=r*u-o*l,E=c*v-d*g,_=c*m-f*g,C=c*y-p*g,M=d*m-f*v,P=d*y-p*v,O=f*y-p*m,R=x*O-w*P+T*M+b*C-S*_+A*E;return R?(R=1/R,i[0]=(h*O-l*P+u*M)*R,i[1]=(l*C-a*O-u*_)*R,i[2]=(a*P-h*C+u*E)*R,i[3]=(r*P-s*O-o*M)*R,i[4]=(n*O-r*C+o*_)*R,i[5]=(s*C-n*P-o*E)*R,i[6]=(v*A-m*S+y*b)*R,i[7]=(m*T-g*A-y*w)*R,i[8]=(g*S-v*T+y*x)*R,this):null}});t.exports=i}),r("hD0DV",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji
//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl
var i=new(s("jwj1g"))({initialize:function(t){/**
         * The matrix values.
         *
         * @name Phaser.Math.Matrix4#val
         * @type {Float32Array}
         * @since 3.0.0
         */this.val=new Float32Array(16),t?this.copy(t):this.identity()},/**
     * Make a clone of this Matrix4.
     *
     * @method Phaser.Math.Matrix4#clone
     * @since 3.0.0
     *
     * @return {Phaser.Math.Matrix4} A clone of this Matrix4.
     */clone:function(){return new i(this)},//  TODO - Should work with basic values
/**
     * This method is an alias for `Matrix4.copy`.
     *
     * @method Phaser.Math.Matrix4#set
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix4} src - The Matrix to set the values of this Matrix's from.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */set:function(t){return this.copy(t)},/**
     * Copy the values of a given Matrix into this Matrix.
     *
     * @method Phaser.Math.Matrix4#copy
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix4} src - The Matrix to copy the values from.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */copy:function(t){var e=this.val,i=t.val;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this},/**
     * Set the values of this Matrix from the given array.
     *
     * @method Phaser.Math.Matrix4#fromArray
     * @since 3.0.0
     *
     * @param {array} a - The array to copy the values from.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */fromArray:function(t){var e=this.val;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],this},/**
     * Reset this Matrix.
     *
     * Sets all values to `0`.
     *
     * @method Phaser.Math.Matrix4#zero
     * @since 3.0.0
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */zero:function(){var t=this.val;return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=0,this},/**
     * Set the `x`, `y` and `z` values of this Matrix.
     *
     * @method Phaser.Math.Matrix4#xyz
     * @since 3.0.0
     *
     * @param {number} x - The x value.
     * @param {number} y - The y value.
     * @param {number} z - The z value.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */xyz:function(t,e,i){this.identity();var n=this.val;return n[12]=t,n[13]=e,n[14]=i,this},/**
     * Set the scaling values of this Matrix.
     *
     * @method Phaser.Math.Matrix4#scaling
     * @since 3.0.0
     *
     * @param {number} x - The x scaling value.
     * @param {number} y - The y scaling value.
     * @param {number} z - The z scaling value.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */scaling:function(t,e,i){this.zero();var n=this.val;return n[0]=t,n[5]=e,n[10]=i,n[15]=1,this},/**
     * Reset this Matrix to an identity (default) matrix.
     *
     * @method Phaser.Math.Matrix4#identity
     * @since 3.0.0
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */identity:function(){var t=this.val;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this},/**
     * Transpose this Matrix.
     *
     * @method Phaser.Math.Matrix4#transpose
     * @since 3.0.0
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */transpose:function(){var t=this.val,e=t[1],i=t[2],n=t[3],s=t[6],r=t[7],o=t[11];return t[1]=t[4],t[2]=t[8],t[3]=t[12],t[4]=e,t[6]=t[9],t[7]=t[13],t[8]=i,t[9]=s,t[11]=t[14],t[12]=n,t[13]=r,t[14]=o,this},/**
     * Invert this Matrix.
     *
     * @method Phaser.Math.Matrix4#invert
     * @since 3.0.0
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */invert:function(){var t=this.val,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],o=t[5],a=t[6],h=t[7],l=t[8],u=t[9],c=t[10],d=t[11],f=t[12],p=t[13],g=t[14],v=t[15],m=e*o-i*r,y=e*a-n*r,x=e*h-s*r,w=i*a-n*o,T=i*h-s*o,b=n*h-s*a,S=l*p-u*f,A=l*g-c*f,E=l*v-d*f,_=u*g-c*p,C=u*v-d*p,M=c*v-d*g,P=m*M-y*C+x*_+w*E-T*A+b*S;return P?(P=1/P,t[0]=(o*M-a*C+h*_)*P,t[1]=(n*C-i*M-s*_)*P,t[2]=(p*b-g*T+v*w)*P,t[3]=(c*T-u*b-d*w)*P,t[4]=(a*E-r*M-h*A)*P,t[5]=(e*M-n*E+s*A)*P,t[6]=(g*x-f*b-v*y)*P,t[7]=(l*b-c*x+d*y)*P,t[8]=(r*C-o*E+h*S)*P,t[9]=(i*E-e*C-s*S)*P,t[10]=(f*T-p*x+v*m)*P,t[11]=(u*x-l*T-d*m)*P,t[12]=(o*A-r*_-a*S)*P,t[13]=(e*_-i*A+n*S)*P,t[14]=(p*y-f*w-g*m)*P,t[15]=(l*w-u*y+c*m)*P,this):null},/**
     * Calculate the adjoint, or adjugate, of this Matrix.
     *
     * @method Phaser.Math.Matrix4#adjoint
     * @since 3.0.0
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */adjoint:function(){var t=this.val,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],o=t[5],a=t[6],h=t[7],l=t[8],u=t[9],c=t[10],d=t[11],f=t[12],p=t[13],g=t[14],v=t[15];return t[0]=o*(c*v-d*g)-u*(a*v-h*g)+p*(a*d-h*c),t[1]=-(i*(c*v-d*g)-u*(n*v-s*g)+p*(n*d-s*c)),t[2]=i*(a*v-h*g)-o*(n*v-s*g)+p*(n*h-s*a),t[3]=-(i*(a*d-h*c)-o*(n*d-s*c)+u*(n*h-s*a)),t[4]=-(r*(c*v-d*g)-l*(a*v-h*g)+f*(a*d-h*c)),t[5]=e*(c*v-d*g)-l*(n*v-s*g)+f*(n*d-s*c),t[6]=-(e*(a*v-h*g)-r*(n*v-s*g)+f*(n*h-s*a)),t[7]=e*(a*d-h*c)-r*(n*d-s*c)+l*(n*h-s*a),t[8]=r*(u*v-d*p)-l*(o*v-h*p)+f*(o*d-h*u),t[9]=-(e*(u*v-d*p)-l*(i*v-s*p)+f*(i*d-s*u)),t[10]=e*(o*v-h*p)-r*(i*v-s*p)+f*(i*h-s*o),t[11]=-(e*(o*d-h*u)-r*(i*d-s*u)+l*(i*h-s*o)),t[12]=-(r*(u*g-c*p)-l*(o*g-a*p)+f*(o*c-a*u)),t[13]=e*(u*g-c*p)-l*(i*g-n*p)+f*(i*c-n*u),t[14]=-(e*(o*g-a*p)-r*(i*g-n*p)+f*(i*a-n*o)),t[15]=e*(o*c-a*u)-r*(i*c-n*u)+l*(i*a-n*o),this},/**
     * Calculate the determinant of this Matrix.
     *
     * @method Phaser.Math.Matrix4#determinant
     * @since 3.0.0
     *
     * @return {number} The determinant of this Matrix.
     */determinant:function(){var t=this.val,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],o=t[5],a=t[6],h=t[7],l=t[8],u=t[9],c=t[10],d=t[11],f=t[12],p=t[13],g=t[14],v=t[15];// Calculate the determinant
return(e*o-i*r)*(c*v-d*g)-(e*a-n*r)*(u*v-d*p)+(e*h-s*r)*(u*g-c*p)+(i*a-n*o)*(l*v-d*f)-(i*h-s*o)*(l*g-c*f)+(n*h-s*a)*(l*p-u*f)},/**
     * Multiply this Matrix by the given Matrix.
     *
     * @method Phaser.Math.Matrix4#multiply
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix4} src - The Matrix to multiply this Matrix by.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */multiply:function(t){var e=this.val,i=e[0],n=e[1],s=e[2],r=e[3],o=e[4],a=e[5],h=e[6],l=e[7],u=e[8],c=e[9],d=e[10],f=e[11],p=e[12],g=e[13],v=e[14],m=e[15],y=t.val,x=y[0],w=y[1],T=y[2],b=y[3];return e[0]=x*i+w*o+T*u+b*p,e[1]=x*n+w*a+T*c+b*g,e[2]=x*s+w*h+T*d+b*v,e[3]=x*r+w*l+T*f+b*m,x=y[4],w=y[5],T=y[6],b=y[7],e[4]=x*i+w*o+T*u+b*p,e[5]=x*n+w*a+T*c+b*g,e[6]=x*s+w*h+T*d+b*v,e[7]=x*r+w*l+T*f+b*m,x=y[8],w=y[9],T=y[10],b=y[11],e[8]=x*i+w*o+T*u+b*p,e[9]=x*n+w*a+T*c+b*g,e[10]=x*s+w*h+T*d+b*v,e[11]=x*r+w*l+T*f+b*m,x=y[12],w=y[13],T=y[14],b=y[15],e[12]=x*i+w*o+T*u+b*p,e[13]=x*n+w*a+T*c+b*g,e[14]=x*s+w*h+T*d+b*v,e[15]=x*r+w*l+T*f+b*m,this},/**
     * Multiply the values of this Matrix4 by those given in the `src` argument.
     *
     * @method Phaser.Math.Matrix4#multiplyLocal
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix4} src - The source Matrix4 that this Matrix4 is multiplied by.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */multiplyLocal:function(t){var e=[],i=this.val,n=t.val;return e[0]=i[0]*n[0]+i[1]*n[4]+i[2]*n[8]+i[3]*n[12],e[1]=i[0]*n[1]+i[1]*n[5]+i[2]*n[9]+i[3]*n[13],e[2]=i[0]*n[2]+i[1]*n[6]+i[2]*n[10]+i[3]*n[14],e[3]=i[0]*n[3]+i[1]*n[7]+i[2]*n[11]+i[3]*n[15],e[4]=i[4]*n[0]+i[5]*n[4]+i[6]*n[8]+i[7]*n[12],e[5]=i[4]*n[1]+i[5]*n[5]+i[6]*n[9]+i[7]*n[13],e[6]=i[4]*n[2]+i[5]*n[6]+i[6]*n[10]+i[7]*n[14],e[7]=i[4]*n[3]+i[5]*n[7]+i[6]*n[11]+i[7]*n[15],e[8]=i[8]*n[0]+i[9]*n[4]+i[10]*n[8]+i[11]*n[12],e[9]=i[8]*n[1]+i[9]*n[5]+i[10]*n[9]+i[11]*n[13],e[10]=i[8]*n[2]+i[9]*n[6]+i[10]*n[10]+i[11]*n[14],e[11]=i[8]*n[3]+i[9]*n[7]+i[10]*n[11]+i[11]*n[15],e[12]=i[12]*n[0]+i[13]*n[4]+i[14]*n[8]+i[15]*n[12],e[13]=i[12]*n[1]+i[13]*n[5]+i[14]*n[9]+i[15]*n[13],e[14]=i[12]*n[2]+i[13]*n[6]+i[14]*n[10]+i[15]*n[14],e[15]=i[12]*n[3]+i[13]*n[7]+i[14]*n[11]+i[15]*n[15],this.fromArray(e)},/**
     * Translate this Matrix using the given Vector.
     *
     * @method Phaser.Math.Matrix4#translate
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to translate this Matrix with.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */translate:function(t){var e=t.x,i=t.y,n=t.z,s=this.val;return s[12]=s[0]*e+s[4]*i+s[8]*n+s[12],s[13]=s[1]*e+s[5]*i+s[9]*n+s[13],s[14]=s[2]*e+s[6]*i+s[10]*n+s[14],s[15]=s[3]*e+s[7]*i+s[11]*n+s[15],this},/**
     * Translate this Matrix using the given values.
     *
     * @method Phaser.Math.Matrix4#translateXYZ
     * @since 3.16.0
     *
     * @param {number} x - The x component.
     * @param {number} y - The y component.
     * @param {number} z - The z component.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */translateXYZ:function(t,e,i){var n=this.val;return n[12]=n[0]*t+n[4]*e+n[8]*i+n[12],n[13]=n[1]*t+n[5]*e+n[9]*i+n[13],n[14]=n[2]*t+n[6]*e+n[10]*i+n[14],n[15]=n[3]*t+n[7]*e+n[11]*i+n[15],this},/**
     * Apply a scale transformation to this Matrix.
     *
     * Uses the `x`, `y` and `z` components of the given Vector to scale the Matrix.
     *
     * @method Phaser.Math.Matrix4#scale
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to scale this Matrix with.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */scale:function(t){var e=t.x,i=t.y,n=t.z,s=this.val;return s[0]=s[0]*e,s[1]=s[1]*e,s[2]=s[2]*e,s[3]=s[3]*e,s[4]=s[4]*i,s[5]=s[5]*i,s[6]=s[6]*i,s[7]=s[7]*i,s[8]=s[8]*n,s[9]=s[9]*n,s[10]=s[10]*n,s[11]=s[11]*n,this},/**
     * Apply a scale transformation to this Matrix.
     *
     * @method Phaser.Math.Matrix4#scaleXYZ
     * @since 3.16.0
     *
     * @param {number} x - The x component.
     * @param {number} y - The y component.
     * @param {number} z - The z component.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */scaleXYZ:function(t,e,i){var n=this.val;return n[0]=n[0]*t,n[1]=n[1]*t,n[2]=n[2]*t,n[3]=n[3]*t,n[4]=n[4]*e,n[5]=n[5]*e,n[6]=n[6]*e,n[7]=n[7]*e,n[8]=n[8]*i,n[9]=n[9]*i,n[10]=n[10]*i,n[11]=n[11]*i,this},/**
     * Derive a rotation matrix around the given axis.
     *
     * @method Phaser.Math.Matrix4#makeRotationAxis
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} axis - The rotation axis.
     * @param {number} angle - The rotation angle in radians.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */makeRotationAxis:function(t,e){// Based on http://www.gamedev.net/reference/articles/article1199.asp
var i=Math.cos(e),n=Math.sin(e),s=1-i,r=t.x,o=t.y,a=t.z,h=s*r,l=s*o;return this.fromArray([h*r+i,h*o-n*a,h*a+n*o,0,h*o+n*a,l*o+i,l*a-n*r,0,h*a-n*o,l*a+n*r,s*a*a+i,0,0,0,0,1]),this},/**
     * Apply a rotation transformation to this Matrix.
     *
     * @method Phaser.Math.Matrix4#rotate
     * @since 3.0.0
     *
     * @param {number} rad - The angle in radians to rotate by.
     * @param {Phaser.Math.Vector3} axis - The axis to rotate upon.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */rotate:function(t,e){var i=this.val,n=e.x,s=e.y,r=e.z,o=Math.sqrt(n*n+s*s+r*r);if(1e-6>Math.abs(o))return null;n*=o=1/o,s*=o,r*=o;var a=Math.sin(t),h=Math.cos(t),l=1-h,u=i[0],c=i[1],d=i[2],f=i[3],p=i[4],g=i[5],v=i[6],m=i[7],y=i[8],x=i[9],w=i[10],T=i[11],b=n*n*l+h,S=s*n*l+r*a,A=r*n*l-s*a,E=n*s*l-r*a,_=s*s*l+h,C=r*s*l+n*a,M=n*r*l+s*a,P=s*r*l-n*a,O=r*r*l+h;return(// Perform rotation-specific matrix multiplication
i[0]=u*b+p*S+y*A,i[1]=c*b+g*S+x*A,i[2]=d*b+v*S+w*A,i[3]=f*b+m*S+T*A,i[4]=u*E+p*_+y*C,i[5]=c*E+g*_+x*C,i[6]=d*E+v*_+w*C,i[7]=f*E+m*_+T*C,i[8]=u*M+p*P+y*O,i[9]=c*M+g*P+x*O,i[10]=d*M+v*P+w*O,i[11]=f*M+m*P+T*O,this)},/**
     * Rotate this matrix on its X axis.
     *
     * @method Phaser.Math.Matrix4#rotateX
     * @since 3.0.0
     *
     * @param {number} rad - The angle in radians to rotate by.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */rotateX:function(t){var e=this.val,i=Math.sin(t),n=Math.cos(t),s=e[4],r=e[5],o=e[6],a=e[7],h=e[8],l=e[9],u=e[10],c=e[11];return(// Perform axis-specific matrix multiplication
e[4]=s*n+h*i,e[5]=r*n+l*i,e[6]=o*n+u*i,e[7]=a*n+c*i,e[8]=h*n-s*i,e[9]=l*n-r*i,e[10]=u*n-o*i,e[11]=c*n-a*i,this)},/**
     * Rotate this matrix on its Y axis.
     *
     * @method Phaser.Math.Matrix4#rotateY
     * @since 3.0.0
     *
     * @param {number} rad - The angle to rotate by, in radians.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */rotateY:function(t){var e=this.val,i=Math.sin(t),n=Math.cos(t),s=e[0],r=e[1],o=e[2],a=e[3],h=e[8],l=e[9],u=e[10],c=e[11];return(// Perform axis-specific matrix multiplication
e[0]=s*n-h*i,e[1]=r*n-l*i,e[2]=o*n-u*i,e[3]=a*n-c*i,e[8]=s*i+h*n,e[9]=r*i+l*n,e[10]=o*i+u*n,e[11]=a*i+c*n,this)},/**
     * Rotate this matrix on its Z axis.
     *
     * @method Phaser.Math.Matrix4#rotateZ
     * @since 3.0.0
     *
     * @param {number} rad - The angle to rotate by, in radians.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */rotateZ:function(t){var e=this.val,i=Math.sin(t),n=Math.cos(t),s=e[0],r=e[1],o=e[2],a=e[3],h=e[4],l=e[5],u=e[6],c=e[7];return(// Perform axis-specific matrix multiplication
e[0]=s*n+h*i,e[1]=r*n+l*i,e[2]=o*n+u*i,e[3]=a*n+c*i,e[4]=h*n-s*i,e[5]=l*n-r*i,e[6]=u*n-o*i,e[7]=c*n-a*i,this)},/**
     * Set the values of this Matrix from the given rotation Quaternion and translation Vector.
     *
     * @method Phaser.Math.Matrix4#fromRotationTranslation
     * @since 3.0.0
     *
     * @param {Phaser.Math.Quaternion} q - The Quaternion to set rotation from.
     * @param {Phaser.Math.Vector3} v - The Vector to set translation from.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */fromRotationTranslation:function(t,e){// Quaternion math
var i=this.val,n=t.x,s=t.y,r=t.z,o=t.w,a=n+n,h=s+s,l=r+r,u=n*a,c=n*h,d=n*l,f=s*h,p=s*l,g=r*l,v=o*a,m=o*h,y=o*l;return i[0]=1-(f+g),i[1]=c+y,i[2]=d-m,i[3]=0,i[4]=c-y,i[5]=1-(u+g),i[6]=p+v,i[7]=0,i[8]=d+m,i[9]=p-v,i[10]=1-(u+f),i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this},/**
     * Set the values of this Matrix from the given Quaternion.
     *
     * @method Phaser.Math.Matrix4#fromQuat
     * @since 3.0.0
     *
     * @param {Phaser.Math.Quaternion} q - The Quaternion to set the values of this Matrix from.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */fromQuat:function(t){var e=this.val,i=t.x,n=t.y,s=t.z,r=t.w,o=i+i,a=n+n,h=s+s,l=i*o,u=i*a,c=i*h,d=n*a,f=n*h,p=s*h,g=r*o,v=r*a,m=r*h;return e[0]=1-(d+p),e[1]=u+m,e[2]=c-v,e[3]=0,e[4]=u-m,e[5]=1-(l+p),e[6]=f+g,e[7]=0,e[8]=c+v,e[9]=f-g,e[10]=1-(l+d),e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this},/**
     * Generate a frustum matrix with the given bounds.
     *
     * @method Phaser.Math.Matrix4#frustum
     * @since 3.0.0
     *
     * @param {number} left - The left bound of the frustum.
     * @param {number} right - The right bound of the frustum.
     * @param {number} bottom - The bottom bound of the frustum.
     * @param {number} top - The top bound of the frustum.
     * @param {number} near - The near bound of the frustum.
     * @param {number} far - The far bound of the frustum.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */frustum:function(t,e,i,n,s,r){var o=this.val,a=1/(e-t),h=1/(n-i),l=1/(s-r);return o[0]=2*s*a,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*s*h,o[6]=0,o[7]=0,o[8]=(e+t)*a,o[9]=(n+i)*h,o[10]=(r+s)*l,o[11]=-1,o[12]=0,o[13]=0,o[14]=r*s*2*l,o[15]=0,this},/**
     * Generate a perspective projection matrix with the given bounds.
     *
     * @method Phaser.Math.Matrix4#perspective
     * @since 3.0.0
     *
     * @param {number} fovy - Vertical field of view in radians
     * @param {number} aspect - Aspect ratio. Typically viewport width  /height.
     * @param {number} near - Near bound of the frustum.
     * @param {number} far - Far bound of the frustum.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */perspective:function(t,e,i,n){var s=this.val,r=1/Math.tan(t/2),o=1/(i-n);return s[0]=r/e,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=r,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=(n+i)*o,s[11]=-1,s[12]=0,s[13]=0,s[14]=2*n*i*o,s[15]=0,this},/**
     * Generate a perspective projection matrix with the given bounds.
     *
     * @method Phaser.Math.Matrix4#perspectiveLH
     * @since 3.0.0
     *
     * @param {number} width - The width of the frustum.
     * @param {number} height - The height of the frustum.
     * @param {number} near - Near bound of the frustum.
     * @param {number} far - Far bound of the frustum.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */perspectiveLH:function(t,e,i,n){var s=this.val;return s[0]=2*i/t,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=2*i/e,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=-n/(i-n),s[11]=1,s[12]=0,s[13]=0,s[14]=i*n/(i-n),s[15]=0,this},/**
     * Generate an orthogonal projection matrix with the given bounds.
     *
     * @method Phaser.Math.Matrix4#ortho
     * @since 3.0.0
     *
     * @param {number} left - The left bound of the frustum.
     * @param {number} right - The right bound of the frustum.
     * @param {number} bottom - The bottom bound of the frustum.
     * @param {number} top - The top bound of the frustum.
     * @param {number} near - The near bound of the frustum.
     * @param {number} far - The far bound of the frustum.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */ortho:function(t,e,i,n,s,r){var o=this.val,a=t-e,h=i-n,l=s-r;return(//  Avoid division by zero
a=0===a?a:1/a,h=0===h?h:1/h,l=0===l?l:1/l,o[0]=-2*a,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=-2*h,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=2*l,o[11]=0,o[12]=(t+e)*a,o[13]=(n+i)*h,o[14]=(r+s)*l,o[15]=1,this)},/**
     * Generate a look-at matrix with the given eye position, focal point, and up axis.
     *
     * @method Phaser.Math.Matrix4#lookAt
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} eye - Position of the viewer
     * @param {Phaser.Math.Vector3} center - Point the viewer is looking at
     * @param {Phaser.Math.Vector3} up - vec3 pointing up.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */lookAt:function(t,e,i){var n=this.val,s=t.x,r=t.y,o=t.z,a=i.x,h=i.y,l=i.z,u=e.x,c=e.y,d=e.z;if(1e-6>Math.abs(s-u)&&1e-6>Math.abs(r-c)&&1e-6>Math.abs(o-d))return this.identity();var f=s-u,p=r-c,g=o-d,v=1/Math.sqrt(f*f+p*p+g*g);f*=v,p*=v;var m=h*(g*=v)-l*p,y=l*f-a*g,x=a*p-h*f;(v=Math.sqrt(m*m+y*y+x*x))?(m*=v=1/v,y*=v,x*=v):(m=0,y=0,x=0);var w=p*x-g*y,T=g*m-f*x,b=f*y-p*m;return(v=Math.sqrt(w*w+T*T+b*b))?(w*=v=1/v,T*=v,b*=v):(w=0,T=0,b=0),n[0]=m,n[1]=w,n[2]=f,n[3]=0,n[4]=y,n[5]=T,n[6]=p,n[7]=0,n[8]=x,n[9]=b,n[10]=g,n[11]=0,n[12]=-(m*s+y*r+x*o),n[13]=-(w*s+T*r+b*o),n[14]=-(f*s+p*r+g*o),n[15]=1,this},/**
     * Set the values of this matrix from the given `yaw`, `pitch` and `roll` values.
     *
     * @method Phaser.Math.Matrix4#yawPitchRoll
     * @since 3.0.0
     *
     * @param {number} yaw - The yaw value.
     * @param {number} pitch - The pitch value.
     * @param {number} roll - The roll value.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */yawPitchRoll:function(t,e,i){this.zero(),n.zero(),r.zero();var s=this.val,o=n.val,a=r.val,h=Math.sin(i),l=Math.cos(i);return s[10]=1,s[15]=1,s[0]=l,s[1]=h,s[4]=-h,s[5]=l,//  Rotate X
h=Math.sin(e),l=Math.cos(e),o[0]=1,o[15]=1,o[5]=l,o[10]=l,o[9]=-h,o[6]=h,//  Rotate Y
h=Math.sin(t),l=Math.cos(t),a[5]=1,a[15]=1,a[0]=l,a[2]=-h,a[8]=h,a[10]=l,this.multiplyLocal(n),this.multiplyLocal(r),this},/**
     * Generate a world matrix from the given rotation, position, scale, view matrix and projection matrix.
     *
     * @method Phaser.Math.Matrix4#setWorldMatrix
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} rotation - The rotation of the world matrix.
     * @param {Phaser.Math.Vector3} position - The position of the world matrix.
     * @param {Phaser.Math.Vector3} scale - The scale of the world matrix.
     * @param {Phaser.Math.Matrix4} [viewMatrix] - The view matrix.
     * @param {Phaser.Math.Matrix4} [projectionMatrix] - The projection matrix.
     *
     * @return {Phaser.Math.Matrix4} This Matrix4.
     */setWorldMatrix:function(t,e,i,s,o){return this.yawPitchRoll(t.y,t.x,t.z),n.scaling(i.x,i.y,i.z),r.xyz(e.x,e.y,e.z),this.multiplyLocal(n),this.multiplyLocal(r),void 0!==s&&this.multiplyLocal(s),void 0!==o&&this.multiplyLocal(o),this}}),n=new i,r=new i;t.exports=i}),r("jzUY5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji
//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl
var i=s("jwj1g"),n=s("gbKIZ"),r=s("gX42i"),o=new Int8Array([1,2,0]),a=new Float32Array([0,0,0]),h=new n(1,0,0),l=new n(0,1,0),u=new n,c=new r,d=new i({initialize:function(t,e,i,n){/**
         * The x component of this Quaternion.
         *
         * @name Phaser.Math.Quaternion#x
         * @type {number}
         * @default 0
         * @since 3.0.0
         *//**
         * The y component of this Quaternion.
         *
         * @name Phaser.Math.Quaternion#y
         * @type {number}
         * @default 0
         * @since 3.0.0
         *//**
         * The z component of this Quaternion.
         *
         * @name Phaser.Math.Quaternion#z
         * @type {number}
         * @default 0
         * @since 3.0.0
         *//**
         * The w component of this Quaternion.
         *
         * @name Phaser.Math.Quaternion#w
         * @type {number}
         * @default 0
         * @since 3.0.0
         */"object"==typeof t?(this.x=t.x||0,this.y=t.y||0,this.z=t.z||0,this.w=t.w||0):(this.x=t||0,this.y=e||0,this.z=i||0,this.w=n||0)},/**
     * Copy the components of a given Quaternion or Vector into this Quaternion.
     *
     * @method Phaser.Math.Quaternion#copy
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} src - The Quaternion or Vector to copy the components from.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */copy:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this},/**
     * Set the components of this Quaternion.
     *
     * @method Phaser.Math.Quaternion#set
     * @since 3.0.0
     *
     * @param {(number|object)} [x=0] - The x component, or an object containing x, y, z, and w components.
     * @param {number} [y=0] - The y component.
     * @param {number} [z=0] - The z component.
     * @param {number} [w=0] - The w component.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */set:function(t,e,i,n){return"object"==typeof t?(this.x=t.x||0,this.y=t.y||0,this.z=t.z||0,this.w=t.w||0):(this.x=t||0,this.y=e||0,this.z=i||0,this.w=n||0),this},/**
     * Add a given Quaternion or Vector to this Quaternion. Addition is component-wise.
     *
     * @method Phaser.Math.Quaternion#add
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to add to this Quaternion.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */add:function(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this},/**
     * Subtract a given Quaternion or Vector from this Quaternion. Subtraction is component-wise.
     *
     * @method Phaser.Math.Quaternion#subtract
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to subtract from this Quaternion.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */subtract:function(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this},/**
     * Scale this Quaternion by the given value.
     *
     * @method Phaser.Math.Quaternion#scale
     * @since 3.0.0
     *
     * @param {number} scale - The value to scale this Quaternion by.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */scale:function(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this},/**
     * Calculate the length of this Quaternion.
     *
     * @method Phaser.Math.Quaternion#length
     * @since 3.0.0
     *
     * @return {number} The length of this Quaternion.
     */length:function(){var t=this.x,e=this.y,i=this.z,n=this.w;return Math.sqrt(t*t+e*e+i*i+n*n)},/**
     * Calculate the length of this Quaternion squared.
     *
     * @method Phaser.Math.Quaternion#lengthSq
     * @since 3.0.0
     *
     * @return {number} The length of this Quaternion, squared.
     */lengthSq:function(){var t=this.x,e=this.y,i=this.z,n=this.w;return t*t+e*e+i*i+n*n},/**
     * Normalize this Quaternion.
     *
     * @method Phaser.Math.Quaternion#normalize
     * @since 3.0.0
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */normalize:function(){var t=this.x,e=this.y,i=this.z,n=this.w,s=t*t+e*e+i*i+n*n;return s>0&&(s=1/Math.sqrt(s),this.x=t*s,this.y=e*s,this.z=i*s,this.w=n*s),this},/**
     * Calculate the dot product of this Quaternion and the given Quaternion or Vector.
     *
     * @method Phaser.Math.Quaternion#dot
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to dot product with this Quaternion.
     *
     * @return {number} The dot product of this Quaternion and the given Quaternion or Vector.
     */dot:function(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w},/**
     * Linearly interpolate this Quaternion towards the given Quaternion or Vector.
     *
     * @method Phaser.Math.Quaternion#lerp
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to interpolate towards.
     * @param {number} [t=0] - The percentage of interpolation.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */lerp:function(t,e){void 0===e&&(e=0);var i=this.x,n=this.y,s=this.z,r=this.w;return this.x=i+e*(t.x-i),this.y=n+e*(t.y-n),this.z=s+e*(t.z-s),this.w=r+e*(t.w-r),this},/**
     * Rotates this Quaternion based on the two given vectors.
     *
     * @method Phaser.Math.Quaternion#rotationTo
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} a - The transform rotation vector.
     * @param {Phaser.Math.Vector3} b - The target rotation vector.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */rotationTo:function(t,e){var i=t.x*e.x+t.y*e.y+t.z*e.z;return i<-.999999?(1e-6>u.copy(h).cross(t).length()&&u.copy(l).cross(t),u.normalize(),this.setAxisAngle(u,Math.PI)):i>.999999?(this.x=0,this.y=0,this.z=0,this.w=1,this):(u.copy(t).cross(e),this.x=u.x,this.y=u.y,this.z=u.z,this.w=1+i,this.normalize())},/**
     * Set the axes of this Quaternion.
     *
     * @method Phaser.Math.Quaternion#setAxes
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} view - The view axis.
     * @param {Phaser.Math.Vector3} right - The right axis.
     * @param {Phaser.Math.Vector3} up - The upwards axis.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */setAxes:function(t,e,i){var n=c.val;return n[0]=e.x,n[3]=e.y,n[6]=e.z,n[1]=i.x,n[4]=i.y,n[7]=i.z,n[2]=-t.x,n[5]=-t.y,n[8]=-t.z,this.fromMat3(c).normalize()},/**
     * Reset this Matrix to an identity (default) Quaternion.
     *
     * @method Phaser.Math.Quaternion#identity
     * @since 3.0.0
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */identity:function(){return this.x=0,this.y=0,this.z=0,this.w=1,this},/**
     * Set the axis angle of this Quaternion.
     *
     * @method Phaser.Math.Quaternion#setAxisAngle
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} axis - The axis.
     * @param {number} rad - The angle in radians.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */setAxisAngle:function(t,e){var i=Math.sin(e*=.5);return this.x=i*t.x,this.y=i*t.y,this.z=i*t.z,this.w=Math.cos(e),this},/**
     * Multiply this Quaternion by the given Quaternion or Vector.
     *
     * @method Phaser.Math.Quaternion#multiply
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - The Quaternion or Vector to multiply this Quaternion by.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */multiply:function(t){var e=this.x,i=this.y,n=this.z,s=this.w,r=t.x,o=t.y,a=t.z,h=t.w;return this.x=e*h+s*r+i*a-n*o,this.y=i*h+s*o+n*r-e*a,this.z=n*h+s*a+e*o-i*r,this.w=s*h-e*r-i*o-n*a,this},/**
     * Smoothly linearly interpolate this Quaternion towards the given Quaternion or Vector.
     *
     * @method Phaser.Math.Quaternion#slerp
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - The Quaternion or Vector to interpolate towards.
     * @param {number} t - The percentage of interpolation.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */slerp:function(t,e){// benchmarks: http://jsperf.com/quaternion-slerp-implementations
var i=this.x,n=this.y,s=this.z,r=this.w,o=t.x,a=t.y,h=t.z,l=t.w,u=i*o+n*a+s*h+r*l;u<0&&(u=-u,o=-o,a=-a,h=-h,l=-l);// "from" and "to" quaternions are very close
//  ... so we can do a linear interpolation
var c=1-e,d=e;// calculate coefficients
if(1-u>1e-6){// standard case (slerp)
var f=Math.acos(u),p=Math.sin(f);c=Math.sin((1-e)*f)/p,d=Math.sin(e*f)/p}return(// calculate final values
this.x=c*i+d*o,this.y=c*n+d*a,this.z=c*s+d*h,this.w=c*r+d*l,this)},/**
     * Invert this Quaternion.
     *
     * @method Phaser.Math.Quaternion#invert
     * @since 3.0.0
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */invert:function(){var t=this.x,e=this.y,i=this.z,n=this.w,s=t*t+e*e+i*i+n*n,r=s?1/s:0;return(// TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
this.x=-t*r,this.y=-e*r,this.z=-i*r,this.w=n*r,this)},/**
     * Convert this Quaternion into its conjugate.
     *
     * Sets the x, y and z components.
     *
     * @method Phaser.Math.Quaternion#conjugate
     * @since 3.0.0
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */conjugate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this},/**
     * Rotate this Quaternion on the X axis.
     *
     * @method Phaser.Math.Quaternion#rotateX
     * @since 3.0.0
     *
     * @param {number} rad - The rotation angle in radians.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */rotateX:function(t){t*=.5;var e=this.x,i=this.y,n=this.z,s=this.w,r=Math.sin(t),o=Math.cos(t);return this.x=e*o+s*r,this.y=i*o+n*r,this.z=n*o-i*r,this.w=s*o-e*r,this},/**
     * Rotate this Quaternion on the Y axis.
     *
     * @method Phaser.Math.Quaternion#rotateY
     * @since 3.0.0
     *
     * @param {number} rad - The rotation angle in radians.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */rotateY:function(t){t*=.5;var e=this.x,i=this.y,n=this.z,s=this.w,r=Math.sin(t),o=Math.cos(t);return this.x=e*o-n*r,this.y=i*o+s*r,this.z=n*o+e*r,this.w=s*o-i*r,this},/**
     * Rotate this Quaternion on the Z axis.
     *
     * @method Phaser.Math.Quaternion#rotateZ
     * @since 3.0.0
     *
     * @param {number} rad - The rotation angle in radians.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */rotateZ:function(t){t*=.5;var e=this.x,i=this.y,n=this.z,s=this.w,r=Math.sin(t),o=Math.cos(t);return this.x=e*o+i*r,this.y=i*o-e*r,this.z=n*o+s*r,this.w=s*o-n*r,this},/**
     * Create a unit (or rotation) Quaternion from its x, y, and z components.
     *
     * Sets the w component.
     *
     * @method Phaser.Math.Quaternion#calculateW
     * @since 3.0.0
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */calculateW:function(){var t=this.x,e=this.y,i=this.z;return this.w=-Math.sqrt(1-t*t-e*e-i*i),this},/**
     * Convert the given Matrix into this Quaternion.
     *
     * @method Phaser.Math.Quaternion#fromMat3
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix3} mat - The Matrix to convert from.
     *
     * @return {Phaser.Math.Quaternion} This Quaternion.
     */fromMat3:function(t){// benchmarks:
//    http://jsperf.com/typed-array-access-speed
//    http://jsperf.com/conversion-of-3x3-matrix-to-quaternion
// Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
// article "Quaternion Calculus and Fast Animation".
var e,i=t.val,n=i[0]+i[4]+i[8];if(n>0)// |w| > 1/2, may as well choose w > 1/2
e=Math.sqrt(n+1),this.w=.5*e,e=.5/e,this.x=(i[7]-i[5])*e,this.y=(i[2]-i[6])*e,this.z=(i[3]-i[1])*e;else{// |w| <= 1/2
var s=0;i[4]>i[0]&&(s=1),i[8]>i[3*s+s]&&(s=2);var r=o[s],h=o[r];//  This isn't quite as clean without array access
e=Math.sqrt(i[3*s+s]-i[3*r+r]-i[3*h+h]+1),a[s]=.5*e,e=.5/e,a[r]=(i[3*r+s]+i[3*s+r])*e,a[h]=(i[3*h+s]+i[3*s+h])*e,this.x=a[0],this.y=a[1],this.z=a[2],this.w=(i[3*h+r]-i[3*r+h])*e}return this}});t.exports=d}),r("iV7dk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gbKIZ"),n=s("hD0DV"),r=s("jzUY5"),o=new n,a=new r,h=new i;t.exports=function(t,e,i){//  Multiply our vector by the rotation matrix
return(//  Set the quaternion to our axis angle
a.setAxisAngle(e,i),//  Create a rotation matrix from the axis angle
o.fromRotationTranslation(a,h.set(0,0,0)),t.transformMat4(o))}}),r("488fh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @typedef {object} Phaser.Plugins.DefaultPlugins
 * 
 * @property {array} Global - These are the Global Managers that are created by the Phaser.Game instance.
 * @property {array} CoreScene - These are the core plugins that are installed into every Scene.Systems instance, no matter what.
 * @property {array} DefaultScene - These plugins are created in Scene.Systems in addition to the CoreScenePlugins.
 */var i={/**
     * These are the Global Managers that are created by the Phaser.Game instance.
     * They are referenced from Scene.Systems so that plugins can use them.
     * 
     * @name Phaser.Plugins.Global
     * @type {array}
     * @since 3.0.0
     */Global:["game","anims","cache","plugins","registry","scale","sound","textures"],/**
     * These are the core plugins that are installed into every Scene.Systems instance, no matter what.
     * They are optionally exposed in the Scene as well (see the InjectionMap for details)
     * 
     * They are created in the order in which they appear in this array and EventEmitter is always first.
     * 
     * @name Phaser.Plugins.CoreScene
     * @type {array}
     * @since 3.0.0
     */CoreScene:["EventEmitter","CameraManager","GameObjectCreator","GameObjectFactory","ScenePlugin","DisplayList","UpdateList"],/**
     * These plugins are created in Scene.Systems in addition to the CoreScenePlugins.
     * 
     * You can elect not to have these plugins by either creating a DefaultPlugins object as part
     * of the Game Config, by creating a Plugins object as part of a Scene Config, or by modifying this array
     * and building your own bundle.
     * 
     * They are optionally exposed in the Scene as well (see the InjectionMap for details)
     * 
     * They are always created in the order in which they appear in the array.
     * 
     * @name Phaser.Plugins.DefaultScene
     * @type {array}
     * @since 3.0.0
     */DefaultScene:["Clock","DataManagerPlugin","InputPlugin","Loader","TweenManager","LightsPlugin"]};i.DefaultScene.push("CameraManager3D"),i.Global.push("facebook"),t.exports=i}),r("dFILV",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("9OJi8"),n=s("kKoer"),r=s("bRAqZ"),o=s("9t9UB");t.exports=function(t){var e,a,h=t.config;if((h.customEnvironment||h.canvas)&&h.renderType===r.AUTO)throw Error("Must set explicit renderType in custom environment");//  Not a custom environment, didn't provide their own canvas and not headless, so determine the renderer:
if(!h.customEnvironment&&!h.canvas&&h.renderType!==r.HEADLESS){if(h.renderType!==r.CANVAS&&(h.renderType===r.CANVAS||o.webGL))h.renderType=r.WEBGL;else if(o.canvas)h.renderType=r.CANVAS;else throw Error("Cannot create Canvas or WebGL context, aborting.")}h.antialias||n.disableSmoothing();var l=t.scale.baseSize,u=l.width,c=l.height;h.canvas?(t.canvas=h.canvas,t.canvas.width=u,t.canvas.height=c):t.canvas=n.create(t,u,c,h.renderType),h.canvasStyle&&(t.canvas.style=h.canvasStyle),h.antialias||i.setCrisp(t.canvas),h.renderType!==r.HEADLESS&&(e=s("b2B4m"),a=s("aPphQ"),h.renderType===r.WEBGL?t.renderer=new a(t):(t.renderer=new e(t),t.context=t.renderer.gameContext))}}),r("9OJi8",function(t,e){t.exports={/**
     * Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast' on webkit).
     *
     * @function Phaser.Display.Canvas.CanvasInterpolation.setCrisp
     * @since 3.0.0
     * 
     * @param {HTMLCanvasElement} canvas - The canvas object to have the style set on.
     * 
     * @return {HTMLCanvasElement} The canvas.
     */setCrisp:function(t){return["optimizeSpeed","-moz-crisp-edges","-o-crisp-edges","-webkit-optimize-contrast","optimize-contrast","crisp-edges","pixelated"].forEach(function(e){t.style["image-rendering"]=e}),t.style.msInterpolationMode="nearest-neighbor",t},/**
     * Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').
     *
     * @function Phaser.Display.Canvas.CanvasInterpolation.setBicubic
     * @since 3.0.0
     * 
     * @param {HTMLCanvasElement} canvas - The canvas object to have the style set on.
     * 
     * @return {HTMLCanvasElement} The canvas.
     */setBicubic:function(t){return t.style["image-rendering"]="auto",t.style.msInterpolationMode="bicubic",t}}}),r("b2B4m",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("feofd"),n=s("3xxp2"),r=s("jwj1g"),o=s("bRAqZ"),a=s("3M7Hx"),h=s("jPI3B"),l=s("azs1m"),u=new r({initialize:function(t){/**
         * The Phaser Game instance that owns this renderer.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#game
         * @type {Phaser.Game}
         * @since 3.0.0
         */this.game=t,/**
         * A constant which allows the renderer to be easily identified as a Canvas Renderer.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#type
         * @type {integer}
         * @since 3.0.0
         */this.type=o.CANVAS,/**
         * The total number of Game Objects which were rendered in a frame.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#drawCount
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.drawCount=0,/**
         * The width of the canvas being rendered to.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#width
         * @type {integer}
         * @since 3.0.0
         */this.width=0,/**
         * The height of the canvas being rendered to.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#height
         * @type {integer}
         * @since 3.0.0
         */this.height=0,/**
         * The local configuration settings of the CanvasRenderer.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#config
         * @type {object}
         * @since 3.0.0
         */this.config={clearBeforeRender:t.config.clearBeforeRender,backgroundColor:t.config.backgroundColor,resolution:t.config.resolution,antialias:t.config.antialias,roundPixels:t.config.roundPixels},/**
         * The canvas element which the Game uses.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#gameCanvas
         * @type {HTMLCanvasElement}
         * @since 3.0.0
         */this.gameCanvas=t.canvas;var e={alpha:t.config.transparent,desynchronized:t.config.desynchronized};/**
         * The canvas context used to render all Cameras in all Scenes during the game loop.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#gameContext
         * @type {CanvasRenderingContext2D}
         * @since 3.0.0
         */this.gameContext=this.game.config.context?this.game.config.context:this.gameCanvas.getContext("2d",e),/**
         * The canvas context currently used by the CanvasRenderer for all rendering operations.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#currentContext
         * @type {CanvasRenderingContext2D}
         * @since 3.0.0
         */this.currentContext=this.gameContext,/**
         * Should the Canvas use Image Smoothing or not when drawing Sprites?
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#antialias
         * @type {boolean}
         * @since 3.20.0
         */this.antialias=t.config.antialias,/**
         * The blend modes supported by the Canvas Renderer.
         *
         * This object maps the {@link Phaser.BlendModes} to canvas compositing operations.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#blendModes
         * @type {array}
         * @since 3.0.0
         */this.blendModes=a(),/**
         * Details about the currently scheduled snapshot.
         * 
         * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#snapshotState
         * @type {Phaser.Types.Renderer.Snapshot.SnapshotState}
         * @since 3.16.0
         */this.snapshotState={x:0,y:0,width:1,height:1,getPixel:!1,callback:null,type:"image/png",encoder:.92},/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix1
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.12.0
         */this._tempMatrix1=new l,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix2
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.12.0
         */this._tempMatrix2=new l,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix3
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.12.0
         */this._tempMatrix3=new l,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix4
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.12.0
         */this._tempMatrix4=new l,this.init()},/**
     * Prepares the game canvas for rendering.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#init
     * @since 3.0.0
     */init:function(){this.game.scale.on(h.RESIZE,this.onResize,this);var t=this.game.scale.baseSize;this.resize(t.width,t.height)},/**
     * The event handler that manages the `resize` event dispatched by the Scale Manager.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#onResize
     * @since 3.16.0
     *
     * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.
     * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.
     * @param {Phaser.Structs.Size} displaySize - The display Size object. The size of the canvas style width / height attributes.
     * @param {number} [resolution] - The Scale Manager resolution setting.
     */onResize:function(t,e){//  Has the underlying canvas size changed?
(e.width!==this.width||e.height!==this.height)&&this.resize(e.width,e.height)},/**
     * Resize the main game canvas.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#resize
     * @since 3.0.0
     *
     * @param {number} [width] - The new width of the renderer.
     * @param {number} [height] - The new height of the renderer.
     */resize:function(t,e){this.width=t,this.height=e},/**
     * Resets the transformation matrix of the current context to the identity matrix, thus resetting any transformation.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#resetTransform
     * @since 3.0.0
     */resetTransform:function(){this.currentContext.setTransform(1,0,0,1,0,0)},/**
     * Sets the blend mode (compositing operation) of the current context.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#setBlendMode
     * @since 3.0.0
     *
     * @param {string} blendMode - The new blend mode which should be used.
     *
     * @return {this} This CanvasRenderer object.
     */setBlendMode:function(t){return this.currentContext.globalCompositeOperation=t,this},/**
     * Changes the Canvas Rendering Context that all draw operations are performed against.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#setContext
     * @since 3.12.0
     *
     * @param {?CanvasRenderingContext2D} [ctx] - The new Canvas Rendering Context to draw everything to. Leave empty to reset to the Game Canvas.
     *
     * @return {this} The Canvas Renderer instance.
     */setContext:function(t){return this.currentContext=t||this.gameContext,this},/**
     * Sets the global alpha of the current context.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#setAlpha
     * @since 3.0.0
     *
     * @param {number} alpha - The new alpha to use, where 0 is fully transparent and 1 is fully opaque.
     *
     * @return {this} This CanvasRenderer object.
     */setAlpha:function(t){return this.currentContext.globalAlpha=t,this},/**
     * Called at the start of the render loop.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#preRender
     * @since 3.0.0
     */preRender:function(){var t=this.gameContext,e=this.config,i=this.width,n=this.height;t.globalAlpha=1,t.globalCompositeOperation="source-over",t.setTransform(1,0,0,1,0,0),e.clearBeforeRender&&t.clearRect(0,0,i,n),e.transparent||(t.fillStyle=e.backgroundColor.rgba,t.fillRect(0,0,i,n)),t.save(),this.drawCount=0},/**
     * Renders the Scene to the given Camera.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#render
     * @since 3.0.0
     *
     * @param {Phaser.Scene} scene - The Scene to render.
     * @param {Phaser.GameObjects.DisplayList} children - The Game Objects within the Scene to be rendered.
     * @param {number} interpolationPercentage - The interpolation percentage to apply. Currently unused.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera to render with.
     */render:function(t,e,i,s){var r=e.list,o=r.length,a=s._cx,h=s._cy,l=s._cw,u=s._ch,c=s.renderToTexture?s.context:t.sys.context;//  Save context pre-clip
c.save(),this.game.scene.customViewports&&(c.beginPath(),c.rect(a,h,l,u),c.clip()),this.currentContext=c;var d=s.mask;d&&d.preRenderCanvas(this,null,s._maskCamera),s.transparent||(c.fillStyle=s.backgroundColor.rgba,c.fillRect(a,h,l,u)),c.globalAlpha=s.alpha,c.globalCompositeOperation="source-over",this.drawCount+=r.length,s.renderToTexture&&s.emit(n.PRE_RENDER,s),s.matrix.copyToContext(c);for(var f=0;f<o;f++){var p=r[f];p.willRender(s)&&(p.mask&&p.mask.preRenderCanvas(this,p,s),p.renderCanvas(this,p,i,s),p.mask&&p.mask.postRenderCanvas(this,p,s))}c.setTransform(1,0,0,1,0,0),c.globalCompositeOperation="source-over",c.globalAlpha=1,s.flashEffect.postRenderCanvas(c),s.fadeEffect.postRenderCanvas(c),s.dirty=!1,d&&d.postRenderCanvas(this),//  Restore pre-clip context
c.restore(),s.renderToTexture&&(s.emit(n.POST_RENDER,s),s.renderToGame&&t.sys.context.drawImage(s.canvas,a,h))},/**
     * Restores the game context's global settings and takes a snapshot if one is scheduled.
     *
     * The post-render step happens after all Cameras in all Scenes have been rendered.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#postRender
     * @since 3.0.0
     */postRender:function(){this.gameContext.restore();var t=this.snapshotState;t.callback&&(i(this.gameCanvas,t),t.callback=null)},/**
     * Takes a snapshot of the given area of the given canvas.
     * 
     * Unlike the other snapshot methods, this one is processed immediately and doesn't wait for the next render.
     * 
     * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets
     * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotCanvas
     * @since 3.19.0
     *
     * @param {HTMLCanvasElement} canvas - The canvas to grab from.
     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.
     * @param {boolean} [getPixel=false] - Grab a single pixel as a Color object, or an area as an Image object?
     * @param {integer} [x=0] - The x coordinate to grab from.
     * @param {integer} [y=0] - The y coordinate to grab from.
     * @param {integer} [width=canvas.width] - The width of the area to grab.
     * @param {integer} [height=canvas.height] - The height of the area to grab.
     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.
     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.
     *
     * @return {this} This Canvas Renderer.
     */snapshotCanvas:function(t,e,n,s,r,o,a,h,l){void 0===n&&(n=!1),this.snapshotArea(s,r,o,a,e,h,l);var u=this.snapshotState;return u.getPixel=n,i(this.canvas,u),u.callback=null,this},/**
     * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.
     * 
     * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.
     * 
     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then
     * calling this method will override it.
     * 
     * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets
     * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshot
     * @since 3.0.0
     *
     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.
     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.
     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.
     *
     * @return {this} This WebGL Renderer.
     */snapshot:function(t,e,i){return this.snapshotArea(0,0,this.gameCanvas.width,this.gameCanvas.height,t,e,i)},/**
     * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.
     * 
     * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.
     * 
     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then
     * calling this method will override it.
     * 
     * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets
     * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotArea
     * @since 3.16.0
     *
     * @param {integer} x - The x coordinate to grab from.
     * @param {integer} y - The y coordinate to grab from.
     * @param {integer} width - The width of the area to grab.
     * @param {integer} height - The height of the area to grab.
     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.
     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.
     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.
     *
     * @return {this} This WebGL Renderer.
     */snapshotArea:function(t,e,i,n,s,r,o){var a=this.snapshotState;return a.callback=s,a.type=r,a.encoder=o,a.getPixel=!1,a.x=t,a.y=e,a.width=Math.min(i,this.gameCanvas.width),a.height=Math.min(n,this.gameCanvas.height),this},/**
     * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.
     * 
     * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.
     * 
     * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then
     * calling this method will override it.
     * 
     * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for
     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,
     * using less memory.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotPixel
     * @since 3.16.0
     *
     * @param {integer} x - The x coordinate of the pixel to get.
     * @param {integer} y - The y coordinate of the pixel to get.
     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.
     *
     * @return {this} This WebGL Renderer.
     */snapshotPixel:function(t,e,i){return this.snapshotArea(t,e,1,1,i),this.snapshotState.getPixel=!0,this},/**
     * Takes a Sprite Game Object, or any object that extends it, and draws it to the current context.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#batchSprite
     * @since 3.12.0
     *
     * @param {Phaser.GameObjects.GameObject} sprite - The texture based Game Object to draw.
     * @param {Phaser.Textures.Frame} frame - The frame to draw, doesn't have to be that owned by the Game Object.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the rendering transform.
     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - The transform matrix of the parent container, if set.
     */batchSprite:function(t,e,i,n){var s=i.alpha*t.alpha;if(0!==s){var r=this.currentContext,o=this._tempMatrix1,a=this._tempMatrix2,h=this._tempMatrix3,l=e.canvasData,u=l.x,c=l.y,d=e.cutWidth,f=e.cutHeight,p=e.customPivot,g=e.source.resolution,v=t.displayOriginX,m=t.displayOriginY,y=-v+e.x,x=-m+e.y;if(t.isCropped){var w=t._crop;(w.flipX!==t.flipX||w.flipY!==t.flipY)&&e.updateCropUVs(w,t.flipX,t.flipY),d=w.cw,f=w.ch,u=w.cx,c=w.cy,y=-v+w.x,x=-m+w.y,t.flipX&&(y>=0?y=-(y+d):y<0&&(y=Math.abs(y)-d)),t.flipY&&(x>=0?x=-(x+f):x<0&&(x=Math.abs(x)-f))}var T=1,b=1;t.flipX&&(p||(y+=-e.realWidth+2*v),T=-1),t.flipY&&(p||(x+=-e.realHeight+2*m),b=-1),a.applyITRS(t.x,t.y,t.rotation,t.scaleX*T,t.scaleY*b),o.copyFrom(i.matrix),n?(//  Multiply the camera by the parent matrix
o.multiplyWithOffset(n,-i.scrollX*t.scrollFactorX,-i.scrollY*t.scrollFactorY),//  Undo the camera scroll
a.e=t.x,a.f=t.y):(a.e-=i.scrollX*t.scrollFactorX,a.f-=i.scrollY*t.scrollFactorY),//  Multiply by the Sprite matrix, store result in calcMatrix
o.multiply(a,h),r.save(),h.setToContext(r),r.globalCompositeOperation=this.blendModes[t.blendMode],r.globalAlpha=s,r.imageSmoothingEnabled=!(!this.antialias||e.source.scaleMode),r.drawImage(e.source.image,u,c,d,f,y,x,d/g,f/g),r.restore()}},/**
     * Destroys all object references in the Canvas Renderer.
     *
     * @method Phaser.Renderer.Canvas.CanvasRenderer#destroy
     * @since 3.0.0
     */destroy:function(){this.gameCanvas=null,this.gameContext=null,this.game=null}});t.exports=u}),r("feofd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kKoer"),n=s("pqNJR"),r=s("7BSWl");t.exports=function(t,e){var s=r(e,"callback"),o=r(e,"type","image/png"),a=r(e,"encoder",.92),h=Math.abs(Math.round(r(e,"x",0))),l=Math.abs(Math.round(r(e,"y",0))),u=r(e,"width",t.width),c=r(e,"height",t.height);if(r(e,"getPixel",!1)){var d=t.getContext("2d").getImageData(h,l,1,1).data;s.call(null,new n(d[0],d[1],d[2],d[3]/255))}else if(0!==h||0!==l||u!==t.width||c!==t.height){//  Area Grab
var f=i.createWebGL(this,u,c);f.getContext("2d").drawImage(t,h,l,u,c,0,0,u,c);var p=new Image;p.onerror=function(){s.call(null),i.remove(f)},p.onload=function(){s.call(null,p),i.remove(f)},p.src=f.toDataURL(o,a)}else{//  Full Grab
var g=new Image;g.onerror=function(){s.call(null)},g.onload=function(){s.call(null,g)},g.src=t.toDataURL(o,a)}}}),r("3M7Hx",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("3qUcC"),n=s("lz57b");t.exports=function(){var t=[],e=n.supportNewBlendModes,s="source-over";return t[i.NORMAL]=s,t[i.ADD]="lighter",t[i.MULTIPLY]=e?"multiply":s,t[i.SCREEN]=e?"screen":s,t[i.OVERLAY]=e?"overlay":s,t[i.DARKEN]=e?"darken":s,t[i.LIGHTEN]=e?"lighten":s,t[i.COLOR_DODGE]=e?"color-dodge":s,t[i.COLOR_BURN]=e?"color-burn":s,t[i.HARD_LIGHT]=e?"hard-light":s,t[i.SOFT_LIGHT]=e?"soft-light":s,t[i.DIFFERENCE]=e?"difference":s,t[i.EXCLUSION]=e?"exclusion":s,t[i.HUE]=e?"hue":s,t[i.SATURATION]=e?"saturation":s,t[i.COLOR]=e?"color":s,t[i.LUMINOSITY]=e?"luminosity":s,t[i.ERASE]="destination-out",t[i.SOURCE_IN]="source-in",t[i.SOURCE_OUT]="source-out",t[i.SOURCE_ATOP]="source-atop",t[i.DESTINATION_OVER]="destination-over",t[i.DESTINATION_IN]="destination-in",t[i.DESTINATION_OUT]="destination-out",t[i.DESTINATION_ATOP]="destination-atop",t[i.LIGHTER]="lighter",t[i.COPY]="copy",t[i.XOR]="xor",t}}),r("aPphQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2LSzx"),n=s("3xxp2"),r=s("jwj1g"),o=s("bRAqZ"),a=s("aqcI1"),h=s("gV9Y0"),l=s("13GYA"),u=s("jPI3B"),c=s("eOqX8"),d=s("6R4Pe"),f=s("azs1m"),p=s("gaO4e"),g=s("65D27"),v=s("84zIv"),m=s("lOOAG"),y=s("jnBZP"),x=s("eBujp"),w=new r({initialize:function(t){var e=t.config,n={alpha:e.transparent,desynchronized:e.desynchronized,depth:!1,antialias:e.antialiasGL,premultipliedAlpha:e.premultipliedAlpha,stencil:!0,failIfMajorPerformanceCaveat:e.failIfMajorPerformanceCaveat,powerPreference:e.powerPreference};/**
         * The local configuration settings of this WebGL Renderer.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#config
         * @type {object}
         * @since 3.0.0
         */this.config={clearBeforeRender:e.clearBeforeRender,antialias:e.antialias,backgroundColor:e.backgroundColor,contextCreation:n,resolution:e.resolution,roundPixels:e.roundPixels,maxTextures:e.maxTextures,maxTextureSize:e.maxTextureSize,batchSize:e.batchSize,maxLights:e.maxLights,mipmapFilter:e.mipmapFilter},/**
         * The Game instance which owns this WebGL Renderer.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#game
         * @type {Phaser.Game}
         * @since 3.0.0
         */this.game=t,/**
         * A constant which allows the renderer to be easily identified as a WebGL Renderer.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#type
         * @type {integer}
         * @since 3.0.0
         */this.type=o.WEBGL,/**
         * The width of the canvas being rendered to.
         * This is populated in the onResize event handler.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#width
         * @type {integer}
         * @since 3.0.0
         */this.width=0,/**
         * The height of the canvas being rendered to.
         * This is populated in the onResize event handler.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#height
         * @type {integer}
         * @since 3.0.0
         */this.height=0,/**
         * The canvas which this WebGL Renderer draws to.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#canvas
         * @type {HTMLCanvasElement}
         * @since 3.0.0
         */this.canvas=t.canvas,/**
         * An array of blend modes supported by the WebGL Renderer.
         * 
         * This array includes the default blend modes as well as any custom blend modes added through {@link #addBlendMode}.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#blendModes
         * @type {array}
         * @default []
         * @since 3.0.0
         */this.blendModes=[],/**
         * Keeps track of any WebGLTexture created with the current WebGLRenderingContext
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#nativeTextures
         * @type {array}
         * @default []
         * @since 3.0.0
         */this.nativeTextures=[],/**
         * This property is set to `true` if the WebGL context of the renderer is lost.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#contextLost
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.contextLost=!1,/**
         * This object will store all pipelines created through addPipeline
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#pipelines
         * @type {object}
         * @default null
         * @since 3.0.0
         */this.pipelines=null,/**
         * Details about the currently scheduled snapshot.
         * 
         * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#snapshotState
         * @type {Phaser.Types.Renderer.Snapshot.SnapshotState}
         * @since 3.0.0
         */this.snapshotState={x:0,y:0,width:1,height:1,getPixel:!1,callback:null,type:"image/png",encoder:.92,isFramebuffer:!1,bufferWidth:0,bufferHeight:0},// Internal Renderer State (Textures, Framebuffers, Pipelines, Buffers, etc)
/**
         * Cached value for the last texture unit that was used
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentActiveTextureUnit
         * @type {integer}
         * @since 3.1.0
         */this.currentActiveTextureUnit=0,/**
         * An array of the last texture handles that were bound to the WebGLRenderingContext
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentTextures
         * @type {array}
         * @since 3.0.0
         */this.currentTextures=Array(16),/**
         * Current framebuffer in use
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentFramebuffer
         * @type {WebGLFramebuffer}
         * @default null
         * @since 3.0.0
         */this.currentFramebuffer=null,/**
         * Current WebGLPipeline in use
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentPipeline
         * @type {Phaser.Renderer.WebGL.WebGLPipeline}
         * @default null
         * @since 3.0.0
         */this.currentPipeline=null,/**
         * Current WebGLProgram in use
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentProgram
         * @type {WebGLProgram}
         * @default null
         * @since 3.0.0
         */this.currentProgram=null,/**
         * Current WebGLBuffer (Vertex buffer) in use
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentVertexBuffer
         * @type {WebGLBuffer}
         * @default null
         * @since 3.0.0
         */this.currentVertexBuffer=null,/**
         * Current WebGLBuffer (Index buffer) in use
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentIndexBuffer
         * @type {WebGLBuffer}
         * @default null
         * @since 3.0.0
         */this.currentIndexBuffer=null,/**
         * Current blend mode in use
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentBlendMode
         * @type {integer}
         * @since 3.0.0
         */this.currentBlendMode=1/0,/**
         * Indicates if the the scissor state is enabled in WebGLRenderingContext
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissorEnabled
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.currentScissorEnabled=!1,/**
         * Stores the current scissor data
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissor
         * @type {Uint32Array}
         * @since 3.0.0
         */this.currentScissor=null,/**
         * Stack of scissor data
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#scissorStack
         * @type {Uint32Array}
         * @since 3.0.0
         */this.scissorStack=[],/**
         * The handler to invoke when the context is lost.
         * This should not be changed and is set in the boot method.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#contextLostHandler
         * @type {function}
         * @since 3.19.0
         */this.contextLostHandler=l,/**
         * The handler to invoke when the context is restored.
         * This should not be changed and is set in the boot method.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#contextRestoredHandler
         * @type {function}
         * @since 3.19.0
         */this.contextRestoredHandler=l,/**
         * The underlying WebGL context of the renderer.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#gl
         * @type {WebGLRenderingContext}
         * @default null
         * @since 3.0.0
         */this.gl=null,/**
         * Array of strings that indicate which WebGL extensions are supported by the browser
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#supportedExtensions
         * @type {object}
         * @default null
         * @since 3.0.0
         */this.supportedExtensions=null,/**
         * Extensions loaded into the current context
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#extensions
         * @type {object}
         * @default {}
         * @since 3.0.0
         */this.extensions={},/**
         * Stores the current WebGL component formats for further use
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#glFormats
         * @type {array}
         * @default []
         * @since 3.2.0
         */this.glFormats=[],/**
         * Stores the supported WebGL texture compression formats.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#compression
         * @type {array}
         * @since 3.8.0
         */this.compression={ETC1:!1,PVRTC:!1,S3TC:!1},/**
         * Cached drawing buffer height to reduce gl calls.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#drawingBufferHeight
         * @type {number}
         * @readonly
         * @since 3.11.0
         */this.drawingBufferHeight=0,/**
         * A blank 32x32 transparent texture, as used by the Graphics system where needed.
         * This is set in the `boot` method.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#blankTexture
         * @type {WebGLTexture}
         * @readonly
         * @since 3.12.0
         */this.blankTexture=null,/**
         * A default Camera used in calls when no other camera has been provided.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#defaultCamera
         * @type {Phaser.Cameras.Scene2D.BaseCamera}
         * @since 3.12.0
         */this.defaultCamera=new i(0,0,0,0),/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix1
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.12.0
         */this._tempMatrix1=new f,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix2
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.12.0
         */this._tempMatrix2=new f,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix3
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.12.0
         */this._tempMatrix3=new f,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix4
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.12.0
         */this._tempMatrix4=new f,/**
         * The total number of masks currently stacked.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#maskCount
         * @type {integer}
         * @since 3.17.0
         */this.maskCount=0,/**
         * The mask stack.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#maskStack
         * @type {Phaser.Display.Masks.GeometryMask[]}
         * @since 3.17.0
         */this.maskStack=[],/**
         * Internal property that tracks the currently set mask.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentMask
         * @type {any}
         * @since 3.17.0
         */this.currentMask={mask:null,camera:null},/**
         * Internal property that tracks the currently set camera mask.
         *
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentCameraMask
         * @type {any}
         * @since 3.17.0
         */this.currentCameraMask={mask:null,camera:null},/**
         * Internal gl function mapping for uniform look-up.
         * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform
         * 
         * @name Phaser.Renderer.WebGL.WebGLRenderer#glFuncMap
         * @type {any}
         * @since 3.17.0
         */this.glFuncMap=null,/**
         * The `type` of the Game Object being currently rendered.
         * This can be used by advanced render functions for batching look-ahead.
         * 
         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentType
         * @type {string}
         * @since 3.19.0
         */this.currentType="",/**
         * Is the `type` of the Game Object being currently rendered different than the
         * type of the object before it in the display list? I.e. it's a 'new' type.
         * 
         * @name Phaser.Renderer.WebGL.WebGLRenderer#newType
         * @type {boolean}
         * @since 3.19.0
         */this.newType=!1,/**
         * Does the `type` of the next Game Object in the display list match that
         * of the object being currently rendered?
         * 
         * @name Phaser.Renderer.WebGL.WebGLRenderer#nextTypeMatch
         * @type {boolean}
         * @since 3.19.0
         */this.nextTypeMatch=!1,/**
         * The mipmap magFilter to be used when creating textures.
         * 
         * You can specify this as a string in the game config, i.e.:
         * 
         * `renderer: { mipmapFilter: 'NEAREST_MIPMAP_LINEAR' }`
         * 
         * The 6 options for WebGL1 are, in order from least to most computationally expensive:
         * 
         * NEAREST (for pixel art)
         * LINEAR (the default)
         * NEAREST_MIPMAP_NEAREST
         * LINEAR_MIPMAP_NEAREST
         * NEAREST_MIPMAP_LINEAR
         * LINEAR_MIPMAP_LINEAR
         * 
         * Mipmaps only work with textures that are fully power-of-two in size.
         * 
         * For more details see https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html
         * 
         * @name Phaser.Renderer.WebGL.WebGLRenderer#mipmapFilter
         * @type {GLenum}
         * @since 3.21.0
         */this.mipmapFilter=null,this.init(this.config)},/**
     * Creates a new WebGLRenderingContext and initializes all internal state.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#init
     * @since 3.0.0
     *
     * @param {object} config - The configuration object for the renderer.
     *
     * @return {this} This WebGLRenderer instance.
     */init:function(t){var e,i=this.game,n=this.canvas,s=t.backgroundColor;if(!(e=i.config.context?i.config.context:n.getContext("webgl",t.contextCreation)||n.getContext("experimental-webgl",t.contextCreation))||e.isContextLost())throw this.contextLost=!0,Error("WebGL unsupported");this.gl=e;var r=this;this.contextLostHandler=function(t){r.contextLost=!0,r.game.events.emit(a.CONTEXT_LOST,r),t.preventDefault()},this.contextRestoredHandler=function(){r.contextLost=!1,r.init(r.config),r.game.events.emit(a.CONTEXT_RESTORED,r)},n.addEventListener("webglcontextlost",this.contextLostHandler,!1),n.addEventListener("webglcontextrestored",this.contextRestoredHandler,!1),//  Set it back into the Game, so developers can access it from there too
i.context=e;for(var h=0;h<=27;h++)this.blendModes.push({func:[e.ONE,e.ONE_MINUS_SRC_ALPHA],equation:e.FUNC_ADD});//  ADD
this.blendModes[1].func=[e.ONE,e.DST_ALPHA],//  MULTIPLY
this.blendModes[2].func=[e.DST_COLOR,e.ONE_MINUS_SRC_ALPHA],//  SCREEN
this.blendModes[3].func=[e.ONE,e.ONE_MINUS_SRC_COLOR],//  ERASE
this.blendModes[17]={func:[e.ZERO,e.ONE_MINUS_SRC_ALPHA],equation:e.FUNC_REVERSE_SUBTRACT},this.glFormats[0]=e.BYTE,this.glFormats[1]=e.SHORT,this.glFormats[2]=e.UNSIGNED_BYTE,this.glFormats[3]=e.UNSIGNED_SHORT,this.glFormats[4]=e.FLOAT,//  Set the gl function map
this.glFuncMap={mat2:{func:e.uniformMatrix2fv,length:1,matrix:!0},mat3:{func:e.uniformMatrix3fv,length:1,matrix:!0},mat4:{func:e.uniformMatrix4fv,length:1,matrix:!0},"1f":{func:e.uniform1f,length:1},"1fv":{func:e.uniform1fv,length:1},"1i":{func:e.uniform1i,length:1},"1iv":{func:e.uniform1iv,length:1},"2f":{func:e.uniform2f,length:2},"2fv":{func:e.uniform2fv,length:1},"2i":{func:e.uniform2i,length:2},"2iv":{func:e.uniform2iv,length:1},"3f":{func:e.uniform3f,length:3},"3fv":{func:e.uniform3fv,length:1},"3i":{func:e.uniform3i,length:3},"3iv":{func:e.uniform3iv,length:1},"4f":{func:e.uniform4f,length:4},"4fv":{func:e.uniform4fv,length:1},"4i":{func:e.uniform4i,length:4},"4iv":{func:e.uniform4iv,length:1}};// Load supported extensions
var l=e.getSupportedExtensions();t.maxTextures||(t.maxTextures=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)),t.maxTextureSize||(t.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE));var u="WEBGL_compressed_texture_",c="WEBKIT_"+u;this.compression.ETC1=e.getExtension(u+"etc1")||e.getExtension(c+"etc1"),this.compression.PVRTC=e.getExtension(u+"pvrtc")||e.getExtension(c+"pvrtc"),this.compression.S3TC=e.getExtension(u+"s3tc")||e.getExtension(c+"s3tc"),this.supportedExtensions=l,//  Setup initial WebGL state
e.disable(e.DEPTH_TEST),e.disable(e.CULL_FACE),e.enable(e.BLEND),e.clearColor(s.redGL,s.greenGL,s.blueGL,s.alphaGL),//  Mipmaps
this.mipmapFilter=e[t.mipmapFilter];// Initialize all textures to null
for(var f=0;f<this.currentTextures.length;++f)this.currentTextures[f]=null;return(// Clear previous pipelines and reload default ones
this.pipelines={},this.addPipeline("TextureTintPipeline",new y({game:i,renderer:this})),this.addPipeline("TextureTintStripPipeline",new x({game:i,renderer:this})),this.addPipeline("BitmapMaskPipeline",new v({game:i,renderer:this})),this.addPipeline("Light2D",new m({game:i,renderer:this,maxLights:t.maxLights})),this.setBlendMode(o.BlendModes.NORMAL),i.textures.once(d.READY,this.boot,this),this)},/**
     * Internal boot handler. Calls 'boot' on each pipeline.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#boot
     * @private
     * @since 3.11.0
     */boot:function(){for(var t in this.pipelines)this.pipelines[t].boot();var e=this.game.textures.getFrame("__DEFAULT");this.pipelines.TextureTintPipeline.currentFrame=e,this.blankTexture=e;var i=this.gl;i.bindFramebuffer(i.FRAMEBUFFER,null),i.enable(i.SCISSOR_TEST),this.setPipeline(this.pipelines.TextureTintPipeline),this.game.scale.on(u.RESIZE,this.onResize,this);var n=this.game.scale.baseSize;this.resize(n.width,n.height,this.game.scale.resolution)},/**
     * The event handler that manages the `resize` event dispatched by the Scale Manager.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#onResize
     * @since 3.16.0
     *
     * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.
     * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.
     * @param {Phaser.Structs.Size} displaySize - The display Size object. The size of the canvas style width / height attributes.
     * @param {number} [resolution] - The Scale Manager resolution setting.
     */onResize:function(t,e,i,n){//  Has the underlying canvas size changed?
(e.width!==this.width||e.height!==this.height||n!==this.resolution)&&this.resize(e.width,e.height,n)},/**
     * Resizes the drawing buffer to match that required by the Scale Manager.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#resize
     * @since 3.0.0
     *
     * @param {number} [width] - The new width of the renderer.
     * @param {number} [height] - The new height of the renderer.
     * @param {number} [resolution] - The new resolution of the renderer.
     *
     * @return {this} This WebGLRenderer instance.
     */resize:function(t,e,i){var n=this.gl,s=this.pipelines;//  Update all registered pipelines
for(var r in this.width=t,this.height=e,this.resolution=i,n.viewport(0,0,t,e),s)s[r].resize(t,e,i);return this.drawingBufferHeight=n.drawingBufferHeight,n.scissor(0,n.drawingBufferHeight-e,t,e),this.defaultCamera.setSize(t,e),this},/**
     * Checks if a WebGL extension is supported
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasExtension
     * @since 3.0.0
     *
     * @param {string} extensionName - Name of the WebGL extension
     *
     * @return {boolean} `true` if the extension is supported, otherwise `false`.
     */hasExtension:function(t){return!!this.supportedExtensions&&this.supportedExtensions.indexOf(t)},/**
     * Loads a WebGL extension
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#getExtension
     * @since 3.0.0
     *
     * @param {string} extensionName - The name of the extension to load.
     *
     * @return {object} WebGL extension if the extension is supported
     */getExtension:function(t){return this.hasExtension(t)?(t in this.extensions||(this.extensions[t]=this.gl.getExtension(t)),this.extensions[t]):null},/**
     * Flushes the current pipeline if the pipeline is bound
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#flush
     * @since 3.0.0
     */flush:function(){this.currentPipeline&&this.currentPipeline.flush()},/**
     * Checks if a pipeline is present in the current WebGLRenderer
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasPipeline
     * @since 3.0.0
     *
     * @param {string} pipelineName - The name of the pipeline.
     *
     * @return {boolean} `true` if the given pipeline is loaded, otherwise `false`.
     */hasPipeline:function(t){return t in this.pipelines},/**
     * Returns the pipeline by name if the pipeline exists
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#getPipeline
     * @since 3.0.0
     *
     * @param {string} pipelineName - The name of the pipeline.
     *
     * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline instance, or `null` if not found.
     */getPipeline:function(t){return this.hasPipeline(t)?this.pipelines[t]:null},/**
     * Removes a pipeline by name.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#removePipeline
     * @since 3.0.0
     *
     * @param {string} pipelineName - The name of the pipeline to be removed.
     *
     * @return {this} This WebGLRenderer instance.
     */removePipeline:function(t){return delete this.pipelines[t],this},/**
     * Adds a pipeline instance into the collection of pipelines
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#addPipeline
     * @since 3.0.0
     *
     * @param {string} pipelineName - A unique string-based key for the pipeline.
     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - A pipeline instance which must extend WebGLPipeline.
     *
     * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline instance that was passed.
     */addPipeline:function(t,e){return this.hasPipeline(t)?console.warn("Pipeline exists: "+t):this.pipelines[t]=e,e.name=t,this.pipelines[t].resize(this.width,this.height,this.config.resolution),e},/**
     * Pushes a new scissor state. This is used to set nested scissor states.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#pushScissor
     * @since 3.0.0
     *
     * @param {integer} x - The x position of the scissor.
     * @param {integer} y - The y position of the scissor.
     * @param {integer} width - The width of the scissor.
     * @param {integer} height - The height of the scissor.
     * @param {integer} [drawingBufferHeight] - Optional drawingBufferHeight override value.
     *
     * @return {integer[]} An array containing the scissor values.
     */pushScissor:function(t,e,i,n,s){void 0===s&&(s=this.drawingBufferHeight);var r=this.scissorStack,o=[t,e,i,n];return r.push(o),this.setScissor(t,e,i,n,s),this.currentScissor=o,o},/**
     * Sets the current scissor state.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setScissor
     * @since 3.0.0
     * 
     * @param {integer} x - The x position of the scissor.
     * @param {integer} y - The y position of the scissor.
     * @param {integer} width - The width of the scissor.
     * @param {integer} height - The height of the scissor.
     * @param {integer} [drawingBufferHeight] - Optional drawingBufferHeight override value.
     */setScissor:function(t,e,i,n,s){void 0===s&&(s=this.drawingBufferHeight);var r=this.gl,o=this.currentScissor,a=i>0&&n>0;if(o&&a){var h=o[0],l=o[1],u=o[2],c=o[3];a=h!==t||l!==e||u!==i||c!==n}a&&(this.flush(),// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/scissor
r.scissor(t,s-e-n,i,n))},/**
     * Pops the last scissor state and sets it.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#popScissor
     * @since 3.0.0
     */popScissor:function(){var t=this.scissorStack;//  Remove the current scissor
t.pop();//  Reset the previous scissor
var e=t[t.length-1];e&&this.setScissor(e[0],e[1],e[2],e[3]),this.currentScissor=e},/**
     * Binds a WebGLPipeline and sets it as the current pipeline to be used.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setPipeline
     * @since 3.0.0
     *
     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - The pipeline instance to be activated.
     * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object that invoked this pipeline, if any.
     *
     * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline that was activated.
     */setPipeline:function(t,e){return(this.currentPipeline!==t||this.currentPipeline.vertexBuffer!==this.currentVertexBuffer||this.currentPipeline.program!==this.currentProgram)&&(this.flush(),this.currentPipeline=t,this.currentPipeline.bind()),this.currentPipeline.onBind(e),this.currentPipeline},/**
     * Is there an active stencil mask?
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasActiveStencilMask
     * @since 3.17.0
     * 
     * @return {boolean} `true` if there is an active stencil mask, otherwise `false`.
     */hasActiveStencilMask:function(){var t=this.currentMask.mask,e=this.currentCameraMask.mask;return t&&t.isStencil||e&&e.isStencil},/**
     * Use this to reset the gl context to the state that Phaser requires to continue rendering.
     * Calling this will:
     * 
     * * Disable `DEPTH_TEST`, `CULL_FACE` and `STENCIL_TEST`.
     * * Clear the depth buffer and stencil buffers.
     * * Reset the viewport size.
     * * Reset the blend mode.
     * * Bind a blank texture as the active texture on texture unit zero.
     * * Rebinds the given pipeline instance.
     * 
     * You should call this having previously called `clearPipeline` and then wishing to return
     * control to Phaser again.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#rebindPipeline
     * @since 3.16.0
     * 
     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - The pipeline instance to be activated.
     */rebindPipeline:function(t){var e=this.gl;e.disable(e.DEPTH_TEST),e.disable(e.CULL_FACE),this.hasActiveStencilMask()?e.clear(e.DEPTH_BUFFER_BIT):(//  If there wasn't a stencil mask set before this call, we can disable it safely
e.disable(e.STENCIL_TEST),e.clear(e.DEPTH_BUFFER_BIT|e.STENCIL_BUFFER_BIT)),e.viewport(0,0,this.width,this.height),this.setBlendMode(0,!0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this.blankTexture.glTexture),this.currentActiveTextureUnit=0,this.currentTextures[0]=this.blankTexture.glTexture,this.currentPipeline=t,this.currentPipeline.bind(),this.currentPipeline.onBind()},/**
     * Flushes the current WebGLPipeline being used and then clears it, along with the
     * the current shader program and vertex buffer. Then resets the blend mode to NORMAL.
     * Call this before jumping to your own gl context handler, and then call `rebindPipeline` when
     * you wish to return control to Phaser again.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#clearPipeline
     * @since 3.16.0
     */clearPipeline:function(){this.flush(),this.currentPipeline=null,this.currentProgram=null,this.currentVertexBuffer=null,this.currentIndexBuffer=null,this.setBlendMode(0,!0)},/**
     * Sets the blend mode to the value given.
     *
     * If the current blend mode is different from the one given, the pipeline is flushed and the new
     * blend mode is enabled.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlendMode
     * @since 3.0.0
     *
     * @param {integer} blendModeId - The blend mode to be set. Can be a `BlendModes` const or an integer value.
     * @param {boolean} [force=false] - Force the blend mode to be set, regardless of the currently set blend mode.
     *
     * @return {boolean} `true` if the blend mode was changed as a result of this call, forcing a flush, otherwise `false`.
     */setBlendMode:function(t,e){void 0===e&&(e=!1);var i=this.gl,n=this.blendModes[t];return(!!e||t!==o.BlendModes.SKIP_CHECK&&this.currentBlendMode!==t)&&(this.flush(),i.enable(i.BLEND),i.blendEquation(n.equation),n.func.length>2?i.blendFuncSeparate(n.func[0],n.func[1],n.func[2],n.func[3]):i.blendFunc(n.func[0],n.func[1]),this.currentBlendMode=t,!0)},/**
     * Creates a new custom blend mode for the renderer.
     * 
     * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#Blending_modes
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#addBlendMode
     * @since 3.0.0
     *
     * @param {GLenum[]} func - An array containing the WebGL functions to use for the source and the destination blending factors, respectively. See the possible constants for {@link WebGLRenderingContext#blendFunc()}.
     * @param {GLenum} equation - The equation to use for combining the RGB and alpha components of a new pixel with a rendered one. See the possible constants for {@link WebGLRenderingContext#blendEquation()}.
     *
     * @return {integer} The index of the new blend mode, used for referencing it in the future.
     */addBlendMode:function(t,e){return this.blendModes.push({func:t,equation:e})-1},/**
     * Updates the function bound to a given custom blend mode.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#updateBlendMode
     * @since 3.0.0
     *
     * @param {integer} index - The index of the custom blend mode.
     * @param {function} func - The function to use for the blend mode.
     * @param {function} equation - The equation to use for the blend mode.
     *
     * @return {this} This WebGLRenderer instance.
     */updateBlendMode:function(t,e,i){return this.blendModes[t]&&(this.blendModes[t].func=e,i&&(this.blendModes[t].equation=i)),this},/**
     * Removes a custom blend mode from the renderer.
     * Any Game Objects still using this blend mode will error, so be sure to clear them first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#removeBlendMode
     * @since 3.0.0
     *
     * @param {integer} index - The index of the custom blend mode to be removed.
     *
     * @return {this} This WebGLRenderer instance.
     */removeBlendMode:function(t){return t>17&&this.blendModes[t]&&this.blendModes.splice(t,1),this},/**
     * Sets the current active texture for texture unit zero to be a blank texture.
     * This only happens if there isn't a texture already in use by texture unit zero.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlankTexture
     * @private
     * @since 3.12.0
     *
     * @param {boolean} [force=false] - Force a blank texture set, regardless of what's already bound?
     */setBlankTexture:function(t){void 0===t&&(t=!1),(t||0!==this.currentActiveTextureUnit||!this.currentTextures[0])&&this.setTexture2D(this.blankTexture.glTexture,0)},/**
     * Binds a texture at a texture unit. If a texture is already
     * bound to that unit it will force a flush on the current pipeline.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setTexture2D
     * @since 3.0.0
     *
     * @param {WebGLTexture} texture - The WebGL texture that needs to be bound.
     * @param {integer} textureUnit - The texture unit to which the texture will be bound.
     * @param {boolean} [flush=true] - Will the current pipeline be flushed if this is a new texture, or not?
     *
     * @return {this} This WebGLRenderer instance.
     */setTexture2D:function(t,e,i){void 0===i&&(i=!0);var n=this.gl;return t!==this.currentTextures[e]&&(i&&this.flush(),this.currentActiveTextureUnit!==e&&(n.activeTexture(n.TEXTURE0+e),this.currentActiveTextureUnit=e),n.bindTexture(n.TEXTURE_2D,t),this.currentTextures[e]=t),this},/**
     * Binds a framebuffer. If there was another framebuffer already bound it will force a pipeline flush.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFramebuffer
     * @since 3.0.0
     *
     * @param {WebGLFramebuffer} framebuffer - The framebuffer that needs to be bound.
     * @param {boolean} [updateScissor=false] - If a framebuffer is given, set the gl scissor to match the frame buffer size? Or, if `null` given, pop the scissor from the stack.
     *
     * @return {this} This WebGLRenderer instance.
     */setFramebuffer:function(t,e){void 0===e&&(e=!1);var i=this.gl,n=this.width,s=this.height;return t!==this.currentFramebuffer&&(t&&t.renderTexture?(n=t.renderTexture.width,s=t.renderTexture.height):this.flush(),i.bindFramebuffer(i.FRAMEBUFFER,t),i.viewport(0,0,n,s),e&&(t?(this.drawingBufferHeight=s,this.pushScissor(0,0,n,s)):(this.drawingBufferHeight=this.height,this.popScissor())),this.currentFramebuffer=t),this},/**
     * Binds a program. If there was another program already bound it will force a pipeline flush.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setProgram
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The program that needs to be bound.
     *
     * @return {this} This WebGLRenderer instance.
     */setProgram:function(t){var e=this.gl;return t!==this.currentProgram&&(this.flush(),e.useProgram(t),this.currentProgram=t),this},/**
     * Bounds a vertex buffer. If there is a vertex buffer already bound it'll force a pipeline flush.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setVertexBuffer
     * @since 3.0.0
     *
     * @param {WebGLBuffer} vertexBuffer - The buffer that needs to be bound.
     *
     * @return {this} This WebGLRenderer instance.
     */setVertexBuffer:function(t){var e=this.gl;return t!==this.currentVertexBuffer&&(this.flush(),e.bindBuffer(e.ARRAY_BUFFER,t),this.currentVertexBuffer=t),this},/**
     * Bounds a index buffer. If there is a index buffer already bound it'll force a pipeline flush.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setIndexBuffer
     * @since 3.0.0
     *
     * @param {WebGLBuffer} indexBuffer - The buffer the needs to be bound.
     *
     * @return {this} This WebGLRenderer instance.
     */setIndexBuffer:function(t){var e=this.gl;return t!==this.currentIndexBuffer&&(this.flush(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),this.currentIndexBuffer=t),this},/**
     * Creates a texture from an image source. If the source is not valid it creates an empty texture.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#createTextureFromSource
     * @since 3.0.0
     *
     * @param {object} source - The source of the texture.
     * @param {integer} width - The width of the texture.
     * @param {integer} height - The height of the texture.
     * @param {integer} scaleMode - The scale mode to be used by the texture.
     *
     * @return {?WebGLTexture} The WebGL Texture that was created, or `null` if it couldn't be created.
     */createTextureFromSource:function(t,e,i,n){var s=this.gl,r=s.NEAREST,a=s.NEAREST,l=s.CLAMP_TO_EDGE,u=h(e=t?t.width:e,i=t?t.height:i);return u&&(l=s.REPEAT),n===o.ScaleModes.LINEAR&&this.config.antialias&&(r=u?this.mipmapFilter:s.LINEAR,a=s.LINEAR),t||"number"!=typeof e||"number"!=typeof i?this.createTexture2D(0,r,a,l,l,s.RGBA,t):this.createTexture2D(0,r,a,l,l,s.RGBA,null,e,i)},/**
     * A wrapper for creating a WebGLTexture. If no pixel data is passed it will create an empty texture.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#createTexture2D
     * @since 3.0.0
     *
     * @param {integer} mipLevel - Mip level of the texture.
     * @param {integer} minFilter - Filtering of the texture.
     * @param {integer} magFilter - Filtering of the texture.
     * @param {integer} wrapT - Wrapping mode of the texture.
     * @param {integer} wrapS - Wrapping mode of the texture.
     * @param {integer} format - Which format does the texture use.
     * @param {?object} pixels - pixel data.
     * @param {integer} width - Width of the texture in pixels.
     * @param {integer} height - Height of the texture in pixels.
     * @param {boolean} [pma=true] - Does the texture have premultiplied alpha?
     * @param {boolean} [forceSize=false] - If `true` it will use the width and height passed to this method, regardless of the pixels dimension.
     * @param {boolean} [flipY=false] - Sets the `UNPACK_FLIP_Y_WEBGL` flag the WebGL Texture uses during upload.
     *
     * @return {WebGLTexture} The WebGLTexture that was created.
     */createTexture2D:function(t,e,i,n,s,r,o,a,l,u,c,d){u=null==u||u,void 0===c&&(c=!1),void 0===d&&(d=!1);var f=this.gl,p=f.createTexture();return this.setTexture2D(p,0),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MIN_FILTER,e),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MAG_FILTER,i),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_S,s),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_T,n),f.pixelStorei(f.UNPACK_PREMULTIPLY_ALPHA_WEBGL,u),f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL,d),null==o?f.texImage2D(f.TEXTURE_2D,t,r,a,l,0,r,f.UNSIGNED_BYTE,null):(c||(a=o.width,l=o.height),f.texImage2D(f.TEXTURE_2D,t,r,r,f.UNSIGNED_BYTE,o)),h(a,l)&&f.generateMipmap(f.TEXTURE_2D),this.setTexture2D(null,0),p.isAlphaPremultiplied=u,p.isRenderTexture=!1,p.width=a,p.height=l,this.nativeTextures.push(p),p},/**
     * Wrapper for creating WebGLFramebuffer.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#createFramebuffer
     * @since 3.0.0
     *
     * @param {integer} width - Width in pixels of the framebuffer
     * @param {integer} height - Height in pixels of the framebuffer
     * @param {WebGLTexture} renderTexture - The color texture to where the color pixels are written
     * @param {boolean} addDepthStencilBuffer - Indicates if the current framebuffer support depth and stencil buffers
     *
     * @return {WebGLFramebuffer} Raw WebGLFramebuffer
     */createFramebuffer:function(t,e,i,n){var s=this.gl,r=s.createFramebuffer(),o=0;if(this.setFramebuffer(r),n){var a=s.createRenderbuffer();s.bindRenderbuffer(s.RENDERBUFFER,a),s.renderbufferStorage(s.RENDERBUFFER,s.DEPTH_STENCIL,t,e),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.DEPTH_STENCIL_ATTACHMENT,s.RENDERBUFFER,a)}if(i.isRenderTexture=!0,i.isAlphaPremultiplied=!1,s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,i,0),(o=s.checkFramebufferStatus(s.FRAMEBUFFER))!==s.FRAMEBUFFER_COMPLETE)throw Error("Framebuffer incomplete. Framebuffer status: "+({36054:"Incomplete Attachment",36055:"Missing Attachment",36057:"Incomplete Dimensions",36061:"Framebuffer Unsupported"})[o]);return r.renderTexture=i,this.setFramebuffer(null),r},/**
     * Wrapper for creating a WebGLProgram
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#createProgram
     * @since 3.0.0
     *
     * @param {string} vertexShader - Source to the vertex shader
     * @param {string} fragmentShader - Source to the fragment shader
     *
     * @return {WebGLProgram} Raw WebGLProgram
     */createProgram:function(t,e){var i=this.gl,n=i.createProgram(),s=i.createShader(i.VERTEX_SHADER),r=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(s,t),i.shaderSource(r,e),i.compileShader(s),i.compileShader(r),!i.getShaderParameter(s,i.COMPILE_STATUS))throw Error("Failed to compile Vertex Shader:\n"+i.getShaderInfoLog(s));if(!i.getShaderParameter(r,i.COMPILE_STATUS))throw Error("Failed to compile Fragment Shader:\n"+i.getShaderInfoLog(r));if(i.attachShader(n,s),i.attachShader(n,r),i.linkProgram(n),!i.getProgramParameter(n,i.LINK_STATUS))throw Error("Failed to link program:\n"+i.getProgramInfoLog(n));return n},/**
     * Wrapper for creating a vertex buffer.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#createVertexBuffer
     * @since 3.0.0
     *
     * @param {ArrayBuffer} initialDataOrSize - It's either ArrayBuffer or an integer indicating the size of the vbo
     * @param {integer} bufferUsage - How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW
     *
     * @return {WebGLBuffer} Raw vertex buffer
     */createVertexBuffer:function(t,e){var i=this.gl,n=i.createBuffer();return this.setVertexBuffer(n),i.bufferData(i.ARRAY_BUFFER,t,e),this.setVertexBuffer(null),n},/**
     * Wrapper for creating a vertex buffer.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#createIndexBuffer
     * @since 3.0.0
     *
     * @param {ArrayBuffer} initialDataOrSize - Either ArrayBuffer or an integer indicating the size of the vbo.
     * @param {integer} bufferUsage - How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW.
     *
     * @return {WebGLBuffer} Raw index buffer
     */createIndexBuffer:function(t,e){var i=this.gl,n=i.createBuffer();return this.setIndexBuffer(n),i.bufferData(i.ELEMENT_ARRAY_BUFFER,t,e),this.setIndexBuffer(null),n},/**
     * Removes the given texture from the nativeTextures array and then deletes it from the GPU.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteTexture
     * @since 3.0.0
     *
     * @param {WebGLTexture} texture - The WebGL Texture to be deleted.
     *
     * @return {this} This WebGLRenderer instance.
     */deleteTexture:function(t){var e=this.nativeTextures.indexOf(t);return -1!==e&&c(this.nativeTextures,e),this.gl.deleteTexture(t),this.currentTextures[0]!==t||this.game.pendingDestroy||this.setBlankTexture(!0),this},/**
     * Deletes a WebGLFramebuffer from the GL instance.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteFramebuffer
     * @since 3.0.0
     *
     * @param {WebGLFramebuffer} framebuffer - The Framebuffer to be deleted.
     *
     * @return {this} This WebGLRenderer instance.
     */deleteFramebuffer:function(t){return this.gl.deleteFramebuffer(t),this},/**
     * Deletes a WebGLProgram from the GL instance.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteProgram
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The shader program to be deleted.
     *
     * @return {this} This WebGLRenderer instance.
     */deleteProgram:function(t){return this.gl.deleteProgram(t),this},/**
     * Deletes a WebGLBuffer from the GL instance.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteBuffer
     * @since 3.0.0
     *
     * @param {WebGLBuffer} vertexBuffer - The WebGLBuffer to be deleted.
     *
     * @return {this} This WebGLRenderer instance.
     */deleteBuffer:function(t){return this.gl.deleteBuffer(t),this},/**
     * Controls the pre-render operations for the given camera.
     * Handles any clipping needed by the camera and renders the background color if a color is visible.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#preRenderCamera
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to pre-render.
     */preRenderCamera:function(t){var e=t._cx,i=t._cy,s=t._cw,r=t._ch,o=this.pipelines.TextureTintPipeline,a=t.backgroundColor;if(t.renderToTexture){this.flush(),this.pushScissor(e,i,s,-r),this.setFramebuffer(t.framebuffer);var h=this.gl;h.clearColor(0,0,0,0),h.clear(h.COLOR_BUFFER_BIT),o.projOrtho(e,s+e,i,r+i,-1e3,1e3),t.mask&&(this.currentCameraMask.mask=t.mask,this.currentCameraMask.camera=t._maskCamera,t.mask.preRenderWebGL(this,t,t._maskCamera)),a.alphaGL>0&&o.drawFillRect(e,i,s+e,r+i,p.getTintFromFloats(a.redGL,a.greenGL,a.blueGL,1),a.alphaGL),t.emit(n.PRE_RENDER,t)}else this.pushScissor(e,i,s,r),t.mask&&(this.currentCameraMask.mask=t.mask,this.currentCameraMask.camera=t._maskCamera,t.mask.preRenderWebGL(this,t,t._maskCamera)),a.alphaGL>0&&o.drawFillRect(e,i,s,r,p.getTintFromFloats(a.redGL,a.greenGL,a.blueGL,1),a.alphaGL)},getCurrentStencilMask:function(){var t=null,e=this.maskStack,i=this.currentCameraMask;return e.length>0?t=e[e.length-1]:i.mask&&i.mask.isStencil&&(t=i),t},/**
     * Controls the post-render operations for the given camera.
     * Renders the foreground camera effects like flash and fading. It resets the current scissor state.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#postRenderCamera
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to post-render.
     */postRenderCamera:function(t){this.setPipeline(this.pipelines.TextureTintPipeline);var e=this.pipelines.TextureTintPipeline;if(t.flashEffect.postRenderWebGL(e,p.getTintFromFloats),t.fadeEffect.postRenderWebGL(e,p.getTintFromFloats),t.dirty=!1,this.popScissor(),t.renderToTexture){if(e.flush(),this.setFramebuffer(null),t.emit(n.POST_RENDER,t),t.renderToGame){e.projOrtho(0,e.width,e.height,0,-1e3,1e3);var i=p.getTintAppendFloatAlpha;(t.pipeline?t.pipeline:e).batchTexture(t,t.glTexture,t.width,t.height,t.x,t.y,t.width,t.height,t.zoom,t.zoom,t.rotation,t.flipX,!t.flipY,1,1,0,0,0,0,t.width,t.height,i(t._tintTL,t._alphaTL),i(t._tintTR,t._alphaTR),i(t._tintBL,t._alphaBL),i(t._tintBR,t._alphaBR),t._isTinted&&t.tintFill,0,0,this.defaultCamera,null)}//  Force clear the current texture so that items next in the batch (like Graphics) don't try and use it
this.setBlankTexture(!0)}t.mask&&(this.currentCameraMask.mask=null,t.mask.postRenderWebGL(this,t._maskCamera))},/**
     * Clears the current vertex buffer and updates pipelines.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#preRender
     * @since 3.0.0
     */preRender:function(){if(!this.contextLost){var t=this.gl,e=this.pipelines;if(//  Make sure we are bound to the main frame buffer
t.bindFramebuffer(t.FRAMEBUFFER,null),this.config.clearBeforeRender){var i=this.config.backgroundColor;t.clearColor(i.redGL,i.greenGL,i.blueGL,i.alphaGL),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT|t.STENCIL_BUFFER_BIT)}for(var n in t.enable(t.SCISSOR_TEST),e)e[n].onPreRender();//  TODO - Find a way to stop needing to create these arrays every frame
//  and equally not need a huge array buffer created to hold them
this.currentScissor=[0,0,this.width,this.height],this.scissorStack=[this.currentScissor],this.game.scene.customViewports&&t.scissor(0,this.drawingBufferHeight-this.height,this.width,this.height),this.currentMask.mask=null,this.currentCameraMask.mask=null,this.maskStack.length=0,this.setPipeline(this.pipelines.TextureTintPipeline)}},/**
     * The core render step for a Scene Camera.
     * 
     * Iterates through the given Game Object's array and renders them with the given Camera.
     * 
     * This is called by the `CameraManager.render` method. The Camera Manager instance belongs to a Scene, and is invoked
     * by the Scene Systems.render method.
     * 
     * This method is not called if `Camera.visible` is `false`, or `Camera.alpha` is zero.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#render
     * @since 3.0.0
     *
     * @param {Phaser.Scene} scene - The Scene to render.
     * @param {Phaser.GameObjects.GameObject} children - The Game Object's within the Scene to be rendered.
     * @param {number} interpolationPercentage - The interpolation percentage to apply. Currently un-used.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera to render with.
     */render:function(t,e,i,n){if(!this.contextLost){var s=e.list,r=s.length,a=this.pipelines;for(var h in a)a[h].onRender(t,n);//  Nothing to render, so bail out
if(//   Apply scissor for cam region + render background color, if not transparent
this.preRenderCamera(n),0===r){this.setBlendMode(o.BlendModes.NORMAL),//  Applies camera effects and pops the scissor, if set
this.postRenderCamera(n);return}//  Reset the current type
this.currentType="";for(var l=this.currentMask,u=0;u<r;u++){var c=s[u];if(c.willRender(n)){c.blendMode!==this.currentBlendMode&&this.setBlendMode(c.blendMode);var d=c.mask;(l=this.currentMask).mask&&l.mask!==d&&l.mask.postRenderWebGL(this,l.camera),d&&l.mask!==d&&d.preRenderWebGL(this,c,n);var f=c.type;f!==this.currentType&&(this.newType=!0,this.currentType=f),this.nextTypeMatch=u<r-1&&s[u+1].type===this.currentType,c.renderWebGL(this,c,i,n),this.newType=!1}}(l=this.currentMask).mask&&l.mask.postRenderWebGL(this,l.camera),this.setBlendMode(o.BlendModes.NORMAL),//  Applies camera effects and pops the scissor, if set
this.postRenderCamera(n)}},/**
     * The post-render step happens after all Cameras in all Scenes have been rendered.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#postRender
     * @since 3.0.0
     */postRender:function(){if(!this.contextLost){this.flush();// Unbind custom framebuffer here
var t=this.snapshotState;t.callback&&(g(this.canvas,t),t.callback=null);var e=this.pipelines;for(var i in e)e[i].onPostRender()}},/**
     * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.
     * 
     * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.
     * 
     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then
     * calling this method will override it.
     * 
     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.
     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,
     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,
     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshot
     * @since 3.0.0
     *
     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.
     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.
     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.
     *
     * @return {this} This WebGL Renderer.
     */snapshot:function(t,e,i){return this.snapshotArea(0,0,this.gl.drawingBufferWidth,this.gl.drawingBufferHeight,t,e,i)},/**
     * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.
     * 
     * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.
     * 
     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then
     * calling this method will override it.
     * 
     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.
     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,
     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,
     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotArea
     * @since 3.16.0
     *
     * @param {integer} x - The x coordinate to grab from.
     * @param {integer} y - The y coordinate to grab from.
     * @param {integer} width - The width of the area to grab.
     * @param {integer} height - The height of the area to grab.
     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.
     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.
     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.
     *
     * @return {this} This WebGL Renderer.
     */snapshotArea:function(t,e,i,n,s,r,o){var a=this.snapshotState;return a.callback=s,a.type=r,a.encoder=o,a.getPixel=!1,a.x=t,a.y=e,a.width=Math.min(i,this.gl.drawingBufferWidth),a.height=Math.min(n,this.gl.drawingBufferHeight),this},/**
     * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.
     * 
     * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.
     * 
     * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then
     * calling this method will override it.
     * 
     * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for
     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,
     * using less memory.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotPixel
     * @since 3.16.0
     *
     * @param {integer} x - The x coordinate of the pixel to get.
     * @param {integer} y - The y coordinate of the pixel to get.
     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.
     *
     * @return {this} This WebGL Renderer.
     */snapshotPixel:function(t,e,i){return this.snapshotArea(t,e,1,1,i),this.snapshotState.getPixel=!0,this},/**
     * Takes a snapshot of the given area of the given frame buffer.
     * 
     * Unlike the other snapshot methods, this one is processed immediately and doesn't wait for the next render.
     * 
     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.
     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,
     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,
     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotFramebuffer
     * @since 3.19.0
     *
     * @param {WebGLFramebuffer} framebuffer - The framebuffer to grab from.
     * @param {integer} bufferWidth - The width of the framebuffer.
     * @param {integer} bufferHeight - The height of the framebuffer.
     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.
     * @param {boolean} [getPixel=false] - Grab a single pixel as a Color object, or an area as an Image object?
     * @param {integer} [x=0] - The x coordinate to grab from.
     * @param {integer} [y=0] - The y coordinate to grab from.
     * @param {integer} [width=bufferWidth] - The width of the area to grab.
     * @param {integer} [height=bufferHeight] - The height of the area to grab.
     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.
     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.
     *
     * @return {this} This WebGL Renderer.
     */snapshotFramebuffer:function(t,e,i,n,s,r,o,a,h,l,u){void 0===s&&(s=!1),void 0===r&&(r=0),void 0===o&&(o=0),void 0===a&&(a=e),void 0===h&&(h=i);var c=this.currentFramebuffer;this.snapshotArea(r,o,a,h,n,l,u);var d=this.snapshotState;return d.getPixel=s,d.isFramebuffer=!0,d.bufferWidth=e,d.bufferHeight=i,this.setFramebuffer(t),g(this.canvas,d),this.setFramebuffer(c),d.callback=null,d.isFramebuffer=!1,this},/**
     * Creates a new WebGL Texture based on the given Canvas Element.
     * 
     * If the `dstTexture` parameter is given, the WebGL Texture is updated, rather than created fresh.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#canvasToTexture
     * @since 3.0.0
     * 
     * @param {HTMLCanvasElement} srcCanvas - The Canvas to create the WebGL Texture from
     * @param {WebGLTexture} [dstTexture] - The destination WebGL Texture to set.
     * @param {boolean} [noRepeat=false] - Should this canvas be allowed to set `REPEAT` (such as for Text objects?)
     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?
     * 
     * @return {WebGLTexture} The newly created, or updated, WebGL Texture.
     */canvasToTexture:function(t,e,i,n){return(void 0===i&&(i=!1),void 0===n&&(n=!1),e)?this.updateCanvasTexture(t,e,n):this.createCanvasTexture(t,i,n)},/**
     * Creates a new WebGL Texture based on the given Canvas Element.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#createCanvasTexture
     * @since 3.20.0
     * 
     * @param {HTMLCanvasElement} srcCanvas - The Canvas to create the WebGL Texture from
     * @param {boolean} [noRepeat=false] - Should this canvas be allowed to set `REPEAT` (such as for Text objects?)
     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?
     * 
     * @return {WebGLTexture} The newly created WebGL Texture.
     */createCanvasTexture:function(t,e,i){void 0===e&&(e=!1),void 0===i&&(i=!1);var n=this.gl,s=n.NEAREST,r=n.NEAREST,o=t.width,a=t.height,l=n.CLAMP_TO_EDGE,u=h(o,a);return!e&&u&&(l=n.REPEAT),this.config.antialias&&(s=u?this.mipmapFilter:n.LINEAR,r=n.LINEAR),this.createTexture2D(0,s,r,l,l,n.RGBA,t,o,a,!0,!1,i)},/**
     * Updates a WebGL Texture based on the given Canvas Element.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#updateCanvasTexture
     * @since 3.20.0
     * 
     * @param {HTMLCanvasElement} srcCanvas - The Canvas to update the WebGL Texture from.
     * @param {WebGLTexture} dstTexture - The destination WebGL Texture to update.
     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?
     * 
     * @return {WebGLTexture} The updated WebGL Texture.
     */updateCanvasTexture:function(t,e,i){void 0===i&&(i=!1);var n=this.gl,s=t.width,r=t.height;return s>0&&r>0&&(this.setTexture2D(e,0),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,i),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t),e.width=s,e.height=r,this.setTexture2D(null,0)),e},/**
     * Creates a new WebGL Texture based on the given HTML Video Element.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#createVideoTexture
     * @since 3.20.0
     * 
     * @param {HTMLVideoElement} srcVideo - The Video to create the WebGL Texture from
     * @param {boolean} [noRepeat=false] - Should this canvas be allowed to set `REPEAT`?
     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?
     * 
     * @return {WebGLTexture} The newly created WebGL Texture.
     */createVideoTexture:function(t,e,i){void 0===e&&(e=!1),void 0===i&&(i=!1);var n=this.gl,s=n.NEAREST,r=n.NEAREST,o=t.videoWidth,a=t.videoHeight,l=n.CLAMP_TO_EDGE,u=h(o,a);return!e&&u&&(l=n.REPEAT),this.config.antialias&&(s=u?this.mipmapFilter:n.LINEAR,r=n.LINEAR),this.createTexture2D(0,s,r,l,l,n.RGBA,t,o,a,!0,!0,i)},/**
     * Updates a WebGL Texture based on the given HTML Video Element.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#updateVideoTexture
     * @since 3.20.0
     * 
     * @param {HTMLVideoElement} srcVideo - The Video to update the WebGL Texture with.
     * @param {WebGLTexture} dstTexture - The destination WebGL Texture to update.
     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?
     * 
     * @return {WebGLTexture} The updated WebGL Texture.
     */updateVideoTexture:function(t,e,i){void 0===i&&(i=!1);var n=this.gl,s=t.videoWidth,r=t.videoHeight;return s>0&&r>0&&(this.setTexture2D(e,0),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,i),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t),e.width=s,e.height=r,this.setTexture2D(null,0)),e},/**
     * Sets the minification and magnification filter for a texture.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setTextureFilter
     * @since 3.0.0
     *
     * @param {integer} texture - The texture to set the filter for.
     * @param {integer} filter - The filter to set. 0 for linear filtering, 1 for nearest neighbor (blocky) filtering.
     *
     * @return {this} This WebGL Renderer instance.
     */setTextureFilter:function(t,e){var i=this.gl,n=[i.LINEAR,i.NEAREST][e];return this.setTexture2D(t,0),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,n),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,n),this.setTexture2D(null,0),this},/**
     * Sets a 1f uniform value on the given shader.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat1
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {number} x - The 1f value to set on the named uniform.
     *
     * @return {this} This WebGL Renderer instance.
     */setFloat1:function(t,e,i){return this.setProgram(t),this.gl.uniform1f(this.gl.getUniformLocation(t,e),i),this},/**
     * Sets the 2f uniform values on the given shader.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat2
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {number} x - The 2f x value to set on the named uniform.
     * @param {number} y - The 2f y value to set on the named uniform.
     *
     * @return {this} This WebGL Renderer instance.
     */setFloat2:function(t,e,i,n){return this.setProgram(t),this.gl.uniform2f(this.gl.getUniformLocation(t,e),i,n),this},/**
     * Sets the 3f uniform values on the given shader.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat3
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {number} x - The 3f x value to set on the named uniform.
     * @param {number} y - The 3f y value to set on the named uniform.
     * @param {number} z - The 3f z value to set on the named uniform.
     *
     * @return {this} This WebGL Renderer instance.
     */setFloat3:function(t,e,i,n,s){return this.setProgram(t),this.gl.uniform3f(this.gl.getUniformLocation(t,e),i,n,s),this},/**
     * Sets the 4f uniform values on the given shader.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat4
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {number} x - The 4f x value to set on the named uniform.
     * @param {number} y - The 4f y value to set on the named uniform.
     * @param {number} z - The 4f z value to set on the named uniform.
     * @param {number} w - The 4f w value to set on the named uniform.
     *
     * @return {this} This WebGL Renderer instance.
     */setFloat4:function(t,e,i,n,s,r){return this.setProgram(t),this.gl.uniform4f(this.gl.getUniformLocation(t,e),i,n,s,r),this},/**
     * Sets the value of a 1fv uniform variable in the given WebGLProgram.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat1v
     * @since 3.13.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {Float32Array} arr - The new value to be used for the uniform variable.
     *
     * @return {this} This WebGL Renderer instance.
     */setFloat1v:function(t,e,i){return this.setProgram(t),this.gl.uniform1fv(this.gl.getUniformLocation(t,e),i),this},/**
     * Sets the value of a 2fv uniform variable in the given WebGLProgram.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat2v
     * @since 3.13.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {Float32Array} arr - The new value to be used for the uniform variable.
     *
     * @return {this} This WebGL Renderer instance.
     */setFloat2v:function(t,e,i){return this.setProgram(t),this.gl.uniform2fv(this.gl.getUniformLocation(t,e),i),this},/**
     * Sets the value of a 3fv uniform variable in the given WebGLProgram.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat3v
     * @since 3.13.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {Float32Array} arr - The new value to be used for the uniform variable.
     *
     * @return {this} This WebGL Renderer instance.
     */setFloat3v:function(t,e,i){return this.setProgram(t),this.gl.uniform3fv(this.gl.getUniformLocation(t,e),i),this},/**
     * Sets the value of a 4fv uniform variable in the given WebGLProgram.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat4v
     * @since 3.13.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {Float32Array} arr - The new value to be used for the uniform variable.
     *
     * @return {this} This WebGL Renderer instance.
     */setFloat4v:function(t,e,i){return this.setProgram(t),this.gl.uniform4fv(this.gl.getUniformLocation(t,e),i),this},/**
     * Sets a 1i uniform value on the given shader.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt1
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {integer} x - The 1i value to set on the named uniform.
     *
     * @return {this} This WebGL Renderer instance.
     */setInt1:function(t,e,i){return this.setProgram(t),this.gl.uniform1i(this.gl.getUniformLocation(t,e),i),this},/**
     * Sets the 2i uniform values on the given shader.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt2
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {integer} x - The 2i x value to set on the named uniform.
     * @param {integer} y - The 2i y value to set on the named uniform.
     *
     * @return {this} This WebGL Renderer instance.
     */setInt2:function(t,e,i,n){return this.setProgram(t),this.gl.uniform2i(this.gl.getUniformLocation(t,e),i,n),this},/**
     * Sets the 3i uniform values on the given shader.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt3
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {integer} x - The 3i x value to set on the named uniform.
     * @param {integer} y - The 3i y value to set on the named uniform.
     * @param {integer} z - The 3i z value to set on the named uniform.
     *
     * @return {this} This WebGL Renderer instance.
     */setInt3:function(t,e,i,n,s){return this.setProgram(t),this.gl.uniform3i(this.gl.getUniformLocation(t,e),i,n,s),this},/**
     * Sets the 4i uniform values on the given shader.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt4
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {integer} x - The 4i x value to set on the named uniform.
     * @param {integer} y - The 4i y value to set on the named uniform.
     * @param {integer} z - The 4i z value to set on the named uniform.
     * @param {integer} w - The 4i w value to set on the named uniform.
     *
     * @return {this} This WebGL Renderer instance.
     */setInt4:function(t,e,i,n,s,r){return this.setProgram(t),this.gl.uniform4i(this.gl.getUniformLocation(t,e),i,n,s,r),this},/**
     * Sets the value of a matrix 2fv uniform variable in the given WebGLProgram.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix2
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {boolean} transpose - The value indicating whether to transpose the matrix. Must be false.
     * @param {Float32Array} matrix - A Float32Array or sequence of 4 float values.
     *
     * @return {this} This WebGL Renderer instance.
     */setMatrix2:function(t,e,i,n){return this.setProgram(t),this.gl.uniformMatrix2fv(this.gl.getUniformLocation(t,e),i,n),this},/**
     * Sets the value of a matrix 3fv uniform variable in the given WebGLProgram.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix3
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {boolean} transpose - The value indicating whether to transpose the matrix. Must be false.
     * @param {Float32Array} matrix - A Float32Array or sequence of 9 float values.
     *
     * @return {this} This WebGL Renderer instance.
     */setMatrix3:function(t,e,i,n){return this.setProgram(t),this.gl.uniformMatrix3fv(this.gl.getUniformLocation(t,e),i,n),this},/**
     * Sets the value of a matrix 4fv uniform variable in the given WebGLProgram.
     * 
     * If the shader is not currently active, it is made active first.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix4
     * @since 3.0.0
     *
     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {boolean} transpose - The value indicating whether to transpose the matrix. Must be false.
     * @param {Float32Array} matrix - A Float32Array or sequence of 16 float values.
     *
     * @return {this} This WebGL Renderer instance.
     */setMatrix4:function(t,e,i,n){return this.setProgram(t),this.gl.uniformMatrix4fv(this.gl.getUniformLocation(t,e),i,n),this},/**
     * Returns the maximum number of texture units that can be used in a fragment shader.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#getMaxTextures
     * @since 3.8.0
     *
     * @return {integer} The maximum number of textures WebGL supports.
     */getMaxTextures:function(){return this.config.maxTextures},/**
     * Returns the largest texture size (either width or height) that can be created.
     * Note that VRAM may not allow a texture of any given size, it just expresses
     * hardware / driver support for a given size.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#getMaxTextureSize
     * @since 3.8.0
     *
     * @return {integer} The maximum supported texture size.
     */getMaxTextureSize:function(){return this.config.maxTextureSize},/**
     * Destroy this WebGLRenderer, cleaning up all related resources such as pipelines, native textures, etc.
     *
     * @method Phaser.Renderer.WebGL.WebGLRenderer#destroy
     * @since 3.0.0
     */destroy:function(){//  Clear-up anything that should be cleared :)
for(var t=0;t<this.nativeTextures.length;t++)this.gl.deleteTexture(this.nativeTextures[t]);for(var e in this.nativeTextures=[],this.pipelines)this.pipelines[e].destroy(),delete this.pipelines[e];this.defaultCamera.destroy(),this.currentMask=null,this.currentCameraMask=null,this.canvas.removeEventListener("webglcontextlost",this.contextLostHandler,!1),this.canvas.removeEventListener("webglcontextrestored",this.contextRestoredHandler,!1),this.game=null,this.gl=null,this.canvas=null,this.maskStack=[],this.contextLost=!0,this.extensions={}}});t.exports=w}),r("eOqX8",function(t,e){t.exports=function(t,e){if(!(e>=t.length)){for(var i=t.length-1,n=t[e],s=e;s<i;s++)t[s]=t[s+1];return t.length=i,n}}}),r("6R4Pe",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Textures.Events
 */t.exports={ADD:s("fmgmG"),ERROR:s("eCT2W"),LOAD:s("djPoi"),READY:s("hlb1j"),REMOVE:s("a6nZA")}}),r("fmgmG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Texture Add Event.
 * 
 * This event is dispatched by the Texture Manager when a texture is added to it.
 * 
 * Listen to this event from within a Scene using: `this.textures.on('addtexture', listener)`.
 *
 * @event Phaser.Textures.Events#ADD
 * @since 3.0.0
 * 
 * @param {string} key - The key of the Texture that was added to the Texture Manager.
 * @param {Phaser.Textures.Texture} texture - A reference to the Texture that was added to the Texture Manager.
 */t.exports="addtexture"}),r("eCT2W",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Texture Load Error Event.
 * 
 * This event is dispatched by the Texture Manager when a texture it requested to load failed.
 * This only happens when base64 encoded textures fail. All other texture types are loaded via the Loader Plugin.
 * 
 * Listen to this event from within a Scene using: `this.textures.on('onerror', listener)`.
 *
 * @event Phaser.Textures.Events#ERROR
 * @since 3.0.0
 * 
 * @param {string} key - The key of the Texture that failed to load into the Texture Manager.
 */t.exports="onerror"}),r("djPoi",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Texture Load Event.
 * 
 * This event is dispatched by the Texture Manager when a texture has finished loading on it.
 * This only happens for base64 encoded textures. All other texture types are loaded via the Loader Plugin.
 * 
 * Listen to this event from within a Scene using: `this.textures.on('onload', listener)`.
 * 
 * This event is dispatched after the [ADD]{@linkcode Phaser.Textures.Events#event:ADD} event.
 *
 * @event Phaser.Textures.Events#LOAD
 * @since 3.0.0
 * 
 * @param {string} key - The key of the Texture that was loaded by the Texture Manager.
 * @param {Phaser.Textures.Texture} texture - A reference to the Texture that was loaded by the Texture Manager.
 */t.exports="onload"}),r("hlb1j",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * This internal event signifies that the Texture Manager is now ready and the Game can continue booting.
 * 
 * When a Phaser Game instance is booting for the first time, the Texture Manager has to wait on a couple of non-blocking
 * async events before it's fully ready to carry on. When those complete the Texture Manager emits this event via the Game
 * instance, which tells the Game to carry on booting.
 *
 * @event Phaser.Textures.Events#READY
 * @since 3.16.1
 */t.exports="ready"}),r("a6nZA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Texture Remove Event.
 * 
 * This event is dispatched by the Texture Manager when a texture is removed from it.
 * 
 * Listen to this event from within a Scene using: `this.textures.on('removetexture', listener)`.
 * 
 * If you have any Game Objects still using the removed texture, they will start throwing
 * errors the next time they try to render. Be sure to clear all use of the texture in this event handler.
 *
 * @event Phaser.Textures.Events#REMOVE
 * @since 3.0.0
 * 
 * @param {string} key - The key of the Texture that was removed from the Texture Manager.
 */t.exports="removetexture"}),r("gaO4e",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Renderer.WebGL.Utils
 * @since 3.0.0
 */t.exports={/**
     * Packs four floats on a range from 0.0 to 1.0 into a single Uint32
     *
     * @function Phaser.Renderer.WebGL.Utils.getTintFromFloats
     * @since 3.0.0
     * 
     * @param {number} r - Red component in a range from 0.0 to 1.0 
     * @param {number} g - Green component in a range from 0.0 to 1.0
     * @param {number} b - Blue component in a range from 0.0 to 1.0
     * @param {number} a - Alpha component in a range from 0.0 to 1.0
     * 
     * @return {number} The packed RGBA values as a Uint32.
     */getTintFromFloats:function(t,e,i,n){return(((255*n|0)&255)<<24|((255*t|0)&255)<<16|((255*e|0)&255)<<8|(255*i|0)&255)>>>0},/**
     * Packs a Uint24, representing RGB components, with a Float32, representing
     * the alpha component, with a range between 0.0 and 1.0 and return a Uint32
     *
     * @function Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha
     * @since 3.0.0
     * 
     * @param {number} rgb - Uint24 representing RGB components
     * @param {number} a - Float32 representing Alpha component
     * 
     * @return {number} Packed RGBA as Uint32
     */getTintAppendFloatAlpha:function(t,e){return(((255*e|0)&255)<<24|t)>>>0},/**
     * Packs a Uint24, representing RGB components, with a Float32, representing
     * the alpha component, with a range between 0.0 and 1.0 and return a 
     * swizzled Uint32
     *
     * @function Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlphaAndSwap
     * @since 3.0.0
     * 
     * @param {number} rgb - Uint24 representing RGB components
     * @param {number} a - Float32 representing Alpha component
     * 
     * @return {number} Packed RGBA as Uint32
     */getTintAppendFloatAlphaAndSwap:function(t,e){return(((255*e|0)&255)<<24|((0|t)&255)<<16|((t>>8|0)&255)<<8|(t>>16|0)&255)>>>0},/**
     * Unpacks a Uint24 RGB into an array of floats of ranges of 0.0 and 1.0
     *
     * @function Phaser.Renderer.WebGL.Utils.getFloatsFromUintRGB
     * @since 3.0.0
     * 
     * @param {number} rgb - RGB packed as a Uint24
     * 
     * @return {array} Array of floats representing each component as a float 
     */getFloatsFromUintRGB:function(t){return[((t>>16|0)&255)/255,((t>>8|0)&255)/255,((0|t)&255)/255]},/**
     * Counts how many attributes of 32 bits a vertex has
     *
     * @function Phaser.Renderer.WebGL.Utils.getComponentCount
     * @since 3.0.0
     * 
     * @param {array} attributes - Array of attributes 
     * @param {WebGLRenderingContext} glContext - WebGLContext used for check types
     * 
     * @return {number} Count of 32 bit attributes in vertex
     */getComponentCount:function(t,e){for(var i=0,n=0;n<t.length;++n){var s=t[n];s.type===e.FLOAT?i+=s.size:i+=1;// We'll force any other type to be 32 bit. for now
}return i}}}),r("65D27",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kKoer"),n=s("pqNJR"),r=s("7BSWl");t.exports=function(t,e){var s=t.getContext("experimental-webgl"),o=r(e,"callback"),a=r(e,"type","image/png"),h=r(e,"encoder",.92),l=r(e,"x",0),u=r(e,"y",0),c=r(e,"getPixel",!1),d=r(e,"isFramebuffer",!1),f=d?r(e,"bufferWidth",1):s.drawingBufferWidth,p=d?r(e,"bufferHeight",1):s.drawingBufferHeight;if(c){var g=new Uint8Array(4),v=d?u:p-u;s.readPixels(l,v,1,1,s.RGBA,s.UNSIGNED_BYTE,g),o.call(null,new n(g[0],g[1],g[2],g[3]/255))}else{var m=r(e,"width",f),y=r(e,"height",p),x=m*y*4,w=new Uint8Array(x);s.readPixels(l,p-u-y,m,y,s.RGBA,s.UNSIGNED_BYTE,w);for(var T=i.createWebGL(this,m,y),b=T.getContext("2d"),S=b.getImageData(0,0,m,y),A=S.data,E=0;E<y;E++)for(var _=0;_<m;_++){var C=((y-E)*m+_)*4,M=d?x-(E*m+(m-_))*4:(E*m+_)*4;A[M+0]=w[C+0],A[M+1]=w[C+1],A[M+2]=w[C+2],A[M+3]=w[C+3]}b.putImageData(S,0,0);var P=new Image;P.onerror=function(){o.call(null),i.remove(T)},P.onload=function(){o.call(null,P),i.remove(T)},P.src=T.toDataURL(a,h)}}}),r("84zIv",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("X6csy"),r=s("66wRu"),o=s("AbdBB"),a=new i({Extends:o,initialize:function(t){o.call(this,{game:t.game,renderer:t.renderer,gl:t.renderer.gl,topology:t.topology?t.topology:t.renderer.gl.TRIANGLES,vertShader:t.vertShader?t.vertShader:r,fragShader:t.fragShader?t.fragShader:n,vertexCapacity:t.vertexCapacity?t.vertexCapacity:3,vertexSize:t.vertexSize?t.vertexSize:2*Float32Array.BYTES_PER_ELEMENT,vertices:new Float32Array([-1,1,-1,-7,7,1]).buffer,attributes:[{name:"inPosition",size:2,type:t.renderer.gl.FLOAT,normalized:!1,offset:0}]}),/**
         * Float32 view of the array buffer containing the pipeline's vertices.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#vertexViewF32
         * @type {Float32Array}
         * @since 3.0.0
         */this.vertexViewF32=new Float32Array(this.vertexData),/**
         * Size of the batch.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#maxQuads
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.maxQuads=1,/**
         * Dirty flag to check if resolution properties need to be updated on the 
         * masking shader.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#resolutionDirty
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.resolutionDirty=!0},/**
     * Called every time the pipeline needs to be used.
     * It binds all necessary resources.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#onBind
     * @since 3.0.0
     *
     * @return {this} This WebGLPipeline instance.
     */onBind:function(){o.prototype.onBind.call(this);var t=this.renderer,e=this.program;return this.resolutionDirty&&(t.setFloat2(e,"uResolution",this.width,this.height),t.setInt1(e,"uMainSampler",0),t.setInt1(e,"uMaskSampler",1),this.resolutionDirty=!1),this},/**
     * Resizes this pipeline and updates the projection.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#resize
     * @since 3.0.0
     *
     * @param {number} width - The new width.
     * @param {number} height - The new height.
     * @param {number} resolution - The resolution.
     *
     * @return {this} This WebGLPipeline instance.
     */resize:function(t,e,i){return o.prototype.resize.call(this,t,e,i),this.resolutionDirty=!0,this},/**
     * Binds necessary resources and renders the mask to a separated framebuffer.
     * The framebuffer for the masked object is also bound for further use.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#beginMask
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} mask - GameObject used as mask.
     * @param {Phaser.GameObjects.GameObject} maskedObject - GameObject masked by the mask GameObject.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera rendering the current mask.
     */beginMask:function(t,e,i){var n=this.renderer,s=this.gl;t.bitmapMask&&s&&(n.flush(),t.prevFramebuffer=n.currentFramebuffer,n.setFramebuffer(t.mainFramebuffer),s.disable(s.STENCIL_TEST),s.clearColor(0,0,0,0),s.clear(s.COLOR_BUFFER_BIT),n.currentCameraMask.mask!==t&&(n.currentMask.mask=t,n.currentMask.camera=i))},/**
     * The masked game objects framebuffer is unbound and its texture 
     * is bound together with the mask texture and the mask shader and 
     * a draw call with a single quad is processed. Here is where the
     * masking effect is applied.  
     *
     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#endMask
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} mask - GameObject used as a mask.
     */endMask:function(t,e){var i=this.gl,n=this.renderer,s=t.bitmapMask;if(s&&i){n.flush(),//  First we draw the mask to the mask fb
n.setFramebuffer(t.maskFramebuffer),i.clearColor(0,0,0,0),i.clear(i.COLOR_BUFFER_BIT),n.setBlendMode(0,!0),s.renderWebGL(n,s,0,e),n.flush(),n.setFramebuffer(t.prevFramebuffer);//  Is there a stencil further up the stack?
var r=n.getCurrentStencilMask();r?(i.enable(i.STENCIL_TEST),r.mask.applyStencil(n,r.camera,!0)):n.currentMask.mask=null,//  Bind bitmap mask pipeline and draw
n.setPipeline(this),i.activeTexture(i.TEXTURE1),i.bindTexture(i.TEXTURE_2D,t.maskTexture),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,t.mainTexture),i.uniform1i(i.getUniformLocation(this.program,"uInvertMaskAlpha"),t.invertAlpha),//  Finally, draw a triangle filling the whole screen
i.drawArrays(this.topology,0,3)}}});t.exports=a}),r("X6csy",function(t,e){t.exports="#define SHADER_NAME PHASER_BITMAP_MASK_FS\n\nprecision mediump float;\n\nuniform vec2 uResolution;\nuniform sampler2D uMainSampler;\nuniform sampler2D uMaskSampler;\nuniform bool uInvertMaskAlpha;\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / uResolution;\n    vec4 mainColor = texture2D(uMainSampler, uv);\n    vec4 maskColor = texture2D(uMaskSampler, uv);\n    float alpha = mainColor.a;\n\n    if (!uInvertMaskAlpha)\n    {\n        alpha *= (maskColor.a);\n    }\n    else\n    {\n        alpha *= (1.0 - maskColor.a);\n    }\n\n    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);\n}\n"}),r("66wRu",function(t,e){t.exports="#define SHADER_NAME PHASER_BITMAP_MASK_VS\n\nprecision mediump float;\n\nattribute vec2 inPosition;\n\nvoid main()\n{\n    gl_Position = vec4(inPosition, 0.0, 1.0);\n}\n"}),r("AbdBB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("gaO4e"),r=new i({initialize:function(t){/**
         * Name of the Pipeline. Used for identifying
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#name
         * @type {string}
         * @since 3.0.0
         */this.name="WebGLPipeline",/**
         * The Game which owns this WebGL Pipeline.
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#game
         * @type {Phaser.Game}
         * @since 3.0.0
         */this.game=t.game,/**
         * The canvas which this WebGL Pipeline renders to.
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#view
         * @type {HTMLCanvasElement}
         * @since 3.0.0
         */this.view=t.game.canvas,/**
         * Used to store the current game resolution
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#resolution
         * @type {number}
         * @since 3.0.0
         */this.resolution=1,/**
         * Width of the current viewport
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#width
         * @type {number}
         * @since 3.0.0
         */this.width=0,/**
         * Height of the current viewport
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#height
         * @type {number}
         * @since 3.0.0
         */this.height=0,/**
         * The WebGL context this WebGL Pipeline uses.
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#gl
         * @type {WebGLRenderingContext}
         * @since 3.0.0
         */this.gl=t.gl,/**
         * How many vertices have been fed to the current pipeline.
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexCount
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.vertexCount=0,/**
         * The limit of vertices that the pipeline can hold
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexCapacity
         * @type {integer}
         * @since 3.0.0
         */this.vertexCapacity=t.vertexCapacity,/**
         * The WebGL Renderer which owns this WebGL Pipeline.
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#renderer
         * @type {Phaser.Renderer.WebGL.WebGLRenderer}
         * @since 3.0.0
         */this.renderer=t.renderer,/**
         * Raw byte buffer of vertices.
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexData
         * @type {ArrayBuffer}
         * @since 3.0.0
         */this.vertexData=t.vertices?t.vertices:new ArrayBuffer(t.vertexCapacity*t.vertexSize),/**
         * The handle to a WebGL vertex buffer object.
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexBuffer
         * @type {WebGLBuffer}
         * @since 3.0.0
         */this.vertexBuffer=this.renderer.createVertexBuffer(t.vertices?t.vertices:this.vertexData.byteLength,this.gl.STREAM_DRAW),/**
         * The handle to a WebGL program
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#program
         * @type {WebGLProgram}
         * @since 3.0.0
         */this.program=this.renderer.createProgram(t.vertShader,t.fragShader),/**
         * Array of objects that describe the vertex attributes
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#attributes
         * @type {object}
         * @since 3.0.0
         */this.attributes=t.attributes,/**
         * The size in bytes of the vertex
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexSize
         * @type {integer}
         * @since 3.0.0
         */this.vertexSize=t.vertexSize,/**
         * The primitive topology which the pipeline will use to submit draw calls
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#topology
         * @type {integer}
         * @since 3.0.0
         */this.topology=t.topology,/**
         * Uint8 view to the vertex raw buffer. Used for uploading vertex buffer resources
         * to the GPU.
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#bytes
         * @type {Uint8Array}
         * @since 3.0.0
         */this.bytes=new Uint8Array(this.vertexData),/**
         * This will store the amount of components of 32 bit length
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexComponentCount
         * @type {integer}
         * @since 3.0.0
         */this.vertexComponentCount=n.getComponentCount(t.attributes,this.gl),/**
         * Indicates if the current pipeline is flushing the contents to the GPU.
         * When the variable is set the flush function will be locked.
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#flushLocked
         * @type {boolean}
         * @since 3.1.0
         */this.flushLocked=!1,/**
         * Indicates if the current pipeline is active or not for this frame only.
         * Reset in the onRender method.
         *
         * @name Phaser.Renderer.WebGL.WebGLPipeline#active
         * @type {boolean}
         * @since 3.10.0
         */this.active=!1},/**
     * Called when the Game has fully booted and the Renderer has finished setting up.
     *
     * By this stage all Game level systems are now in place and you can perform any final
     * tasks that the pipeline may need that relied on game systems such as the Texture Manager.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#boot
     * @since 3.11.0
     */boot:function(){},/**
     * Adds a description of vertex attribute to the pipeline
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#addAttribute
     * @since 3.2.0
     *
     * @param {string} name - Name of the vertex attribute
     * @param {integer} size - Vertex component size
     * @param {integer} type - Type of the attribute
     * @param {boolean} normalized - Is the value normalized to a range
     * @param {integer} offset - Byte offset to the beginning of the first element in the vertex
     *
     * @return {this} This WebGLPipeline instance.
     */addAttribute:function(t,e,i,s,r){return this.attributes.push({name:t,size:e,type:this.renderer.glFormats[i],normalized:s,offset:r}),this.vertexComponentCount=n.getComponentCount(this.attributes,this.gl),this},/**
     * Check if the current batch of vertices is full.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#shouldFlush
     * @since 3.0.0
     *
     * @return {boolean} `true` if the current batch should be flushed, otherwise `false`.
     */shouldFlush:function(){return this.vertexCount>=this.vertexCapacity},/**
     * Resizes the properties used to describe the viewport
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#resize
     * @since 3.0.0
     *
     * @param {number} width - The new width of this WebGL Pipeline.
     * @param {number} height - The new height of this WebGL Pipeline.
     * @param {number} resolution - The resolution this WebGL Pipeline should be resized to.
     *
     * @return {this} This WebGLPipeline instance.
     */resize:function(t,e,i){return this.width=t*i,this.height=e*i,this.resolution=i,this},/**
     * Binds the pipeline resources, including programs, vertex buffers and binds attributes
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#bind
     * @since 3.0.0
     *
     * @return {this} This WebGLPipeline instance.
     */bind:function(){var t=this.gl,e=this.vertexBuffer,i=this.attributes,n=this.program,s=this.renderer,r=this.vertexSize;s.setProgram(n),s.setVertexBuffer(e);for(var o=0;o<i.length;++o){var a=i[o],h=t.getAttribLocation(n,a.name);h>=0?(t.enableVertexAttribArray(h),t.vertexAttribPointer(h,a.size,a.type,a.normalized,r,a.offset)):-1!==h&&t.disableVertexAttribArray(h)}return this},/**
     * Set whenever this WebGL Pipeline is bound to a WebGL Renderer.
     *
     * This method is called every time the WebGL Pipeline is attempted to be bound, even if it already is the current pipeline.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#onBind
     * @since 3.0.0
     *
     * @return {this} This WebGLPipeline instance.
     */onBind:function(){// This is for updating uniform data it's called on each bind attempt.
return this},/**
     * Called before each frame is rendered, but after the canvas has been cleared.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#onPreRender
     * @since 3.0.0
     *
     * @return {this} This WebGLPipeline instance.
     */onPreRender:function(){// called once every frame
return this},/**
     * Called before a Scene's Camera is rendered.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#onRender
     * @since 3.0.0
     *
     * @param {Phaser.Scene} scene - The Scene being rendered.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera being rendered with.
     *
     * @return {this} This WebGLPipeline instance.
     */onRender:function(){// called for each camera
return this},/**
     * Called after each frame has been completely rendered and snapshots have been taken.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#onPostRender
     * @since 3.0.0
     *
     * @return {this} This WebGLPipeline instance.
     */onPostRender:function(){// called once every frame
return this},/**
     * Uploads the vertex data and emits a draw call
     * for the current batch of vertices.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#flush
     * @since 3.0.0
     *
     * @return {this} This WebGLPipeline instance.
     */flush:function(){if(this.flushLocked)return this;this.flushLocked=!0;var t=this.gl,e=this.vertexCount,i=this.topology,n=this.vertexSize;if(0===e){this.flushLocked=!1;return}return t.bufferSubData(t.ARRAY_BUFFER,0,this.bytes.subarray(0,e*n)),t.drawArrays(i,0,e),this.vertexCount=0,this.flushLocked=!1,this},/**
     * Removes all object references in this WebGL Pipeline and removes its program from the WebGL context.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#destroy
     * @since 3.0.0
     *
     * @return {this} This WebGLPipeline instance.
     */destroy:function(){var t=this.gl;return t.deleteProgram(this.program),t.deleteBuffer(this.vertexBuffer),delete this.program,delete this.vertexBuffer,delete this.gl,this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setFloat1
     * @since 3.2.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {number} x - The new value of the `float` uniform.
     *
     * @return {this} This WebGLPipeline instance.
     */setFloat1:function(t,e){return this.renderer.setFloat1(this.program,t,e),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setFloat2
     * @since 3.2.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {number} x - The new X component of the `vec2` uniform.
     * @param {number} y - The new Y component of the `vec2` uniform.
     *
     * @return {this} This WebGLPipeline instance.
     */setFloat2:function(t,e,i){return this.renderer.setFloat2(this.program,t,e,i),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setFloat3
     * @since 3.2.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {number} x - The new X component of the `vec3` uniform.
     * @param {number} y - The new Y component of the `vec3` uniform.
     * @param {number} z - The new Z component of the `vec3` uniform.
     *
     * @return {this} This WebGLPipeline instance.
     */setFloat3:function(t,e,i,n){return this.renderer.setFloat3(this.program,t,e,i,n),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setFloat4
     * @since 3.2.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {number} x - X component of the uniform
     * @param {number} y - Y component of the uniform
     * @param {number} z - Z component of the uniform
     * @param {number} w - W component of the uniform
     *
     * @return {this} This WebGLPipeline instance.
     */setFloat4:function(t,e,i,n,s){return this.renderer.setFloat4(this.program,t,e,i,n,s),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setFloat1v
     * @since 3.13.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {Float32Array} arr - The new value to be used for the uniform variable.
     *
     * @return {this} This WebGLPipeline instance.
     */setFloat1v:function(t,e){return this.renderer.setFloat1v(this.program,t,e),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setFloat2v
     * @since 3.13.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {Float32Array} arr - The new value to be used for the uniform variable.
     *
     * @return {this} This WebGLPipeline instance.
     */setFloat2v:function(t,e){return this.renderer.setFloat2v(this.program,t,e),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setFloat3v
     * @since 3.13.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {Float32Array} arr - The new value to be used for the uniform variable.
     *
     * @return {this} This WebGLPipeline instance.
     */setFloat3v:function(t,e){return this.renderer.setFloat3v(this.program,t,e),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setFloat4v
     * @since 3.13.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {Float32Array} arr - The new value to be used for the uniform variable.
     *
     * @return {this} This WebGLPipeline instance.
     */setFloat4v:function(t,e){return this.renderer.setFloat4v(this.program,t,e),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setInt1
     * @since 3.2.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {integer} x - The new value of the `int` uniform.
     *
     * @return {this} This WebGLPipeline instance.
     */setInt1:function(t,e){return this.renderer.setInt1(this.program,t,e),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setInt2
     * @since 3.2.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {integer} x - The new X component of the `ivec2` uniform.
     * @param {integer} y - The new Y component of the `ivec2` uniform.
     *
     * @return {this} This WebGLPipeline instance.
     */setInt2:function(t,e,i){return this.renderer.setInt2(this.program,t,e,i),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setInt3
     * @since 3.2.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {integer} x - The new X component of the `ivec3` uniform.
     * @param {integer} y - The new Y component of the `ivec3` uniform.
     * @param {integer} z - The new Z component of the `ivec3` uniform.
     *
     * @return {this} This WebGLPipeline instance.
     */setInt3:function(t,e,i,n){return this.renderer.setInt3(this.program,t,e,i,n),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setInt4
     * @since 3.2.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {integer} x - X component of the uniform
     * @param {integer} y - Y component of the uniform
     * @param {integer} z - Z component of the uniform
     * @param {integer} w - W component of the uniform
     *
     * @return {this} This WebGLPipeline instance.
     */setInt4:function(t,e,i,n,s){return this.renderer.setInt4(this.program,t,e,i,n,s),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setMatrix2
     * @since 3.2.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {boolean} transpose - Whether to transpose the matrix. Should be `false`.
     * @param {Float32Array} matrix - The new values for the `mat2` uniform.
     *
     * @return {this} This WebGLPipeline instance.
     */setMatrix2:function(t,e,i){return this.renderer.setMatrix2(this.program,t,e,i),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setMatrix3
     * @since 3.2.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {boolean} transpose - Whether to transpose the matrix. Should be `false`.
     * @param {Float32Array} matrix - The new values for the `mat3` uniform.
     *
     * @return {this} This WebGLPipeline instance.
     */setMatrix3:function(t,e,i){return this.renderer.setMatrix3(this.program,t,e,i),this},/**
     * Set a uniform value of the current pipeline program.
     *
     * @method Phaser.Renderer.WebGL.WebGLPipeline#setMatrix4
     * @since 3.2.0
     *
     * @param {string} name - The name of the uniform to look-up and modify.
     * @param {boolean} transpose - Should the matrix be transpose
     * @param {Float32Array} matrix - Matrix data
     *
     * @return {this} This WebGLPipeline instance.
     */setMatrix4:function(t,e,i){return this.renderer.setMatrix4(this.program,t,e,i),this}});t.exports=r}),r("lOOAG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("5eWH0"),r=s("jnBZP"),o=10,a=new i({Extends:r,initialize:function(t){o=t.maxLights,t.fragShader=n.replace("%LIGHT_COUNT%",o.toString()),r.call(this,t),/**
         * Default normal map texture to use.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#defaultNormalMap
         * @type {Phaser.Texture.Frame}
         * @private
         * @since 3.11.0
         */this.defaultNormalMap,/**
         * Inverse rotation matrix for normal map rotations.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#inverseRotationMatrix
         * @type {Float32Array}
         * @private
         * @since 3.16.0
         */this.inverseRotationMatrix=new Float32Array([1,0,0,0,1,0,0,0,1])},/**
     * Called when the Game has fully booted and the Renderer has finished setting up.
     * 
     * By this stage all Game level systems are now in place and you can perform any final
     * tasks that the pipeline may need that relied on game systems such as the Texture Manager.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#boot
     * @override
     * @since 3.11.0
     */boot:function(){this.defaultNormalMap=this.game.textures.getFrame("__DEFAULT")},/**
     * This function binds its base class resources and this lights 2D resources.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#onBind
     * @override
     * @since 3.0.0
     * 
     * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object that invoked this pipeline, if any.
     *
     * @return {this} This WebGLPipeline instance.
     */onBind:function(t){r.prototype.onBind.call(this);var e=this.renderer,i=this.program;return this.mvpUpdate(),e.setInt1(i,"uNormSampler",1),e.setFloat2(i,"uResolution",this.width,this.height),t&&this.setNormalMap(t),this},/**
     * This function sets all the needed resources for each camera pass.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#onRender
     * @since 3.0.0
     *
     * @param {Phaser.Scene} scene - The Scene being rendered.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera being rendered with.
     *
     * @return {this} This WebGLPipeline instance.
     */onRender:function(t,e){this.active=!1;var i,n=t.sys.lights;if(!n||n.lights.length<=0||!n.active)return this;var s=n.cull(e),r=Math.min(s.length,o);if(0===r)return this;this.active=!0;var a=this.renderer,h=this.program,l=e.matrix,u={x:0,y:0},c=a.height;for(i=0;i<o;++i)a.setFloat1(h,"uLights["+i+"].radius",0);for(a.setFloat4(h,"uCamera",e.x,e.y,e.rotation,e.zoom),a.setFloat3(h,"uAmbientLightColor",n.ambientColor.r,n.ambientColor.g,n.ambientColor.b),i=0;i<r;++i){var d=s[i],f="uLights["+i+"].";l.transformPoint(d.x,d.y,u),a.setFloat2(h,f+"position",u.x-e.scrollX*d.scrollFactorX*e.zoom,c-(u.y-e.scrollY*d.scrollFactorY*e.zoom)),a.setFloat3(h,f+"color",d.r,d.g,d.b),a.setFloat1(h,f+"intensity",d.intensity),a.setFloat1(h,f+"radius",d.radius)}return this.currentNormalMapRotation=null,this},/**
     * Generic function for batching a textured quad
     *
     * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#batchTexture
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - Source GameObject
     * @param {WebGLTexture} texture - Raw WebGLTexture associated with the quad
     * @param {integer} textureWidth - Real texture width
     * @param {integer} textureHeight - Real texture height
     * @param {number} srcX - X coordinate of the quad
     * @param {number} srcY - Y coordinate of the quad
     * @param {number} srcWidth - Width of the quad
     * @param {number} srcHeight - Height of the quad
     * @param {number} scaleX - X component of scale
     * @param {number} scaleY - Y component of scale
     * @param {number} rotation - Rotation of the quad
     * @param {boolean} flipX - Indicates if the quad is horizontally flipped
     * @param {boolean} flipY - Indicates if the quad is vertically flipped
     * @param {number} scrollFactorX - By which factor is the quad affected by the camera horizontal scroll
     * @param {number} scrollFactorY - By which factor is the quad effected by the camera vertical scroll
     * @param {number} displayOriginX - Horizontal origin in pixels
     * @param {number} displayOriginY - Vertical origin in pixels
     * @param {number} frameX - X coordinate of the texture frame
     * @param {number} frameY - Y coordinate of the texture frame
     * @param {number} frameWidth - Width of the texture frame
     * @param {number} frameHeight - Height of the texture frame
     * @param {integer} tintTL - Tint for top left
     * @param {integer} tintTR - Tint for top right
     * @param {integer} tintBL - Tint for bottom left
     * @param {integer} tintBR - Tint for bottom right
     * @param {number} tintEffect - The tint effect (0 for additive, 1 for replacement)
     * @param {number} uOffset - Horizontal offset on texture coordinate
     * @param {number} vOffset - Vertical offset on texture coordinate
     * @param {Phaser.Cameras.Scene2D.Camera} camera - Current used camera
     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - Parent container
     */batchTexture:function(t,e,i,n,s,r,o,a,h,l,u,c,d,f,p,g,v,m,y,x,w,T,b,S,A,E,_,C,M,P){if(this.active){if(this.renderer.setPipeline(this),t.displayTexture?O=t.displayTexture.dataSource[t.displayFrame.sourceIndex]:t.texture?O=t.texture.dataSource[t.frame.sourceIndex]:t.tileset&&(O=Array.isArray(t.tileset)?t.tileset[0].image.dataSource[0]:t.tileset.image.dataSource[0]),!O){console.warn("Normal map missing or invalid");return}this.setTexture2D(O.glTexture,1),this.setNormalMapRotation(u);var O,R=this._tempMatrix1,L=this._tempMatrix2,k=this._tempMatrix3,D=m/i+_,F=y/n+C,I=(m+x)/i+_,B=(y+w)/n+C,N=o,Y=a,z=-g,j=-v;if(t.isCropped){var X=t._crop;N=X.width,Y=X.height,o=X.width,a=X.height,m=X.x,y=X.y;var U=m,G=y;c&&(U=x-X.x-X.width),d&&!e.isRenderTexture&&(G=w-X.y-X.height),D=U/i+_,F=G/n+C,I=(U+X.width)/i+_,B=(G+X.height)/n+C,z=-g+m,j=-v+y}//  Invert the flipY if this is a RenderTexture
d^=e.isRenderTexture?1:0,c&&(N*=-1,z+=o),d&&(Y*=-1,j+=a);//  Do we need this? (doubt it)
// if (camera.roundPixels)
// {
//     x |= 0;
//     y |= 0;
// }
var W=z+N,V=j+Y;L.applyITRS(s,r,u,h,l),R.copyFrom(M.matrix),P?(//  Multiply the camera by the parent matrix
R.multiplyWithOffset(P,-M.scrollX*f,-M.scrollY*p),//  Undo the camera scroll
L.e=s,L.f=r):(L.e-=M.scrollX*f,L.f-=M.scrollY*p),//  Multiply by the Sprite matrix, store result in calcMatrix
R.multiply(L,k);var H=k.getX(z,j),q=k.getY(z,j),K=k.getX(z,V),Z=k.getY(z,V),Q=k.getX(W,V),J=k.getY(W,V),$=k.getX(W,j),tt=k.getY(W,j);M.roundPixels&&(H=Math.round(H),q=Math.round(q),K=Math.round(K),Z=Math.round(Z),Q=Math.round(Q),J=Math.round(J),$=Math.round($),tt=Math.round(tt)),this.setTexture2D(e,0),this.batchQuad(H,q,K,Z,Q,J,$,tt,D,F,I,B,T,b,S,A,E,e,0)}},/**
     * Sets the Game Objects normal map as the active texture.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#setNormalMap
     * @since 3.11.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to update.
     */setNormalMap:function(t){var e;this.active&&t&&(t.texture&&(e=t.texture.dataSource[t.frame.sourceIndex]),e||(e=this.defaultNormalMap),this.setTexture2D(e.glTexture,1),this.renderer.setPipeline(t.defaultPipeline))},/**
     * Rotates the normal map vectors inversely by the given angle.
     * Only works in 2D space.
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#setNormalMapRotation
     * @since 3.16.0
     * 
     * @param {number} rotation - The angle of rotation in radians.
     */setNormalMapRotation:function(t){if(t!==this.currentNormalMapRotation||0===this.batches.length){this.batches.length>0&&this.flush();var e=this.inverseRotationMatrix;if(t){var i=-t,n=Math.cos(i),s=Math.sin(i);e[1]=s,e[3]=-s,e[0]=e[4]=n}else e[0]=e[4]=1,e[1]=e[3]=0;this.renderer.setMatrix3(this.program,"uInverseRotationMatrix",!1,e),this.currentNormalMapRotation=t}},/**
     * Takes a Sprite Game Object, or any object that extends it, which has a normal texture and adds it to the batch.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#batchSprite
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Sprite} sprite - The texture-based Game Object to add to the batch.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the rendering transform.
     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - The transform matrix of the parent container, if set.
     */batchSprite:function(t,e,i){if(this.active){var n=t.texture.dataSource[t.frame.sourceIndex];n&&(this.renderer.setPipeline(this),this.setTexture2D(n.glTexture,1),this.setNormalMapRotation(t.rotation),r.prototype.batchSprite.call(this,t,e,i))}}});a.LIGHT_COUNT=o,t.exports=a}),r("5eWH0",function(t,e){t.exports="#define SHADER_NAME PHASER_FORWARD_DIFFUSE_FS\n\nprecision mediump float;\n\nstruct Light\n{\n    vec2 position;\n    vec3 color;\n    float intensity;\n    float radius;\n};\n\nconst int kMaxLights = %LIGHT_COUNT%;\n\nuniform vec4 uCamera; /* x, y, rotation, zoom */\nuniform vec2 uResolution;\nuniform sampler2D uMainSampler;\nuniform sampler2D uNormSampler;\nuniform vec3 uAmbientLightColor;\nuniform Light uLights[kMaxLights];\nuniform mat3 uInverseRotationMatrix;\n\nvarying vec2 outTexCoord;\nvarying vec4 outTint;\n\nvoid main()\n{\n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.rgb * outTint.a, outTint.a);\n    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;\n    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));\n    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;\n\n    for (int index = 0; index < kMaxLights; ++index)\n    {\n        Light light = uLights[index];\n        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);\n        vec3 lightNormal = normalize(lightDir);\n        float distToSurf = length(lightDir) * uCamera.w;\n        float diffuseFactor = max(dot(normal, lightNormal), 0.0);\n        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;\n        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);\n        vec3 diffuse = light.color * diffuseFactor;\n        finalColor += (attenuation * diffuse) * light.intensity;\n    }\n\n    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);\n    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);\n\n}\n"}),r("jnBZP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("hjbjS"),r=s("7BSWl"),o=s("g1JCF"),a=s("uU5DT"),h=s("kaOgK"),l=s("azs1m"),u=s("gaO4e"),c=s("AbdBB"),d=new i({Extends:c,Mixins:[o],initialize:function(t){var e=t.renderer.config;//  Vertex Size = attribute size added together (2 + 2 + 1 + 4)
c.call(this,{game:t.game,renderer:t.renderer,gl:t.renderer.gl,topology:r(t,"topology",t.renderer.gl.TRIANGLES),vertShader:r(t,"vertShader",h),fragShader:r(t,"fragShader",a),vertexCapacity:r(t,"vertexCapacity",6*e.batchSize),vertexSize:r(t,"vertexSize",5*Float32Array.BYTES_PER_ELEMENT+4*Uint8Array.BYTES_PER_ELEMENT),attributes:[{name:"inPosition",size:2,type:t.renderer.gl.FLOAT,normalized:!1,offset:0},{name:"inTexCoord",size:2,type:t.renderer.gl.FLOAT,normalized:!1,offset:2*Float32Array.BYTES_PER_ELEMENT},{name:"inTintEffect",size:1,type:t.renderer.gl.FLOAT,normalized:!1,offset:4*Float32Array.BYTES_PER_ELEMENT},{name:"inTint",size:4,type:t.renderer.gl.UNSIGNED_BYTE,normalized:!0,offset:5*Float32Array.BYTES_PER_ELEMENT}]}),/**
         * Float32 view of the array buffer containing the pipeline's vertices.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#vertexViewF32
         * @type {Float32Array}
         * @since 3.0.0
         */this.vertexViewF32=new Float32Array(this.vertexData),/**
         * Uint32 view of the array buffer containing the pipeline's vertices.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#vertexViewU32
         * @type {Uint32Array}
         * @since 3.0.0
         */this.vertexViewU32=new Uint32Array(this.vertexData),/**
         * Size of the batch.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#maxQuads
         * @type {integer}
         * @since 3.0.0
         */this.maxQuads=e.batchSize,/**
         * Collection of batch information
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batches
         * @type {array}
         * @since 3.1.0
         */this.batches=[],/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#_tempMatrix1
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.11.0
         */this._tempMatrix1=new l,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#_tempMatrix2
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.11.0
         */this._tempMatrix2=new l,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#_tempMatrix3
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.11.0
         */this._tempMatrix3=new l,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#_tempMatrix4
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.11.0
         */this._tempMatrix4=new l,/**
         * Used internally to draw stroked triangles.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#tempTriangle
         * @type {array}
         * @private
         * @since 3.12.0
         */this.tempTriangle=[{x:0,y:0,width:0},{x:0,y:0,width:0},{x:0,y:0,width:0},{x:0,y:0,width:0}],/**
         * The tint effect to be applied by the shader in the next geometry draw:
         * 
         * 0 = texture multiplied by color
         * 1 = solid color + texture alpha
         * 2 = solid color, no texture
         * 3 = solid texture, no color
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#tintEffect
         * @type {number}
         * @private
         * @since 3.12.0
         */this.tintEffect=2,/**
         * Cached stroke tint.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#strokeTint
         * @type {object}
         * @private
         * @since 3.12.0
         */this.strokeTint={TL:0,TR:0,BL:0,BR:0},/**
         * Cached fill tint.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#fillTint
         * @type {object}
         * @private
         * @since 3.12.0
         */this.fillTint={TL:0,TR:0,BL:0,BR:0},/**
         * Internal texture frame reference.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#currentFrame
         * @type {Phaser.Textures.Frame}
         * @private
         * @since 3.12.0
         */this.currentFrame={u0:0,v0:0,u1:1,v1:1},/**
         * Internal path quad cache.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#firstQuad
         * @type {array}
         * @private
         * @since 3.12.0
         */this.firstQuad=[0,0,0,0,0],/**
         * Internal path quad cache.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#prevQuad
         * @type {array}
         * @private
         * @since 3.12.0
         */this.prevQuad=[0,0,0,0,0],/**
         * Used internally for triangulating a polygon.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#polygonCache
         * @type {array}
         * @private
         * @since 3.12.0
         */this.polygonCache=[],this.mvpInit()},/**
     * Called every time the pipeline needs to be used.
     * It binds all necessary resources.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#onBind
     * @since 3.0.0
     *
     * @return {this} This WebGLPipeline instance.
     */onBind:function(){return c.prototype.onBind.call(this),this.mvpUpdate(),this},/**
     * Resizes this pipeline and updates the projection.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#resize
     * @since 3.0.0
     *
     * @param {number} width - The new width.
     * @param {number} height - The new height.
     * @param {number} resolution - The resolution.
     *
     * @return {this} This WebGLPipeline instance.
     */resize:function(t,e,i){return c.prototype.resize.call(this,t,e,i),this.projOrtho(0,this.width,this.height,0,-1e3,1e3),this},/**
     * Assigns a texture to the current batch. If a different texture is already set it creates a new batch object.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#setTexture2D
     * @since 3.1.0
     *
     * @param {WebGLTexture} [texture] - WebGLTexture that will be assigned to the current batch. If not given uses blankTexture.
     * @param {integer} [unit=0] - Texture unit to which the texture needs to be bound.
     *
     * @return {Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline} This pipeline instance.
     */setTexture2D:function(t,e){return void 0===t&&(t=this.renderer.blankTexture.glTexture),void 0===e&&(e=0),this.requireTextureBatch(t,e)&&this.pushBatch(t,e),this},/**
     * Checks if the current batch has the same texture and texture unit, or if we need to create a new batch.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#requireTextureBatch
     * @since 3.16.0
     *
     * @param {WebGLTexture} texture - WebGLTexture that will be assigned to the current batch. If not given uses blankTexture.
     * @param {integer} unit - Texture unit to which the texture needs to be bound.
     *
     * @return {boolean} `true` if the pipeline needs to create a new batch, otherwise `false`.
     */requireTextureBatch:function(t,e){var i=this.batches,n=i.length;return!(n>0)||(e>0?i[n-1].textures[e-1]:i[n-1].texture)!==t},/**
     * Creates a new batch object and pushes it to a batch array.
     * The batch object contains information relevant to the current 
     * vertex batch like the offset in the vertex buffer, vertex count and 
     * the textures used by that batch.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#pushBatch
     * @since 3.1.0
     * 
     * @param {WebGLTexture} texture - Optional WebGLTexture that will be assigned to the created batch.
     * @param {integer} unit - Texture unit to which the texture needs to be bound.
     */pushBatch:function(t,e){if(0===e)this.batches.push({first:this.vertexCount,texture:t,textures:[]});else{var i=[];i[e-1]=t,this.batches.push({first:this.vertexCount,texture:null,textures:i})}},/**
     * Uploads the vertex data and emits a draw call for the current batch of vertices.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#flush
     * @since 3.0.0
     *
     * @return {this} This WebGLPipeline instance.
     */flush:function(){if(this.flushLocked)return this;this.flushLocked=!0;var t,e,i,n=this.gl,s=this.vertexCount,r=this.topology,o=this.vertexSize,a=this.renderer,h=this.batches,l=h.length,u=0,c=null;if(0===l||0===s)return this.flushLocked=!1,this;n.bufferSubData(n.ARRAY_BUFFER,0,this.bytes.subarray(0,s*o));//  Process the TEXTURE BATCHES
for(var d=0;d<l-1;d++){//  Multi-texture check (for non-zero texture units)
if(c=h[d],t=h[d+1],c.textures.length>0){for(e=0;e<c.textures.length;++e)(i=c.textures[e])&&a.setTexture2D(i,1+e,!1);n.activeTexture(n.TEXTURE0)}u=t.first-c.first,null===c.texture||u<=0||(a.setTexture2D(c.texture,0,!1),n.drawArrays(r,c.first,u))}//  Multi-texture check (for non-zero texture units)
if(// Left over data
(c=h[l-1]).textures.length>0){for(e=0;e<c.textures.length;++e)(i=c.textures[e])&&a.setTexture2D(i,1+e,!1);n.activeTexture(n.TEXTURE0)}return u=s-c.first,c.texture&&u>0&&(a.setTexture2D(c.texture,0,!1),n.drawArrays(r,c.first,u)),this.vertexCount=0,h.length=0,this.flushLocked=!1,this},/**
     * Takes a Sprite Game Object, or any object that extends it, and adds it to the batch.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchSprite
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.Image|Phaser.GameObjects.Sprite)} sprite - The texture based Game Object to add to the batch.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the rendering transform.
     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - The transform matrix of the parent container, if set.
     */batchSprite:function(t,e,i){//  Will cause a flush if there are batchSize entries already
this.renderer.setPipeline(this);var n=this._tempMatrix1,s=this._tempMatrix2,r=this._tempMatrix3,o=t.frame,a=o.glTexture,h=o.u0,l=o.v0,c=o.u1,d=o.v1,f=o.x,p=o.y,g=o.cutWidth,v=o.cutHeight,m=o.customPivot,y=t.displayOriginX,x=t.displayOriginY,w=-y+f,T=-x+p;if(t.isCropped){var b=t._crop;(b.flipX!==t.flipX||b.flipY!==t.flipY)&&o.updateCropUVs(b,t.flipX,t.flipY),h=b.u0,l=b.v0,c=b.u1,d=b.v1,g=b.width,v=b.height,f=b.x,p=b.y,w=-y+f,T=-x+p}var S=1,A=1;t.flipX&&(m||(w+=-o.realWidth+2*y),S=-1),(t.flipY||o.source.isGLTexture&&!a.flipY)&&(m||(T+=-o.realHeight+2*x),A=-1),s.applyITRS(t.x,t.y,t.rotation,t.scaleX*S,t.scaleY*A),n.copyFrom(e.matrix),i?(//  Multiply the camera by the parent matrix
n.multiplyWithOffset(i,-e.scrollX*t.scrollFactorX,-e.scrollY*t.scrollFactorY),//  Undo the camera scroll
s.e=t.x,s.f=t.y):(s.e-=e.scrollX*t.scrollFactorX,s.f-=e.scrollY*t.scrollFactorY),//  Multiply by the Sprite matrix, store result in calcMatrix
n.multiply(s,r);var E=w+g,_=T+v,C=r.getX(w,T),M=r.getY(w,T),P=r.getX(w,_),O=r.getY(w,_),R=r.getX(E,_),L=r.getY(E,_),k=r.getX(E,T),D=r.getY(E,T),F=u.getTintAppendFloatAlpha(t._tintTL,e.alpha*t._alphaTL),I=u.getTintAppendFloatAlpha(t._tintTR,e.alpha*t._alphaTR),B=u.getTintAppendFloatAlpha(t._tintBL,e.alpha*t._alphaBL),N=u.getTintAppendFloatAlpha(t._tintBR,e.alpha*t._alphaBR);e.roundPixels&&(C=Math.round(C),M=Math.round(M),P=Math.round(P),O=Math.round(O),R=Math.round(R),L=Math.round(L),k=Math.round(k),D=Math.round(D)),this.setTexture2D(a,0);var Y=t._isTinted&&t.tintFill;this.batchQuad(C,M,P,O,R,L,k,D,h,l,c,d,F,I,B,N,Y,a,0)},/**
     * Adds the vertices data into the batch and flushes if full.
     * 
     * Assumes 6 vertices in the following arrangement:
     * 
     * ```
     * 0----3
     * |\  B|
     * | \  |
     * |  \ |
     * | A \|
     * |    \
     * 1----2
     * ```
     * 
     * Where tx0/ty0 = 0, tx1/ty1 = 1, tx2/ty2 = 2 and tx3/ty3 = 3
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchQuad
     * @since 3.12.0
     *
     * @param {number} x0 - The top-left x position.
     * @param {number} y0 - The top-left y position.
     * @param {number} x1 - The bottom-left x position.
     * @param {number} y1 - The bottom-left y position.
     * @param {number} x2 - The bottom-right x position.
     * @param {number} y2 - The bottom-right y position.
     * @param {number} x3 - The top-right x position.
     * @param {number} y3 - The top-right y position.
     * @param {number} u0 - UV u0 value.
     * @param {number} v0 - UV v0 value.
     * @param {number} u1 - UV u1 value.
     * @param {number} v1 - UV v1 value.
     * @param {number} tintTL - The top-left tint color value.
     * @param {number} tintTR - The top-right tint color value.
     * @param {number} tintBL - The bottom-left tint color value.
     * @param {number} tintBR - The bottom-right tint color value.
     * @param {(number|boolean)} tintEffect - The tint effect for the shader to use.
     * @param {WebGLTexture} [texture] - WebGLTexture that will be assigned to the current batch if a flush occurs.
     * @param {integer} [unit=0] - Texture unit to which the texture needs to be bound.
     * 
     * @return {boolean} `true` if this method caused the batch to flush, otherwise `false`.
     */batchQuad:function(t,e,i,n,s,r,o,a,h,l,u,c,d,f,p,g,v,m,y){var x=!1;this.vertexCount+6>this.vertexCapacity&&(this.flush(),x=!0,this.setTexture2D(m,y));var w=this.vertexViewF32,T=this.vertexViewU32,b=this.vertexCount*this.vertexComponentCount-1;return w[++b]=t,w[++b]=e,w[++b]=h,w[++b]=l,w[++b]=v,T[++b]=d,w[++b]=i,w[++b]=n,w[++b]=h,w[++b]=c,w[++b]=v,T[++b]=p,w[++b]=s,w[++b]=r,w[++b]=u,w[++b]=c,w[++b]=v,T[++b]=g,w[++b]=t,w[++b]=e,w[++b]=h,w[++b]=l,w[++b]=v,T[++b]=d,w[++b]=s,w[++b]=r,w[++b]=u,w[++b]=c,w[++b]=v,T[++b]=g,w[++b]=o,w[++b]=a,w[++b]=u,w[++b]=l,w[++b]=v,T[++b]=f,this.vertexCount+=6,x},/**
     * Adds the vertices data into the batch and flushes if full.
     * 
     * Assumes 3 vertices in the following arrangement:
     * 
     * ```
     * 0
     * |\
     * | \
     * |  \
     * |   \
     * |    \
     * 1-----2
     * ```
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchTri
     * @since 3.12.0
     *
     * @param {number} x1 - The bottom-left x position.
     * @param {number} y1 - The bottom-left y position.
     * @param {number} x2 - The bottom-right x position.
     * @param {number} y2 - The bottom-right y position.
     * @param {number} x3 - The top-right x position.
     * @param {number} y3 - The top-right y position.
     * @param {number} u0 - UV u0 value.
     * @param {number} v0 - UV v0 value.
     * @param {number} u1 - UV u1 value.
     * @param {number} v1 - UV v1 value.
     * @param {number} tintTL - The top-left tint color value.
     * @param {number} tintTR - The top-right tint color value.
     * @param {number} tintBL - The bottom-left tint color value.
     * @param {(number|boolean)} tintEffect - The tint effect for the shader to use.
     * @param {WebGLTexture} [texture] - WebGLTexture that will be assigned to the current batch if a flush occurs.
     * @param {integer} [unit=0] - Texture unit to which the texture needs to be bound.
     * 
     * @return {boolean} `true` if this method caused the batch to flush, otherwise `false`.
     */batchTri:function(t,e,i,n,s,r,o,a,h,l,u,c,d,f,p,g){var v=!1;this.vertexCount+3>this.vertexCapacity&&(this.flush(),this.setTexture2D(p,g),v=!0);var m=this.vertexViewF32,y=this.vertexViewU32,x=this.vertexCount*this.vertexComponentCount-1;return m[++x]=t,m[++x]=e,m[++x]=o,m[++x]=a,m[++x]=f,y[++x]=u,m[++x]=i,m[++x]=n,m[++x]=o,m[++x]=l,m[++x]=f,y[++x]=c,m[++x]=s,m[++x]=r,m[++x]=h,m[++x]=l,m[++x]=f,y[++x]=d,this.vertexCount+=3,v},/**
     * Generic function for batching a textured quad using argument values instead of a Game Object.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchTexture
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - Source GameObject.
     * @param {WebGLTexture} texture - Raw WebGLTexture associated with the quad.
     * @param {integer} textureWidth - Real texture width.
     * @param {integer} textureHeight - Real texture height.
     * @param {number} srcX - X coordinate of the quad.
     * @param {number} srcY - Y coordinate of the quad.
     * @param {number} srcWidth - Width of the quad.
     * @param {number} srcHeight - Height of the quad.
     * @param {number} scaleX - X component of scale.
     * @param {number} scaleY - Y component of scale.
     * @param {number} rotation - Rotation of the quad.
     * @param {boolean} flipX - Indicates if the quad is horizontally flipped.
     * @param {boolean} flipY - Indicates if the quad is vertically flipped.
     * @param {number} scrollFactorX - By which factor is the quad affected by the camera horizontal scroll.
     * @param {number} scrollFactorY - By which factor is the quad effected by the camera vertical scroll.
     * @param {number} displayOriginX - Horizontal origin in pixels.
     * @param {number} displayOriginY - Vertical origin in pixels.
     * @param {number} frameX - X coordinate of the texture frame.
     * @param {number} frameY - Y coordinate of the texture frame.
     * @param {number} frameWidth - Width of the texture frame.
     * @param {number} frameHeight - Height of the texture frame.
     * @param {integer} tintTL - Tint for top left.
     * @param {integer} tintTR - Tint for top right.
     * @param {integer} tintBL - Tint for bottom left.
     * @param {integer} tintBR - Tint for bottom right.
     * @param {number} tintEffect - The tint effect.
     * @param {number} uOffset - Horizontal offset on texture coordinate.
     * @param {number} vOffset - Vertical offset on texture coordinate.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - Current used camera.
     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - Parent container.
     * @param {boolean} [skipFlip=false] - Skip the renderTexture check.
     */batchTexture:function(t,e,i,n,s,r,o,a,h,l,u,c,d,f,p,g,v,m,y,x,w,T,b,S,A,E,_,C,M,P,O){this.renderer.setPipeline(this,t);var R=this._tempMatrix1,L=this._tempMatrix2,k=this._tempMatrix3,D=m/i+_,F=y/n+C,I=(m+x)/i+_,B=(y+w)/n+C,N=o,Y=a,z=-g,j=-v;if(t.isCropped){var X=t._crop;N=X.width,Y=X.height,o=X.width,a=X.height,m=X.x,y=X.y;var U=m,G=y;c&&(U=x-X.x-X.width),d&&!e.isRenderTexture&&(G=w-X.y-X.height),D=U/i+_,F=G/n+C,I=(U+X.width)/i+_,B=(G+X.height)/n+C,z=-g+m,j=-v+y}//  Invert the flipY if this is a RenderTexture
d^=!O&&e.isRenderTexture?1:0,c&&(N*=-1,z+=o),d&&(Y*=-1,j+=a);var W=z+N,V=j+Y;L.applyITRS(s,r,u,h,l),R.copyFrom(M.matrix),P?(//  Multiply the camera by the parent matrix
R.multiplyWithOffset(P,-M.scrollX*f,-M.scrollY*p),//  Undo the camera scroll
L.e=s,L.f=r):(L.e-=M.scrollX*f,L.f-=M.scrollY*p),//  Multiply by the Sprite matrix, store result in calcMatrix
R.multiply(L,k);var H=k.getX(z,j),q=k.getY(z,j),K=k.getX(z,V),Z=k.getY(z,V),Q=k.getX(W,V),J=k.getY(W,V),$=k.getX(W,j),tt=k.getY(W,j);M.roundPixels&&(H=Math.round(H),q=Math.round(q),K=Math.round(K),Z=Math.round(Z),Q=Math.round(Q),J=Math.round(J),$=Math.round($),tt=Math.round(tt)),this.setTexture2D(e,0),this.batchQuad(H,q,K,Z,Q,J,$,tt,D,F,I,B,T,b,S,A,E,e,0)},/**
     * Adds a Texture Frame into the batch for rendering.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchTextureFrame
     * @since 3.12.0
     *
     * @param {Phaser.Textures.Frame} frame - The Texture Frame to be rendered.
     * @param {number} x - The horizontal position to render the texture at.
     * @param {number} y - The vertical position to render the texture at.
     * @param {number} tint - The tint color.
     * @param {number} alpha - The alpha value.
     * @param {Phaser.GameObjects.Components.TransformMatrix} transformMatrix - The Transform Matrix to use for the texture.
     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - A parent Transform Matrix.
     */batchTextureFrame:function(t,e,i,n,s,r,o){this.renderer.setPipeline(this);var a=this._tempMatrix1.copyFrom(r),h=this._tempMatrix2,l=e+t.width,c=i+t.height;o?a.multiply(o,h):h=a;var d=h.getX(e,i),f=h.getY(e,i),p=h.getX(e,c),g=h.getY(e,c),v=h.getX(l,c),m=h.getY(l,c),y=h.getX(l,i),x=h.getY(l,i);this.setTexture2D(t.glTexture,0),n=u.getTintAppendFloatAlpha(n,s),this.batchQuad(d,f,p,g,v,m,y,x,t.u0,t.v0,t.u1,t.v1,n,n,n,n,0,t.glTexture,0)},/**
     * Pushes a filled rectangle into the vertex batch.
     * Rectangle has no transform values and isn't transformed into the local space.
     * Used for directly batching untransformed rectangles, such as Camera background colors.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#drawFillRect
     * @since 3.12.0
     *
     * @param {number} x - Horizontal top left coordinate of the rectangle.
     * @param {number} y - Vertical top left coordinate of the rectangle.
     * @param {number} width - Width of the rectangle.
     * @param {number} height - Height of the rectangle.
     * @param {number} color - Color of the rectangle to draw.
     * @param {number} alpha - Alpha value of the rectangle to draw.
     */drawFillRect:function(t,e,i,n,s,r){var o=t+i,a=e+n;this.setTexture2D();var h=u.getTintAppendFloatAlphaAndSwap(s,r);this.batchQuad(t,e,t,a,o,a,o,e,0,0,1,1,h,h,h,h,2)},/**
     * Pushes a filled rectangle into the vertex batch.
     * Rectangle factors in the given transform matrices before adding to the batch.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchFillRect
     * @since 3.12.0
     *
     * @param {number} x - Horizontal top left coordinate of the rectangle.
     * @param {number} y - Vertical top left coordinate of the rectangle.
     * @param {number} width - Width of the rectangle.
     * @param {number} height - Height of the rectangle.
     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.
     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.
     */batchFillRect:function(t,e,i,n,s,r){this.renderer.setPipeline(this);var o=this._tempMatrix3;//  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix
r&&r.multiply(s,o);var a=t+i,h=e+n,l=o.getX(t,e),u=o.getY(t,e),c=o.getX(t,h),d=o.getY(t,h),f=o.getX(a,h),p=o.getY(a,h),g=o.getX(a,e),v=o.getY(a,e),m=this.currentFrame,y=m.u0,x=m.v0,w=m.u1,T=m.v1;this.batchQuad(l,u,c,d,f,p,g,v,y,x,w,T,this.fillTint.TL,this.fillTint.TR,this.fillTint.BL,this.fillTint.BR,this.tintEffect)},/**
     * Pushes a filled triangle into the vertex batch.
     * Triangle factors in the given transform matrices before adding to the batch.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchFillTriangle
     * @since 3.12.0
     *
     * @param {number} x0 - Point 0 x coordinate.
     * @param {number} y0 - Point 0 y coordinate.
     * @param {number} x1 - Point 1 x coordinate.
     * @param {number} y1 - Point 1 y coordinate.
     * @param {number} x2 - Point 2 x coordinate.
     * @param {number} y2 - Point 2 y coordinate.
     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.
     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.
     */batchFillTriangle:function(t,e,i,n,s,r,o,a){this.renderer.setPipeline(this);var h=this._tempMatrix3;//  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix
a&&a.multiply(o,h);var l=h.getX(t,e),u=h.getY(t,e),c=h.getX(i,n),d=h.getY(i,n),f=h.getX(s,r),p=h.getY(s,r),g=this.currentFrame,v=g.u0,m=g.v0,y=g.u1,x=g.v1;this.batchTri(l,u,c,d,f,p,v,m,y,x,this.fillTint.TL,this.fillTint.TR,this.fillTint.BL,this.tintEffect)},/**
     * Pushes a stroked triangle into the vertex batch.
     * Triangle factors in the given transform matrices before adding to the batch.
     * The triangle is created from 3 lines and drawn using the `batchStrokePath` method.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchStrokeTriangle
     * @since 3.12.0
     *
     * @param {number} x0 - Point 0 x coordinate.
     * @param {number} y0 - Point 0 y coordinate.
     * @param {number} x1 - Point 1 x coordinate.
     * @param {number} y1 - Point 1 y coordinate.
     * @param {number} x2 - Point 2 x coordinate.
     * @param {number} y2 - Point 2 y coordinate.
     * @param {number} lineWidth - The width of the line in pixels.
     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.
     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.
     */batchStrokeTriangle:function(t,e,i,n,s,r,o,a,h){var l=this.tempTriangle;l[0].x=t,l[0].y=e,l[0].width=o,l[1].x=i,l[1].y=n,l[1].width=o,l[2].x=s,l[2].y=r,l[2].width=o,l[3].x=t,l[3].y=e,l[3].width=o,this.batchStrokePath(l,o,!1,a,h)},/**
     * Adds the given path to the vertex batch for rendering.
     * 
     * It works by taking the array of path data and then passing it through Earcut, which
     * creates a list of polygons. Each polygon is then added to the batch.
     * 
     * The path is always automatically closed because it's filled.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchFillPath
     * @since 3.12.0
     *
     * @param {array} path - Collection of points that represent the path.
     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.
     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.
     */batchFillPath:function(t,e,i){this.renderer.setPipeline(this);var s,r,o=this._tempMatrix3;//  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix
i&&i.multiply(e,o);for(var a=t.length,h=this.polygonCache,l=this.fillTint.TL,u=this.fillTint.TR,c=this.fillTint.BL,d=this.tintEffect,f=0;f<a;++f)r=t[f],h.push(r.x,r.y);a=(s=n(h)).length;for(var p=this.currentFrame,g=0;g<a;g+=3){var v=2*s[g+0],m=2*s[g+1],y=2*s[g+2],x=h[v+0],w=h[v+1],T=h[m+0],b=h[m+1],S=h[y+0],A=h[y+1],E=o.getX(x,w),_=o.getY(x,w),C=o.getX(T,b),M=o.getY(T,b),P=o.getX(S,A),O=o.getY(S,A),R=p.u0,L=p.v0,k=p.u1,D=p.v1;this.batchTri(E,_,C,M,P,O,R,L,k,D,l,u,c,d)}h.length=0},/**
     * Adds the given path to the vertex batch for rendering.
     * 
     * It works by taking the array of path data and calling `batchLine` for each section
     * of the path.
     * 
     * The path is optionally closed at the end.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchStrokePath
     * @since 3.12.0
     *
     * @param {array} path - Collection of points that represent the path.
     * @param {number} lineWidth - The width of the line segments in pixels.
     * @param {boolean} pathOpen - Indicates if the path should be closed or left open.
     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.
     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.
     */batchStrokePath:function(t,e,i,n,s){this.renderer.setPipeline(this),//  Reset the closePath booleans
this.prevQuad[4]=0,this.firstQuad[4]=0;for(var r=t.length-1,o=0;o<r;o++){var a=t[o],h=t[o+1];this.batchLine(a.x,a.y,h.x,h.y,a.width/2,h.width/2,e,o,!i&&o===r-1,n,s)}},/**
     * Creates a quad and adds it to the vertex batch based on the given line values.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchLine
     * @since 3.12.0
     *
     * @param {number} ax - X coordinate to the start of the line
     * @param {number} ay - Y coordinate to the start of the line
     * @param {number} bx - X coordinate to the end of the line
     * @param {number} by - Y coordinate to the end of the line
     * @param {number} aLineWidth - Width of the start of the line
     * @param {number} bLineWidth - Width of the end of the line
     * @param {Float32Array} currentMatrix - Parent matrix, generally used by containers
     */batchLine:function(t,e,i,n,s,r,o,a,h,l,u){this.renderer.setPipeline(this);var c=this._tempMatrix3;u&&u.multiply(l,c);var d=i-t,f=n-e,p=Math.sqrt(d*d+f*f),g=s*(n-e)/p,v=s*(t-i)/p,m=r*(n-e)/p,y=r*(t-i)/p,x=i-m,w=n-y,T=t-g,b=e-v,S=i+m,A=n+y,E=t+g,_=e+v,C=c.getX(x,w),M=c.getY(x,w),P=c.getX(T,b),O=c.getY(T,b),R=c.getX(S,A),L=c.getY(S,A),k=c.getX(E,_),D=c.getY(E,_),F=this.strokeTint,I=this.tintEffect,B=F.TL,N=F.TR,Y=F.BL,z=F.BR,j=this.currentFrame,X=j.u0,U=j.v0,G=j.u1,W=j.v1;if(//  TL, BL, BR, TR
this.batchQuad(k,D,P,O,C,M,R,L,X,U,G,W,B,N,Y,z,I),!(o<=2)){var V=this.prevQuad,H=this.firstQuad;a>0&&V[4]?this.batchQuad(k,D,P,O,V[0],V[1],V[2],V[3],X,U,G,W,B,N,Y,z,I):(H[0]=k,H[1]=D,H[2]=P,H[3]=O,H[4]=1),h&&H[4]?this.batchQuad(C,M,R,L,H[0],H[1],H[2],H[3],X,U,G,W,B,N,Y,z,I):(//  Store it
V[0]=C,V[1]=M,V[2]=R,V[3]=L,V[4]=1)}}});t.exports=d}),r("hjbjS",function(t,e){function i(t,e,i){i=i||2;var f,g,v,m,y,x,w,T=e&&e.length,b=T?e[0]*i:t.length,S=n(t,0,b,i,!0),A=[];if(!S||S.next===S.prev)return A;// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
if(T&&(S=// link every hole into the outer loop, producing a single-ring polygon without holes
function(t,e,i,o){var h,l,u,f,p,g=[];for(h=0,l=e.length;h<l;h++)u=e[h]*o,f=h<l-1?e[h+1]*o:t.length,(p=n(t,u,f,o,!1))===p.next&&(p.steiner=!0),g.push(// find the leftmost node of a polygon ring
function(t){var e=t,i=t;do e.x<i.x&&(i=e),e=e.next;while(e!==t)return i}(p));// process holes from left to right
for(g.sort(r),h=0;h<g.length;h++)// find a bridge between vertices that connects hole with an outer ring and and link it
(function(t,e){if(e=// David Eberly's algorithm for finding a bridge between hole and outer polygon
function(t,e){var i,n=e,s=t.x,r=t.y,o=-1/0;// find a segment intersected by a ray from the hole's leftmost point to the left;
// segment's endpoint with lesser x will be potential connection point
do{if(r<=n.y&&r>=n.next.y&&n.next.y!==n.y){var h=n.x+(r-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(h<=s&&h>o){if(o=h,h===s){if(r===n.y)return n;if(r===n.next.y)return n.next}i=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e)if(!i)return null;if(s===o)return i.prev;// hole touches outer segment; pick lower endpoint
// look for points inside the triangle of hole point, segment intersection and endpoint;
// if there are no points found, we have a valid connection;
// otherwise choose the point of the minimum angle with the ray as connection point
var l,u=i,d=i.x,f=i.y,p=1/0;for(n=i.next;n!==u;)s>=n.x&&n.x>=d&&s!==n.x&&a(r<f?s:o,r,d,f,r<f?o:s,r,n.x,n.y)&&((l=Math.abs(r-n.y)/(s-n.x))<p||l===p&&n.x>i.x)&&c(n,t)&&(i=n,p=l),n=n.next;return i}(t,e)){var i=d(e,t);s(i,i.next)}})(g[h],i),i=s(i,i.next);return i}(t,e,S,i)),t.length>80*i){f=v=t[0],g=m=t[1];for(var E=i;E<b;E+=i)y=t[E],x=t[E+1],y<f&&(f=y),x<g&&(g=x),y>v&&(v=y),x>m&&(m=x);w=0!==// minX, minY and invSize are later used to transform coords into integers for z-order calculation
(w=Math.max(v-f,m-g))?1/w:0}return(// main ear slicing loop which triangulates a polygon (given as a linked list)
function t(e,i,n,r,f,g,v){if(e){// interlink polygon nodes in z-order
!v&&g&&// interlink polygon nodes in z-order
function(t,e,i,n){var s=t;do null===s.z&&(s.z=o(s.x,s.y,e,i,n)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==t)s.prevZ.nextZ=null,s.prevZ=null,// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function(t){var e,i,n,s,r,o,a,h,l=1;do{for(i=t,t=null,r=null,o=0;i;){for(o++,n=i,a=0,e=0;e<l&&(a++,n=n.nextZ);e++);for(h=l;a>0||h>0&&n;)0!==a&&(0===h||!n||i.z<=n.z)?(s=i,i=i.nextZ,a--):(s=n,n=n.nextZ,h--),r?r.nextZ=s:t=s,s.prevZ=r,r=s;i=n}r.nextZ=null,l*=2}while(o>1)}(s)}(e,r,f,g);// iterate through ears, slicing them one by one
for(var m,y,x=e;e.prev!==e.next;){if(m=e.prev,y=e.next,g?function(t,e,i,n){var s=t.prev,r=t.next;if(h(s,t,r)>=0)return!1;// reflex, can't be an ear
// look for points inside the triangle in both directions
for(// triangle bbox; min & max are calculated like this for speed
var l=s.x<t.x?s.x<r.x?s.x:r.x:t.x<r.x?t.x:r.x,u=s.y<t.y?s.y<r.y?s.y:r.y:t.y<r.y?t.y:r.y,c=s.x>t.x?s.x>r.x?s.x:r.x:t.x>r.x?t.x:r.x,d=s.y>t.y?s.y>r.y?s.y:r.y:t.y>r.y?t.y:r.y,f=o(l,u,e,i,n),p=o(c,d,e,i,n),g=t.prevZ,v=t.nextZ;g&&g.z>=f&&v&&v.z<=p;){if(g!==t.prev&&g!==t.next&&a(s.x,s.y,t.x,t.y,r.x,r.y,g.x,g.y)&&h(g.prev,g,g.next)>=0||(g=g.prevZ,v!==t.prev&&v!==t.next&&a(s.x,s.y,t.x,t.y,r.x,r.y,v.x,v.y)&&h(v.prev,v,v.next)>=0))return!1;v=v.nextZ}// look for remaining points in decreasing z-order
for(;g&&g.z>=f;){if(g!==t.prev&&g!==t.next&&a(s.x,s.y,t.x,t.y,r.x,r.y,g.x,g.y)&&h(g.prev,g,g.next)>=0)return!1;g=g.prevZ}// look for remaining points in increasing z-order
for(;v&&v.z<=p;){if(v!==t.prev&&v!==t.next&&a(s.x,s.y,t.x,t.y,r.x,r.y,v.x,v.y)&&h(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}(e,r,f,g):// check whether a polygon node forms a valid ear with adjacent nodes
function(t){var e=t.prev,i=t.next;if(h(e,t,i)>=0)return!1;// reflex, can't be an ear
for(// now make sure we don't have other points inside the potential ear
var n=t.next.next;n!==t.prev;){if(a(e.x,e.y,t.x,t.y,i.x,i.y,n.x,n.y)&&h(n.prev,n,n.next)>=0)return!1;n=n.next}return!0}(e)){// cut off the triangle
i.push(m.i/n),i.push(e.i/n),i.push(y.i/n),p(e),// skipping the next vertex leads to less sliver triangles
e=y.next,x=y.next;continue}// if we looped through the whole remaining polygon and can't find any more ears
if((e=y)===x){// try filtering points and slicing again
v?1===v?t(e=// go through all polygon nodes and cure small local self-intersections
function(t,e,i){var n=t;do{var s=n.prev,r=n.next.next;!l(s,r)&&u(s,n,n.next,r)&&c(s,r)&&c(r,s)&&(e.push(s.i/i),e.push(n.i/i),e.push(r.i/i),// remove two nodes involved
p(n),p(n.next),n=t=r),n=n.next}while(n!==t)return n}(e,i,n),i,n,r,f,g,2):2===v&&// try splitting polygon into two and triangulate them independently
function(e,i,n,r,o,a){// look for a valid diagonal that divides the polygon into two
var h=e;do{for(var l,f,p=h.next.next;p!==h.prev;){if(h.i!==p.i&&(l=h,f=p,l.next.i!==f.i&&l.prev.i!==f.i&&!// check if a polygon diagonal intersects any polygon segments
function(t,e){var i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==e.i&&i.next.i!==e.i&&u(i,i.next,t,e))return!0;i=i.next}while(i!==t)return!1}(l,f)&&c(l,f)&&c(f,l)&&// check if the middle point of a polygon diagonal is inside the polygon
function(t,e){var i=t,n=!1,s=(t.x+e.x)/2,r=(t.y+e.y)/2;do i.y>r!=i.next.y>r&&i.next.y!==i.y&&s<(i.next.x-i.x)*(r-i.y)/(i.next.y-i.y)+i.x&&(n=!n),i=i.next;while(i!==t)return n}(l,f))){// split the polygon in two by the diagonal
var g=d(h,p);// filter collinear points around the cuts
h=s(h,h.next),g=s(g,g.next),// run earcut on each half
t(h,i,n,r,o,a),t(g,i,n,r,o,a);return}p=p.next}h=h.next}while(h!==e)}(e,i,n,r,f,g):t(s(e),i,n,r,f,g,1);break}}}}(S,A,i,f,g,w),A)}// create a circular doubly linked list from polygon points in the specified winding order
function n(t,e,i,n,s){var r,o;if(s===v(t,e,i,n)>0)for(r=e;r<i;r+=n)o=f(r,t[r],t[r+1],o);else for(r=i-n;r>=e;r-=n)o=f(r,t[r],t[r+1],o);return o&&l(o,o.next)&&(p(o),o=o.next),o}// eliminate collinear or duplicate points
function s(t,e){if(!t)return t;e||(e=t);var i,n=t;do if(i=!1,!n.steiner&&(l(n,n.next)||0===h(n.prev,n,n.next))){if(p(n),(n=e=n.prev)===n.next)break;i=!0}else n=n.next;while(i||n!==e)return e}function r(t,e){return t.x-e.x}// z-order of a point given coords and inverse of the longer side of data bbox
function o(t,e,i,n,s){return(t=((t=((t=((t=(// coords are transformed into non-negative 15-bit integer range
(t=32767*(t-i)*s)|t<<8)&16711935)|t<<4)&252645135)|t<<2)&858993459)|t<<1)&1431655765)|(e=((e=((e=((e=((e=32767*(e-n)*s)|e<<8)&16711935)|e<<4)&252645135)|e<<2)&858993459)|e<<1)&1431655765)<<1}// check if a point lies within a convex triangle
function a(t,e,i,n,s,r,o,a){return(s-o)*(e-a)-(t-o)*(r-a)>=0&&(t-o)*(n-a)-(i-o)*(e-a)>=0&&(i-o)*(r-a)-(s-o)*(n-a)>=0}// signed area of a triangle
function h(t,e,i){return(e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y)}// check if two points are equal
function l(t,e){return t.x===e.x&&t.y===e.y}// check if two segments intersect
function u(t,e,i,n){return!!(l(t,e)&&l(i,n)||l(t,n)&&l(i,e))||h(t,e,i)>0!=h(t,e,n)>0&&h(i,n,t)>0!=h(i,n,e)>0}// check if a polygon diagonal is locally inside the polygon
function c(t,e){return 0>h(t.prev,t,t.next)?h(t,e,t.next)>=0&&h(t,t.prev,e)>=0:0>h(t,e,t.prev)||0>h(t,t.next,e)}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function d(t,e){var i=new g(t.i,t.x,t.y),n=new g(e.i,e.x,e.y),s=t.next,r=e.prev;return t.next=e,e.prev=t,i.next=s,s.prev=i,n.next=i,i.prev=n,r.next=n,n.prev=r,n}// create a node and optionally link it with previous one (in a circular doubly linked list)
function f(t,e,i,n){var s=new g(t,e,i);return n?(s.next=n.next,s.prev=n,n.next.prev=s,n.next=s):(s.prev=s,s.next=s),s}function p(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function g(t,e,i){// vertex index in coordinates array
this.i=t,// vertex coordinates
this.x=e,this.y=i,// previous and next vertex nodes in a polygon ring
this.prev=null,this.next=null,// z-order curve value
this.z=null,// previous and next nodes in z-order
this.prevZ=null,this.nextZ=null,// indicates whether this is a steiner point
this.steiner=!1}function v(t,e,i,n){for(var s=0,r=e,o=i-n;r<i;r+=n)s+=(t[o]-t[r])*(t[r+1]+t[o+1]),o=r;return s}t.exports=i,// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
i.deviation=function(t,e,i,n){var s=e&&e.length,r=s?e[0]*i:t.length,o=Math.abs(v(t,0,r,i));if(s)for(var a=0,h=e.length;a<h;a++){var l=e[a]*i,u=a<h-1?e[a+1]*i:t.length;o-=Math.abs(v(t,l,u,i))}var c=0;for(a=0;a<n.length;a+=3){var d=n[a]*i,f=n[a+1]*i,p=n[a+2]*i;c+=Math.abs((t[d]-t[p])*(t[f+1]-t[d+1])-(t[d]-t[f])*(t[p+1]-t[d+1]))}return 0===o&&0===c?0:Math.abs((c-o)/o)},// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
i.flatten=function(t){for(var e=t[0][0].length,i={vertices:[],holes:[],dimensions:e},n=0,s=0;s<t.length;s++){for(var r=0;r<t[s].length;r++)for(var o=0;o<e;o++)i.vertices.push(t[s][r][o]);s>0&&(n+=t[s-1].length,i.holes.push(n))}return i}}),r("g1JCF",function(t,e){t.exports={/**
     * Dirty flag for checking if model matrix needs to be updated on GPU.
     * 
     * @name Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#modelMatrixDirty
     * @type {boolean}
     * @since 3.0.0
     */modelMatrixDirty:!1,/**
     * Dirty flag for checking if view matrix needs to be updated on GPU.
     * 
     * @name Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#viewMatrixDirty
     * @type {boolean}
     * @since 3.0.0
     */viewMatrixDirty:!1,/**
     * Dirty flag for checking if projection matrix needs to be updated on GPU.
     * 
     * @name Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#projectionMatrixDirty
     * @type {boolean}
     * @since 3.0.0
     */projectionMatrixDirty:!1,/**
     * Model matrix
     * 
     * @name Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#modelMatrix
     * @type {?Float32Array}
     * @since 3.0.0
     */modelMatrix:null,/**
     * View matrix
     * 
     * @name Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#viewMatrix
     * @type {?Float32Array}
     * @since 3.0.0
     */viewMatrix:null,/**
     * Projection matrix
     * 
     * @name Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#projectionMatrix
     * @type {?Float32Array}
     * @since 3.0.0
     */projectionMatrix:null,/**
     * Initializes MVP matrices with an identity matrix
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#mvpInit
     * @since 3.0.0
     */mvpInit:function(){return this.modelMatrixDirty=!0,this.viewMatrixDirty=!0,this.projectionMatrixDirty=!0,this.modelMatrix=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.viewMatrix=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.projectionMatrix=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this},/**
     * If dirty flags are set then the matrices are uploaded to the GPU.
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#mvpUpdate
     * @since 3.0.0
     */mvpUpdate:function(){var t=this.program;return this.modelMatrixDirty&&(this.renderer.setMatrix4(t,"uModelMatrix",!1,this.modelMatrix),this.modelMatrixDirty=!1),this.viewMatrixDirty&&(this.renderer.setMatrix4(t,"uViewMatrix",!1,this.viewMatrix),this.viewMatrixDirty=!1),this.projectionMatrixDirty&&(this.renderer.setMatrix4(t,"uProjectionMatrix",!1,this.projectionMatrix),this.projectionMatrixDirty=!1),this},/**
     * Loads an identity matrix to the model matrix
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#modelIdentity
     * @since 3.0.0
     */modelIdentity:function(){var t=this.modelMatrix;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this.modelMatrixDirty=!0,this},/**
     * Scale model matrix
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#modelScale
     * @since 3.0.0
     *
     * @param {number} x - The x component.
     * @param {number} y - The y component.
     * @param {number} z - The z component.
     *
     * @return {this} This Model View Projection.
     */modelScale:function(t,e,i){var n=this.modelMatrix;return n[0]=n[0]*t,n[1]=n[1]*t,n[2]=n[2]*t,n[3]=n[3]*t,n[4]=n[4]*e,n[5]=n[5]*e,n[6]=n[6]*e,n[7]=n[7]*e,n[8]=n[8]*i,n[9]=n[9]*i,n[10]=n[10]*i,n[11]=n[11]*i,this.modelMatrixDirty=!0,this},/**
     * Translate model matrix
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#modelTranslate
     * @since 3.0.0
     *
     * @param {number} x - The x component.
     * @param {number} y - The y component.
     * @param {number} z - The z component.
     *
     * @return {this} This Model View Projection.
     */modelTranslate:function(t,e,i){var n=this.modelMatrix;return n[12]=n[0]*t+n[4]*e+n[8]*i+n[12],n[13]=n[1]*t+n[5]*e+n[9]*i+n[13],n[14]=n[2]*t+n[6]*e+n[10]*i+n[14],n[15]=n[3]*t+n[7]*e+n[11]*i+n[15],this.modelMatrixDirty=!0,this},/**
     * Rotates the model matrix in the X axis.
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#modelRotateX
     * @since 3.0.0
     *
     * @param {number} radians - The amount to rotate by.
     *
     * @return {this} This Model View Projection.
     */modelRotateX:function(t){var e=this.modelMatrix,i=Math.sin(t),n=Math.cos(t),s=e[4],r=e[5],o=e[6],a=e[7],h=e[8],l=e[9],u=e[10],c=e[11];return e[4]=s*n+h*i,e[5]=r*n+l*i,e[6]=o*n+u*i,e[7]=a*n+c*i,e[8]=h*n-s*i,e[9]=l*n-r*i,e[10]=u*n-o*i,e[11]=c*n-a*i,this.modelMatrixDirty=!0,this},/**
     * Rotates the model matrix in the Y axis.
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#modelRotateY
     * @since 3.0.0
     *
     * @param {number} radians - The amount to rotate by.
     *
     * @return {this} This Model View Projection.
     */modelRotateY:function(t){var e=this.modelMatrix,i=Math.sin(t),n=Math.cos(t),s=e[0],r=e[1],o=e[2],a=e[3],h=e[8],l=e[9],u=e[10],c=e[11];return e[0]=s*n-h*i,e[1]=r*n-l*i,e[2]=o*n-u*i,e[3]=a*n-c*i,e[8]=s*i+h*n,e[9]=r*i+l*n,e[10]=o*i+u*n,e[11]=a*i+c*n,this.modelMatrixDirty=!0,this},/**
     * Rotates the model matrix in the Z axis.
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#modelRotateZ
     * @since 3.0.0
     *
     * @param {number} radians - The amount to rotate by.
     *
     * @return {this} This Model View Projection.
     */modelRotateZ:function(t){var e=this.modelMatrix,i=Math.sin(t),n=Math.cos(t),s=e[0],r=e[1],o=e[2],a=e[3],h=e[4],l=e[5],u=e[6],c=e[7];return e[0]=s*n+h*i,e[1]=r*n+l*i,e[2]=o*n+u*i,e[3]=a*n+c*i,e[4]=h*n-s*i,e[5]=l*n-r*i,e[6]=u*n-o*i,e[7]=c*n-a*i,this.modelMatrixDirty=!0,this},/**
     * Loads identity matrix into the view matrix
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#viewIdentity
     * @since 3.0.0
     *
     * @return {this} This Model View Projection.
     */viewIdentity:function(){var t=this.viewMatrix;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this.viewMatrixDirty=!0,this},/**
     * Scales view matrix
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#viewScale
     * @since 3.0.0
     *
     * @param {number} x - The x component.
     * @param {number} y - The y component.
     * @param {number} z - The z component.
     *
     * @return {this} This Model View Projection.
     */viewScale:function(t,e,i){var n=this.viewMatrix;return n[0]=n[0]*t,n[1]=n[1]*t,n[2]=n[2]*t,n[3]=n[3]*t,n[4]=n[4]*e,n[5]=n[5]*e,n[6]=n[6]*e,n[7]=n[7]*e,n[8]=n[8]*i,n[9]=n[9]*i,n[10]=n[10]*i,n[11]=n[11]*i,this.viewMatrixDirty=!0,this},/**
     * Translates view matrix
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#viewTranslate
     * @since 3.0.0
     *
     * @param {number} x - The x component.
     * @param {number} y - The y component.
     * @param {number} z - The z component.
     *
     * @return {this} This Model View Projection.
     */viewTranslate:function(t,e,i){var n=this.viewMatrix;return n[12]=n[0]*t+n[4]*e+n[8]*i+n[12],n[13]=n[1]*t+n[5]*e+n[9]*i+n[13],n[14]=n[2]*t+n[6]*e+n[10]*i+n[14],n[15]=n[3]*t+n[7]*e+n[11]*i+n[15],this.viewMatrixDirty=!0,this},/**
     * Rotates view matrix in the X axis.
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#viewRotateX
     * @since 3.0.0
     *
     * @param {number} radians - The amount to rotate by.
     *
     * @return {this} This Model View Projection.
     */viewRotateX:function(t){var e=this.viewMatrix,i=Math.sin(t),n=Math.cos(t),s=e[4],r=e[5],o=e[6],a=e[7],h=e[8],l=e[9],u=e[10],c=e[11];return e[4]=s*n+h*i,e[5]=r*n+l*i,e[6]=o*n+u*i,e[7]=a*n+c*i,e[8]=h*n-s*i,e[9]=l*n-r*i,e[10]=u*n-o*i,e[11]=c*n-a*i,this.viewMatrixDirty=!0,this},/**
     * Rotates view matrix in the Y axis.
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#viewRotateY
     * @since 3.0.0
     *
     * @param {number} radians - The amount to rotate by.
     *
     * @return {this} This Model View Projection.
     */viewRotateY:function(t){var e=this.viewMatrix,i=Math.sin(t),n=Math.cos(t),s=e[0],r=e[1],o=e[2],a=e[3],h=e[8],l=e[9],u=e[10],c=e[11];return e[0]=s*n-h*i,e[1]=r*n-l*i,e[2]=o*n-u*i,e[3]=a*n-c*i,e[8]=s*i+h*n,e[9]=r*i+l*n,e[10]=o*i+u*n,e[11]=a*i+c*n,this.viewMatrixDirty=!0,this},/**
     * Rotates view matrix in the Z axis.
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#viewRotateZ
     * @since 3.0.0
     *
     * @param {number} radians - The amount to rotate by.
     *
     * @return {this} This Model View Projection.
     */viewRotateZ:function(t){var e=this.viewMatrix,i=Math.sin(t),n=Math.cos(t),s=e[0],r=e[1],o=e[2],a=e[3],h=e[4],l=e[5],u=e[6],c=e[7];return e[0]=s*n+h*i,e[1]=r*n+l*i,e[2]=o*n+u*i,e[3]=a*n+c*i,e[4]=h*n-s*i,e[5]=l*n-r*i,e[6]=u*n-o*i,e[7]=c*n-a*i,this.viewMatrixDirty=!0,this},/**
     * Loads a 2D view matrix (3x2 matrix) into a 4x4 view matrix 
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#viewLoad2D
     * @since 3.0.0
     *
     * @param {Float32Array} matrix2D - The Matrix2D.
     *
     * @return {this} This Model View Projection.
     */viewLoad2D:function(t){var e=this.viewMatrix;return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=0,e[4]=t[2],e[5]=t[3],e[6]=0,e[7]=0,e[8]=t[4],e[9]=t[5],e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this.viewMatrixDirty=!0,this},/**
     * Copies a 4x4 matrix into the view matrix
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#viewLoad
     * @since 3.0.0
     *
     * @param {Float32Array} matrix - The Matrix2D.
     *
     * @return {this} This Model View Projection.
     */viewLoad:function(t){var e=this.viewMatrix;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],this.viewMatrixDirty=!0,this},/**
     * Loads identity matrix into the projection matrix.
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#projIdentity
     * @since 3.0.0
     *
     * @return {this} This Model View Projection.
     */projIdentity:function(){var t=this.projectionMatrix;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this.projectionMatrixDirty=!0,this},/**
     * Sets up an orthographic projection matrix
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#projOrtho
     * @since 3.0.0
     *
     * @param {number} left - The left value.
     * @param {number} right - The right value.
     * @param {number} bottom - The bottom value.
     * @param {number} top - The top value.
     * @param {number} near - The near value.
     * @param {number} far - The far value.
     *
     * @return {this} This Model View Projection.
     */projOrtho:function(t,e,i,n,s,r){var o=this.projectionMatrix,a=1/(t-e),h=1/(i-n),l=1/(s-r);return o[0]=-2*a,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=-2*h,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=2*l,o[11]=0,o[12]=(t+e)*a,o[13]=(n+i)*h,o[14]=(r+s)*l,o[15]=1,this.projectionMatrixDirty=!0,this},/**
     * Sets up a perspective projection matrix
     * 
     * @method Phaser.Renderer.WebGL.Pipelines.ModelViewProjection#projPersp
     * @since 3.0.0
     *
     * @param {number} fovY - The fov value.
     * @param {number} aspectRatio - The aspectRatio value.
     * @param {number} near - The near value.
     * @param {number} far - The far value.
     *
     * @return {this} This Model View Projection.
     */projPersp:function(t,e,i,n){var s=this.projectionMatrix,r=1/Math.tan(t/2),o=1/(i-n);return s[0]=r/e,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=r,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=(n+i)*o,s[11]=-1,s[12]=0,s[13]=0,s[14]=2*n*i*o,s[15]=0,this.projectionMatrixDirty=!0,this}}}),r("uU5DT",function(t,e){t.exports="#define SHADER_NAME PHASER_TEXTURE_TINT_FS\n\nprecision mediump float;\n\nuniform sampler2D uMainSampler;\n\nvarying vec2 outTexCoord;\nvarying float outTintEffect;\nvarying vec4 outTint;\n\nvoid main()\n{\n    vec4 texture = texture2D(uMainSampler, outTexCoord);\n    vec4 texel = vec4(outTint.rgb * outTint.a, outTint.a);\n    vec4 color = texture;\n\n    if (outTintEffect == 0.0)\n    {\n        //  Multiply texture tint\n        color = texture * texel;\n    }\n    else if (outTintEffect == 1.0)\n    {\n        //  Solid color + texture alpha\n        color.rgb = mix(texture.rgb, outTint.rgb * outTint.a, texture.a);\n        color.a = texture.a * texel.a;\n    }\n    else if (outTintEffect == 2.0)\n    {\n        //  Solid color, no texture\n        color = texel;\n    }\n\n    gl_FragColor = color;\n}\n"}),r("kaOgK",function(t,e){t.exports="#define SHADER_NAME PHASER_TEXTURE_TINT_VS\n\nprecision mediump float;\n\nuniform mat4 uProjectionMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uModelMatrix;\n\nattribute vec2 inPosition;\nattribute vec2 inTexCoord;\nattribute float inTintEffect;\nattribute vec4 inTint;\n\nvarying vec2 outTexCoord;\nvarying float outTintEffect;\nvarying vec4 outTint;\n\nvoid main ()\n{\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(inPosition, 1.0, 1.0);\n\n    outTexCoord = inTexCoord;\n    outTint = inTint;\n    outTintEffect = inTintEffect;\n}\n\n"}),r("eBujp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7BSWl"),r=s("g1JCF"),o=s("uU5DT"),a=s("kaOgK"),h=s("azs1m"),l=s("AbdBB"),u=new i({Extends:l,Mixins:[r],initialize:function(t){var e=t.renderer.config;//  Vertex Size = attribute size added together (2 + 2 + 1 + 4)
l.call(this,{game:t.game,renderer:t.renderer,gl:t.renderer.gl,topology:t.renderer.gl.TRIANGLE_STRIP,vertShader:n(t,"vertShader",a),fragShader:n(t,"fragShader",o),vertexCapacity:n(t,"vertexCapacity",6*e.batchSize),vertexSize:n(t,"vertexSize",5*Float32Array.BYTES_PER_ELEMENT+4*Uint8Array.BYTES_PER_ELEMENT),attributes:[{name:"inPosition",size:2,type:t.renderer.gl.FLOAT,normalized:!1,offset:0},{name:"inTexCoord",size:2,type:t.renderer.gl.FLOAT,normalized:!1,offset:2*Float32Array.BYTES_PER_ELEMENT},{name:"inTintEffect",size:1,type:t.renderer.gl.FLOAT,normalized:!1,offset:4*Float32Array.BYTES_PER_ELEMENT},{name:"inTint",size:4,type:t.renderer.gl.UNSIGNED_BYTE,normalized:!0,offset:5*Float32Array.BYTES_PER_ELEMENT}]}),/**
         * Float32 view of the array buffer containing the pipeline's vertices.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#vertexViewF32
         * @type {Float32Array}
         * @since 3.23.0
         */this.vertexViewF32=new Float32Array(this.vertexData),/**
         * Uint32 view of the array buffer containing the pipeline's vertices.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#vertexViewU32
         * @type {Uint32Array}
         * @since 3.23.0
         */this.vertexViewU32=new Uint32Array(this.vertexData),/**
         * Size of the batch.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#maxQuads
         * @type {integer}
         * @since 3.23.0
         */this.maxQuads=e.batchSize,/**
         * Collection of batch information
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#batches
         * @type {array}
         * @since 3.23.0
         */this.batches=[],/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#_tempMatrix1
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.23.0
         */this._tempMatrix1=new h,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#_tempMatrix2
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.23.0
         */this._tempMatrix2=new h,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#_tempMatrix3
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.23.0
         */this._tempMatrix3=new h,this.mvpInit()},/**
     * Called every time the pipeline needs to be used.
     * It binds all necessary resources.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#onBind
     * @since 3.23.0
     *
     * @return {this} This WebGLPipeline instance.
     */onBind:function(){return l.prototype.onBind.call(this),this.mvpUpdate(),this},/**
     * Resizes this pipeline and updates the projection.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#resize
     * @since 3.23.0
     *
     * @param {number} width - The new width.
     * @param {number} height - The new height.
     * @param {number} resolution - The resolution.
     *
     * @return {this} This WebGLPipeline instance.
     */resize:function(t,e,i){return l.prototype.resize.call(this,t,e,i),this.projOrtho(0,this.width,this.height,0,-1e3,1e3),this},/**
     * Assigns a texture to the current batch. If a different texture is already set it creates a new batch object.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#setTexture2D
     * @since 3.23.0
     *
     * @param {WebGLTexture} [texture] - WebGLTexture that will be assigned to the current batch. If not given uses blankTexture.
     * @param {integer} [unit=0] - Texture unit to which the texture needs to be bound.
     *
     * @return {Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline} This pipeline instance.
     */setTexture2D:function(t,e){return void 0===t&&(t=this.renderer.blankTexture.glTexture),void 0===e&&(e=0),this.requireTextureBatch(t,e)&&this.pushBatch(t,e),this},/**
     * Checks if the current batch has the same texture and texture unit, or if we need to create a new batch.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#requireTextureBatch
     * @since 3.23.0
     *
     * @param {WebGLTexture} texture - WebGLTexture that will be assigned to the current batch. If not given uses blankTexture.
     * @param {integer} unit - Texture unit to which the texture needs to be bound.
     *
     * @return {boolean} `true` if the pipeline needs to create a new batch, otherwise `false`.
     */requireTextureBatch:function(t,e){var i=this.batches,n=i.length;return!(n>0)||(e>0?i[n-1].textures[e-1]:i[n-1].texture)!==t},/**
     * Creates a new batch object and pushes it to a batch array.
     * The batch object contains information relevant to the current 
     * vertex batch like the offset in the vertex buffer, vertex count and 
     * the textures used by that batch.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#pushBatch
     * @since 3.23.0
     * 
     * @param {WebGLTexture} texture - Optional WebGLTexture that will be assigned to the created batch.
     * @param {integer} unit - Texture unit to which the texture needs to be bound.
     */pushBatch:function(t,e){if(0===e)this.batches.push({first:this.vertexCount,texture:t,textures:[]});else{var i=[];i[e-1]=t,this.batches.push({first:this.vertexCount,texture:null,textures:i})}},/**
     * Uploads the vertex data and emits a draw call for the current batch of vertices.
     *
     * @method Phaser.Renderer.WebGL.Pipelines.TextureTintStripPipeline#flush
     * @since 3.23.0
     *
     * @return {this} This WebGLPipeline instance.
     */flush:function(){if(this.flushLocked)return this;this.flushLocked=!0;var t,e,i,n=this.gl,s=this.vertexCount,r=this.topology,o=this.vertexSize,a=this.renderer,h=this.batches,l=h.length,u=0,c=null;if(0===l||0===s)return this.flushLocked=!1,this;n.bufferSubData(n.ARRAY_BUFFER,0,this.bytes.subarray(0,s*o));//  Process the TEXTURE BATCHES
for(var d=0;d<l-1;d++){//  Multi-texture check (for non-zero texture units)
if(c=h[d],t=h[d+1],c.textures.length>0){for(e=0;e<c.textures.length;++e)(i=c.textures[e])&&a.setTexture2D(i,1+e,!1);n.activeTexture(n.TEXTURE0)}u=t.first-c.first,null===c.texture||u<=0||(a.setTexture2D(c.texture,0,!1),n.drawArrays(r,c.first,u))}//  Multi-texture check (for non-zero texture units)
if(// Left over data
(c=h[l-1]).textures.length>0){for(e=0;e<c.textures.length;++e)(i=c.textures[e])&&a.setTexture2D(i,1+e,!1);n.activeTexture(n.TEXTURE0)}return u=s-c.first,c.texture&&u>0&&(a.setTexture2D(c.texture,0,!1),n.drawArrays(r,c.first,u)),this.vertexCount=0,h.length=0,this.flushLocked=!1,this}});t.exports=u}),r("aGYvp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bRAqZ");t.exports=function(t){var e=t.config;if(!e.hideBanner){var n="WebGL";e.renderType===i.CANVAS?n="Canvas":e.renderType===i.HEADLESS&&(n="Headless");var s=e.audio,r=t.device.audio;if(o=r.webAudio&&!(s&&s.disableWebAudio)?"Web Audio":s&&s.noAudio||!r.webAudio&&!r.audioData?"No Audio":"HTML5 Audio",t.device.browser.ie)window.console&&console.log("Phaser v"+i.VERSION+" / https://phaser.io");else{var o,a,h="",l=[h];Array.isArray(e.bannerBackgroundColor)?(e.bannerBackgroundColor.forEach(function(t){h=h.concat("%c "),l.push("background: "+t),a=t}),//  inject the text color
l[l.length-1]="color: "+e.bannerTextColor+"; background: "+a):(h=h.concat("%c "),l.push("color: "+e.bannerTextColor+"; background: "+e.bannerBackgroundColor)),//  URL link background color (always white)
l.push("background: #fff"),e.gameTitle&&(h=h.concat(e.gameTitle),e.gameVersion&&(h=h.concat(" v"+e.gameVersion)),e.hidePhaser||(h=h.concat(" / "))),e.hidePhaser||(h=h.concat("Phaser v"+i.VERSION+"-FB ("+n+" | "+o+")")),h=h.concat(" %c "+e.gameURL),//  Inject the new string back into the args array
l[0]=h,console.log.apply(console,l)}}}}),r("bc6Xj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("5pMDk"),r=s("13GYA"),o=s("eGwje"),a=new i({initialize:function(t,e){/**
         * A reference to the Phaser.Game instance.
         *
         * @name Phaser.Core.TimeStep#game
         * @type {Phaser.Game}
         * @readonly
         * @since 3.0.0
         */this.game=t,/**
         * The Request Animation Frame DOM Event handler.
         *
         * @name Phaser.Core.TimeStep#raf
         * @type {Phaser.DOM.RequestAnimationFrame}
         * @readonly
         * @since 3.0.0
         */this.raf=new o,/**
         * A flag that is set once the TimeStep has started running and toggled when it stops.
         *
         * @name Phaser.Core.TimeStep#started
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.0.0
         */this.started=!1,/**
         * A flag that is set once the TimeStep has started running and toggled when it stops.
         * The difference between this value and `started` is that `running` is toggled when
         * the TimeStep is sent to sleep, where-as `started` remains `true`, only changing if
         * the TimeStep is actually stopped, not just paused.
         *
         * @name Phaser.Core.TimeStep#running
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.0.0
         */this.running=!1,/**
         * The minimum fps rate you want the Time Step to run at.
         *
         * @name Phaser.Core.TimeStep#minFps
         * @type {integer}
         * @default 5
         * @since 3.0.0
         */this.minFps=n(e,"min",5),/**
         * The target fps rate for the Time Step to run at.
         *
         * Setting this value will not actually change the speed at which the browser runs, that is beyond
         * the control of Phaser. Instead, it allows you to determine performance issues and if the Time Step
         * is spiraling out of control.
         *
         * @name Phaser.Core.TimeStep#targetFps
         * @type {integer}
         * @default 60
         * @since 3.0.0
         */this.targetFps=n(e,"target",60),/**
         * The minFps value in ms.
         * Defaults to 200ms between frames (i.e. super slow!)
         *
         * @name Phaser.Core.TimeStep#_min
         * @type {number}
         * @private
         * @since 3.0.0
         */this._min=1e3/this.minFps,/**
         * The targetFps value in ms.
         * Defaults to 16.66ms between frames (i.e. normal)
         *
         * @name Phaser.Core.TimeStep#_target
         * @type {number}
         * @private
         * @since 3.0.0
         */this._target=1e3/this.targetFps,/**
         * An exponential moving average of the frames per second.
         *
         * @name Phaser.Core.TimeStep#actualFps
         * @type {integer}
         * @readonly
         * @default 60
         * @since 3.0.0
         */this.actualFps=this.targetFps,/**
         * The time at which the next fps rate update will take place.
         * When an fps update happens, the `framesThisSecond` value is reset.
         *
         * @name Phaser.Core.TimeStep#nextFpsUpdate
         * @type {integer}
         * @readonly
         * @default 0
         * @since 3.0.0
         */this.nextFpsUpdate=0,/**
         * The number of frames processed this second.
         *
         * @name Phaser.Core.TimeStep#framesThisSecond
         * @type {integer}
         * @readonly
         * @default 0
         * @since 3.0.0
         */this.framesThisSecond=0,/**
         * A callback to be invoked each time the Time Step steps.
         *
         * @name Phaser.Core.TimeStep#callback
         * @type {Phaser.Types.Core.TimeStepCallback}
         * @default NOOP
         * @since 3.0.0
         */this.callback=r,/**
         * You can force the Time Step to use Set Timeout instead of Request Animation Frame by setting
         * the `forceSetTimeOut` property to `true` in the Game Configuration object. It cannot be changed at run-time.
         *
         * @name Phaser.Core.TimeStep#forceSetTimeOut
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.0.0
         */this.forceSetTimeOut=n(e,"forceSetTimeOut",!1),/**
         * The time, calculated at the start of the current step, as smoothed by the delta value.
         *
         * @name Phaser.Core.TimeStep#time
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.time=0,/**
         * The time at which the game started running. This value is adjusted if the game is then
         * paused and resumes.
         *
         * @name Phaser.Core.TimeStep#startTime
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.startTime=0,/**
         * The time, as returned by `performance.now` of the previous step.
         *
         * @name Phaser.Core.TimeStep#lastTime
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.lastTime=0,/**
         * The current frame the game is on. This counter is incremented once every game step, regardless of how much
         * time has passed and is unaffected by delta smoothing.
         *
         * @name Phaser.Core.TimeStep#frame
         * @type {integer}
         * @readonly
         * @default 0
         * @since 3.0.0
         */this.frame=0,/**
         * Is the browser currently considered in focus by the Page Visibility API?
         * This value is set in the `blur` method, which is called automatically by the Game instance.
         *
         * @name Phaser.Core.TimeStep#inFocus
         * @type {boolean}
         * @readonly
         * @default true
         * @since 3.0.0
         */this.inFocus=!0,/**
         * The timestamp at which the game became paused, as determined by the Page Visibility API.
         *
         * @name Phaser.Core.TimeStep#_pauseTime
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._pauseTime=0,/**
         * An internal counter to allow for the browser 'cooling down' after coming back into focus.
         *
         * @name Phaser.Core.TimeStep#_coolDown
         * @type {integer}
         * @private
         * @default 0
         * @since 3.0.0
         */this._coolDown=0,/**
         * The delta time, in ms, since the last game step. This is a clamped and smoothed average value.
         *
         * @name Phaser.Core.TimeStep#delta
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.delta=0,/**
         * Internal index of the delta history position.
         *
         * @name Phaser.Core.TimeStep#deltaIndex
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.deltaIndex=0,/**
         * Internal array holding the previous delta values, used for delta smoothing.
         *
         * @name Phaser.Core.TimeStep#deltaHistory
         * @type {integer[]}
         * @since 3.0.0
         */this.deltaHistory=[],/**
         * The maximum number of delta values that are retained in order to calculate a smoothed moving average.
         * 
         * This can be changed in the Game Config via the `fps.deltaHistory` property. The default is 10.
         *
         * @name Phaser.Core.TimeStep#deltaSmoothingMax
         * @type {integer}
         * @default 10
         * @since 3.0.0
         */this.deltaSmoothingMax=n(e,"deltaHistory",10),/**
         * The number of frames that the cooldown is set to after the browser panics over the FPS rate, usually
         * as a result of switching tabs and regaining focus.
         * 
         * This can be changed in the Game Config via the `fps.panicMax` property. The default is 120.
         *
         * @name Phaser.Core.TimeStep#panicMax
         * @type {integer}
         * @default 120
         * @since 3.0.0
         */this.panicMax=n(e,"panicMax",120),/**
         * The actual elapsed time in ms between one update and the next.
         * 
         * Unlike with `delta`, no smoothing, capping, or averaging is applied to this value.
         * So please be careful when using this value in math calculations.
         *
         * @name Phaser.Core.TimeStep#rawDelta
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.rawDelta=0,/**
         * The time, as returned by `performance.now` at the very start of the current step.
         * This can differ from the `time` value in that it isn't calculated based on the delta value.
         *
         * @name Phaser.Core.TimeStep#now
         * @type {number}
         * @default 0
         * @since 3.18.0
         */this.now=0,/**
         * Apply smoothing to the delta value used within Phasers internal calculations?
         * 
         * This can be changed in the Game Config via the `fps.smoothStep` property. The default is `true`.
         * 
         * Smoothing helps settle down the delta values after browser tab switches, or other situations
         * which could cause significant delta spikes or dips. By default it has been enabled in Phaser 3
         * since the first version, but is now exposed under this property (and the corresponding game config
         * `smoothStep` value), to allow you to easily disable it, should you require.
         *
         * @name Phaser.Core.TimeStep#smoothStep
         * @type {boolean}
         * @since 3.22.0
         */this.smoothStep=n(e,"smoothStep",!0)},/**
     * Called by the Game instance when the DOM window.onBlur event triggers.
     *
     * @method Phaser.Core.TimeStep#blur
     * @since 3.0.0
     */blur:function(){this.inFocus=!1},/**
     * Called by the Game instance when the DOM window.onFocus event triggers.
     *
     * @method Phaser.Core.TimeStep#focus
     * @since 3.0.0
     */focus:function(){this.inFocus=!0,this.resetDelta()},/**
     * Called when the visibility API says the game is 'hidden' (tab switch out of view, etc)
     *
     * @method Phaser.Core.TimeStep#pause
     * @since 3.0.0
     */pause:function(){this._pauseTime=window.performance.now()},/**
     * Called when the visibility API says the game is 'visible' again (tab switch back into view, etc)
     *
     * @method Phaser.Core.TimeStep#resume
     * @since 3.0.0
     */resume:function(){this.resetDelta(),this.startTime+=this.time-this._pauseTime},/**
     * Resets the time, lastTime, fps averages and delta history.
     * Called automatically when a browser sleeps them resumes.
     *
     * @method Phaser.Core.TimeStep#resetDelta
     * @since 3.0.0
     */resetDelta:function(){var t=window.performance.now();this.time=t,this.lastTime=t,this.nextFpsUpdate=t+1e3,this.framesThisSecond=0;//  Pre-populate smoothing array
for(var e=0;e<this.deltaSmoothingMax;e++)this.deltaHistory[e]=Math.min(this._target,this.deltaHistory[e]);this.delta=0,this.deltaIndex=0,this._coolDown=this.panicMax},/**
     * Starts the Time Step running, if it is not already doing so.
     * Called automatically by the Game Boot process.
     *
     * @method Phaser.Core.TimeStep#start
     * @since 3.0.0
     *
     * @param {Phaser.Types.Core.TimeStepCallback} callback - The callback to be invoked each time the Time Step steps.
     */start:function(t){if(this.started)return this;this.started=!0,this.running=!0;for(var e=0;e<this.deltaSmoothingMax;e++)this.deltaHistory[e]=this._target;this.resetDelta(),this.startTime=window.performance.now(),this.callback=t,this.raf.start(this.step.bind(this),this.forceSetTimeOut,this._target)},/**
     * The main step method. This is called each time the browser updates, either by Request Animation Frame,
     * or by Set Timeout. It is responsible for calculating the delta values, frame totals, cool down history and more.
     * You generally should never call this method directly.
     *
     * @method Phaser.Core.TimeStep#step
     * @since 3.0.0
     */step:function(){//  Because the timestamp passed in from raf represents the beginning of the main thread frame that were currently in,
//  not the actual time now, and as we want to compare this time value against Event timeStamps and the like, we need a
//  more accurate one:
var t=window.performance.now();this.now=t;var e=t-this.lastTime;e<0&&(e=0),this.rawDelta=e;var i=this.deltaIndex,n=this.deltaHistory,s=this.deltaSmoothingMax,r=e,o=e;//  When a browser switches tab, then comes back again, it takes around 10 frames before
//  the delta time settles down so we employ a 'cooling down' period before we start
//  trusting the delta values again, to avoid spikes flooding through our delta average
if(this.smoothStep){(this._coolDown>0||!this.inFocus)&&(this._coolDown--,r=Math.min(r,this._target)),r>this._min&&//  Clamp delta to min (in case history has become corrupted somehow)
(r=Math.min(//  Probably super bad start time or browser tab context loss,
//  so use the last 'sane' dt value
r=n[i],this._min)),//  Smooth out the delta over the previous X frames
//  add the delta to the smoothing array
n[i]=r,//  adjusts the delta history array index based on the smoothing count
//  this stops the array growing beyond the size of deltaSmoothingMax
this.deltaIndex++,this.deltaIndex>s&&(this.deltaIndex=0),//  Loop the history array, adding the delta values together
o=0;for(var a=0;a<s;a++)o+=n[a];//  Then divide by the array length to get the average delta
o/=s}//  Set as the world delta value
this.delta=o,//  Real-world timer advance
this.time+=this.rawDelta,t>this.nextFpsUpdate&&(//  Compute the new exponential moving average with an alpha of 0.25.
this.actualFps=.25*this.framesThisSecond+.75*this.actualFps,this.nextFpsUpdate=t+1e3,this.framesThisSecond=0),this.framesThisSecond++;//  Interpolation - how far between what is expected and where we are?
var h=o/this._target;this.callback(t,o,h),//  Shift time value over
this.lastTime=t,this.frame++},/**
     * Manually calls `TimeStep.step`.
     *
     * @method Phaser.Core.TimeStep#tick
     * @since 3.0.0
     */tick:function(){this.step()},/**
     * Sends the TimeStep to sleep, stopping Request Animation Frame (or SetTimeout) and toggling the `running` flag to false.
     *
     * @method Phaser.Core.TimeStep#sleep
     * @since 3.0.0
     */sleep:function(){this.running&&(this.raf.stop(),this.running=!1)},/**
     * Wakes-up the TimeStep, restarting Request Animation Frame (or SetTimeout) and toggling the `running` flag to true.
     * The `seamless` argument controls if the wake-up should adjust the start time or not.
     *
     * @method Phaser.Core.TimeStep#wake
     * @since 3.0.0
     *
     * @param {boolean} [seamless=false] - Adjust the startTime based on the lastTime values.
     */wake:function(t){this.running?this.sleep():t&&(this.startTime+=-this.lastTime+(this.lastTime+window.performance.now())),this.raf.start(this.step.bind(this),this.useRAF),this.running=!0,this.step()},/**
     * Gets the duration which the game has been running, in seconds.
     *
     * @method Phaser.Core.TimeStep#getDuration
     * @since 3.17.0
     *
     * @return {number} The duration in seconds.
     */getDuration:function(){return Math.round(this.lastTime-this.startTime)/1e3},/**
     * Gets the duration which the game has been running, in ms.
     *
     * @method Phaser.Core.TimeStep#getDurationMS
     * @since 3.17.0
     *
     * @return {number} The duration in ms.
     */getDurationMS:function(){return Math.round(this.lastTime-this.startTime)},/**
     * Stops the TimeStep running.
     *
     * @method Phaser.Core.TimeStep#stop
     * @since 3.0.0
     *
     * @return {this} The TimeStep object.
     */stop:function(){return this.running=!1,this.started=!1,this.raf.stop(),this},/**
     * Destroys the TimeStep. This will stop Request Animation Frame, stop the step, clear the callbacks and null
     * any objects.
     *
     * @method Phaser.Core.TimeStep#destroy
     * @since 3.0.0
     */destroy:function(){this.stop(),this.callback=r,this.raf=null,this.game=null}});t.exports=a}),r("eGwje",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("13GYA"),r=new i({initialize:function(){/**
         * True if RequestAnimationFrame is running, otherwise false.
         *
         * @name Phaser.DOM.RequestAnimationFrame#isRunning
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.isRunning=!1,/**
         * The callback to be invoked each step.
         *
         * @name Phaser.DOM.RequestAnimationFrame#callback
         * @type {FrameRequestCallback}
         * @since 3.0.0
         */this.callback=n,/**
         * The most recent timestamp. Either a DOMHighResTimeStamp under RAF or `Date.now` under SetTimeout.
         *
         * @name Phaser.DOM.RequestAnimationFrame#tick
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.tick=0,/**
         * True if the step is using setTimeout instead of RAF.
         *
         * @name Phaser.DOM.RequestAnimationFrame#isSetTimeOut
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.isSetTimeOut=!1,/**
         * The setTimeout or RAF callback ID used when canceling them.
         *
         * @name Phaser.DOM.RequestAnimationFrame#timeOutID
         * @type {?number}
         * @default null
         * @since 3.0.0
         */this.timeOutID=null,/**
         * The previous time the step was called.
         *
         * @name Phaser.DOM.RequestAnimationFrame#lastTime
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.lastTime=0,/**
         * The target FPS rate in ms.
         * Only used when setTimeout is used instead of RAF.
         *
         * @name Phaser.DOM.RequestAnimationFrame#target
         * @type {number}
         * @default 0
         * @since 3.21.0
         */this.target=0;var t=this;/**
         * The RAF step function.
         * Updates the local tick value, invokes the callback and schedules another call to requestAnimationFrame.
         *
         * @name Phaser.DOM.RequestAnimationFrame#step
         * @type {FrameRequestCallback}
         * @since 3.0.0
         */this.step=function e(){//  Because we cannot trust the time passed to this callback from the browser and need it kept in sync with event times
var i=window.performance.now();//  DOMHighResTimeStamp
t.lastTime=t.tick,t.tick=i,t.callback(i),t.timeOutID=window.requestAnimationFrame(e)},/**
         * The SetTimeout step function.
         * Updates the local tick value, invokes the callback and schedules another call to setTimeout.
         *
         * @name Phaser.DOM.RequestAnimationFrame#stepTimeout
         * @type {function}
         * @since 3.0.0
         */this.stepTimeout=function e(){var i=Date.now(),n=Math.min(Math.max(2*t.target+t.tick-i,0),t.target);t.lastTime=t.tick,t.tick=i,t.callback(i),t.timeOutID=window.setTimeout(e,n)}},/**
     * Starts the requestAnimationFrame or setTimeout process running.
     *
     * @method Phaser.DOM.RequestAnimationFrame#start
     * @since 3.0.0
     *
     * @param {FrameRequestCallback} callback - The callback to invoke each step.
     * @param {boolean} forceSetTimeOut - Should it use SetTimeout, even if RAF is available?
     * @param {number} targetFPS - The target fps rate (in ms). Only used when setTimeout is used.
     */start:function(t,e,i){this.isRunning||(this.callback=t,this.isSetTimeOut=e,this.target=i,this.isRunning=!0,this.timeOutID=e?window.setTimeout(this.stepTimeout,0):window.requestAnimationFrame(this.step))},/**
     * Stops the requestAnimationFrame or setTimeout from running.
     *
     * @method Phaser.DOM.RequestAnimationFrame#stop
     * @since 3.0.0
     */stop:function(){this.isRunning=!1,this.isSetTimeOut?clearTimeout(this.timeOutID):window.cancelAnimationFrame(this.timeOutID)},/**
     * Stops the step from running and clears the callback reference.
     *
     * @method Phaser.DOM.RequestAnimationFrame#destroy
     * @since 3.0.0
     */destroy:function(){this.stop(),this.callback=n}});t.exports=r}),r("cEGtP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("aqcI1");t.exports=function(t){var e,n=t.events;void 0!==document.hidden?e="visibilitychange":["webkit","moz","ms"].forEach(function(t){void 0!==document[t+"Hidden"]&&(document.hidden=function(){return document[t+"Hidden"]},e=t+"visibilitychange")}),e&&document.addEventListener(e,function(t){document.hidden||"pause"===t.type?n.emit(i.HIDDEN):n.emit(i.VISIBLE)},!1),window.onblur=function(){n.emit(i.BLUR)},window.onfocus=function(){n.emit(i.FOCUS)},window.focus&&t.config.autoFocus&&window.focus()}}),r("avk0U",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Create
 */t.exports={GenerateTexture:s("gRl5V"),Palettes:s("2OPde")}}),r("gRl5V",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eU8IS"),n=s("kKoer"),r=s("5pMDk");t.exports=function(t){var e=r(t,"data",[]),s=r(t,"canvas",null),o=r(t,"palette",i),a=r(t,"pixelWidth",1),h=r(t,"pixelHeight",a),l=r(t,"resizeCanvas",!0),u=r(t,"clearCanvas",!0),c=r(t,"preRender",null),d=r(t,"postRender",null),f=Math.floor(Math.abs(e[0].length*a)),p=Math.floor(Math.abs(e.length*h));s||(s=n.create2D(this,f,p),l=!1,u=!1),l&&(s.width=f,s.height=p);var g=s.getContext("2d");u&&g.clearRect(0,0,f,p),c&&c(s,g);//  Draw it
for(var v=0;v<e.length;v++)for(var m=e[v],y=0;y<m.length;y++){var x=m[y];"."!==x&&" "!==x&&(g.fillStyle=o[x],g.fillRect(y*a,v*h,a,h))}return d&&d(s,g),s}}),r("eU8IS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * A 16 color palette by [Arne](http://androidarts.com/palette/16pal.htm)
 *
 * @name Phaser.Create.Palettes.ARNE16
 * @since 3.0.0
 *
 * @type {Phaser.Types.Create.Palette}
 */t.exports={0:"#000",1:"#9D9D9D",2:"#FFF",3:"#BE2633",4:"#E06F8B",5:"#493C2B",6:"#A46422",7:"#EB8931",8:"#F7E26B",9:"#2F484E",A:"#44891A",B:"#A3CE27",C:"#1B2632",D:"#005784",E:"#31A2F2",F:"#B2DCEF"}}),r("2OPde",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Create.Palettes
 */t.exports={ARNE16:s("eU8IS"),C64:s("6HQdH"),CGA:s("dcP4o"),JMP:s("ldJiA"),MSX:s("5cKMW")}}),r("6HQdH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * A 16 color palette inspired by the Commodore 64.
 *
 * @name Phaser.Create.Palettes.C64
 * @since 3.0.0
 *
 * @type {Phaser.Types.Create.Palette}
 */t.exports={0:"#000",1:"#fff",2:"#8b4131",3:"#7bbdc5",4:"#8b41ac",5:"#6aac41",6:"#3931a4",7:"#d5de73",8:"#945a20",9:"#5a4100",A:"#bd736a",B:"#525252",C:"#838383",D:"#acee8b",E:"#7b73de",F:"#acacac"}}),r("dcP4o",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * A 16 color CGA inspired palette by [Arne](http://androidarts.com/palette/16pal.htm)
 *
 * @name Phaser.Create.Palettes.CGA
 * @since 3.0.0
 *
 * @type {Phaser.Types.Create.Palette}
 */t.exports={0:"#000",1:"#2234d1",2:"#0c7e45",3:"#44aacc",4:"#8a3622",5:"#5c2e78",6:"#aa5c3d",7:"#b5b5b5",8:"#5e606e",9:"#4c81fb",A:"#6cd947",B:"#7be2f9",C:"#eb8a60",D:"#e23d69",E:"#ffd93f",F:"#fff"}}),r("ldJiA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * A 16 color JMP palette by [Arne](http://androidarts.com/palette/16pal.htm)
 *
 * @name Phaser.Create.Palettes.JMP
 * @since 3.0.0
 *
 * @type {Phaser.Types.Create.Palette}
 */t.exports={0:"#000",1:"#191028",2:"#46af45",3:"#a1d685",4:"#453e78",5:"#7664fe",6:"#833129",7:"#9ec2e8",8:"#dc534b",9:"#e18d79",A:"#d6b97b",B:"#e9d8a1",C:"#216c4b",D:"#d365c8",E:"#afaab9",F:"#f5f4eb"}}),r("5cKMW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * A 16 color palette inspired by Japanese computers like the MSX.
 *
 * @name Phaser.Create.Palettes.MSX
 * @since 3.0.0
 *
 * @type {Phaser.Types.Create.Palette}
 */t.exports={0:"#000",1:"#191028",2:"#46af45",3:"#a1d685",4:"#453e78",5:"#7664fe",6:"#833129",7:"#9ec2e8",8:"#dc534b",9:"#e18d79",A:"#d6b97b",B:"#e9d8a1",C:"#216c4b",D:"#d365c8",E:"#afaab9",F:"#fff"}}),r("fIfAn",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Curves
 */t.exports={Path:s("bPycw"),CubicBezier:s("j2fdY"),Curve:s("bNtX1"),Ellipse:s("i4AdP"),Line:s("ibIaQ"),QuadraticBezier:s("7qbxE"),Spline:s("l3YGt")}}),r("bPycw",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)
var i=s("jwj1g"),n=s("j2fdY"),r=s("i4AdP"),o=s("kge7H"),a=s("ibIaQ"),h=s("8wqGH"),l=s("7qbxE"),u=s("cwr8X"),c=s("l3YGt"),d=s("7SBSk"),f=s("bNtDi"),p=new i({initialize:function(t,e){void 0===t&&(t=0),void 0===e&&(e=0),/**
         * The name of this Path.
         * Empty by default and never populated by Phaser, this is left for developers to use.
         *
         * @name Phaser.Curves.Path#name
         * @type {string}
         * @default ''
         * @since 3.0.0
         */this.name="",/**
         * The list of Curves which make up this Path.
         *
         * @name Phaser.Curves.Path#curves
         * @type {Phaser.Curves.Curve[]}
         * @default []
         * @since 3.0.0
         */this.curves=[],/**
         * The cached length of each Curve in the Path.
         *
         * Used internally by {@link #getCurveLengths}.
         *
         * @name Phaser.Curves.Path#cacheLengths
         * @type {number[]}
         * @default []
         * @since 3.0.0
         */this.cacheLengths=[],/**
         * Automatically closes the path.
         *
         * @name Phaser.Curves.Path#autoClose
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.autoClose=!1,/**
         * The starting point of the Path.
         *
         * This is not necessarily equivalent to the starting point of the first Curve in the Path. In an empty Path, it's also treated as the ending point.
         *
         * @name Phaser.Curves.Path#startPoint
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.startPoint=new d,/**
         * A temporary vector used to avoid object creation when adding a Curve to the Path.
         *
         * @name Phaser.Curves.Path#_tmpVec2A
         * @type {Phaser.Math.Vector2}
         * @private
         * @since 3.0.0
         */this._tmpVec2A=new d,/**
         * A temporary vector used to avoid object creation when adding a Curve to the Path.
         *
         * @name Phaser.Curves.Path#_tmpVec2B
         * @type {Phaser.Math.Vector2}
         * @private
         * @since 3.0.0
         */this._tmpVec2B=new d,"object"==typeof t?this.fromJSON(t):this.startPoint.set(t,e)},/**
     * Appends a Curve to the end of the Path.
     *
     * The Curve does not have to start where the Path ends or, for an empty Path, at its defined starting point.
     *
     * @method Phaser.Curves.Path#add
     * @since 3.0.0
     *
     * @param {Phaser.Curves.Curve} curve - The Curve to append.
     *
     * @return {this} This Path object.
     */add:function(t){return this.curves.push(t),this},/**
     * Creates a circular Ellipse Curve positioned at the end of the Path.
     *
     * @method Phaser.Curves.Path#circleTo
     * @since 3.0.0
     *
     * @param {number} radius - The radius of the circle.
     * @param {boolean} [clockwise=false] - `true` to create a clockwise circle as opposed to a counter-clockwise circle.
     * @param {number} [rotation=0] - The rotation of the circle in degrees.
     *
     * @return {this} This Path object.
     */circleTo:function(t,e,i){return void 0===e&&(e=!1),this.ellipseTo(t,t,0,360,e,i)},/**
     * Ensures that the Path is closed.
     *
     * A closed Path starts and ends at the same point. If the Path is not closed, a straight Line Curve will be created from the ending point directly to the starting point. During the check, the actual starting point of the Path, i.e. the starting point of the first Curve, will be used as opposed to the Path's defined {@link startPoint}, which could differ.
     *
     * Calling this method on an empty Path will result in an error.
     *
     * @method Phaser.Curves.Path#closePath
     * @since 3.0.0
     *
     * @return {this} This Path object.
     */closePath:function(){// Add a line curve if start and end of lines are not connected
var t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);return t.equals(e)||this.curves.push(new a(e,t)),this},/**
     * Creates a cubic bezier curve starting at the previous end point and ending at p3, using p1 and p2 as control points.
     *
     * @method Phaser.Curves.Path#cubicBezierTo
     * @since 3.0.0
     *
     * @param {(number|Phaser.Math.Vector2)} x - The x coordinate of the end point. Or, if a Vector2, the p1 value.
     * @param {(number|Phaser.Math.Vector2)} y - The y coordinate of the end point. Or, if a Vector2, the p2 value.
     * @param {(number|Phaser.Math.Vector2)} control1X - The x coordinate of the first control point. Or, if a Vector2, the p3 value.
     * @param {number} [control1Y] - The y coordinate of the first control point. Not used if Vector2s are provided as the first 3 arguments.
     * @param {number} [control2X] - The x coordinate of the second control point. Not used if Vector2s are provided as the first 3 arguments.
     * @param {number} [control2Y] - The y coordinate of the second control point. Not used if Vector2s are provided as the first 3 arguments.
     *
     * @return {this} This Path object.
     */cubicBezierTo:function(t,e,i,s,r,o){var a,h,l,u=this.getEndPoint();return t instanceof d?(a=t,h=e,l=i):(a=new d(i,s),h=new d(r,o),l=new d(t,e)),this.add(new n(u,a,h,l))},//  Creates a quadratic bezier curve starting at the previous end point and ending at p2, using p1 as a control point
/**
     * Creates a Quadratic Bezier Curve starting at the ending point of the Path.
     *
     * @method Phaser.Curves.Path#quadraticBezierTo
     * @since 3.2.0
     *
     * @param {(number|Phaser.Math.Vector2[])} x - The X coordinate of the second control point or, if it's a `Vector2`, the first control point.
     * @param {number} [y] - The Y coordinate of the second control point or, if `x` is a `Vector2`, the second control point.
     * @param {number} [controlX] - If `x` is not a `Vector2`, the X coordinate of the first control point.
     * @param {number} [controlY] - If `x` is not a `Vector2`, the Y coordinate of the first control point.
     *
     * @return {this} This Path object.
     */quadraticBezierTo:function(t,e,i,n){var s,r,o=this.getEndPoint();return t instanceof d?(s=t,r=e):(s=new d(i,n),r=new d(t,e)),this.add(new l(o,s,r))},/**
     * Draws all Curves in the Path to a Graphics Game Object.
     *
     * @method Phaser.Curves.Path#draw
     * @since 3.0.0
     *
     * @generic {Phaser.GameObjects.Graphics} G - [out,$return]
     *
     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics Game Object to draw to.
     * @param {integer} [pointsTotal=32] - The number of points to draw for each Curve. Higher numbers result in a smoother curve but require more processing.
     *
     * @return {Phaser.GameObjects.Graphics} The Graphics object which was drawn to.
     */draw:function(t,e){for(var i=0;i<this.curves.length;i++){var n=this.curves[i];n.active&&n.draw(t,e)}return t},/**
     * Creates an ellipse curve positioned at the previous end point, using the given parameters.
     *
     * @method Phaser.Curves.Path#ellipseTo
     * @since 3.0.0
     *
     * @param {number} [xRadius=0] - The horizontal radius of ellipse.
     * @param {number} [yRadius=0] - The vertical radius of ellipse.
     * @param {integer} [startAngle=0] - The start angle of the ellipse, in degrees.
     * @param {integer} [endAngle=360] - The end angle of the ellipse, in degrees.
     * @param {boolean} [clockwise=false] - Whether the ellipse angles are given as clockwise (`true`) or counter-clockwise (`false`).
     * @param {number} [rotation=0] - The rotation of the ellipse, in degrees.
     *
     * @return {this} This Path object.
     */ellipseTo:function(t,e,i,n,s,o){var a=new r(0,0,t,e,i,n,s,o),h=this.getEndPoint(this._tmpVec2A),l=a.getStartPoint(this._tmpVec2B);return h.subtract(l),a.x=h.x,a.y=h.y,this.add(a)},/**
     * Creates a Path from a Path Configuration object.
     *
     * The provided object should be a {@link Phaser.Types.Curves.JSONPath}, as returned by {@link #toJSON}. Providing a malformed object may cause errors.
     *
     * @method Phaser.Curves.Path#fromJSON
     * @since 3.0.0
     *
     * @param {Phaser.Types.Curves.JSONPath} data - The JSON object containing the Path data.
     *
     * @return {this} This Path object.
     */fromJSON:function(t){//  data should be an object matching the Path.toJSON object structure.
this.curves=[],this.cacheLengths=[],this.startPoint.set(t.x,t.y),this.autoClose=t.autoClose;for(var e=0;e<t.curves.length;e++){var i=t.curves[e];switch(i.type){case"LineCurve":this.add(a.fromJSON(i));break;case"EllipseCurve":this.add(r.fromJSON(i));break;case"SplineCurve":this.add(c.fromJSON(i));break;case"CubicBezierCurve":this.add(n.fromJSON(i));break;case"QuadraticBezierCurve":this.add(l.fromJSON(i))}}return this},/**
     * Returns a Rectangle with a position and size matching the bounds of this Path.
     *
     * @method Phaser.Curves.Path#getBounds
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {Phaser.Geom.Rectangle} [out] - The Rectangle to store the bounds in.
     * @param {integer} [accuracy=16] - The accuracy of the bounds calculations. Higher values are more accurate at the cost of calculation speed.
     *
     * @return {Phaser.Geom.Rectangle} The modified `out` Rectangle, or a new Rectangle if none was provided.
     */getBounds:function(t,e){void 0===t&&(t=new u),void 0===e&&(e=16),t.x=Number.MAX_VALUE,t.y=Number.MAX_VALUE;for(var i=new u,n=f.MIN_SAFE_INTEGER,s=f.MIN_SAFE_INTEGER,r=0;r<this.curves.length;r++){var o=this.curves[r];o.active&&(o.getBounds(i,e),t.x=Math.min(t.x,i.x),t.y=Math.min(t.y,i.y),n=Math.max(n,i.right),s=Math.max(s,i.bottom))}return t.right=n,t.bottom=s,t},/**
     * Returns an array containing the length of the Path at the end of each Curve.
     *
     * The result of this method will be cached to avoid recalculating it in subsequent calls. The cache is only invalidated when the {@link #curves} array changes in length, leading to potential inaccuracies if a Curve in the Path is changed, or if a Curve is removed and another is added in its place.
     *
     * @method Phaser.Curves.Path#getCurveLengths
     * @since 3.0.0
     *
     * @return {number[]} An array containing the length of the Path at the end of each one of its Curves.
     */getCurveLengths:function(){// We use cache values if curves and cache array are same length
if(this.cacheLengths.length===this.curves.length)return this.cacheLengths;for(var t=[],e=0,i=0;i<this.curves.length;i++)t.push(e+=this.curves[i].getLength());return this.cacheLengths=t,t},/**
     * Returns the ending point of the Path.
     *
     * A Path's ending point is equivalent to the ending point of the last Curve in the Path. For an empty Path, the ending point is at the Path's defined {@link #startPoint}.
     *
     * @method Phaser.Curves.Path#getEndPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {Phaser.Math.Vector2} [out] - The object to store the point in.
     *
     * @return {Phaser.Math.Vector2} The modified `out` object, or a new Vector2 if none was provided.
     */getEndPoint:function(t){return void 0===t&&(t=new d),this.curves.length>0?this.curves[this.curves.length-1].getPoint(1,t):t.copy(this.startPoint),t},/**
     * Returns the total length of the Path.
     *
     * @see {@link #getCurveLengths}
     *
     * @method Phaser.Curves.Path#getLength
     * @since 3.0.0
     *
     * @return {number} The total length of the Path.
     */getLength:function(){var t=this.getCurveLengths();return t[t.length-1]},// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:
// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')
/**
     * Calculates the coordinates of the point at the given normalized location (between 0 and 1) on the Path.
     *
     * The location is relative to the entire Path, not to an individual Curve. A location of 0.5 is always in the middle of the Path and is thus an equal distance away from both its starting and ending points. In a Path with one Curve, it would be in the middle of the Curve; in a Path with two Curves, it could be anywhere on either one of them depending on their lengths.
     *
     * @method Phaser.Curves.Path#getPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} t - The location of the point to return, between 0 and 1.
     * @param {Phaser.Math.Vector2} [out] - The object in which to store the calculated point.
     *
     * @return {?Phaser.Math.Vector2} The modified `out` object, or a new `Vector2` if none was provided.
     */getPoint:function(t,e){void 0===e&&(e=new d);for(var i=t*this.getLength(),n=this.getCurveLengths(),s=0;s<n.length;){if(n[s]>=i){var r=n[s]-i,o=this.curves[s],a=o.getLength(),h=0===a?0:1-r/a;return o.getPointAt(h,e)}s++}// loop where sum != 0, sum > d , sum+1 <d
return null},/**
     * Get a sequence of points on the path.
     *
     * @method Phaser.Curves.Path#getPoints
     * @since 3.0.0
     *
     * @param {integer} [divisions=12] - The number of divisions per resolution per curve.
     *
     * @return {Phaser.Math.Vector2[]} An array of Vector2 objects that containing the points along the Path.
     */getPoints:function(t){void 0===t&&(t=12);for(var e,i=[],n=0;n<this.curves.length;n++){var s=this.curves[n];if(s.active)for(var r=s.getResolution(t),o=s.getPoints(r),a=0;a<o.length;a++){var h=o[a];e&&e.equals(h)||(i.push(h),e=h)}}return this.autoClose&&i.length>1&&!i[i.length-1].equals(i[0])&&i.push(i[0]),i},/**
     * Returns a randomly chosen point anywhere on the path. This follows the same rules as `getPoint` in that it may return a point on any Curve inside this path.
     *
     * When calling this method multiple times, the points are not guaranteed to be equally spaced spatially.
     *
     * @method Phaser.Curves.Path#getRandomPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {Phaser.Math.Vector2} [out] - `Vector2` instance that should be used for storing the result. If `undefined` a new `Vector2` will be created.
     *
     * @return {Phaser.Math.Vector2} The modified `out` object, or a new `Vector2` if none was provided.
     */getRandomPoint:function(t){return void 0===t&&(t=new d),this.getPoint(Math.random(),t)},/**
     * Divides this Path into a set of equally spaced points,
     *
     * The resulting points are equally spaced with respect to the points' position on the path, but not necessarily equally spaced spatially.
     *
     * @method Phaser.Curves.Path#getSpacedPoints
     * @since 3.0.0
     *
     * @param {integer} [divisions=40] - The amount of points to divide this Path into.
     *
     * @return {Phaser.Math.Vector2[]} A list of the points this path was subdivided into.
     */getSpacedPoints:function(t){void 0===t&&(t=40);for(var e=[],i=0;i<=t;i++)e.push(this.getPoint(i/t));return this.autoClose&&e.push(e[0]),e},/**
     * Returns the starting point of the Path.
     *
     * @method Phaser.Curves.Path#getStartPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {Phaser.Math.Vector2} [out] - `Vector2` instance that should be used for storing the result. If `undefined` a new `Vector2` will be created.
     *
     * @return {Phaser.Math.Vector2} The modified `out` object, or a new Vector2 if none was provided.
     */getStartPoint:function(t){return void 0===t&&(t=new d),t.copy(this.startPoint)},/**
     * Gets a unit vector tangent at a relative position on the path.
     *
     * @method Phaser.Curves.Path#getTangent
     * @since 3.23.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} t - The relative position on the path, [0..1].
     * @param {Phaser.Math.Vector2} [out] - A vector to store the result in.
     *
     * @return {Phaser.Math.Vector2} Vector approximating the tangent line at the point t (delta +/- 0.0001)
     */getTangent:function(t,e){void 0===e&&(e=new d);for(var i=t*this.getLength(),n=this.getCurveLengths(),s=0;s<n.length;){if(n[s]>=i){var r=n[s]-i,o=this.curves[s],a=o.getLength(),h=0===a?0:1-r/a;return o.getTangentAt(h,e)}s++}return null},/**
     * Creates a line curve from the previous end point to x/y.
     *
     * @method Phaser.Curves.Path#lineTo
     * @since 3.0.0
     *
     * @param {(number|Phaser.Math.Vector2)} x - The X coordinate of the line's end point, or a `Vector2` containing the entire end point.
     * @param {number} [y] - The Y coordinate of the line's end point, if a number was passed as the X parameter.
     *
     * @return {this} This Path object.
     */lineTo:function(t,e){t instanceof d?this._tmpVec2B.copy(t):this._tmpVec2B.set(t,e);var i=this.getEndPoint(this._tmpVec2A);return this.add(new a([i.x,i.y,this._tmpVec2B.x,this._tmpVec2B.y]))},/**
     * Creates a spline curve starting at the previous end point, using the given points on the curve.
     *
     * @method Phaser.Curves.Path#splineTo
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2[]} points - The points the newly created spline curve should consist of.
     *
     * @return {this} This Path object.
     */splineTo:function(t){return t.unshift(this.getEndPoint()),this.add(new c(t))},/**
     * Creates a "gap" in this path from the path's current end point to the given coordinates.
     *
     * After calling this function, this Path's end point will be equal to the given coordinates
     *
     * @method Phaser.Curves.Path#moveTo
     * @since 3.0.0
     *
     * @param {(number|Phaser.Math.Vector2)} x - The X coordinate of the position to move the path's end point to, or a `Vector2` containing the entire new end point.
     * @param {number} y - The Y coordinate of the position to move the path's end point to, if a number was passed as the X coordinate.
     *
     * @return {this} This Path object.
     */moveTo:function(t,e){return t instanceof d?this.add(new h(t.x,t.y)):this.add(new h(t,e))},/**
     * Converts this Path to a JSON object containing the path information and its constituent curves.
     *
     * @method Phaser.Curves.Path#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.Curves.JSONPath} The JSON object containing this path's data.
     */toJSON:function(){for(var t=[],e=0;e<this.curves.length;e++)t.push(this.curves[e].toJSON());return{type:"Path",x:this.startPoint.x,y:this.startPoint.y,autoClose:this.autoClose,curves:t}},/**
     * cacheLengths must be recalculated.
     *
     * @method Phaser.Curves.Path#updateArcLengths
     * @since 3.0.0
     */updateArcLengths:function(){this.cacheLengths=[],this.getCurveLengths()},/**
     * Disposes of this Path, clearing its internal references to objects so they can be garbage-collected.
     *
     * @method Phaser.Curves.Path#destroy
     * @since 3.0.0
     */destroy:function(){this.curves.length=0,this.cacheLengths.length=0,this.startPoint=void 0}});/**
 * Creates a new Path Object.
 *
 * @method Phaser.GameObjects.GameObjectFactory#path
 * @since 3.0.0
 *
 * @param {number} x - The horizontal position of this Path.
 * @param {number} y - The vertical position of this Path.
 *
 * @return {Phaser.Curves.Path} The Path Object that was created.
 */o.register("path",function(t,e){return new p(t,e)}),//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
t.exports=p}),r("j2fdY",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)
var i=s("jwj1g"),n=s("2OzPP"),r=s("bNtX1"),o=s("7SBSk"),a=new i({Extends:r,initialize:function(t,e,i,n){r.call(this,"CubicBezierCurve"),Array.isArray(t)&&(n=new o(t[6],t[7]),i=new o(t[4],t[5]),e=new o(t[2],t[3]),t=new o(t[0],t[1])),/**
         * The start point of this curve.
         *
         * @name Phaser.Curves.CubicBezier#p0
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.p0=t,/**
         * The first control point of this curve.
         *
         * @name Phaser.Curves.CubicBezier#p1
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.p1=e,/**
         * The second control point of this curve.
         *
         * @name Phaser.Curves.CubicBezier#p2
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.p2=i,/**
         * The end point of this curve.
         *
         * @name Phaser.Curves.CubicBezier#p3
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.p3=n},/**
     * Gets the starting point on the curve.
     *
     * @method Phaser.Curves.CubicBezier#getStartPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.
     *
     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.
     */getStartPoint:function(t){return void 0===t&&(t=new o),t.copy(this.p0)},/**
     * Returns the resolution of this curve.
     *
     * @method Phaser.Curves.CubicBezier#getResolution
     * @since 3.0.0
     *
     * @param {number} divisions - The amount of divisions used by this curve.
     *
     * @return {number} The resolution of the curve.
     */getResolution:function(t){return t},/**
     * Get point at relative position in curve according to length.
     *
     * @method Phaser.Curves.CubicBezier#getPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.
     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.
     *
     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.
     */getPoint:function(t,e){void 0===e&&(e=new o);var i=this.p0,s=this.p1,r=this.p2,a=this.p3;return e.set(n(t,i.x,s.x,r.x,a.x),n(t,i.y,s.y,r.y,a.y))},/**
     * Draws this curve to the specified graphics object.
     *
     * @method Phaser.Curves.CubicBezier#draw
     * @since 3.0.0
     *
     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]
     *
     * @param {Phaser.GameObjects.Graphics} graphics - The graphics object this curve should be drawn to.
     * @param {integer} [pointsTotal=32] - The number of intermediary points that make up this curve. A higher number of points will result in a smoother curve.
     *
     * @return {Phaser.GameObjects.Graphics} The graphics object this curve was drawn to. Useful for method chaining.
     */draw:function(t,e){void 0===e&&(e=32);var i=this.getPoints(e);t.beginPath(),t.moveTo(this.p0.x,this.p0.y);for(var n=1;n<i.length;n++)t.lineTo(i[n].x,i[n].y);//  So you can chain graphics calls
return t.strokePath(),t},/**
     * Returns a JSON object that describes this curve.
     *
     * @method Phaser.Curves.CubicBezier#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.Curves.JSONCurve} The JSON object containing this curve data.
     */toJSON:function(){return{type:this.type,points:[this.p0.x,this.p0.y,this.p1.x,this.p1.y,this.p2.x,this.p2.y,this.p3.x,this.p3.y]}}});/**
 * Generates a curve from a JSON object.
 *
 * @function Phaser.Curves.CubicBezier.fromJSON
 * @since 3.0.0
 *
 * @param {Phaser.Types.Curves.JSONCurve} data - The JSON object containing this curve data.
 *
 * @return {Phaser.Curves.CubicBezier} The curve generated from the JSON object.
 */a.fromJSON=function(t){var e=t.points,i=new o(e[0],e[1]),n=new o(e[2],e[3]),s=new o(e[4],e[5]),r=new o(e[6],e[7]);return new a(i,n,s,r)},t.exports=a}),r("bNtX1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("1zoJ0"),r=s("cwr8X"),o=s("7SBSk"),a=new i({initialize:function(t){/**
         * String based identifier for the type of curve.
         *
         * @name Phaser.Curves.Curve#type
         * @type {string}
         * @since 3.0.0
         */this.type=t,/**
         * The default number of divisions within the curve.
         *
         * @name Phaser.Curves.Curve#defaultDivisions
         * @type {integer}
         * @default 5
         * @since 3.0.0
         */this.defaultDivisions=5,/**
         * The quantity of arc length divisions within the curve.
         *
         * @name Phaser.Curves.Curve#arcLengthDivisions
         * @type {integer}
         * @default 100
         * @since 3.0.0
         */this.arcLengthDivisions=100,/**
         * An array of cached arc length values.
         *
         * @name Phaser.Curves.Curve#cacheArcLengths
         * @type {number[]}
         * @default []
         * @since 3.0.0
         */this.cacheArcLengths=[],/**
         * Does the data of this curve need updating?
         *
         * @name Phaser.Curves.Curve#needsUpdate
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.needsUpdate=!0,/**
         * For a curve on a Path, `false` means the Path will ignore this curve.
         *
         * @name Phaser.Curves.Curve#active
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.active=!0,/**
         * A temporary calculation Vector.
         *
         * @name Phaser.Curves.Curve#_tmpVec2A
         * @type {Phaser.Math.Vector2}
         * @private
         * @since 3.0.0
         */this._tmpVec2A=new o,/**
         * A temporary calculation Vector.
         *
         * @name Phaser.Curves.Curve#_tmpVec2B
         * @type {Phaser.Math.Vector2}
         * @private
         * @since 3.0.0
         */this._tmpVec2B=new o},/**
     * Draws this curve on the given Graphics object.
     *
     * The curve is drawn using `Graphics.strokePoints` so will be drawn at whatever the present Graphics stroke color is.
     * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.
     *
     * @method Phaser.Curves.Curve#draw
     * @since 3.0.0
     *
     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]
     *
     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.
     * @param {integer} [pointsTotal=32] - The resolution of the curve. The higher the value the smoother it will render, at the cost of rendering performance.
     *
     * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.
     */draw:function(t,e){//  So you can chain graphics calls
return void 0===e&&(e=32),t.strokePoints(this.getPoints(e))},/**
     * Returns a Rectangle where the position and dimensions match the bounds of this Curve.
     *
     * You can control the accuracy of the bounds. The value given is used to work out how many points
     * to plot across the curve. Higher values are more accurate at the cost of calculation speed.
     *
     * @method Phaser.Curves.Curve#getBounds
     * @since 3.0.0
     *
     * @param {Phaser.Geom.Rectangle} [out] - The Rectangle to store the bounds in. If falsey a new object will be created.
     * @param {integer} [accuracy=16] - The accuracy of the bounds calculations.
     *
     * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.
     */getBounds:function(t,e){t||(t=new r),void 0===e&&(e=16);var i=this.getLength();e>i&&(e=i/2);//  The length of the curve in pixels
//  So we'll have 1 spaced point per 'accuracy' pixels
var s=Math.max(1,Math.round(i/e));return n(this.getSpacedPoints(s),t)},/**
     * Returns an array of points, spaced out X distance pixels apart.
     * The smaller the distance, the larger the array will be.
     *
     * @method Phaser.Curves.Curve#getDistancePoints
     * @since 3.0.0
     *
     * @param {integer} distance - The distance, in pixels, between each point along the curve.
     *
     * @return {Phaser.Geom.Point[]} An Array of Point objects.
     */getDistancePoints:function(t){var e=Math.max(1,this.getLength()/t);return this.getSpacedPoints(e)},/**
     * Get a point at the end of the curve.
     *
     * @method Phaser.Curves.Curve#getEndPoint
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} [out] - Optional Vector object to store the result in.
     *
     * @return {Phaser.Math.Vector2} Vector2 containing the coordinates of the curves end point.
     */getEndPoint:function(t){return void 0===t&&(t=new o),this.getPointAt(1,t)},/**
     * Get total curve arc length
     *
     * @method Phaser.Curves.Curve#getLength
     * @since 3.0.0
     *
     * @return {number} The total length of the curve.
     */getLength:function(){var t=this.getLengths();return t[t.length-1]},/**
     * Get a list of cumulative segment lengths.
     *
     * These lengths are
     *
     * - [0] 0
     * - [1] The first segment
     * - [2] The first and second segment
     * - ...
     * - [divisions] All segments
     *
     * @method Phaser.Curves.Curve#getLengths
     * @since 3.0.0
     *
     * @param {integer} [divisions] - The number of divisions or segments.
     *
     * @return {number[]} An array of cumulative lengths.
     */getLengths:function(t){if(void 0===t&&(t=this.arcLengthDivisions),this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var e,i=[],n=this.getPoint(0,this._tmpVec2A),s=0;i.push(0);for(var r=1;r<=t;r++)i.push(s+=(e=this.getPoint(r/t,this._tmpVec2B)).distance(n)),n.copy(e);return this.cacheArcLengths=i,i;// { sums: cache, sum:sum }; Sum is in the last element.
},// Get point at relative position in curve according to arc length
// - u [0 .. 1]
/**
     * Get a point at a relative position on the curve, by arc length.
     *
     * @method Phaser.Curves.Curve#getPointAt
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} u - The relative position, [0..1].
     * @param {Phaser.Math.Vector2} [out] - A point to store the result in.
     *
     * @return {Phaser.Math.Vector2} The point.
     */getPointAt:function(t,e){var i=this.getUtoTmapping(t);return this.getPoint(i,e)},// Get sequence of points using getPoint( t )
/**
     * Get a sequence of evenly spaced points from the curve.
     *
     * You can pass `divisions`, `stepRate`, or neither.
     *
     * The number of divisions will be
     *
     * 1. `divisions`, if `divisions` > 0; or
     * 2. `this.getLength / stepRate`, if `stepRate` > 0; or
     * 3. `this.defaultDivisions`
     *
     * `1 + divisions` points will be returned.
     *
     * @method Phaser.Curves.Curve#getPoints
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2[]} O - [out,$return]
     *
     * @param {integer} [divisions] - The number of divisions to make.
     * @param {number} [stepRate] - The curve distance between points, implying `divisions`.
     * @param {(array|Phaser.Math.Vector2[])} [out] - An optional array to store the points in.
     *
     * @return {(array|Phaser.Math.Vector2[])} An array of Points from the curve.
     */getPoints:function(t,e,i){void 0===i&&(i=[]),t||(t=e?this.getLength()/e:this.defaultDivisions);for(var n=0;n<=t;n++)i.push(this.getPoint(n/t));return i},/**
     * Get a random point from the curve.
     *
     * @method Phaser.Curves.Curve#getRandomPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {Phaser.Math.Vector2} [out] - A point object to store the result in.
     *
     * @return {Phaser.Math.Vector2} The point.
     */getRandomPoint:function(t){return void 0===t&&(t=new o),this.getPoint(Math.random(),t)},// Get sequence of points using getPointAt( u )
/**
     * Get a sequence of equally spaced points (by arc distance) from the curve.
     *
     * `1 + divisions` points will be returned.
     *
     * @method Phaser.Curves.Curve#getSpacedPoints
     * @since 3.0.0
     *
     * @param {integer} [divisions=this.defaultDivisions] - The number of divisions to make.
     * @param {number} [stepRate] - Step between points. Used to calculate the number of points to return when divisions is falsy. Ignored if divisions is positive.
     * @param {(array|Phaser.Math.Vector2[])} [out] - An optional array to store the points in.
     *
     * @return {Phaser.Math.Vector2[]} An array of points.
     */getSpacedPoints:function(t,e,i){void 0===i&&(i=[]),t||(t=e?this.getLength()/e:this.defaultDivisions);for(var n=0;n<=t;n++){var s=this.getUtoTmapping(n/t,null,t);i.push(this.getPoint(s))}return i},/**
     * Get a point at the start of the curve.
     *
     * @method Phaser.Curves.Curve#getStartPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {Phaser.Math.Vector2} [out] - A point to store the result in.
     *
     * @return {Phaser.Math.Vector2} The point.
     */getStartPoint:function(t){return void 0===t&&(t=new o),this.getPointAt(0,t)},/**
     * Get a unit vector tangent at a relative position on the curve.
     * In case any sub curve does not implement its tangent derivation,
     * 2 points a small delta apart will be used to find its gradient
     * which seems to give a reasonable approximation
     *
     * @method Phaser.Curves.Curve#getTangent
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} t - The relative position on the curve, [0..1].
     * @param {Phaser.Math.Vector2} [out] - A vector to store the result in.
     *
     * @return {Phaser.Math.Vector2} Vector approximating the tangent line at the point t (delta +/- 0.0001)
     */getTangent:function(t,e){void 0===e&&(e=new o);var i=t-1e-4,n=t+1e-4;return i<0&&(i=0),n>1&&(n=1),this.getPoint(i,this._tmpVec2A),this.getPoint(n,e),e.subtract(this._tmpVec2A).normalize()},/**
     * Get a unit vector tangent at a relative position on the curve, by arc length.
     *
     * @method Phaser.Curves.Curve#getTangentAt
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} u - The relative position on the curve, [0..1].
     * @param {Phaser.Math.Vector2} [out] - A vector to store the result in.
     *
     * @return {Phaser.Math.Vector2} The tangent vector.
     */getTangentAt:function(t,e){var i=this.getUtoTmapping(t);return this.getTangent(i,e)},/**
     * Given a distance in pixels, get a t to find p.
     *
     * @method Phaser.Curves.Curve#getTFromDistance
     * @since 3.0.0
     *
     * @param {integer} distance - The distance, in pixels.
     * @param {integer} [divisions] - Optional amount of divisions.
     *
     * @return {number} The distance.
     */getTFromDistance:function(t,e){return t<=0?0:this.getUtoTmapping(0,t,e)},/**
     * Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant.
     *
     * @method Phaser.Curves.Curve#getUtoTmapping
     * @since 3.0.0
     *
     * @param {number} u - A float between 0 and 1.
     * @param {integer} distance - The distance, in pixels.
     * @param {integer} [divisions] - Optional amount of divisions.
     *
     * @return {number} The equidistant value.
     */getUtoTmapping:function(t,e,i){var n,s,r=this.getLengths(i),o=0,a=r.length;n=e?Math.min(e,r[a-1]):t*r[a-1];for(// binary search for the index with largest value smaller than target u distance
var h=0,l=a-1;h<=l;)if((s=r[o=Math.floor(h+(l-h)/2)]-n)<0)h=o+1;else if(s>0)l=o-1;else{l=o;break}if(r[o=l]===n)return o/(a-1);// we could get finer grain at lengths, or use simple interpolation between two points
var u=r[o],c=r[o+1];// add that fractional amount to t
return(o+(n-u)/(c-u))/(a-1)},/**
     * Calculate and cache the arc lengths.
     *
     * @method Phaser.Curves.Curve#updateArcLengths
     * @since 3.0.0
     *
     * @see Phaser.Curves.Curve#getLengths()
     */updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()}});t.exports=a}),r("1zoJ0",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cwr8X"),n=s("bNtDi");t.exports=function(t,e){if(void 0===e&&(e=new i),0===t.length)return e;for(var s,r,o,a=Number.MAX_VALUE,h=Number.MAX_VALUE,l=n.MIN_SAFE_INTEGER,u=n.MIN_SAFE_INTEGER,c=0;c<t.length;c++)Array.isArray(s=t[c])?(r=s[0],o=s[1]):(r=s.x,o=s.y),a=Math.min(a,r),h=Math.min(h,o),l=Math.max(l,r),u=Math.max(u,o);return e.x=a,e.y=h,e.width=l-a,e.height=u-h,e}}),r("i4AdP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)
var i=s("jwj1g"),n=s("bNtX1"),r=s("2zqSA"),o=s("5pMDk"),a=s("dcSyA"),h=s("7SBSk"),l=new i({Extends:n,initialize:function(t,e,i,s,a,l,u,c){if("object"==typeof t){var d=t;t=o(d,"x",0),e=o(d,"y",0),i=o(d,"xRadius",0),s=o(d,"yRadius",i),a=o(d,"startAngle",0),l=o(d,"endAngle",360),u=o(d,"clockwise",!1),c=o(d,"rotation",0)}else void 0===s&&(s=i),void 0===a&&(a=0),void 0===l&&(l=360),void 0===u&&(u=!1),void 0===c&&(c=0);n.call(this,"EllipseCurve"),//  Center point
/**
         * The center point of the ellipse. Used for calculating rotation.
         *
         * @name Phaser.Curves.Ellipse#p0
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.p0=new h(t,e),/**
         * The horizontal radius of the ellipse.
         *
         * @name Phaser.Curves.Ellipse#_xRadius
         * @type {number}
         * @private
         * @since 3.0.0
         */this._xRadius=i,/**
         * The vertical radius of the ellipse.
         *
         * @name Phaser.Curves.Ellipse#_yRadius
         * @type {number}
         * @private
         * @since 3.0.0
         */this._yRadius=s,//  Radians
/**
         * The starting angle of the ellipse in radians.
         *
         * @name Phaser.Curves.Ellipse#_startAngle
         * @type {number}
         * @private
         * @since 3.0.0
         */this._startAngle=r(a),/**
         * The end angle of the ellipse in radians.
         *
         * @name Phaser.Curves.Ellipse#_endAngle
         * @type {number}
         * @private
         * @since 3.0.0
         */this._endAngle=r(l),/**
         * Anti-clockwise direction.
         *
         * @name Phaser.Curves.Ellipse#_clockwise
         * @type {boolean}
         * @private
         * @since 3.0.0
         */this._clockwise=u,/**
         * The rotation of the arc.
         *
         * @name Phaser.Curves.Ellipse#_rotation
         * @type {number}
         * @private
         * @since 3.0.0
         */this._rotation=r(c)},/**
     * Gets the starting point on the curve.
     *
     * @method Phaser.Curves.Ellipse#getStartPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.
     *
     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.
     */getStartPoint:function(t){return void 0===t&&(t=new h),this.getPoint(0,t)},/**
     * Get the resolution of the curve.
     *
     * @method Phaser.Curves.Ellipse#getResolution
     * @since 3.0.0
     *
     * @param {number} divisions - Optional divisions value.
     *
     * @return {number} The curve resolution.
     */getResolution:function(t){return 2*t},/**
     * Get point at relative position in curve according to length.
     *
     * @method Phaser.Curves.Ellipse#getPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.
     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.
     *
     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.
     */getPoint:function(t,e){void 0===e&&(e=new h);// ensures that deltaAngle is 0 .. 2 PI
for(var i=2*Math.PI,n=this._endAngle-this._startAngle,s=Math.abs(n)<Number.EPSILON;n<0;)n+=i;for(;n>i;)n-=i;n<Number.EPSILON&&(n=s?0:i),this._clockwise&&!s&&(n===i?n=-i:n-=i);var r=this._startAngle+t*n,o=this.p0.x+this._xRadius*Math.cos(r),a=this.p0.y+this._yRadius*Math.sin(r);if(0!==this._rotation){var l=Math.cos(this._rotation),u=Math.sin(this._rotation),c=o-this.p0.x,d=a-this.p0.y;// Rotate the point about the center of the ellipse.
o=c*l-d*u+this.p0.x,a=c*u+d*l+this.p0.y}return e.set(o,a)},/**
     * Sets the horizontal radius of this curve.
     *
     * @method Phaser.Curves.Ellipse#setXRadius
     * @since 3.0.0
     *
     * @param {number} value - The horizontal radius of this curve.
     *
     * @return {this} This curve object.
     */setXRadius:function(t){return this.xRadius=t,this},/**
     * Sets the vertical radius of this curve.
     *
     * @method Phaser.Curves.Ellipse#setYRadius
     * @since 3.0.0
     *
     * @param {number} value - The vertical radius of this curve.
     *
     * @return {this} This curve object.
     */setYRadius:function(t){return this.yRadius=t,this},/**
     * Sets the width of this curve.
     *
     * @method Phaser.Curves.Ellipse#setWidth
     * @since 3.0.0
     *
     * @param {number} value - The width of this curve.
     *
     * @return {this} This curve object.
     */setWidth:function(t){return this.xRadius=2*t,this},/**
     * Sets the height of this curve.
     *
     * @method Phaser.Curves.Ellipse#setHeight
     * @since 3.0.0
     *
     * @param {number} value - The height of this curve.
     *
     * @return {this} This curve object.
     */setHeight:function(t){return this.yRadius=2*t,this},/**
     * Sets the start angle of this curve.
     *
     * @method Phaser.Curves.Ellipse#setStartAngle
     * @since 3.0.0
     *
     * @param {number} value - The start angle of this curve, in radians.
     *
     * @return {this} This curve object.
     */setStartAngle:function(t){return this.startAngle=t,this},/**
     * Sets the end angle of this curve.
     *
     * @method Phaser.Curves.Ellipse#setEndAngle
     * @since 3.0.0
     *
     * @param {number} value - The end angle of this curve, in radians.
     *
     * @return {this} This curve object.
     */setEndAngle:function(t){return this.endAngle=t,this},/**
     * Sets if this curve extends clockwise or anti-clockwise.
     *
     * @method Phaser.Curves.Ellipse#setClockwise
     * @since 3.0.0
     *
     * @param {boolean} value - The clockwise state of this curve.
     *
     * @return {this} This curve object.
     */setClockwise:function(t){return this.clockwise=t,this},/**
     * Sets the rotation of this curve.
     *
     * @method Phaser.Curves.Ellipse#setRotation
     * @since 3.0.0
     *
     * @param {number} value - The rotation of this curve, in radians.
     *
     * @return {this} This curve object.
     */setRotation:function(t){return this.rotation=t,this},/**
     * The x coordinate of the center of the ellipse.
     *
     * @name Phaser.Curves.Ellipse#x
     * @type {number}
     * @since 3.0.0
     */x:{get:function(){return this.p0.x},set:function(t){this.p0.x=t}},/**
     * The y coordinate of the center of the ellipse.
     *
     * @name Phaser.Curves.Ellipse#y
     * @type {number}
     * @since 3.0.0
     */y:{get:function(){return this.p0.y},set:function(t){this.p0.y=t}},/**
     * The horizontal radius of the ellipse.
     *
     * @name Phaser.Curves.Ellipse#xRadius
     * @type {number}
     * @since 3.0.0
     */xRadius:{get:function(){return this._xRadius},set:function(t){this._xRadius=t}},/**
     * The vertical radius of the ellipse.
     *
     * @name Phaser.Curves.Ellipse#yRadius
     * @type {number}
     * @since 3.0.0
     */yRadius:{get:function(){return this._yRadius},set:function(t){this._yRadius=t}},/**
     * The start angle of the ellipse in degrees.
     *
     * @name Phaser.Curves.Ellipse#startAngle
     * @type {number}
     * @since 3.0.0
     */startAngle:{get:function(){return a(this._startAngle)},set:function(t){this._startAngle=r(t)}},/**
     * The end angle of the ellipse in degrees.
     *
     * @name Phaser.Curves.Ellipse#endAngle
     * @type {number}
     * @since 3.0.0
     */endAngle:{get:function(){return a(this._endAngle)},set:function(t){this._endAngle=r(t)}},/**
     * `true` if the ellipse rotation is clockwise or `false` if anti-clockwise.
     *
     * @name Phaser.Curves.Ellipse#clockwise
     * @type {boolean}
     * @since 3.0.0
     */clockwise:{get:function(){return this._clockwise},set:function(t){this._clockwise=t}},/**
     * The rotation of the ellipse, relative to the center, in degrees.
     *
     * @name Phaser.Curves.Ellipse#angle
     * @type {number}
     * @since 3.14.0
     */angle:{get:function(){return a(this._rotation)},set:function(t){this._rotation=r(t)}},/**
     * The rotation of the ellipse, relative to the center, in radians.
     *
     * @name Phaser.Curves.Ellipse#rotation
     * @type {number}
     * @since 3.0.0
     */rotation:{get:function(){return this._rotation},set:function(t){this._rotation=t}},/**
     * JSON serialization of the curve.
     *
     * @method Phaser.Curves.Ellipse#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.Curves.JSONEllipseCurve} The JSON object containing this curve data.
     */toJSON:function(){return{type:this.type,x:this.p0.x,y:this.p0.y,xRadius:this._xRadius,yRadius:this._yRadius,startAngle:a(this._startAngle),endAngle:a(this._endAngle),clockwise:this._clockwise,rotation:a(this._rotation)}}});/**
 * Creates a curve from the provided Ellipse Curve Configuration object.
 *
 * @function Phaser.Curves.Ellipse.fromJSON
 * @since 3.0.0
 *
 * @param {Phaser.Types.Curves.JSONEllipseCurve} data - The JSON object containing this curve data.
 *
 * @return {Phaser.Curves.Ellipse} The ellipse curve constructed from the configuration object.
 */l.fromJSON=function(t){return new l(t)},t.exports=l}),r("kge7H",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7AzQW"),r=s("4rtgc"),o=new i({initialize:function(t){/**
         * The Scene to which this Game Object Factory belongs.
         *
         * @name Phaser.GameObjects.GameObjectFactory#scene
         * @type {Phaser.Scene}
         * @protected
         * @since 3.0.0
         */this.scene=t,/**
         * A reference to the Scene.Systems.
         *
         * @name Phaser.GameObjects.GameObjectFactory#systems
         * @type {Phaser.Scenes.Systems}
         * @protected
         * @since 3.0.0
         */this.systems=t.sys,/**
         * A reference to the Scene Display List.
         *
         * @name Phaser.GameObjects.GameObjectFactory#displayList
         * @type {Phaser.GameObjects.DisplayList}
         * @protected
         * @since 3.0.0
         */this.displayList,/**
         * A reference to the Scene Update List.
         *
         * @name Phaser.GameObjects.GameObjectFactory#updateList
         * @type {Phaser.GameObjects.UpdateList}
         * @protected
         * @since 3.0.0
         */this.updateList,t.sys.events.once(r.BOOT,this.boot,this),t.sys.events.on(r.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.GameObjects.GameObjectFactory#boot
     * @private
     * @since 3.5.1
     */boot:function(){this.displayList=this.systems.displayList,this.updateList=this.systems.updateList,this.systems.events.once(r.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.GameObjects.GameObjectFactory#start
     * @private
     * @since 3.5.0
     */start:function(){this.systems.events.once(r.SHUTDOWN,this.shutdown,this)},/**
     * Adds an existing Game Object to this Scene.
     *
     * If the Game Object renders, it will be added to the Display List.
     * If it has a `preUpdate` method, it will be added to the Update List.
     *
     * @method Phaser.GameObjects.GameObjectFactory#existing
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.Group)} child - The child to be added to this Scene.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that was added.
     */existing:function(t){return(t.renderCanvas||t.renderWebGL)&&this.displayList.add(t),t.preUpdate&&this.updateList.add(t),t},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.GameObjects.GameObjectFactory#shutdown
     * @private
     * @since 3.0.0
     */shutdown:function(){this.systems.events.off(r.SHUTDOWN,this.shutdown,this)},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.GameObjects.GameObjectFactory#destroy
     * @private
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.scene.sys.events.off(r.START,this.start,this),this.scene=null,this.systems=null,this.displayList=null,this.updateList=null}});/**
 * Static method called directly by the Game Object factory functions.
 * With this method you can register a custom GameObject factory in the GameObjectFactory,
 * providing a name (`factoryType`) and the constructor (`factoryFunction`) in order
 * to be called when you call to Phaser.Scene.add[ factoryType ] method.
 *
 * @method Phaser.GameObjects.GameObjectFactory.register
 * @static
 * @since 3.0.0
 *
 * @param {string} factoryType - The key of the factory that you will use to call to Phaser.Scene.add[ factoryType ] method.
 * @param {function} factoryFunction - The constructor function to be called when you invoke to the Phaser.Scene.add method.
 */o.register=function(t,e){o.prototype.hasOwnProperty(t)||(o.prototype[t]=e)},/**
 * Static method called directly by the Game Object factory functions.
 * With this method you can remove a custom GameObject factory registered in the GameObjectFactory,
 * providing a its `factoryType`.
 *
 * @method Phaser.GameObjects.GameObjectFactory.remove
 * @static
 * @since 3.0.0
 *
 * @param {string} factoryType - The key of the factory that you want to remove from the GameObjectFactory.
 */o.remove=function(t){o.prototype.hasOwnProperty(t)&&delete o.prototype[t]},n.register("GameObjectFactory",o,"add"),t.exports=o}),r("ibIaQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)
var i=s("jwj1g"),n=s("bNtX1"),r=s("1zoJ0"),o=s("cwr8X"),a=s("7SBSk"),h=new a,l=new i({Extends:n,initialize:function(t,e){n.call(this,"LineCurve"),Array.isArray(t)&&(e=new a(t[2],t[3]),t=new a(t[0],t[1])),/**
         * The first endpoint.
         *
         * @name Phaser.Curves.Line#p0
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.p0=t,/**
         * The second endpoint.
         *
         * @name Phaser.Curves.Line#p1
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.p1=e,//  Override default Curve.arcLengthDivisions
/**
         * The quantity of arc length divisions within the curve.
         *
         * @name Phaser.Curves.Line#arcLengthDivisions
         * @type {integer}
         * @default 1
         * @since 3.0.0
         */this.arcLengthDivisions=1},/**
     * Returns a Rectangle where the position and dimensions match the bounds of this Curve.
     *
     * @method Phaser.Curves.Line#getBounds
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Rectangle} O - [out,$return]
     *
     * @param {Phaser.Geom.Rectangle} [out] - A Rectangle object to store the bounds in. If not given a new Rectangle will be created.
     *
     * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.
     */getBounds:function(t){return void 0===t&&(t=new o),r([this.p0,this.p1],t)},/**
     * Gets the starting point on the curve.
     *
     * @method Phaser.Curves.Line#getStartPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.
     *
     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.
     */getStartPoint:function(t){return void 0===t&&(t=new a),t.copy(this.p0)},/**
     * Gets the resolution of the line.
     *
     * @method Phaser.Curves.Line#getResolution
     * @since 3.0.0
     *
     * @param {number} [divisions=1] - The number of divisions to consider.
     *
     * @return {number} The resolution. Equal to the number of divisions.
     */getResolution:function(t){return void 0===t&&(t=1),t},/**
     * Get point at relative position in curve according to length.
     *
     * @method Phaser.Curves.Line#getPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.
     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.
     *
     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.
     */getPoint:function(t,e){return(void 0===e&&(e=new a),1===t)?e.copy(this.p1):(e.copy(this.p1).subtract(this.p0).scale(t).add(this.p0),e)},// Line curve is linear, so we can overwrite default getPointAt
/**
     * Gets a point at a given position on the line.
     *
     * @method Phaser.Curves.Line#getPointAt
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} u - The position along the curve to return. Where 0 is the start and 1 is the end.
     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.
     *
     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.
     */getPointAt:function(t,e){return this.getPoint(t,e)},/**
     * Gets the slope of the line as a unit vector.
     *
     * @method Phaser.Curves.Line#getTangent
     * @since 3.0.0
     * 
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @return {Phaser.Math.Vector2} The tangent vector.
     */getTangent:function(){return h.copy(this.p1).subtract(this.p0).normalize()},/**
     * Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant.
     *
     * @method Phaser.Curves.Line#getUtoTmapping
     * @since 3.0.0
     *
     * @param {number} u - A float between 0 and 1.
     * @param {integer} distance - The distance, in pixels.
     * @param {integer} [divisions] - Optional amount of divisions.
     *
     * @return {number} The equidistant value.
     */getUtoTmapping:function(t,e,i){var n;if(e){var s=this.getLengths(i),r=s[s.length-1];n=Math.min(e,r)/r}else n=t;return n},//  Override default Curve.draw because this is better than calling getPoints on a line!
/**
     * Draws this curve on the given Graphics object.
     *
     * The curve is drawn using `Graphics.lineBetween` so will be drawn at whatever the present Graphics line color is.
     * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.
     *
     * @method Phaser.Curves.Line#draw
     * @since 3.0.0
     *
     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]
     *
     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.
     *
     * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.
     */draw:function(t){//  So you can chain graphics calls
return t.lineBetween(this.p0.x,this.p0.y,this.p1.x,this.p1.y),t},/**
     * Gets a JSON representation of the line.
     *
     * @method Phaser.Curves.Line#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.Curves.JSONCurve} The JSON object containing this curve data.
     */toJSON:function(){return{type:this.type,points:[this.p0.x,this.p0.y,this.p1.x,this.p1.y]}}});/**
 * Configures this line from a JSON representation.
 *
 * @function Phaser.Curves.Line.fromJSON
 * @since 3.0.0
 *
 * @param {Phaser.Types.Curves.JSONCurve} data - The JSON object containing this curve data.
 *
 * @return {Phaser.Curves.Line} A new LineCurve object.
 */l.fromJSON=function(t){var e=t.points,i=new a(e[0],e[1]),n=new a(e[2],e[3]);return new l(i,n)},t.exports=l}),r("8wqGH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7SBSk"),r=new i({initialize:function(t,e){//  Skip length calcs in paths
/**
         * Denotes that this Curve does not influence the bounds, points, and drawing of its parent Path. Must be `false` or some methods in the parent Path will throw errors.
         *
         * @name Phaser.Curves.MoveTo#active
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.active=!1,/**
         * The lone point which this curve consists of.
         *
         * @name Phaser.Curves.MoveTo#p0
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.p0=new n(t,e)},/**
     * Get point at relative position in curve according to length.
     *
     * @method Phaser.Curves.MoveTo#getPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.
     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.
     *
     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.
     */getPoint:function(t,e){return void 0===e&&(e=new n),e.copy(this.p0)},/**
     * Retrieves the point at given position in the curve. This will always return this curve's only point.
     *
     * @method Phaser.Curves.MoveTo#getPointAt
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} u - The position in the path to retrieve, between 0 and 1. Not used.
     * @param {Phaser.Math.Vector2} [out] - An optional vector in which to store the point.
     *
     * @return {Phaser.Math.Vector2} The modified `out` vector, or a new `Vector2` if none was provided.
     */getPointAt:function(t,e){return this.getPoint(t,e)},/**
     * Gets the resolution of this curve.
     *
     * @method Phaser.Curves.MoveTo#getResolution
     * @since 3.0.0
     *
     * @return {number} The resolution of this curve. For a MoveTo the value is always 1.
     */getResolution:function(){return 1},/**
     * Gets the length of this curve.
     *
     * @method Phaser.Curves.MoveTo#getLength
     * @since 3.0.0
     *
     * @return {number} The length of this curve. For a MoveTo the value is always 0.
     */getLength:function(){return 0},/**
     * Converts this curve into a JSON-serializable object.
     *
     * @method Phaser.Curves.MoveTo#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.Curves.JSONCurve} A primitive object with the curve's type and only point.
     */toJSON:function(){return{type:"MoveTo",points:[this.p0.x,this.p0.y]}}});t.exports=r}),r("7qbxE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("bNtX1"),r=s("lNAp3"),o=s("7SBSk"),a=new i({Extends:n,initialize:function(t,e,i){n.call(this,"QuadraticBezier"),Array.isArray(t)&&(i=new o(t[4],t[5]),e=new o(t[2],t[3]),t=new o(t[0],t[1])),/**
         * The start point.
         *
         * @name Phaser.Curves.QuadraticBezier#p0
         * @type {Phaser.Math.Vector2}
         * @since 3.2.0
         */this.p0=t,/**
         * The first control point.
         *
         * @name Phaser.Curves.QuadraticBezier#p1
         * @type {Phaser.Math.Vector2}
         * @since 3.2.0
         */this.p1=e,/**
         * The second control point.
         *
         * @name Phaser.Curves.QuadraticBezier#p2
         * @type {Phaser.Math.Vector2}
         * @since 3.2.0
         */this.p2=i},/**
     * Gets the starting point on the curve.
     *
     * @method Phaser.Curves.QuadraticBezier#getStartPoint
     * @since 3.2.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.
     *
     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.
     */getStartPoint:function(t){return void 0===t&&(t=new o),t.copy(this.p0)},/**
     * Get the resolution of the curve.
     *
     * @method Phaser.Curves.QuadraticBezier#getResolution
     * @since 3.2.0
     *
     * @param {number} divisions - Optional divisions value.
     *
     * @return {number} The curve resolution.
     */getResolution:function(t){return t},/**
     * Get point at relative position in curve according to length.
     *
     * @method Phaser.Curves.QuadraticBezier#getPoint
     * @since 3.2.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.
     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.
     *
     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.
     */getPoint:function(t,e){void 0===e&&(e=new o);var i=this.p0,n=this.p1,s=this.p2;return e.set(r(t,i.x,n.x,s.x),r(t,i.y,n.y,s.y))},/**
     * Draws this curve on the given Graphics object.
     *
     * The curve is drawn using `Graphics.strokePoints` so will be drawn at whatever the present Graphics stroke color is.
     * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.
     *
     * @method Phaser.Curves.QuadraticBezier#draw
     * @since 3.2.0
     *
     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]
     *
     * @param {Phaser.GameObjects.Graphics} graphics - `Graphics` object to draw onto.
     * @param {integer} [pointsTotal=32] - Number of points to be used for drawing the curve. Higher numbers result in smoother curve but require more processing.
     *
     * @return {Phaser.GameObjects.Graphics} `Graphics` object that was drawn to.
     */draw:function(t,e){void 0===e&&(e=32);var i=this.getPoints(e);t.beginPath(),t.moveTo(this.p0.x,this.p0.y);for(var n=1;n<i.length;n++)t.lineTo(i[n].x,i[n].y);//  So you can chain graphics calls
return t.strokePath(),t},/**
     * Converts the curve into a JSON compatible object.
     *
     * @method Phaser.Curves.QuadraticBezier#toJSON
     * @since 3.2.0
     *
     * @return {Phaser.Types.Curves.JSONCurve} The JSON object containing this curve data.
     */toJSON:function(){return{type:this.type,points:[this.p0.x,this.p0.y,this.p1.x,this.p1.y,this.p2.x,this.p2.y]}}});/**
 * Creates a curve from a JSON object, e. g. created by `toJSON`.
 *
 * @function Phaser.Curves.QuadraticBezier.fromJSON
 * @since 3.2.0
 *
 * @param {Phaser.Types.Curves.JSONCurve} data - The JSON object containing this curve data.
 *
 * @return {Phaser.Curves.QuadraticBezier} The created curve instance.
 */a.fromJSON=function(t){var e=t.points,i=new o(e[0],e[1]),n=new o(e[2],e[3]),s=new o(e[4],e[5]);return new a(i,n,s)},t.exports=a}),r("l3YGt",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)
var i=s("4pkLE"),n=s("jwj1g"),r=s("bNtX1"),o=s("7SBSk"),a=new n({Extends:r,initialize:function(t){void 0===t&&(t=[]),r.call(this,"SplineCurve"),/**
         * The Vector2 points that configure the curve.
         *
         * @name Phaser.Curves.Spline#points
         * @type {Phaser.Math.Vector2[]}
         * @default []
         * @since 3.0.0
         */this.points=[],this.addPoints(t)},/**
     * Add a list of points to the current list of Vector2 points of the curve.
     *
     * @method Phaser.Curves.Spline#addPoints
     * @since 3.0.0
     *
     * @param {(Phaser.Math.Vector2[]|number[]|number[][])} points - The points that configure the curve.
     *
     * @return {this} This curve object.
     */addPoints:function(t){for(var e=0;e<t.length;e++){var i=new o;"number"==typeof t[e]?(i.x=t[e],i.y=t[e+1],e++):Array.isArray(t[e])?(//  An array of arrays?
i.x=t[e][0],i.y=t[e][1]):(i.x=t[e].x,i.y=t[e].y),this.points.push(i)}return this},/**
     * Add a point to the current list of Vector2 points of the curve.
     *
     * @method Phaser.Curves.Spline#addPoint
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate of this curve
     * @param {number} y - The y coordinate of this curve
     *
     * @return {Phaser.Math.Vector2} The new Vector2 added to the curve
     */addPoint:function(t,e){var i=new o(t,e);return this.points.push(i),i},/**
     * Gets the starting point on the curve.
     *
     * @method Phaser.Curves.Spline#getStartPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.
     *
     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.
     */getStartPoint:function(t){return void 0===t&&(t=new o),t.copy(this.points[0])},/**
     * Get the resolution of the curve.
     *
     * @method Phaser.Curves.Spline#getResolution
     * @since 3.0.0
     *
     * @param {number} divisions - Optional divisions value.
     *
     * @return {number} The curve resolution.
     */getResolution:function(t){return t*this.points.length},/**
     * Get point at relative position in curve according to length.
     *
     * @method Phaser.Curves.Spline#getPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Math.Vector2} O - [out,$return]
     *
     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.
     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.
     *
     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.
     */getPoint:function(t,e){void 0===e&&(e=new o);var n=this.points,s=(n.length-1)*t,r=Math.floor(s),a=s-r,h=n[0===r?r:r-1],l=n[r],u=n[r>n.length-2?n.length-1:r+1],c=n[r>n.length-3?n.length-1:r+2];return e.set(i(a,h.x,l.x,u.x,c.x),i(a,h.y,l.y,u.y,c.y))},/**
     * Exports a JSON object containing this curve data.
     *
     * @method Phaser.Curves.Spline#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.Curves.JSONCurve} The JSON object containing this curve data.
     */toJSON:function(){for(var t=[],e=0;e<this.points.length;e++)t.push(this.points[e].x),t.push(this.points[e].y);return{type:this.type,points:t}}});/**
 * Imports a JSON object containing this curve data.
 *
 * @function Phaser.Curves.Spline.fromJSON
 * @since 3.0.0
 *
 * @param {Phaser.Types.Curves.JSONCurve} data - The JSON object containing this curve data.
 *
 * @return {Phaser.Curves.Spline} The spline curve created.
 */a.fromJSON=function(t){return new a(t.points)},t.exports=a}),r("fvFEG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Data
 */t.exports={DataManager:s("ewzDY"),DataManagerPlugin:s("1xQQd"),Events:s("jKmu9")}}),r("1xQQd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("ewzDY"),r=s("7AzQW"),o=s("4rtgc"),a=new i({Extends:n,initialize:function(t){n.call(this,t,t.sys.events),/**
         * A reference to the Scene that this DataManager belongs to.
         *
         * @name Phaser.Data.DataManagerPlugin#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * A reference to the Scene's Systems.
         *
         * @name Phaser.Data.DataManagerPlugin#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,t.sys.events.once(o.BOOT,this.boot,this),t.sys.events.on(o.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.Data.DataManagerPlugin#boot
     * @private
     * @since 3.5.1
     */boot:function(){this.events=this.systems.events,this.events.once(o.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.Data.DataManagerPlugin#start
     * @private
     * @since 3.5.0
     */start:function(){this.events.once(o.SHUTDOWN,this.shutdown,this)},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.Data.DataManagerPlugin#shutdown
     * @private
     * @since 3.5.0
     */shutdown:function(){this.systems.events.off(o.SHUTDOWN,this.shutdown,this)},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.Data.DataManagerPlugin#destroy
     * @since 3.5.0
     */destroy:function(){n.prototype.destroy.call(this),this.events.off(o.START,this.start,this),this.scene=null,this.systems=null}});r.register("DataManagerPlugin",a,"data"),t.exports=a}),r("g2mK1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Display
 */t.exports={Align:s("8WKjk"),BaseShader:s("dtVn6"),Bounds:s("bPXBb"),Canvas:s("4V4gt"),Color:s("dqWRJ"),Masks:s("7QACF")}}),r("8WKjk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hPWXH"),n=s("hVk4C"),r={In:s("4FNJt"),To:s("h6oXX")};//   Merge in the consts
r=n(!1,r,i),t.exports=r}),r("4FNJt",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Display.Align.In
 */t.exports={BottomCenter:s("bI66X"),BottomLeft:s("9aKJT"),BottomRight:s("57VIW"),Center:s("8OPIk"),LeftCenter:s("lCav5"),QuickSet:s("lW6Z2"),RightCenter:s("d4CDm"),TopCenter:s("aBZ2v"),TopLeft:s("jIofi"),TopRight:s("gVJ1b")}}),r("h6oXX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Display.Align.To
 */t.exports={BottomCenter:s("7V1sp"),BottomLeft:s("hUnFl"),BottomRight:s("hyRjB"),LeftBottom:s("fNGut"),LeftCenter:s("1LQnW"),LeftTop:s("fPpzE"),QuickSet:s("g6HRX"),RightBottom:s("7d2qQ"),RightCenter:s("lavD1"),RightTop:s("suJhd"),TopCenter:s("hjjdG"),TopLeft:s("5H3NR"),TopRight:s("6Cewx")}}),r("dtVn6",function(t,e){/**
 * @classdesc
 * A BaseShader is a small resource class that contains the data required for a WebGL Shader to be created.
 * 
 * It contains the raw source code to the fragment and vertex shader, as well as an object that defines
 * the uniforms the shader requires, if any.
 * 
 * BaseShaders are stored in the Shader Cache, available in a Scene via `this.cache.shaders` and are referenced
 * by a unique key-based string. Retrieve them via `this.cache.shaders.get(key)`.
 * 
 * BaseShaders are created automatically by the GLSL File Loader when loading an external shader resource.
 * They can also be created at runtime, allowing you to use dynamically generated shader source code.
 * 
 * Default fragment and vertex source is used if not provided in the constructor, setting-up a basic shader,
 * suitable for debug rendering.
 *
 * @class BaseShader
 * @memberof Phaser.Display
 * @constructor
 * @since 3.17.0
 *
 * @param {string} key - The key of this shader. Must be unique within the shader cache.
 * @param {string} [fragmentSrc] - The fragment source for the shader.
 * @param {string} [vertexSrc] - The vertex source for the shader.
 * @param {any} [uniforms] - Optional object defining the uniforms the shader uses.
 */var i=new(s("jwj1g"))({initialize:function(t,e,i,n){e&&""!==e||(e="precision mediump float;\nuniform vec2 resolution;\nvarying vec2 fragCoord;\nvoid main () {\n    vec2 uv = fragCoord / resolution.xy;\n    gl_FragColor = vec4(uv.xyx, 1.0);\n}"),i&&""!==i||(i="precision mediump float;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uViewMatrix;\nuniform vec2 uResolution;\nattribute vec2 inPosition;\nvarying vec2 fragCoord;\nvoid main () {\ngl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);\nfragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);\n}"),void 0===n&&(n=null),/**
         * The key of this shader, unique within the shader cache of this Phaser game instance.
         *
         * @name Phaser.Display.BaseShader#key
         * @type {string}
         * @since 3.17.0
         */this.key=t,/**
         * The source code, as a string, of the fragment shader being used.
         *
         * @name Phaser.Display.BaseShader#fragmentSrc
         * @type {string}
         * @since 3.17.0
         */this.fragmentSrc=e,/**
         * The source code, as a string, of the vertex shader being used.
         *
         * @name Phaser.Display.BaseShader#vertexSrc
         * @type {string}
         * @since 3.17.0
         */this.vertexSrc=i,/**
         * The default uniforms for this shader.
         *
         * @name Phaser.Display.BaseShader#uniforms
         * @type {?any}
         * @since 3.17.0
         */this.uniforms=n}});t.exports=i}),r("bPXBb",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Display.Bounds
 */t.exports={CenterOn:s("73gOb"),GetBottom:s("cWmua"),GetCenterX:s("k74fg"),GetCenterY:s("14FXn"),GetLeft:s("7Hc2m"),GetOffsetX:s("fXG4g"),GetOffsetY:s("dg84n"),GetRight:s("dD4Dr"),GetTop:s("b873I"),SetBottom:s("gNxHP"),SetCenterX:s("7ltKj"),SetCenterY:s("9L2xG"),SetLeft:s("jcMTD"),SetRight:s("4G1x9"),SetTop:s("2yhAk")}}),r("fXG4g",function(t,e){t.exports=function(t){return t.width*t.originX}}),r("dg84n",function(t,e){t.exports=function(t){return t.height*t.originY}}),r("4V4gt",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Display.Canvas
 */t.exports={CanvasInterpolation:s("9OJi8"),CanvasPool:s("kKoer"),Smoothing:s("g0MK9"),TouchAction:s("cUjum"),UserSelect:s("3pBEz")}}),r("cUjum",function(t,e){t.exports=function(t,e){return void 0===e&&(e="none"),t.style.msTouchAction=e,t.style["ms-touch-action"]=e,t.style["touch-action"]=e,t}}),r("3pBEz",function(t,e){t.exports=function(t,e){return void 0===e&&(e="none"),["-webkit-","-khtml-","-moz-","-ms-",""].forEach(function(i){t.style[i+"user-select"]=e}),t.style["-webkit-touch-callout"]=e,t.style["-webkit-tap-highlight-color"]="rgba(0, 0, 0, 0)",t}}),r("dqWRJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("pqNJR");i.ColorToRGBA=s("gsgi6"),i.ComponentToHex=s("8j7ov"),i.GetColor=s("hqJVB"),i.GetColor32=s("cEpdV"),i.HexStringToColor=s("geCzd"),i.HSLToColor=s("3GTIE"),i.HSVColorWheel=s("jrQ9H"),i.HSVToRGB=s("1jgzS"),i.HueToComponent=s("1AMCZ"),i.IntegerToColor=s("bAeWh"),i.IntegerToRGB=s("3sQbm"),i.Interpolate=s("hxSfB"),i.ObjectToColor=s("1xsnc"),i.RandomRGB=s("itc7X"),i.RGBStringToColor=s("8lcCL"),i.RGBToHSV=s("hM4Fo"),i.RGBToString=s("4BTW2"),i.ValueToColor=s("iYnst"),t.exports=i}),r("gsgi6",function(t,e){t.exports=function(t){var e={r:t>>16&255,g:t>>8&255,b:255&t,a:255};return t>16777215&&(e.a=t>>>24),e}}),r("8j7ov",function(t,e){t.exports=function(t){var e=t.toString(16);return 1===e.length?"0"+e:e}}),r("3GTIE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("pqNJR"),n=s("1AMCZ");t.exports=function(t,e,s){// achromatic by default
var r=s,o=s,a=s;if(0!==e){var h=s<.5?s*(1+e):s+e-s*e,l=2*s-h;r=n(l,h,t+1/3),o=n(l,h,t),a=n(l,h,t-1/3)}return new i().setGLTo(r,o,a,1)}}),r("1AMCZ",function(t,e){t.exports=function(t,e,i){return(i<0&&(i+=1),i>1&&(i-=1),i<1/6)?t+(e-t)*6*i:i<.5?e:i<2/3?t+(e-t)*(2/3-i)*6:t}}),r("jrQ9H",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1jgzS");t.exports=function(t,e){void 0===t&&(t=1),void 0===e&&(e=1);for(var n=[],s=0;s<=359;s++)n.push(i(s/359,t,e));return n}}),r("hxSfB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("fDkZ4"),n=function(t,e,n,s,r,o,a,h){void 0===a&&(a=100),void 0===h&&(h=0);var l=h/a;return{r:i(t,s,l),g:i(e,r,l),b:i(n,o,l)}};t.exports={RGBWithRGB:n,ColorWithRGB:function(t,e,i,s,r,o){return void 0===r&&(r=100),void 0===o&&(o=0),n(t.r,t.g,t.b,e,i,s,r,o)},ColorWithColor:function(t,e,i,s){return void 0===i&&(i=100),void 0===s&&(s=0),n(t.r,t.g,t.b,e.r,e.g,e.b,i,s)}}}),r("itc7X",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2EBZh"),n=s("pqNJR");t.exports=function(t,e){return void 0===t&&(t=0),void 0===e&&(e=255),new n(i(t,e),i(t,e),i(t,e))}}),r("4BTW2",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("8j7ov");t.exports=function(t,e,n,s,r){return(void 0===s&&(s=255),void 0===r&&(r="#"),"#"===r)?"#"+(16777216+(t<<16)+(e<<8)+n).toString(16).slice(1):"0x"+i(s)+i(t)+i(e)+i(n)}}),r("7QACF",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Display.Masks
 */t.exports={BitmapMask:s("JBPsZ"),GeometryMask:s("gPaIB")}}),r("4SM0m",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.DOM
 */var i={AddToDOM:s("6686h"),DOMContentLoaded:s("e741E"),GetScreenOrientation:s("6rG19"),GetTarget:s("ckyH1"),ParseXML:s("1zOUS"),RemoveFromDOM:s("kJrIV"),RequestAnimationFrame:s("eGwje")};t.exports=i}),r("6686h",function(t,e){t.exports=function(t,e){var i;if(e)"string"==typeof e?i=document.getElementById(e):"object"==typeof e&&1===e.nodeType&&(i=e);else if(t.parentElement)return t;return i||(i=document.body),i.appendChild(t),t}}),r("e741E",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1SePj");t.exports=function(t){if("complete"===document.readyState||"interactive"===document.readyState){t();return}var e=function(){document.removeEventListener("deviceready",e,!0),document.removeEventListener("DOMContentLoaded",e,!0),window.removeEventListener("load",e,!0),t()};document.body?i.cordova?document.addEventListener("deviceready",e,!1):(document.addEventListener("DOMContentLoaded",e,!0),window.addEventListener("load",e,!0)):window.setTimeout(e,20)}}),r("6rG19",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("dlsVr");t.exports=function(t,e){var n=window.screen,s=!!n&&(n.orientation||n.mozOrientation||n.msOrientation);if(s&&"string"==typeof s.type)return s.type;if("string"==typeof s)return s;if(n)return n.height>n.width?i.ORIENTATION.PORTRAIT:i.ORIENTATION.LANDSCAPE;if("number"==typeof window.orientation)return 0===window.orientation||180===window.orientation?i.ORIENTATION.PORTRAIT:i.ORIENTATION.LANDSCAPE;if(window.matchMedia){if(window.matchMedia("(orientation: portrait)").matches)return i.ORIENTATION.PORTRAIT;if(window.matchMedia("(orientation: landscape)").matches)return i.ORIENTATION.LANDSCAPE}return e>t?i.ORIENTATION.PORTRAIT:i.ORIENTATION.LANDSCAPE}}),r("dlsVr",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i={CENTER:s("9tm7z"),ORIENTATION:s("8cRWJ"),SCALE_MODE:s("1mQJz"),ZOOM:s("9l9Tb")};t.exports=i}),r("9tm7z",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * Phaser Scale Manager constants for centering the game canvas.
 * 
 * @namespace Phaser.Scale.Center
 * @memberof Phaser.Scale
 * @since 3.16.0
 *//**
 * Phaser Scale Manager constants for centering the game canvas.
 * 
 * To find out what each mode does please see [Phaser.Scale.Center]{@link Phaser.Scale.Center}.
 * 
 * @typedef {Phaser.Scale.Center} Phaser.Scale.CenterType
 * @memberof Phaser.Scale
 * @since 3.16.0
 */t.exports={/**
     * The game canvas is not centered within the parent by Phaser.
     * You can still center it yourself via CSS.
     * 
     * @name Phaser.Scale.Center.NO_CENTER
     * @type {integer}
     * @const
     * @since 3.16.0
     */NO_CENTER:0,/**
     * The game canvas is centered both horizontally and vertically within the parent.
     * To do this, the parent has to have a bounds that can be calculated and not be empty.
     * 
     * Centering is achieved by setting the margin left and top properties of the
     * game canvas, and does not factor in any other CSS styles you may have applied.
     * 
     * @name Phaser.Scale.Center.CENTER_BOTH
     * @type {integer}
     * @const
     * @since 3.16.0
     */CENTER_BOTH:1,/**
     * The game canvas is centered horizontally within the parent.
     * To do this, the parent has to have a bounds that can be calculated and not be empty.
     * 
     * Centering is achieved by setting the margin left and top properties of the
     * game canvas, and does not factor in any other CSS styles you may have applied.
     * 
     * @name Phaser.Scale.Center.CENTER_HORIZONTALLY
     * @type {integer}
     * @const
     * @since 3.16.0
     */CENTER_HORIZONTALLY:2,/**
     * The game canvas is centered both vertically within the parent.
     * To do this, the parent has to have a bounds that can be calculated and not be empty.
     * 
     * Centering is achieved by setting the margin left and top properties of the
     * game canvas, and does not factor in any other CSS styles you may have applied.
     * 
     * @name Phaser.Scale.Center.CENTER_VERTICALLY
     * @type {integer}
     * @const
     * @since 3.16.0
     */CENTER_VERTICALLY:3}}),r("8cRWJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * Phaser Scale Manager constants for orientation.
 * 
 * @namespace Phaser.Scale.Orientation
 * @memberof Phaser.Scale
 * @since 3.16.0
 *//**
 * Phaser Scale Manager constants for orientation.
 * 
 * To find out what each mode does please see [Phaser.Scale.Orientation]{@link Phaser.Scale.Orientation}.
 * 
 * @typedef {Phaser.Scale.Orientation} Phaser.Scale.OrientationType
 * @memberof Phaser.Scale
 * @since 3.16.0
 */t.exports={/**
     * A landscape orientation.
     * 
     * @name Phaser.Scale.Orientation.LANDSCAPE
     * @type {string}
     * @const
     * @since 3.16.0
     */LANDSCAPE:"landscape-primary",/**
     * A portrait orientation.
     * 
     * @name Phaser.Scale.Orientation.PORTRAIT
     * @type {string}
     * @const
     * @since 3.16.0
     */PORTRAIT:"portrait-primary"}}),r("1mQJz",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * Phaser Scale Manager constants for the different scale modes available.
 * 
 * @namespace Phaser.Scale.ScaleModes
 * @memberof Phaser.Scale
 * @since 3.16.0
 *//**
 * Phaser Scale Manager constants for the different scale modes available.
 * 
 * To find out what each mode does please see [Phaser.Scale.ScaleModes]{@link Phaser.Scale.ScaleModes}.
 * 
 * @typedef {Phaser.Scale.ScaleModes} Phaser.Scale.ScaleModeType
 * @memberof Phaser.Scale
 * @since 3.16.0
 */t.exports={/**
     * No scaling happens at all. The canvas is set to the size given in the game config and Phaser doesn't change it
     * again from that point on. If you change the canvas size, either via CSS, or directly via code, then you need
     * to call the Scale Managers `resize` method to give the new dimensions, or input events will stop working.
     * 
     * @name Phaser.Scale.ScaleModes.NONE
     * @type {integer}
     * @const
     * @since 3.16.0
     */NONE:0,/**
     * The height is automatically adjusted based on the width.
     * 
     * @name Phaser.Scale.ScaleModes.WIDTH_CONTROLS_HEIGHT
     * @type {integer}
     * @const
     * @since 3.16.0
     */WIDTH_CONTROLS_HEIGHT:1,/**
     * The width is automatically adjusted based on the height.
     * 
     * @name Phaser.Scale.ScaleModes.HEIGHT_CONTROLS_WIDTH
     * @type {integer}
     * @const
     * @since 3.16.0
     */HEIGHT_CONTROLS_WIDTH:2,/**
     * The width and height are automatically adjusted to fit inside the given target area,
     * while keeping the aspect ratio. Depending on the aspect ratio there may be some space
     * inside the area which is not covered.
     * 
     * @name Phaser.Scale.ScaleModes.FIT
     * @type {integer}
     * @const
     * @since 3.16.0
     */FIT:3,/**
     * The width and height are automatically adjusted to make the size cover the entire target
     * area while keeping the aspect ratio. This may extend further out than the target size.
     * 
     * @name Phaser.Scale.ScaleModes.ENVELOP
     * @type {integer}
     * @const
     * @since 3.16.0
     */ENVELOP:4,/**
     * The Canvas is resized to fit all available _parent_ space, regardless of aspect ratio.
     * 
     * @name Phaser.Scale.ScaleModes.RESIZE
     * @type {integer}
     * @const
     * @since 3.16.0
     */RESIZE:5}}),r("9l9Tb",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * Phaser Scale Manager constants for zoom modes.
 * 
 * @namespace Phaser.Scale.Zoom
 * @memberof Phaser.Scale
 * @since 3.16.0
 *//**
 * Phaser Scale Manager constants for zoom modes.
 * 
 * To find out what each mode does please see [Phaser.Scale.Zoom]{@link Phaser.Scale.Zoom}.
 * 
 * @typedef {Phaser.Scale.Zoom} Phaser.Scale.ZoomType
 * @memberof Phaser.Scale
 * @since 3.16.0
 */t.exports={/**
     * The game canvas will not be zoomed by Phaser.
     * 
     * @name Phaser.Scale.Zoom.NO_ZOOM
     * @type {integer}
     * @const
     * @since 3.16.0
     */NO_ZOOM:1,/**
     * The game canvas will be 2x zoomed by Phaser.
     * 
     * @name Phaser.Scale.Zoom.ZOOM_2X
     * @type {integer}
     * @const
     * @since 3.16.0
     */ZOOM_2X:2,/**
     * The game canvas will be 4x zoomed by Phaser.
     * 
     * @name Phaser.Scale.Zoom.ZOOM_4X
     * @type {integer}
     * @const
     * @since 3.16.0
     */ZOOM_4X:4,/**
     * Calculate the zoom value based on the maximum multiplied game size that will
     * fit into the parent, or browser window if no parent is set.
     * 
     * @name Phaser.Scale.Zoom.MAX_ZOOM
     * @type {integer}
     * @const
     * @since 3.16.0
     */MAX_ZOOM:-1}}),r("ckyH1",function(t,e){t.exports=function(t){var e;return""!==t&&("string"==typeof t?e=document.getElementById(t):t&&1===t.nodeType&&(e=t)),e||(e=document.body),e}}),r("1zOUS",function(t,e){t.exports=function(t){var e="";try{window.DOMParser?e=new DOMParser().parseFromString(t,"text/xml"):(e=new ActiveXObject("Microsoft.XMLDOM")).loadXML(t)}catch(t){e=null}return e&&e.documentElement&&!e.getElementsByTagName("parsererror").length?e:null}}),r("kJrIV",function(t,e){t.exports=function(t){t.parentNode&&t.parentNode.removeChild(t)}}),r("1ZXFk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Events
 */t.exports={EventEmitter:s("j77Xc")}}),r("j77Xc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("3vRz3"),r=s("7AzQW"),o=new i({Extends:n,initialize:function(){n.call(this)},/**
     * Removes all listeners.
     *
     * @method Phaser.Events.EventEmitter#shutdown
     * @since 3.0.0
     */shutdown:function(){this.removeAllListeners()},/**
     * Removes all listeners.
     *
     * @method Phaser.Events.EventEmitter#destroy
     * @since 3.0.0
     */destroy:function(){this.removeAllListeners()}});/**
 * Return an array listing the events for which the emitter has registered listeners.
 *
 * @method Phaser.Events.EventEmitter#eventNames
 * @since 3.0.0
 *
 * @return {Array.<string|symbol>}
 *//**
 * Return the listeners registered for a given event.
 *
 * @method Phaser.Events.EventEmitter#listeners
 * @since 3.0.0
 *
 * @param {(string|symbol)} event - The event name.
 *
 * @return {Function[]} The registered listeners.
 *//**
 * Return the number of listeners listening to a given event.
 *
 * @method Phaser.Events.EventEmitter#listenerCount
 * @since 3.0.0
 *
 * @param {(string|symbol)} event - The event name.
 *
 * @return {number} The number of listeners.
 *//**
 * Calls each of the listeners registered for a given event.
 *
 * @method Phaser.Events.EventEmitter#emit
 * @since 3.0.0
 *
 * @param {(string|symbol)} event - The event name.
 * @param {...*} [args] - Additional arguments that will be passed to the event handler.
 *
 * @return {boolean} `true` if the event had listeners, else `false`.
 *//**
 * Add a listener for a given event.
 *
 * @method Phaser.Events.EventEmitter#on
 * @since 3.0.0
 *
 * @param {(string|symbol)} event - The event name.
 * @param {function} fn - The listener function.
 * @param {*} [context=this] - The context to invoke the listener with.
 *
 * @return {this} `this`.
 *//**
 * Add a listener for a given event.
 *
 * @method Phaser.Events.EventEmitter#addListener
 * @since 3.0.0
 *
 * @param {(string|symbol)} event - The event name.
 * @param {function} fn - The listener function.
 * @param {*} [context=this] - The context to invoke the listener with.
 *
 * @return {this} `this`.
 *//**
 * Add a one-time listener for a given event.
 *
 * @method Phaser.Events.EventEmitter#once
 * @since 3.0.0
 *
 * @param {(string|symbol)} event - The event name.
 * @param {function} fn - The listener function.
 * @param {*} [context=this] - The context to invoke the listener with.
 *
 * @return {this} `this`.
 *//**
 * Remove the listeners of a given event.
 *
 * @method Phaser.Events.EventEmitter#removeListener
 * @since 3.0.0
 *
 * @param {(string|symbol)} event - The event name.
 * @param {function} [fn] - Only remove the listeners that match this function.
 * @param {*} [context] - Only remove the listeners that have this context.
 * @param {boolean} [once] - Only remove one-time listeners.
 *
 * @return {this} `this`.
 *//**
 * Remove the listeners of a given event.
 *
 * @method Phaser.Events.EventEmitter#off
 * @since 3.0.0
 *
 * @param {(string|symbol)} event - The event name.
 * @param {function} [fn] - Only remove the listeners that match this function.
 * @param {*} [context] - Only remove the listeners that have this context.
 * @param {boolean} [once] - Only remove one-time listeners.
 *
 * @return {this} `this`.
 *//**
 * Remove all listeners, or those of the specified event.
 *
 * @method Phaser.Events.EventEmitter#removeAllListeners
 * @since 3.0.0
 *
 * @param {(string|symbol)} [event] - The event name.
 *
 * @return {this} `this`.
 */r.register("EventEmitter",o,"events"),t.exports=o}),r("L2T5H",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6686h"),n=s("dq46t"),r=s("083aW"),o=s("kKoer"),a=s("jwj1g"),h=s("cIuDW"),l=s("fmVR6"),u=s("dFILV"),c=s("ewzDY"),d=s("aGYvp"),f=s("eii8B"),p=s("e741E"),g=s("3vRz3"),v=s("aqcI1"),m=s("5ZH3f"),y=s("7AzQW"),x=s("brulE"),w=s("861Bh"),T=s("TOZF7"),b=s("6R4Pe"),S=s("5QcEl"),A=s("bc6Xj"),E=s("cEGtP"),_=s("jskqO"),C=s("LHpuq"),M=new a({initialize:function(t){/**
         * The parsed Game Configuration object.
         *
         * The values stored within this object are read-only and should not be changed at run-time.
         *
         * @name Phaser.Game#config
         * @type {Phaser.Core.Config}
         * @readonly
         * @since 3.0.0
         */this.config=new h(t),/**
         * A reference to either the Canvas or WebGL Renderer that this Game is using.
         *
         * @name Phaser.Game#renderer
         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}
         * @since 3.0.0
         */this.renderer=null,/**
         * A reference to an HTML Div Element used as the DOM Element Container.
         *
         * Only set if `createDOMContainer` is `true` in the game config (by default it is `false`) and
         * if you provide a parent element to insert the Phaser Game inside.
         *
         * See the DOM Element Game Object for more details.
         *
         * @name Phaser.Game#domContainer
         * @type {HTMLDivElement}
         * @since 3.17.0
         */this.domContainer=null,/**
         * A reference to the HTML Canvas Element that Phaser uses to render the game.
         * This is created automatically by Phaser unless you provide a `canvas` property
         * in your Game Config.
         *
         * @name Phaser.Game#canvas
         * @type {HTMLCanvasElement}
         * @since 3.0.0
         */this.canvas=null,/**
         * A reference to the Rendering Context belonging to the Canvas Element this game is rendering to.
         * If the game is running under Canvas it will be a 2d Canvas Rendering Context.
         * If the game is running under WebGL it will be a WebGL Rendering Context.
         * This context is created automatically by Phaser unless you provide a `context` property
         * in your Game Config.
         *
         * @name Phaser.Game#context
         * @type {(CanvasRenderingContext2D|WebGLRenderingContext)}
         * @since 3.0.0
         */this.context=null,/**
         * A flag indicating when this Game instance has finished its boot process.
         *
         * @name Phaser.Game#isBooted
         * @type {boolean}
         * @readonly
         * @since 3.0.0
         */this.isBooted=!1,/**
         * A flag indicating if this Game is currently running its game step or not.
         *
         * @name Phaser.Game#isRunning
         * @type {boolean}
         * @readonly
         * @since 3.0.0
         */this.isRunning=!1,/**
         * An Event Emitter which is used to broadcast game-level events from the global systems.
         *
         * @name Phaser.Game#events
         * @type {Phaser.Events.EventEmitter}
         * @since 3.0.0
         */this.events=new g,/**
         * An instance of the Animation Manager.
         *
         * The Animation Manager is a global system responsible for managing all animations used within your game.
         *
         * @name Phaser.Game#anims
         * @type {Phaser.Animations.AnimationManager}
         * @since 3.0.0
         */this.anims=new n(this),/**
         * An instance of the Texture Manager.
         *
         * The Texture Manager is a global system responsible for managing all textures being used by your game.
         *
         * @name Phaser.Game#textures
         * @type {Phaser.Textures.TextureManager}
         * @since 3.0.0
         */this.textures=new S(this),/**
         * An instance of the Cache Manager.
         *
         * The Cache Manager is a global system responsible for caching, accessing and releasing external game assets.
         *
         * @name Phaser.Game#cache
         * @type {Phaser.Cache.CacheManager}
         * @since 3.0.0
         */this.cache=new r(this),/**
         * An instance of the Data Manager
         *
         * @name Phaser.Game#registry
         * @type {Phaser.Data.DataManager}
         * @since 3.0.0
         */this.registry=new c(this),/**
         * An instance of the Input Manager.
         *
         * The Input Manager is a global system responsible for the capture of browser-level input events.
         *
         * @name Phaser.Game#input
         * @type {Phaser.Input.InputManager}
         * @since 3.0.0
         */this.input=new m(this,this.config),/**
         * An instance of the Scene Manager.
         *
         * The Scene Manager is a global system responsible for creating, modifying and updating the Scenes in your game.
         *
         * @name Phaser.Game#scene
         * @type {Phaser.Scenes.SceneManager}
         * @since 3.0.0
         */this.scene=new T(this,this.config.sceneConfig),/**
         * A reference to the Device inspector.
         *
         * Contains information about the device running this game, such as OS, browser vendor and feature support.
         * Used by various systems to determine capabilities and code paths.
         *
         * @name Phaser.Game#device
         * @type {Phaser.DeviceConf}
         * @since 3.0.0
         */this.device=f,/**
         * An instance of the Scale Manager.
         *
         * The Scale Manager is a global system responsible for handling scaling of the game canvas.
         *
         * @name Phaser.Game#scale
         * @type {Phaser.Scale.ScaleManager}
         * @since 3.16.0
         */this.scale=new w(this,this.config),/**
         * An instance of the base Sound Manager.
         *
         * The Sound Manager is a global system responsible for the playback and updating of all audio in your game.
         *
         * You can disable the inclusion of the Sound Manager in your build by toggling the webpack `FEATURE_SOUND` flag.
         *
         * @name Phaser.Game#sound
         * @type {(Phaser.Sound.NoAudioSoundManager|Phaser.Sound.HTML5AudioSoundManager|Phaser.Sound.WebAudioSoundManager)}
         * @since 3.0.0
         */this.sound=null,this.sound=_.create(this),/**
         * An instance of the Time Step.
         *
         * The Time Step is a global system responsible for setting-up and responding to the browser frame events, processing
         * them and calculating delta values. It then automatically calls the game step.
         *
         * @name Phaser.Game#loop
         * @type {Phaser.Core.TimeStep}
         * @since 3.0.0
         */this.loop=new A(this,this.config.fps),/**
         * An instance of the Plugin Manager.
         *
         * The Plugin Manager is a global system that allows plugins to register themselves with it, and can then install
         * those plugins into Scenes as required.
         *
         * @name Phaser.Game#plugins
         * @type {Phaser.Plugins.PluginManager}
         * @since 3.0.0
         */this.plugins=new x(this,this.config),/**
             * An instance of the Facebook Instant Games Plugin.
             *
             * This will only be available if the plugin has been built into Phaser,
             * or you're using the special Facebook Instant Games custom build.
             *
             * @name Phaser.Game#facebook
             * @type {Phaser.FacebookInstantGamesPlugin}
             * @since 3.13.0
             */this.facebook=new C(this),/**
         * Is this Game pending destruction at the start of the next frame?
         *
         * @name Phaser.Game#pendingDestroy
         * @type {boolean}
         * @private
         * @since 3.5.0
         */this.pendingDestroy=!1,/**
         * Remove the Canvas once the destroy is over?
         *
         * @name Phaser.Game#removeCanvas
         * @type {boolean}
         * @private
         * @since 3.5.0
         */this.removeCanvas=!1,/**
         * Remove everything when the game is destroyed.
         * You cannot create a new Phaser instance on the same web page after doing this.
         *
         * @name Phaser.Game#noReturn
         * @type {boolean}
         * @private
         * @since 3.12.0
         */this.noReturn=!1,/**
         * Does the window the game is running in currently have focus or not?
         * This is modified by the VisibilityHandler.
         *
         * @name Phaser.Game#hasFocus
         * @type {boolean}
         * @readonly
         * @since 3.9.0
         */this.hasFocus=!1,//  Wait for the DOM Ready event, then call boot.
p(this.boot.bind(this))},/**
     * This method is called automatically when the DOM is ready. It is responsible for creating the renderer,
     * displaying the Debug Header, adding the game canvas to the DOM and emitting the 'boot' event.
     * It listens for a 'ready' event from the base systems and once received it will call `Game.start`.
     *
     * @method Phaser.Game#boot
     * @protected
     * @fires Phaser.Core.Events#BOOT
     * @listens Phaser.Textures.Events#READY
     * @since 3.0.0
     */boot:function(){if(!y.hasCore("EventEmitter")){console.warn("Aborting. Core Plugins missing.");return}this.isBooted=!0,this.config.preBoot(this),this.scale.preBoot(),u(this),l(this),d(this),i(this.canvas,this.config.parent),//  The Texture Manager has to wait on a couple of non-blocking events before it's fully ready.
//  So it will emit this internal event when done:
this.textures.once(b.READY,this.texturesReady,this),this.events.emit(v.BOOT)},/**
     * Called automatically when the Texture Manager has finished setting up and preparing the
     * default textures.
     *
     * @method Phaser.Game#texturesReady
     * @private
     * @fires Phaser.Game#READY
     * @since 3.12.0
     */texturesReady:function(){//  Start all the other systems
this.events.emit(v.READY),this.start()},/**
     * Called automatically by Game.boot once all of the global systems have finished setting themselves up.
     * By this point the Game is now ready to start the main loop running.
     * It will also enable the Visibility Handler.
     *
     * @method Phaser.Game#start
     * @protected
     * @since 3.0.0
     */start:function(){this.isRunning=!0,this.config.postBoot(this),this.renderer?this.loop.start(this.step.bind(this)):this.loop.start(this.headlessStep.bind(this)),E(this);var t=this.events;t.on(v.HIDDEN,this.onHidden,this),t.on(v.VISIBLE,this.onVisible,this),t.on(v.BLUR,this.onBlur,this),t.on(v.FOCUS,this.onFocus,this)},/**
     * The main Game Step. Called automatically by the Time Step, once per browser frame (typically as a result of
     * Request Animation Frame, or Set Timeout on very old browsers.)
     *
     * The step will update the global managers first, then proceed to update each Scene in turn, via the Scene Manager.
     *
     * It will then render each Scene in turn, via the Renderer. This process emits `prerender` and `postrender` events.
     *
     * @method Phaser.Game#step
     * @fires Phaser.Core.Events#PRE_STEP
     * @fires Phaser.Core.Events#STEP
     * @fires Phaser.Core.Events#POST_STEP
     * @fires Phaser.Core.Events#PRE_RENDER
     * @fires Phaser.Core.Events#POST_RENDER
     * @since 3.0.0
     *
     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     */step:function(t,e){if(this.pendingDestroy)return this.runDestroy();var i=this.events;//  Global Managers like Input and Sound update in the prestep
i.emit(v.PRE_STEP,t,e),//  This is mostly meant for user-land code and plugins
i.emit(v.STEP,t,e),//  Update the Scene Manager and all active Scenes
this.scene.update(t,e),//  Our final event before rendering starts
i.emit(v.POST_STEP,t,e);var n=this.renderer;//  Run the Pre-render (clearing the canvas, setting background colors, etc)
n.preRender(),i.emit(v.PRE_RENDER,n,t,e),//  The main render loop. Iterates all Scenes and all Cameras in those scenes, rendering to the renderer instance.
this.scene.render(n),//  The Post-Render call. Tidies up loose end, takes snapshots, etc.
n.postRender(),//  The final event before the step repeats. Your last chance to do anything to the canvas before it all starts again.
i.emit(v.POST_RENDER,n,t,e)},/**
     * A special version of the Game Step for the HEADLESS renderer only.
     *
     * The main Game Step. Called automatically by the Time Step, once per browser frame (typically as a result of
     * Request Animation Frame, or Set Timeout on very old browsers.)
     *
     * The step will update the global managers first, then proceed to update each Scene in turn, via the Scene Manager.
     *
     * This process emits `prerender` and `postrender` events, even though nothing actually displays.
     *
     * @method Phaser.Game#headlessStep
     * @fires Phaser.Game#PRE_RENDER
     * @fires Phaser.Game#POST_RENDER
     * @since 3.2.0
     *
     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     */headlessStep:function(t,e){if(this.pendingDestroy)return this.runDestroy();var i=this.events;//  Global Managers
i.emit(v.PRE_STEP,t,e),i.emit(v.STEP,t,e),//  Scenes
this.scene.update(t,e),i.emit(v.POST_STEP,t,e),//  Render
i.emit(v.PRE_RENDER),i.emit(v.POST_RENDER)},/**
     * Called automatically by the Visibility Handler.
     * This will pause the main loop and then emit a pause event.
     *
     * @method Phaser.Game#onHidden
     * @protected
     * @fires Phaser.Core.Events#PAUSE
     * @since 3.0.0
     */onHidden:function(){this.loop.pause(),this.events.emit(v.PAUSE)},/**
     * Called automatically by the Visibility Handler.
     * This will resume the main loop and then emit a resume event.
     *
     * @method Phaser.Game#onVisible
     * @protected
     * @fires Phaser.Core.Events#RESUME
     * @since 3.0.0
     */onVisible:function(){this.loop.resume(),this.events.emit(v.RESUME)},/**
     * Called automatically by the Visibility Handler.
     * This will set the main loop into a 'blurred' state, which pauses it.
     *
     * @method Phaser.Game#onBlur
     * @protected
     * @since 3.0.0
     */onBlur:function(){this.hasFocus=!1,this.loop.blur()},/**
     * Called automatically by the Visibility Handler.
     * This will set the main loop into a 'focused' state, which resumes it.
     *
     * @method Phaser.Game#onFocus
     * @protected
     * @since 3.0.0
     */onFocus:function(){this.hasFocus=!0,this.loop.focus()},/**
     * Returns the current game frame.
     *
     * When the game starts running, the frame is incremented every time Request Animation Frame, or Set Timeout, fires.
     *
     * @method Phaser.Game#getFrame
     * @since 3.16.0
     *
     * @return {number} The current game frame.
     */getFrame:function(){return this.loop.frame},/**
     * Returns the time that the current game step started at, as based on `performance.now`.
     *
     * @method Phaser.Game#getTime
     * @since 3.16.0
     *
     * @return {number} The current game timestamp.
     */getTime:function(){return this.loop.now},/**
     * Flags this Game instance as needing to be destroyed on the _next frame_, making this an asynchronous operation.
     *
     * It will wait until the current frame has completed and then call `runDestroy` internally.
     *
     * If you need to react to the games eventual destruction, listen for the `DESTROY` event.
     *
     * If you **do not** need to run Phaser again on the same web page you can set the `noReturn` argument to `true` and it will free-up
     * memory being held by the core Phaser plugins. If you do need to create another game instance on the same page, leave this as `false`.
     *
     * @method Phaser.Game#destroy
     * @fires Phaser.Core.Events#DESTROY
     * @since 3.0.0
     *
     * @param {boolean} removeCanvas - Set to `true` if you would like the parent canvas element removed from the DOM, or `false` to leave it in place.
     * @param {boolean} [noReturn=false] - If `true` all the core Phaser plugins are destroyed. You cannot create another instance of Phaser on the same web page if you do this.
     */destroy:function(t,e){void 0===e&&(e=!1),this.pendingDestroy=!0,this.removeCanvas=t,this.noReturn=e},/**
     * Destroys this Phaser.Game instance, all global systems, all sub-systems and all Scenes.
     *
     * @method Phaser.Game#runDestroy
     * @private
     * @since 3.5.0
     */runDestroy:function(){this.scene.destroy(),this.events.emit(v.DESTROY),this.events.removeAllListeners(),this.renderer&&this.renderer.destroy(),this.removeCanvas&&this.canvas&&(o.remove(this.canvas),this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)),this.domContainer&&this.domContainer.parentNode.removeChild(this.domContainer),this.loop.destroy(),this.pendingDestroy=!1}});t.exports=M;/**
 * "Computers are good at following instructions, but not at reading your mind." - Donald Knuth
 */}),r("fmVR6",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6686h");t.exports=function(t){var e=t.config;if(e.parent&&e.domCreateContainer){//  DOM Element Container
var n=document.createElement("div");n.style.cssText=["display: block;","width: "+t.scale.width+"px;","height: "+t.scale.height+"px;","padding: 0; margin: 0;","position: absolute;","overflow: hidden;","pointer-events: none;","transform: scale(1);","transform-origin: left top;"].join(" "),t.domContainer=n,i(n,e.parent)}}}),r("5ZH3f",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("1BSIy"),r=s("3vRz3"),o=s("2nOjn"),a=s("aqcI1"),h=s("c0CF7"),l=s("jy9yA"),u=s("1Oao7"),c=s("d3PYD"),d=s("azs1m"),f=s("coTXE"),p=new i({initialize:function(t,e){/**
         * The Game instance that owns the Input Manager.
         * A Game only maintains on instance of the Input Manager at any time.
         *
         * @name Phaser.Input.InputManager#game
         * @type {Phaser.Game}
         * @readonly
         * @since 3.0.0
         */this.game=t,/**
         * A reference to the global Game Scale Manager.
         * Used for all bounds checks and pointer scaling.
         *
         * @name Phaser.Input.InputManager#scaleManager
         * @type {Phaser.Scale.ScaleManager}
         * @since 3.16.0
         */this.scaleManager,/**
         * The Canvas that is used for all DOM event input listeners.
         *
         * @name Phaser.Input.InputManager#canvas
         * @type {HTMLCanvasElement}
         * @since 3.0.0
         */this.canvas,/**
         * The Game Configuration object, as set during the game boot.
         *
         * @name Phaser.Input.InputManager#config
         * @type {Phaser.Core.Config}
         * @since 3.0.0
         */this.config=e,/**
         * If set, the Input Manager will run its update loop every frame.
         *
         * @name Phaser.Input.InputManager#enabled
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.enabled=!0,/**
         * The Event Emitter instance that the Input Manager uses to emit events from.
         *
         * @name Phaser.Input.InputManager#events
         * @type {Phaser.Events.EventEmitter}
         * @since 3.0.0
         */this.events=new r,/**
         * Are any mouse or touch pointers currently over the game canvas?
         * This is updated automatically by the canvas over and out handlers.
         *
         * @name Phaser.Input.InputManager#isOver
         * @type {boolean}
         * @readonly
         * @since 3.16.0
         */this.isOver=!0,/**
         * The default CSS cursor to be used when interacting with your game.
         *
         * See the `setDefaultCursor` method for more details.
         *
         * @name Phaser.Input.InputManager#defaultCursor
         * @type {string}
         * @since 3.10.0
         */this.defaultCursor="",/**
         * A reference to the Keyboard Manager class, if enabled via the `input.keyboard` Game Config property.
         *
         * @name Phaser.Input.InputManager#keyboard
         * @type {?Phaser.Input.Keyboard.KeyboardManager}
         * @since 3.16.0
         */this.keyboard=e.inputKeyboard?new h(this):null,/**
         * A reference to the Mouse Manager class, if enabled via the `input.mouse` Game Config property.
         *
         * @name Phaser.Input.InputManager#mouse
         * @type {?Phaser.Input.Mouse.MouseManager}
         * @since 3.0.0
         */this.mouse=e.inputMouse?new l(this):null,/**
         * A reference to the Touch Manager class, if enabled via the `input.touch` Game Config property.
         *
         * @name Phaser.Input.InputManager#touch
         * @type {Phaser.Input.Touch.TouchManager}
         * @since 3.0.0
         */this.touch=e.inputTouch?new c(this):null,/**
         * An array of Pointers that have been added to the game.
         * The first entry is reserved for the Mouse Pointer, the rest are Touch Pointers.
         *
         * By default there is 1 touch pointer enabled. If you need more use the `addPointer` method to start them,
         * or set the `input.activePointers` property in the Game Config.
         *
         * @name Phaser.Input.InputManager#pointers
         * @type {Phaser.Input.Pointer[]}
         * @since 3.10.0
         */this.pointers=[],/**
         * The number of touch objects activated and being processed each update.
         *
         * You can change this by either calling `addPointer` at run-time, or by
         * setting the `input.activePointers` property in the Game Config.
         *
         * @name Phaser.Input.InputManager#pointersTotal
         * @type {integer}
         * @readonly
         * @since 3.10.0
         */this.pointersTotal=e.inputActivePointers,e.inputTouch&&1===this.pointersTotal&&(this.pointersTotal=2);for(var i=0;i<=this.pointersTotal;i++){var n=new u(this,i);n.smoothFactor=e.inputSmoothFactor,this.pointers.push(n)}/**
         * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.
         * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`
         * which will always map to the most recently interacted pointer.
         *
         * @name Phaser.Input.InputManager#mousePointer
         * @type {?Phaser.Input.Pointer}
         * @since 3.10.0
         */this.mousePointer=e.inputMouse?this.pointers[0]:null,/**
         * The most recently active Pointer object.
         *
         * If you've only 1 Pointer in your game then this will accurately be either the first finger touched, or the mouse.
         *
         * If your game doesn't need to support multi-touch then you can safely use this property in all of your game
         * code and it will adapt to be either the mouse or the touch, based on device.
         *
         * @name Phaser.Input.InputManager#activePointer
         * @type {Phaser.Input.Pointer}
         * @since 3.0.0
         */this.activePointer=this.pointers[0],/**
         * If the top-most Scene in the Scene List receives an input it will stop input from
         * propagating any lower down the scene list, i.e. if you have a UI Scene at the top
         * and click something on it, that click will not then be passed down to any other
         * Scene below. Disable this to have input events passed through all Scenes, all the time.
         *
         * @name Phaser.Input.InputManager#globalTopOnly
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.globalTopOnly=!0,/**
         * The time this Input Manager was last updated.
         * This value is populated by the Game Step each frame.
         *
         * @name Phaser.Input.InputManager#time
         * @type {number}
         * @readonly
         * @since 3.16.2
         */this.time=0,/**
         * A re-cycled point-like object to store hit test values in.
         *
         * @name Phaser.Input.InputManager#_tempPoint
         * @type {{x:number, y:number}}
         * @private
         * @since 3.0.0
         */this._tempPoint={x:0,y:0},/**
         * A re-cycled array to store hit results in.
         *
         * @name Phaser.Input.InputManager#_tempHitTest
         * @type {array}
         * @private
         * @default []
         * @since 3.0.0
         */this._tempHitTest=[],/**
         * A re-cycled matrix used in hit test calculations.
         *
         * @name Phaser.Input.InputManager#_tempMatrix
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @private
         * @since 3.4.0
         */this._tempMatrix=new d,/**
         * A re-cycled matrix used in hit test calculations.
         *
         * @name Phaser.Input.InputManager#_tempMatrix2
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @private
         * @since 3.12.0
         */this._tempMatrix2=new d,/**
         * An internal private var that records Scenes aborting event processing.
         *
         * @name Phaser.Input.InputManager#_tempSkip
         * @type {boolean}
         * @private
         * @since 3.18.0
         */this._tempSkip=!1,/**
         * An internal private array that avoids needing to create a new array on every DOM mouse event.
         *
         * @name Phaser.Input.InputManager#mousePointerContainer
         * @type {Phaser.Input.Pointer[]}
         * @private
         * @since 3.18.0
         */this.mousePointerContainer=[this.mousePointer],t.events.once(a.BOOT,this.boot,this)},/**
     * The Boot handler is called by Phaser.Game when it first starts up.
     * The renderer is available by now.
     *
     * @method Phaser.Input.InputManager#boot
     * @protected
     * @fires Phaser.Input.Events#MANAGER_BOOT
     * @since 3.0.0
     */boot:function(){this.canvas=this.game.canvas,this.scaleManager=this.game.scale,this.events.emit(o.MANAGER_BOOT),this.game.events.on(a.PRE_RENDER,this.preRender,this),this.game.events.once(a.DESTROY,this.destroy,this)},/**
     * Internal canvas state change, called automatically by the Mouse Manager.
     *
     * @method Phaser.Input.InputManager#setCanvasOver
     * @fires Phaser.Input.Events#GAME_OVER
     * @private
     * @since 3.16.0
     *
     * @param {(MouseEvent|TouchEvent)} event - The DOM Event.
     */setCanvasOver:function(t){this.isOver=!0,this.events.emit(o.GAME_OVER,t)},/**
     * Internal canvas state change, called automatically by the Mouse Manager.
     *
     * @method Phaser.Input.InputManager#setCanvasOut
     * @fires Phaser.Input.Events#GAME_OUT
     * @private
     * @since 3.16.0
     *
     * @param {(MouseEvent|TouchEvent)} event - The DOM Event.
     */setCanvasOut:function(t){this.isOver=!1,this.events.emit(o.GAME_OUT,t)},/**
     * Internal update, called automatically by the Game Step right at the start.
     *
     * @method Phaser.Input.InputManager#preRender
     * @private
     * @since 3.18.0
     */preRender:function(){var t=this.game.loop.now,e=this.game.loop.delta,i=this.game.scene.getScenes(!0,!0);this.time=t,this.events.emit(o.MANAGER_UPDATE);for(var n=0;n<i.length;n++){var s=i[n];if(s.sys.input&&s.sys.input.updatePoll(t,e)&&this.globalTopOnly)return}},/**
     * Tells the Input system to set a custom cursor.
     * 
     * This cursor will be the default cursor used when interacting with the game canvas.
     *
     * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.
     *
     * Any valid CSS cursor value is allowed, including paths to image files, i.e.:
     *
     * ```javascript
     * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');
     * ```
     * 
     * Please read about the differences between browsers when it comes to the file formats and sizes they support:
     *
     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property
     *
     * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.
     *
     * @method Phaser.Input.InputManager#setDefaultCursor
     * @since 3.10.0
     * 
     * @param {string} cursor - The CSS to be used when setting the default cursor.
     */setDefaultCursor:function(t){this.defaultCursor=t,this.canvas.style.cursor!==t&&(this.canvas.style.cursor=t)},/**
     * Called by the InputPlugin when processing over and out events.
     * 
     * Tells the Input Manager to set a custom cursor during its postUpdate step.
     *
     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
     *
     * @method Phaser.Input.InputManager#setCursor
     * @private
     * @since 3.10.0
     * 
     * @param {Phaser.Types.Input.InteractiveObject} interactiveObject - The Interactive Object that called this method.
     */setCursor:function(t){t.cursor&&(this.canvas.style.cursor=t.cursor)},/**
     * Called by the InputPlugin when processing over and out events.
     * 
     * Tells the Input Manager to clear the hand cursor, if set, during its postUpdate step.
     *
     * @method Phaser.Input.InputManager#resetCursor
     * @private
     * @since 3.10.0
     * 
     * @param {Phaser.Types.Input.InteractiveObject} interactiveObject - The Interactive Object that called this method.
     */resetCursor:function(t){t.cursor&&this.canvas&&(this.canvas.style.cursor=this.defaultCursor)},/**
     * Adds new Pointer objects to the Input Manager.
     *
     * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.
     *
     * You can create more either by calling this method, or by setting the `input.activePointers` property
     * in the Game Config, up to a maximum of 10 pointers.
     *
     * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added
     * via this method.
     *
     * @method Phaser.Input.InputManager#addPointer
     * @since 3.10.0
     *
     * @param {integer} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.
     *
     * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.
     */addPointer:function(t){void 0===t&&(t=1);var e=[];this.pointersTotal+t>10&&(t=10-this.pointersTotal);for(var i=0;i<t;i++){var n=this.pointers.length,s=new u(this,n);s.smoothFactor=this.config.inputSmoothFactor,this.pointers.push(s),this.pointersTotal++,e.push(s)}return e},/**
     * Internal method that gets a list of all the active Input Plugins in the game
     * and updates each of them in turn, in reverse order (top to bottom), to allow
     * for DOM top-level event handling simulation.
     *
     * @method Phaser.Input.InputManager#updateInputPlugins
     * @since 3.16.0
     *
     * @param {integer} type - The type of event to process.
     * @param {Phaser.Input.Pointer[]} pointers - An array of Pointers on which the event occurred.
     */updateInputPlugins:function(t,e){var i=this.game.scene.getScenes(!0,!0);this._tempSkip=!1;for(var n=0;n<i.length;n++){var s=i[n];if(s.sys.input&&(s.sys.input.update(t,e)&&this.globalTopOnly||this._tempSkip))return}},//  event.targetTouches = list of all touches on the TARGET ELEMENT (i.e. game dom element)
//  event.touches = list of all touches on the ENTIRE DOCUMENT, not just the target element
//  event.changedTouches = the touches that CHANGED in this event, not the total number of them
/**
     * Processes a touch start event, as passed in by the TouchManager.
     *
     * @method Phaser.Input.InputManager#onTouchStart
     * @private
     * @since 3.18.0
     *
     * @param {TouchEvent} event - The native DOM Touch event.
     */onTouchStart:function(t){for(var e=this.pointers,i=[],s=0;s<t.changedTouches.length;s++)for(var r=t.changedTouches[s],o=1;o<this.pointersTotal;o++){var a=e[o];if(!a.active){a.touchstart(r,t),this.activePointer=a,i.push(a);break}}this.updateInputPlugins(n.TOUCH_START,i)},/**
     * Processes a touch move event, as passed in by the TouchManager.
     *
     * @method Phaser.Input.InputManager#onTouchMove
     * @private
     * @since 3.18.0
     *
     * @param {TouchEvent} event - The native DOM Touch event.
     */onTouchMove:function(t){for(var e=this.pointers,i=[],s=0;s<t.changedTouches.length;s++)for(var r=t.changedTouches[s],o=1;o<this.pointersTotal;o++){var a=e[o];if(a.active&&a.identifier===r.identifier){a.touchmove(r,t),this.activePointer=a,i.push(a);break}}this.updateInputPlugins(n.TOUCH_MOVE,i)},//  For touch end its a list of the touch points that have been removed from the surface
//  https://developer.mozilla.org/en-US/docs/DOM/TouchList
//  event.changedTouches = the touches that CHANGED in this event, not the total number of them
/**
     * Processes a touch end event, as passed in by the TouchManager.
     *
     * @method Phaser.Input.InputManager#onTouchEnd
     * @private
     * @since 3.18.0
     *
     * @param {TouchEvent} event - The native DOM Touch event.
     */onTouchEnd:function(t){for(var e=this.pointers,i=[],s=0;s<t.changedTouches.length;s++)for(var r=t.changedTouches[s],o=1;o<this.pointersTotal;o++){var a=e[o];if(a.active&&a.identifier===r.identifier){a.touchend(r,t),i.push(a);break}}this.updateInputPlugins(n.TOUCH_END,i)},/**
     * Processes a touch cancel event, as passed in by the TouchManager.
     *
     * @method Phaser.Input.InputManager#onTouchCancel
     * @private
     * @since 3.18.0
     *
     * @param {TouchEvent} event - The native DOM Touch event.
     */onTouchCancel:function(t){for(var e=this.pointers,i=[],s=0;s<t.changedTouches.length;s++)for(var r=t.changedTouches[s],o=1;o<this.pointersTotal;o++){var a=e[o];if(a.active&&a.identifier===r.identifier){a.touchcancel(r,t),i.push(a);break}}this.updateInputPlugins(n.TOUCH_CANCEL,i)},/**
     * Processes a mouse down event, as passed in by the MouseManager.
     *
     * @method Phaser.Input.InputManager#onMouseDown
     * @private
     * @since 3.18.0
     *
     * @param {MouseEvent} event - The native DOM Mouse event.
     */onMouseDown:function(t){this.mousePointer.down(t),this.mousePointer.updateMotion(),this.updateInputPlugins(n.MOUSE_DOWN,this.mousePointerContainer)},/**
     * Processes a mouse move event, as passed in by the MouseManager.
     *
     * @method Phaser.Input.InputManager#onMouseMove
     * @private
     * @since 3.18.0
     *
     * @param {MouseEvent} event - The native DOM Mouse event.
     */onMouseMove:function(t){this.mousePointer.move(t),this.mousePointer.updateMotion(),this.updateInputPlugins(n.MOUSE_MOVE,this.mousePointerContainer)},/**
     * Processes a mouse up event, as passed in by the MouseManager.
     *
     * @method Phaser.Input.InputManager#onMouseUp
     * @private
     * @since 3.18.0
     *
     * @param {MouseEvent} event - The native DOM Mouse event.
     */onMouseUp:function(t){this.mousePointer.up(t),this.mousePointer.updateMotion(),this.updateInputPlugins(n.MOUSE_UP,this.mousePointerContainer)},/**
     * Processes a mouse wheel event, as passed in by the MouseManager.
     *
     * @method Phaser.Input.InputManager#onMouseWheel
     * @private
     * @since 3.18.0
     *
     * @param {WheelEvent} event - The native DOM Wheel event.
     */onMouseWheel:function(t){this.mousePointer.wheel(t),this.updateInputPlugins(n.MOUSE_WHEEL,this.mousePointerContainer)},/**
     * Processes a pointer lock change event, as passed in by the MouseManager.
     *
     * @method Phaser.Input.InputManager#onPointerLockChange
     * @fires Phaser.Input.Events#POINTERLOCK_CHANGE
     * @private
     * @since 3.19.0
     *
     * @param {MouseEvent} event - The native DOM Mouse event.
     */onPointerLockChange:function(t){var e=this.mouse.locked;this.mousePointer.locked=e,this.events.emit(o.POINTERLOCK_CHANGE,t,e)},/**
     * Checks if the given Game Object should be considered as a candidate for input or not.
     *
     * Checks if the Game Object has an input component that is enabled, that it will render,
     * and finally, if it has a parent, that the parent parent, or any ancestor, is visible or not.
     *
     * @method Phaser.Input.InputManager#inputCandidate
     * @private
     * @since 3.10.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to test.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera which is being tested against.
     *
     * @return {boolean} `true` if the Game Object should be considered for input, otherwise `false`.
     */inputCandidate:function(t,e){var i=t.input;if(!i||!i.enabled||!i.alwaysEnabled&&!t.willRender(e))return!1;var n=!0,s=t.parentContainer;if(s)do{if(!s.willRender(e)){n=!1;break}s=s.parentContainer}while(s)return n},/**
     * Performs a hit test using the given Pointer and camera, against an array of interactive Game Objects.
     *
     * The Game Objects are culled against the camera, and then the coordinates are translated into the local camera space
     * and used to determine if they fall within the remaining Game Objects hit areas or not.
     *
     * If nothing is matched an empty array is returned.
     *
     * This method is called automatically by InputPlugin.hitTestPointer and doesn't usually need to be invoked directly.
     *
     * @method Phaser.Input.InputManager#hitTest
     * @since 3.0.0
     *
     * @param {Phaser.Input.Pointer} pointer - The Pointer to test against.
     * @param {array} gameObjects - An array of interactive Game Objects to check.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera which is being tested against.
     * @param {array} [output] - An array to store the results in. If not given, a new empty array is created.
     *
     * @return {array} An array of the Game Objects that were hit during this hit test.
     */hitTest:function(t,e,i,n){void 0===n&&(n=this._tempHitTest);var s=this._tempPoint,r=i.scrollX,o=i.scrollY;n.length=0;var a=t.x,h=t.y;1!==i.resolution&&(a+=i._x,h+=i._y),//  Stores the world point inside of tempPoint
i.getWorldPoint(a,h,s),t.worldX=s.x,t.worldY=s.y;for(var l={x:0,y:0},u=this._tempMatrix,c=this._tempMatrix2,d=0;d<e.length;d++){var p=e[d];//  Checks if the Game Object can receive input (isn't being ignored by the camera, invisible, etc)
//  and also checks all of its parents, if any
if(this.inputCandidate(p,i)){var g=s.x+r*p.scrollFactorX-r,v=s.y+o*p.scrollFactorY-o;p.parentContainer?(p.getWorldTransformMatrix(u,c),u.applyInverse(g,v,l)):f(g,v,p.x,p.y,p.rotation,p.scaleX,p.scaleY,l),this.pointWithinHitArea(p,l.x,l.y)&&n.push(p)}}return n},/**
     * Checks if the given x and y coordinate are within the hit area of the Game Object.
     *
     * This method assumes that the coordinate values have already been translated into the space of the Game Object.
     *
     * If the coordinates are within the hit area they are set into the Game Objects Input `localX` and `localY` properties.
     *
     * @method Phaser.Input.InputManager#pointWithinHitArea
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The interactive Game Object to check against.
     * @param {number} x - The translated x coordinate for the hit test.
     * @param {number} y - The translated y coordinate for the hit test.
     *
     * @return {boolean} `true` if the coordinates were inside the Game Objects hit area, otherwise `false`.
     */pointWithinHitArea:function(t,e,i){//  Normalize the origin
e+=t.displayOriginX,i+=t.displayOriginY;var n=t.input;return!!(n&&n.hitAreaCallback(n.hitArea,e,i,t))&&(n.localX=e,n.localY=i,!0)},/**
     * Checks if the given x and y coordinate are within the hit area of the Interactive Object.
     *
     * This method assumes that the coordinate values have already been translated into the space of the Interactive Object.
     *
     * If the coordinates are within the hit area they are set into the Interactive Objects Input `localX` and `localY` properties.
     *
     * @method Phaser.Input.InputManager#pointWithinInteractiveObject
     * @since 3.0.0
     *
     * @param {Phaser.Types.Input.InteractiveObject} object - The Interactive Object to check against.
     * @param {number} x - The translated x coordinate for the hit test.
     * @param {number} y - The translated y coordinate for the hit test.
     *
     * @return {boolean} `true` if the coordinates were inside the Game Objects hit area, otherwise `false`.
     */pointWithinInteractiveObject:function(t,e,i){return!!t.hitArea&&(//  Normalize the origin
e+=t.gameObject.displayOriginX,i+=t.gameObject.displayOriginY,t.localX=e,t.localY=i,t.hitAreaCallback(t.hitArea,e,i,t))},/**
     * Transforms the pageX and pageY values of a Pointer into the scaled coordinate space of the Input Manager.
     *
     * @method Phaser.Input.InputManager#transformPointer
     * @since 3.10.0
     *
     * @param {Phaser.Input.Pointer} pointer - The Pointer to transform the values for.
     * @param {number} pageX - The Page X value.
     * @param {number} pageY - The Page Y value.
     * @param {boolean} wasMove - Are we transforming the Pointer from a move event, or an up / down event?
     */transformPointer:function(t,e,i,n){var s=t.position,r=t.prevPosition;//  Store previous position
r.x=s.x,r.y=s.y;//  Translate coordinates
var o=this.scaleManager.transformX(e),a=this.scaleManager.transformY(i),h=t.smoothFactor;n&&0!==h?(//  Apply smoothing
s.x=o*h+r.x*(1-h),s.y=a*h+r.y*(1-h)):(//  Set immediately
s.x=o,s.y=a)},/**
     * Destroys the Input Manager and all of its systems.
     *
     * There is no way to recover from doing this.
     *
     * @method Phaser.Input.InputManager#destroy
     * @since 3.0.0
     */destroy:function(){this.events.removeAllListeners(),this.game.events.off(a.PRE_RENDER),this.keyboard&&this.keyboard.destroy(),this.mouse&&this.mouse.destroy(),this.touch&&this.touch.destroy();for(var t=0;t<this.pointers.length;t++)this.pointers[t].destroy();this.pointers=[],this._tempHitTest=[],this._tempMatrix.destroy(),this.canvas=null,this.game=null}});t.exports=p}),r("1BSIy",function(t,e){t.exports={/**
     * The mouse pointer is being held down.
     * 
     * @name Phaser.Input.MOUSE_DOWN
     * @type {integer}
     * @since 3.10.0
     */MOUSE_DOWN:0,/**
     * The mouse pointer is being moved.
     * 
     * @name Phaser.Input.MOUSE_MOVE
     * @type {integer}
     * @since 3.10.0
     */MOUSE_MOVE:1,/**
     * The mouse pointer is released.
     * 
     * @name Phaser.Input.MOUSE_UP
     * @type {integer}
     * @since 3.10.0
     */MOUSE_UP:2,/**
     * A touch pointer has been started.
     * 
     * @name Phaser.Input.TOUCH_START
     * @type {integer}
     * @since 3.10.0
     */TOUCH_START:3,/**
     * A touch pointer has been started.
     * 
     * @name Phaser.Input.TOUCH_MOVE
     * @type {integer}
     * @since 3.10.0
     */TOUCH_MOVE:4,/**
     * A touch pointer has been started.
     * 
     * @name Phaser.Input.TOUCH_END
     * @type {integer}
     * @since 3.10.0
     */TOUCH_END:5,/**
     * The pointer lock has changed.
     * 
     * @name Phaser.Input.POINTER_LOCK_CHANGE
     * @type {integer}
     * @since 3.10.0
     */POINTER_LOCK_CHANGE:6,/**
     * A touch pointer has been been cancelled by the browser.
     * 
     * @name Phaser.Input.TOUCH_CANCEL
     * @type {integer}
     * @since 3.15.0
     */TOUCH_CANCEL:7,/**
     * The mouse wheel changes.
     * 
     * @name Phaser.Input.MOUSE_WHEEL
     * @type {integer}
     * @since 3.18.0
     */MOUSE_WHEEL:8}}),r("2nOjn",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Input.Events
 */t.exports={BOOT:s("iFiZ5"),DESTROY:s("3HaDB"),DRAG_END:s("6mx1i"),DRAG_ENTER:s("jk8Kd"),DRAG:s("3WF9Q"),DRAG_LEAVE:s("5Qkj5"),DRAG_OVER:s("ltytI"),DRAG_START:s("6Qryf"),DROP:s("knigW"),GAME_OUT:s("5oC5k"),GAME_OVER:s("8C4sB"),GAMEOBJECT_DOWN:s("7Oftj"),GAMEOBJECT_DRAG_END:s("9Iwd8"),GAMEOBJECT_DRAG_ENTER:s("frUzC"),GAMEOBJECT_DRAG:s("hCqfb"),GAMEOBJECT_DRAG_LEAVE:s("bXQ64"),GAMEOBJECT_DRAG_OVER:s("bNYF4"),GAMEOBJECT_DRAG_START:s("OmQPT"),GAMEOBJECT_DROP:s("jEnda"),GAMEOBJECT_MOVE:s("60XRK"),GAMEOBJECT_OUT:s("1sITA"),GAMEOBJECT_OVER:s("eqcRo"),GAMEOBJECT_POINTER_DOWN:s("6TpPo"),GAMEOBJECT_POINTER_MOVE:s("g3uzZ"),GAMEOBJECT_POINTER_OUT:s("i7mHF"),GAMEOBJECT_POINTER_OVER:s("4eRkD"),GAMEOBJECT_POINTER_UP:s("gg7DB"),GAMEOBJECT_POINTER_WHEEL:s("8UIGa"),GAMEOBJECT_UP:s("ctPWb"),GAMEOBJECT_WHEEL:s("5IRJh"),MANAGER_BOOT:s("3kqsk"),MANAGER_PROCESS:s("i7zGI"),MANAGER_UPDATE:s("dd0KV"),POINTER_DOWN:s("1sxHL"),POINTER_DOWN_OUTSIDE:s("8CGcw"),POINTER_MOVE:s("4li2e"),POINTER_OUT:s("aZsBE"),POINTER_OVER:s("9fwZR"),POINTER_UP:s("eNCWU"),POINTER_UP_OUTSIDE:s("bROn8"),POINTER_WHEEL:s("5GjXc"),POINTERLOCK_CHANGE:s("a5LHP"),PRE_UPDATE:s("cD8SJ"),SHUTDOWN:s("eC17K"),START:s("8cyv7"),UPDATE:s("32r8k")}}),r("iFiZ5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Input Plugin Boot Event.
 * 
 * This internal event is dispatched by the Input Plugin when it boots, signalling to all of its systems to create themselves.
 *
 * @event Phaser.Input.Events#BOOT
 * @since 3.0.0
 */t.exports="boot"}),r("3HaDB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Input Plugin Destroy Event.
 * 
 * This internal event is dispatched by the Input Plugin when it is destroyed, signalling to all of its systems to destroy themselves.
 *
 * @event Phaser.Input.Events#DESTROY
 * @since 3.0.0
 */t.exports="destroy"}),r("6mx1i",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Drag End Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer stops dragging a Game Object.
 * 
 * Listen to this event from within a Scene using: `this.input.on('dragend', listener)`.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_END]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_END} event instead.
 *
 * @event Phaser.Input.Events#DRAG_END
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The interactive Game Object that this pointer stopped dragging.
 */t.exports="dragend"}),r("jk8Kd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Drag Enter Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer drags a Game Object into a Drag Target.
 * 
 * Listen to this event from within a Scene using: `this.input.on('dragenter', listener)`.
 * 
 * A Pointer can only drag a single Game Object at once.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_ENTER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_ENTER} event instead.
 *
 * @event Phaser.Input.Events#DRAG_ENTER
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The interactive Game Object that this pointer is dragging.
 * @param {Phaser.GameObjects.GameObject} target - The drag target that this pointer has moved into.
 */t.exports="dragenter"}),r("3WF9Q",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Drag Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer moves while dragging a Game Object.
 * 
 * Listen to this event from within a Scene using: `this.input.on('drag', listener)`.
 * 
 * A Pointer can only drag a single Game Object at once.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG} event instead.
 *
 * @event Phaser.Input.Events#DRAG
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The interactive Game Object that this pointer is dragging.
 * @param {number} dragX - The x coordinate where the Pointer is currently dragging the Game Object, in world space.
 * @param {number} dragY - The y coordinate where the Pointer is currently dragging the Game Object, in world space.
 */t.exports="drag"}),r("5Qkj5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Drag Leave Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer drags a Game Object out of a Drag Target.
 * 
 * Listen to this event from within a Scene using: `this.input.on('dragleave', listener)`.
 * 
 * A Pointer can only drag a single Game Object at once.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_LEAVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_LEAVE} event instead.
 *
 * @event Phaser.Input.Events#DRAG_LEAVE
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The interactive Game Object that this pointer is dragging.
 * @param {Phaser.GameObjects.GameObject} target - The drag target that this pointer has left.
 */t.exports="dragleave"}),r("ltytI",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Drag Over Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer drags a Game Object over a Drag Target.
 * 
 * When the Game Object first enters the drag target it will emit a `dragenter` event. If it then moves while within
 * the drag target, it will emit this event instead.
 * 
 * Listen to this event from within a Scene using: `this.input.on('dragover', listener)`.
 * 
 * A Pointer can only drag a single Game Object at once.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_OVER} event instead.
 *
 * @event Phaser.Input.Events#DRAG_OVER
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The interactive Game Object that this pointer is dragging.
 * @param {Phaser.GameObjects.GameObject} target - The drag target that this pointer has moved over.
 */t.exports="dragover"}),r("6Qryf",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Drag Start Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer starts to drag any Game Object.
 * 
 * Listen to this event from within a Scene using: `this.input.on('dragstart', listener)`.
 * 
 * A Pointer can only drag a single Game Object at once.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_START]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_START} event instead.
 *
 * @event Phaser.Input.Events#DRAG_START
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The interactive Game Object that this pointer is dragging.
 */t.exports="dragstart"}),r("knigW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Drop Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer drops a Game Object on a Drag Target.
 * 
 * Listen to this event from within a Scene using: `this.input.on('drop', listener)`.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DROP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DROP} event instead.
 *
 * @event Phaser.Input.Events#DROP
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The interactive Game Object that this pointer was dragging.
 * @param {Phaser.GameObjects.GameObject} target - The Drag Target the `gameObject` has been dropped on.
 */t.exports="drop"}),r("5oC5k",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Input Plugin Game Out Event.
 * 
 * This event is dispatched by the Input Plugin if the active pointer leaves the game canvas and is now
 * outside of it, elsewhere on the web page.
 * 
 * Listen to this event from within a Scene using: `this.input.on('gameout', listener)`.
 *
 * @event Phaser.Input.Events#GAME_OUT
 * @since 3.16.1
 * 
 * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
 * @param {(MouseEvent|TouchEvent)} event - The DOM Event that triggered the canvas out.
 */t.exports="gameout"}),r("8C4sB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Input Plugin Game Over Event.
 * 
 * This event is dispatched by the Input Plugin if the active pointer enters the game canvas and is now
 * over of it, having previously been elsewhere on the web page.
 * 
 * Listen to this event from within a Scene using: `this.input.on('gameover', listener)`.
 *
 * @event Phaser.Input.Events#GAME_OVER
 * @since 3.16.1
 * 
 * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
 * @param {(MouseEvent|TouchEvent)} event - The DOM Event that triggered the canvas over.
 */t.exports="gameover"}),r("7Oftj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Down Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is pressed down on _any_ interactive Game Object.
 * 
 * Listen to this event from within a Scene using: `this.input.on('gameobjectdown', listener)`.
 * 
 * To receive this event, the Game Objects must have been set as interactive.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN} event instead.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}
 * 2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}
 * 3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_DOWN
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object the pointer was pressed down on.
 * @param {Phaser.Types.Input.EventData} event - The Phaser input event. You can call `stopPropagation()` to halt it from going any further in the event flow.
 */t.exports="gameobjectdown"}),r("9Iwd8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Drag End Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer stops dragging it.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('dragend', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive and enabled for drag.
 * See [GameObject.setInteractive](Phaser.GameObjects.GameObject#setInteractive) for more details.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_DRAG_END
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {number} dragX - The x coordinate where the Pointer stopped dragging the Game Object, in world space.
 * @param {number} dragY - The y coordinate where the Pointer stopped dragging the Game Object, in world space.
 */t.exports="dragend"}),r("frUzC",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Drag Enter Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer drags it into a drag target.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('dragenter', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive and enabled for drag.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_DRAG_ENTER
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} target - The drag target that this pointer has moved into.
 */t.exports="dragenter"}),r("hCqfb",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Drag Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer moves while dragging it.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('drag', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive and enabled for drag.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_DRAG
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {number} dragX - The x coordinate where the Pointer is currently dragging the Game Object, in world space.
 * @param {number} dragY - The y coordinate where the Pointer is currently dragging the Game Object, in world space.
 */t.exports="drag"}),r("bXQ64",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Drag Leave Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer drags it out of a drag target.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('dragleave', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive and enabled for drag.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_DRAG_LEAVE
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} target - The drag target that this pointer has left.
 */t.exports="dragleave"}),r("bNYF4",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Drag Over Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer drags it over a drag target.
 * 
 * When the Game Object first enters the drag target it will emit a `dragenter` event. If it then moves while within
 * the drag target, it will emit this event instead.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('dragover', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive and enabled for drag.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_DRAG_OVER
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} target - The drag target that this pointer has moved over.
 */t.exports="dragover"}),r("OmQPT",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Drag Start Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer starts to drag it.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('dragstart', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive and enabled for drag.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * There are lots of useful drag related properties that are set within the Game Object when dragging occurs.
 * For example, `gameObject.input.dragStartX`, `dragStartY` and so on.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_DRAG_START
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {number} dragX - The x coordinate where the Pointer is currently dragging the Game Object, in world space.
 * @param {number} dragY - The y coordinate where the Pointer is currently dragging the Game Object, in world space.
 */t.exports="dragstart"}),r("jEnda",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Drop Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer drops it on a Drag Target.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('drop', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive and enabled for drag.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_DROP
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} target - The Drag Target the `gameObject` has been dropped on.
 */t.exports="drop"}),r("60XRK",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Move Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is moved across _any_ interactive Game Object.
 * 
 * Listen to this event from within a Scene using: `this.input.on('gameobjectmove', listener)`.
 * 
 * To receive this event, the Game Objects must have been set as interactive.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE} event instead.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE}
 * 2. [GAMEOBJECT_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_MOVE}
 * 3. [POINTER_MOVE]{@linkcode Phaser.Input.Events#event:POINTER_MOVE}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_MOVE
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object the pointer was moved on.
 * @param {Phaser.Types.Input.EventData} event - The Phaser input event. You can call `stopPropagation()` to halt it from going any further in the event flow.
 */t.exports="gameobjectmove"}),r("1sITA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Out Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer moves out of _any_ interactive Game Object.
 * 
 * Listen to this event from within a Scene using: `this.input.on('gameobjectout', listener)`.
 * 
 * To receive this event, the Game Objects must have been set as interactive.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT} event instead.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT}
 * 2. [GAMEOBJECT_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OUT}
 * 3. [POINTER_OUT]{@linkcode Phaser.Input.Events#event:POINTER_OUT}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_OUT
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object the pointer moved out of.
 * @param {Phaser.Types.Input.EventData} event - The Phaser input event. You can call `stopPropagation()` to halt it from going any further in the event flow.
 */t.exports="gameobjectout"}),r("eqcRo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Over Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer moves over _any_ interactive Game Object.
 * 
 * Listen to this event from within a Scene using: `this.input.on('gameobjectover', listener)`.
 * 
 * To receive this event, the Game Objects must have been set as interactive.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER} event instead.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER}
 * 2. [GAMEOBJECT_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OVER}
 * 3. [POINTER_OVER]{@linkcode Phaser.Input.Events#event:POINTER_OVER}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_OVER
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object the pointer moved over.
 * @param {Phaser.Types.Input.EventData} event - The Phaser input event. You can call `stopPropagation()` to halt it from going any further in the event flow.
 */t.exports="gameobjectover"}),r("6TpPo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Pointer Down Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer is pressed down on it.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('pointerdown', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}
 * 2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}
 * 3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_POINTER_DOWN
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {number} localX - The x coordinate that the Pointer interacted with this object on, relative to the Game Object's top-left position.
 * @param {number} localY - The y coordinate that the Pointer interacted with this object on, relative to the Game Object's top-left position.
 * @param {Phaser.Types.Input.EventData} event - The Phaser input event. You can call `stopPropagation()` to halt it from going any further in the event flow.
 */t.exports="pointerdown"}),r("g3uzZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Pointer Move Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer is moved while over it.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('pointermove', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE}
 * 2. [GAMEOBJECT_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_MOVE}
 * 3. [POINTER_MOVE]{@linkcode Phaser.Input.Events#event:POINTER_MOVE}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_POINTER_MOVE
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {number} localX - The x coordinate that the Pointer interacted with this object on, relative to the Game Object's top-left position.
 * @param {number} localY - The y coordinate that the Pointer interacted with this object on, relative to the Game Object's top-left position.
 * @param {Phaser.Types.Input.EventData} event - The Phaser input event. You can call `stopPropagation()` to halt it from going any further in the event flow.
 */t.exports="pointermove"}),r("i7mHF",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Pointer Out Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer moves out of it.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('pointerout', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT}
 * 2. [GAMEOBJECT_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OUT}
 * 3. [POINTER_OUT]{@linkcode Phaser.Input.Events#event:POINTER_OUT}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_POINTER_OUT
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.Types.Input.EventData} event - The Phaser input event. You can call `stopPropagation()` to halt it from going any further in the event flow.
 */t.exports="pointerout"}),r("4eRkD",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Pointer Over Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer moves over it.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('pointerover', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER}
 * 2. [GAMEOBJECT_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OVER}
 * 3. [POINTER_OVER]{@linkcode Phaser.Input.Events#event:POINTER_OVER}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_POINTER_OVER
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {number} localX - The x coordinate that the Pointer interacted with this object on, relative to the Game Object's top-left position.
 * @param {number} localY - The y coordinate that the Pointer interacted with this object on, relative to the Game Object's top-left position.
 * @param {Phaser.Types.Input.EventData} event - The Phaser input event. You can call `stopPropagation()` to halt it from going any further in the event flow.
 */t.exports="pointerover"}),r("gg7DB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Pointer Up Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer is released while over it.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('pointerup', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}
 * 2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}
 * 3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_POINTER_UP
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {number} localX - The x coordinate that the Pointer interacted with this object on, relative to the Game Object's top-left position.
 * @param {number} localY - The y coordinate that the Pointer interacted with this object on, relative to the Game Object's top-left position.
 * @param {Phaser.Types.Input.EventData} event - The Phaser input event. You can call `stopPropagation()` to halt it from going any further in the event flow.
 */t.exports="pointerup"}),r("8UIGa",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Pointer Wheel Event.
 * 
 * This event is dispatched by an interactive Game Object if a pointer has its wheel moved while over it.
 * 
 * Listen to this event from a Game Object using: `gameObject.on('wheel', listener)`.
 * Note that the scope of the listener is automatically set to be the Game Object instance itself.
 * 
 * To receive this event, the Game Object must have been set as interactive.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_WHEEL}
 * 2. [GAMEOBJECT_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_WHEEL}
 * 3. [POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:POINTER_WHEEL}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_POINTER_WHEEL
 * @since 3.18.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {number} deltaX - The horizontal scroll amount that occurred due to the user moving a mouse wheel or similar input device.
 * @param {number} deltaY - The vertical scroll amount that occurred due to the user moving a mouse wheel or similar input device. This value will typically be less than 0 if the user scrolls up and greater than zero if scrolling down.
 * @param {number} deltaZ - The z-axis scroll amount that occurred due to the user moving a mouse wheel or similar input device.
 * @param {Phaser.Types.Input.EventData} event - The Phaser input event. You can call `stopPropagation()` to halt it from going any further in the event flow.
 */t.exports="wheel"}),r("ctPWb",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Up Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is released while over _any_ interactive Game Object.
 * 
 * Listen to this event from within a Scene using: `this.input.on('gameobjectup', listener)`.
 * 
 * To receive this event, the Game Objects must have been set as interactive.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP} event instead.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}
 * 2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}
 * 3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_UP
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object the pointer was over when released.
 * @param {Phaser.Types.Input.EventData} event - The Phaser input event. You can call `stopPropagation()` to halt it from going any further in the event flow.
 */t.exports="gameobjectup"}),r("5IRJh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Game Object Wheel Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer has its wheel moved while over _any_ interactive Game Object.
 * 
 * Listen to this event from within a Scene using: `this.input.on('gameobjectwheel', listener)`.
 * 
 * To receive this event, the Game Objects must have been set as interactive.
 * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
 * 
 * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_WHEEL} event instead.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_WHEEL}
 * 2. [GAMEOBJECT_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_WHEEL}
 * 3. [POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:POINTER_WHEEL}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#GAMEOBJECT_WHEEL
 * @since 3.18.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object the pointer was over when the wheel changed.
 * @param {number} deltaX - The horizontal scroll amount that occurred due to the user moving a mouse wheel or similar input device.
 * @param {number} deltaY - The vertical scroll amount that occurred due to the user moving a mouse wheel or similar input device. This value will typically be less than 0 if the user scrolls up and greater than zero if scrolling down.
 * @param {number} deltaZ - The z-axis scroll amount that occurred due to the user moving a mouse wheel or similar input device.
 * @param {Phaser.Types.Input.EventData} event - The Phaser input event. You can call `stopPropagation()` to halt it from going any further in the event flow.
 */t.exports="gameobjectwheel"}),r("3kqsk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Input Manager Boot Event.
 * 
 * This internal event is dispatched by the Input Manager when it boots.
 *
 * @event Phaser.Input.Events#MANAGER_BOOT
 * @since 3.0.0
 */t.exports="boot"}),r("i7zGI",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Input Manager Process Event.
 * 
 * This internal event is dispatched by the Input Manager when not using the legacy queue system,
 * and it wants the Input Plugins to update themselves.
 *
 * @event Phaser.Input.Events#MANAGER_PROCESS
 * @since 3.0.0
 * 
 * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
 * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
 */t.exports="process"}),r("dd0KV",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Input Manager Update Event.
 * 
 * This internal event is dispatched by the Input Manager as part of its update step.
 *
 * @event Phaser.Input.Events#MANAGER_UPDATE
 * @since 3.0.0
 */t.exports="update"}),r("1sxHL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Down Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is pressed down anywhere.
 * 
 * Listen to this event from within a Scene using: `this.input.on('pointerdown', listener)`.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}
 * 2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}
 * 3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#POINTER_DOWN
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject[]} currentlyOver - An array containing all interactive Game Objects that the pointer was over when the event was created.
 */t.exports="pointerdown"}),r("8CGcw",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Down Outside Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is pressed down anywhere outside of the game canvas.
 * 
 * Listen to this event from within a Scene using: `this.input.on('pointerdownoutside', listener)`.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}
 * 2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}
 * 3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#POINTER_DOWN_OUTSIDE
 * @since 3.16.1
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 */t.exports="pointerdownoutside"}),r("4li2e",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Move Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is moved anywhere.
 * 
 * Listen to this event from within a Scene using: `this.input.on('pointermove', listener)`.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE}
 * 2. [GAMEOBJECT_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_MOVE}
 * 3. [POINTER_MOVE]{@linkcode Phaser.Input.Events#event:POINTER_MOVE}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#POINTER_MOVE
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject[]} currentlyOver - An array containing all interactive Game Objects that the pointer was over when the event was created.
 */t.exports="pointermove"}),r("aZsBE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Out Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer moves out of any interactive Game Object.
 * 
 * Listen to this event from within a Scene using: `this.input.on('pointerout', listener)`.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT}
 * 2. [GAMEOBJECT_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OUT}
 * 3. [POINTER_OUT]{@linkcode Phaser.Input.Events#event:POINTER_OUT}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#POINTER_OUT
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject[]} justOut - An array containing all interactive Game Objects that the pointer moved out of when the event was created.
 */t.exports="pointerout"}),r("9fwZR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Over Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer moves over any interactive Game Object.
 * 
 * Listen to this event from within a Scene using: `this.input.on('pointerover', listener)`.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER}
 * 2. [GAMEOBJECT_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OVER}
 * 3. [POINTER_OVER]{@linkcode Phaser.Input.Events#event:POINTER_OVER}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#POINTER_OVER
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject[]} justOver - An array containing all interactive Game Objects that the pointer moved over when the event was created.
 */t.exports="pointerover"}),r("eNCWU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Up Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is released anywhere.
 * 
 * Listen to this event from within a Scene using: `this.input.on('pointerup', listener)`.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}
 * 2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}
 * 3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#POINTER_UP
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject[]} currentlyOver - An array containing all interactive Game Objects that the pointer was over when the event was created.
 */t.exports="pointerup"}),r("bROn8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Up Outside Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is released anywhere outside of the game canvas.
 * 
 * Listen to this event from within a Scene using: `this.input.on('pointerupoutside', listener)`.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}
 * 2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}
 * 3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#POINTER_UP_OUTSIDE
 * @since 3.16.1
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 */t.exports="pointerupoutside"}),r("5GjXc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pointer Wheel Input Event.
 * 
 * This event is dispatched by the Input Plugin belonging to a Scene if a pointer has its wheel updated.
 * 
 * Listen to this event from within a Scene using: `this.input.on('wheel', listener)`.
 * 
 * The event hierarchy is as follows:
 * 
 * 1. [GAMEOBJECT_POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_WHEEL}
 * 2. [GAMEOBJECT_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_WHEEL}
 * 3. [POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:POINTER_WHEEL}
 * 
 * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
 * the propagation of this event.
 *
 * @event Phaser.Input.Events#POINTER_WHEEL
 * @since 3.18.0
 * 
 * @param {Phaser.Input.Pointer} pointer - The Pointer responsible for triggering this event.
 * @param {Phaser.GameObjects.GameObject[]} currentlyOver - An array containing all interactive Game Objects that the pointer was over when the event was created.
 * @param {number} deltaX - The horizontal scroll amount that occurred due to the user moving a mouse wheel or similar input device.
 * @param {number} deltaY - The vertical scroll amount that occurred due to the user moving a mouse wheel or similar input device. This value will typically be less than 0 if the user scrolls up and greater than zero if scrolling down.
 * @param {number} deltaZ - The z-axis scroll amount that occurred due to the user moving a mouse wheel or similar input device.
 */t.exports="wheel"}),r("a5LHP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Input Manager Pointer Lock Change Event.
 * 
 * This event is dispatched by the Input Manager when it is processing a native Pointer Lock Change DOM Event.
 *
 * @event Phaser.Input.Events#POINTERLOCK_CHANGE
 * @since 3.0.0
 * 
 * @param {Event} event - The native DOM Event.
 * @param {boolean} locked - The locked state of the Mouse Pointer.
 */t.exports="pointerlockchange"}),r("cD8SJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Input Plugin Pre-Update Event.
 * 
 * This internal event is dispatched by the Input Plugin at the start of its `preUpdate` method.
 * This hook is designed specifically for input plugins, but can also be listened to from user-land code.
 *
 * @event Phaser.Input.Events#PRE_UPDATE
 * @since 3.0.0
 */t.exports="preupdate"}),r("eC17K",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Input Plugin Shutdown Event.
 * 
 * This internal event is dispatched by the Input Plugin when it shuts down, signalling to all of its systems to shut themselves down.
 *
 * @event Phaser.Input.Events#SHUTDOWN
 * @since 3.0.0
 */t.exports="shutdown"}),r("8cyv7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Input Plugin Start Event.
 * 
 * This internal event is dispatched by the Input Plugin when it has finished setting-up,
 * signalling to all of its internal systems to start.
 *
 * @event Phaser.Input.Events#START
 * @since 3.0.0
 */t.exports="start"}),r("32r8k",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Input Plugin Update Event.
 * 
 * This internal event is dispatched by the Input Plugin at the start of its `update` method.
 * This hook is designed specifically for input plugins, but can also be listened to from user-land code.
 *
 * @event Phaser.Input.Events#UPDATE
 * @since 3.0.0
 * 
 * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
 * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
 */t.exports="update"}),r("c0CF7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2SW6f"),n=s("jwj1g"),r=s("aqcI1"),o=s("2nOjn"),a=s("hmrEO"),n=s("jwj1g"),h=new n({initialize:function(t){/**
         * A reference to the Input Manager.
         *
         * @name Phaser.Input.Keyboard.KeyboardManager#manager
         * @type {Phaser.Input.InputManager}
         * @since 3.16.0
         */this.manager=t,/**
         * An internal event queue.
         *
         * @name Phaser.Input.Keyboard.KeyboardManager#queue
         * @type {KeyboardEvent[]}
         * @private
         * @since 3.16.0
         */this.queue=[],/**
         * A flag that controls if the non-modified keys, matching those stored in the `captures` array,
         * have `preventDefault` called on them or not.
         * 
         * A non-modified key is one that doesn't have a modifier key held down with it. The modifier keys are
         * shift, control, alt and the meta key (Command on a Mac, the Windows Key on Windows).
         * Therefore, if the user presses shift + r, it won't prevent this combination, because of the modifier.
         * However, if the user presses just the r key on its own, it will have its event prevented.
         * 
         * If you wish to stop capturing the keys, for example switching out to a DOM based element, then
         * you can toggle this property at run-time.
         *
         * @name Phaser.Input.Keyboard.KeyboardManager#preventDefault
         * @type {boolean}
         * @since 3.16.0
         */this.preventDefault=!0,/**
         * An array of Key Code values that will automatically have `preventDefault` called on them,
         * as long as the `KeyboardManager.preventDefault` boolean is set to `true`.
         * 
         * By default the array is empty.
         * 
         * The key must be non-modified when pressed in order to be captured.
         * 
         * A non-modified key is one that doesn't have a modifier key held down with it. The modifier keys are
         * shift, control, alt and the meta key (Command on a Mac, the Windows Key on Windows).
         * Therefore, if the user presses shift + r, it won't prevent this combination, because of the modifier.
         * However, if the user presses just the r key on its own, it will have its event prevented.
         * 
         * If you wish to stop capturing the keys, for example switching out to a DOM based element, then
         * you can toggle the `KeyboardManager.preventDefault` boolean at run-time.
         * 
         * If you need more specific control, you can create Key objects and set the flag on each of those instead.
         * 
         * This array can be populated via the Game Config by setting the `input.keyboard.capture` array, or you
         * can call the `addCapture` method. See also `removeCapture` and `clearCaptures`.
         *
         * @name Phaser.Input.Keyboard.KeyboardManager#captures
         * @type {integer[]}
         * @since 3.16.0
         */this.captures=[],/**
         * A boolean that controls if the Keyboard Manager is enabled or not.
         * Can be toggled on the fly.
         *
         * @name Phaser.Input.Keyboard.KeyboardManager#enabled
         * @type {boolean}
         * @default false
         * @since 3.16.0
         */this.enabled=!1,/**
         * The Keyboard Event target, as defined in the Game Config.
         * Typically the window in which the game is rendering, but can be any interactive DOM element.
         *
         * @name Phaser.Input.Keyboard.KeyboardManager#target
         * @type {any}
         * @since 3.16.0
         */this.target,/**
         * The Key Down Event handler.
         * This function is sent the native DOM KeyEvent.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Keyboard.KeyboardManager#onKeyDown
         * @type {function}
         * @since 3.16.00
         */this.onKeyDown=n,/**
         * The Key Up Event handler.
         * This function is sent the native DOM KeyEvent.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Keyboard.KeyboardManager#onKeyUp
         * @type {function}
         * @since 3.16.00
         */this.onKeyUp=n,t.events.once(o.MANAGER_BOOT,this.boot,this)},/**
     * The Keyboard Manager boot process.
     *
     * @method Phaser.Input.Keyboard.KeyboardManager#boot
     * @private
     * @since 3.16.0
     */boot:function(){var t=this.manager.config;this.enabled=t.inputKeyboard,this.target=t.inputKeyboardEventTarget,this.addCapture(t.inputKeyboardCapture),!this.target&&window&&(this.target=window),this.enabled&&this.target&&this.startListeners(),this.manager.game.events.on(r.POST_STEP,this.postUpdate,this)},/**
     * Starts the Keyboard Event listeners running.
     * This is called automatically and does not need to be manually invoked.
     *
     * @method Phaser.Input.Keyboard.KeyboardManager#startListeners
     * @since 3.16.0
     */startListeners:function(){var t=this;this.onKeyDown=function(e){if(!e.defaultPrevented&&t.enabled&&t.manager){t.queue.push(e),t.manager.useQueue||t.manager.events.emit(o.MANAGER_PROCESS);var i=e.altKey||e.ctrlKey||e.shiftKey||e.metaKey;t.preventDefault&&!i&&t.captures.indexOf(e.keyCode)>-1&&e.preventDefault()}},this.onKeyUp=function(e){if(!e.defaultPrevented&&t.enabled&&t.manager){t.queue.push(e),t.manager.useQueue||t.manager.events.emit(o.MANAGER_PROCESS);var i=e.altKey||e.ctrlKey||e.shiftKey||e.metaKey;t.preventDefault&&!i&&t.captures.indexOf(e.keyCode)>-1&&e.preventDefault()}};var e=this.target;e&&(e.addEventListener("keydown",this.onKeyDown,!1),e.addEventListener("keyup",this.onKeyUp,!1),this.enabled=!0)},/**
     * Stops the Key Event listeners.
     * This is called automatically and does not need to be manually invoked.
     *
     * @method Phaser.Input.Keyboard.KeyboardManager#stopListeners
     * @since 3.16.0
     */stopListeners:function(){var t=this.target;t.removeEventListener("keydown",this.onKeyDown,!1),t.removeEventListener("keyup",this.onKeyUp,!1),this.enabled=!1},/**
     * Clears the event queue.
     * Called automatically by the Input Manager.
     *
     * @method Phaser.Input.Keyboard.KeyboardManager#postUpdate
     * @private
     * @since 3.16.0
     */postUpdate:function(){this.queue=[]},/**
     * By default when a key is pressed Phaser will not stop the event from propagating up to the browser.
     * There are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.
     *
     * This `addCapture` method enables consuming keyboard event for specific keys so it doesn't bubble up to the the browser
     * and cause the default browser behavior.
     * 
     * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to say prevent
     * the SPACE BAR from triggering a page scroll, then it will prevent it for any Scene in your game, not just the calling one.
     * 
     * You can pass in a single key code value, or an array of key codes, or a string:
     * 
     * ```javascript
     * this.input.keyboard.addCapture(62);
     * ```
     * 
     * An array of key codes:
     * 
     * ```javascript
     * this.input.keyboard.addCapture([ 62, 63, 64 ]);
     * ```
     * 
     * Or a string:
     * 
     * ```javascript
     * this.input.keyboard.addCapture('W,S,A,D');
     * ```
     * 
     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.
     * 
     * You can also provide an array mixing both strings and key code integers.
     * 
     * If there are active captures after calling this method, the `preventDefault` property is set to `true`.
     *
     * @method Phaser.Input.Keyboard.KeyboardManager#addCapture
     * @since 3.16.0
     * 
     * @param {(string|integer|integer[]|any[])} keycode - The Key Codes to enable capture for, preventing them reaching the browser.
     */addCapture:function(t){"string"==typeof t&&(t=t.split(",")),Array.isArray(t)||(t=[t]);for(var e=this.captures,i=0;i<t.length;i++){var n=t[i];"string"==typeof n&&(n=a[n.trim().toUpperCase()]),-1===e.indexOf(n)&&e.push(n)}this.preventDefault=e.length>0},/**
     * Removes an existing key capture.
     * 
     * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to remove
     * the capture of a key, then it will remove it for any Scene in your game, not just the calling one.
     * 
     * You can pass in a single key code value, or an array of key codes, or a string:
     * 
     * ```javascript
     * this.input.keyboard.removeCapture(62);
     * ```
     * 
     * An array of key codes:
     * 
     * ```javascript
     * this.input.keyboard.removeCapture([ 62, 63, 64 ]);
     * ```
     * 
     * Or a string:
     * 
     * ```javascript
     * this.input.keyboard.removeCapture('W,S,A,D');
     * ```
     * 
     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.
     * 
     * You can also provide an array mixing both strings and key code integers.
     * 
     * If there are no captures left after calling this method, the `preventDefault` property is set to `false`.
     *
     * @method Phaser.Input.Keyboard.KeyboardManager#removeCapture
     * @since 3.16.0
     * 
     * @param {(string|integer|integer[]|any[])} keycode - The Key Codes to disable capture for, allowing them reaching the browser again.
     */removeCapture:function(t){"string"==typeof t&&(t=t.split(",")),Array.isArray(t)||(t=[t]);for(var e=this.captures,n=0;n<t.length;n++){var s=t[n];"string"==typeof s&&(s=a[s.toUpperCase()]),i(e,s)}this.preventDefault=e.length>0},/**
     * Removes all keyboard captures and sets the `preventDefault` property to `false`.
     *
     * @method Phaser.Input.Keyboard.KeyboardManager#clearCaptures
     * @since 3.16.0
     */clearCaptures:function(){this.captures=[],this.preventDefault=!1},/**
     * Destroys this Keyboard Manager instance.
     *
     * @method Phaser.Input.Keyboard.KeyboardManager#destroy
     * @since 3.16.0
     */destroy:function(){this.stopListeners(),this.clearCaptures(),this.queue=[],this.manager.game.events.off(r.POST_RENDER,this.postUpdate,this),this.target=null,this.enabled=!1,this.manager=null}});t.exports=h}),r("2SW6f",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eOqX8");t.exports=function(t,e,n,s){//  Fast path to avoid array mutation and iteration
if(void 0===s&&(s=t),!Array.isArray(e))return -1!==(r=t.indexOf(e))?(i(t,r),n&&n.call(s,e),e):null;for(//  If we got this far, we have an array of items to remove
var r,o=e.length-1;o>=0;){var a=e[o];-1!==(r=t.indexOf(a))?(i(t,r),n&&n.call(s,a)):e.pop(),o--}return e}}),r("hmrEO",function(t,e){t.exports={/**
     * The BACKSPACE key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.BACKSPACE
     * @type {integer}
     * @since 3.0.0
     */BACKSPACE:8,/**
     * The TAB key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.TAB
     * @type {integer}
     * @since 3.0.0
     */TAB:9,/**
     * The ENTER key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.ENTER
     * @type {integer}
     * @since 3.0.0
     */ENTER:13,/**
     * The SHIFT key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.SHIFT
     * @type {integer}
     * @since 3.0.0
     */SHIFT:16,/**
     * The CTRL key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.CTRL
     * @type {integer}
     * @since 3.0.0
     */CTRL:17,/**
     * The ALT key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.ALT
     * @type {integer}
     * @since 3.0.0
     */ALT:18,/**
     * The PAUSE key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.PAUSE
     * @type {integer}
     * @since 3.0.0
     */PAUSE:19,/**
     * The CAPS_LOCK key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.CAPS_LOCK
     * @type {integer}
     * @since 3.0.0
     */CAPS_LOCK:20,/**
     * The ESC key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.ESC
     * @type {integer}
     * @since 3.0.0
     */ESC:27,/**
     * The SPACE key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.SPACE
     * @type {integer}
     * @since 3.0.0
     */SPACE:32,/**
     * The PAGE_UP key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.PAGE_UP
     * @type {integer}
     * @since 3.0.0
     */PAGE_UP:33,/**
     * The PAGE_DOWN key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.PAGE_DOWN
     * @type {integer}
     * @since 3.0.0
     */PAGE_DOWN:34,/**
     * The END key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.END
     * @type {integer}
     * @since 3.0.0
     */END:35,/**
     * The HOME key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.HOME
     * @type {integer}
     * @since 3.0.0
     */HOME:36,/**
     * The LEFT key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.LEFT
     * @type {integer}
     * @since 3.0.0
     */LEFT:37,/**
     * The UP key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.UP
     * @type {integer}
     * @since 3.0.0
     */UP:38,/**
     * The RIGHT key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.RIGHT
     * @type {integer}
     * @since 3.0.0
     */RIGHT:39,/**
     * The DOWN key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.DOWN
     * @type {integer}
     * @since 3.0.0
     */DOWN:40,/**
     * The PRINT_SCREEN key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.PRINT_SCREEN
     * @type {integer}
     * @since 3.0.0
     */PRINT_SCREEN:42,/**
     * The INSERT key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.INSERT
     * @type {integer}
     * @since 3.0.0
     */INSERT:45,/**
     * The DELETE key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.DELETE
     * @type {integer}
     * @since 3.0.0
     */DELETE:46,/**
     * The ZERO key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.ZERO
     * @type {integer}
     * @since 3.0.0
     */ZERO:48,/**
     * The ONE key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.ONE
     * @type {integer}
     * @since 3.0.0
     */ONE:49,/**
     * The TWO key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.TWO
     * @type {integer}
     * @since 3.0.0
     */TWO:50,/**
     * The THREE key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.THREE
     * @type {integer}
     * @since 3.0.0
     */THREE:51,/**
     * The FOUR key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.FOUR
     * @type {integer}
     * @since 3.0.0
     */FOUR:52,/**
     * The FIVE key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.FIVE
     * @type {integer}
     * @since 3.0.0
     */FIVE:53,/**
     * The SIX key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.SIX
     * @type {integer}
     * @since 3.0.0
     */SIX:54,/**
     * The SEVEN key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.SEVEN
     * @type {integer}
     * @since 3.0.0
     */SEVEN:55,/**
     * The EIGHT key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.EIGHT
     * @type {integer}
     * @since 3.0.0
     */EIGHT:56,/**
     * The NINE key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NINE
     * @type {integer}
     * @since 3.0.0
     */NINE:57,/**
     * The NUMPAD_ZERO key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NUMPAD_ZERO
     * @type {integer}
     * @since 3.0.0
     */NUMPAD_ZERO:96,/**
     * The NUMPAD_ONE key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NUMPAD_ONE
     * @type {integer}
     * @since 3.0.0
     */NUMPAD_ONE:97,/**
     * The NUMPAD_TWO key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NUMPAD_TWO
     * @type {integer}
     * @since 3.0.0
     */NUMPAD_TWO:98,/**
     * The NUMPAD_THREE key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NUMPAD_THREE
     * @type {integer}
     * @since 3.0.0
     */NUMPAD_THREE:99,/**
     * The NUMPAD_FOUR key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NUMPAD_FOUR
     * @type {integer}
     * @since 3.0.0
     */NUMPAD_FOUR:100,/**
     * The NUMPAD_FIVE key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NUMPAD_FIVE
     * @type {integer}
     * @since 3.0.0
     */NUMPAD_FIVE:101,/**
     * The NUMPAD_SIX key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NUMPAD_SIX
     * @type {integer}
     * @since 3.0.0
     */NUMPAD_SIX:102,/**
     * The NUMPAD_SEVEN key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NUMPAD_SEVEN
     * @type {integer}
     * @since 3.0.0
     */NUMPAD_SEVEN:103,/**
     * The NUMPAD_EIGHT key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NUMPAD_EIGHT
     * @type {integer}
     * @since 3.0.0
     */NUMPAD_EIGHT:104,/**
     * The NUMPAD_NINE key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NUMPAD_NINE
     * @type {integer}
     * @since 3.0.0
     */NUMPAD_NINE:105,/**
     * The Numpad Addition (+) key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NUMPAD_ADD
     * @type {integer}
     * @since 3.21.0
     */NUMPAD_ADD:107,/**
     * The Numpad Subtraction (-) key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.NUMPAD_SUBTRACT
     * @type {integer}
     * @since 3.21.0
     */NUMPAD_SUBTRACT:109,/**
     * The A key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.A
     * @type {integer}
     * @since 3.0.0
     */A:65,/**
     * The B key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.B
     * @type {integer}
     * @since 3.0.0
     */B:66,/**
     * The C key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.C
     * @type {integer}
     * @since 3.0.0
     */C:67,/**
     * The D key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.D
     * @type {integer}
     * @since 3.0.0
     */D:68,/**
     * The E key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.E
     * @type {integer}
     * @since 3.0.0
     */E:69,/**
     * The F key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F
     * @type {integer}
     * @since 3.0.0
     */F:70,/**
     * The G key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.G
     * @type {integer}
     * @since 3.0.0
     */G:71,/**
     * The H key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.H
     * @type {integer}
     * @since 3.0.0
     */H:72,/**
     * The I key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.I
     * @type {integer}
     * @since 3.0.0
     */I:73,/**
     * The J key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.J
     * @type {integer}
     * @since 3.0.0
     */J:74,/**
     * The K key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.K
     * @type {integer}
     * @since 3.0.0
     */K:75,/**
     * The L key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.L
     * @type {integer}
     * @since 3.0.0
     */L:76,/**
     * The M key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.M
     * @type {integer}
     * @since 3.0.0
     */M:77,/**
     * The N key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.N
     * @type {integer}
     * @since 3.0.0
     */N:78,/**
     * The O key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.O
     * @type {integer}
     * @since 3.0.0
     */O:79,/**
     * The P key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.P
     * @type {integer}
     * @since 3.0.0
     */P:80,/**
     * The Q key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.Q
     * @type {integer}
     * @since 3.0.0
     */Q:81,/**
     * The R key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.R
     * @type {integer}
     * @since 3.0.0
     */R:82,/**
     * The S key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.S
     * @type {integer}
     * @since 3.0.0
     */S:83,/**
     * The T key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.T
     * @type {integer}
     * @since 3.0.0
     */T:84,/**
     * The U key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.U
     * @type {integer}
     * @since 3.0.0
     */U:85,/**
     * The V key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.V
     * @type {integer}
     * @since 3.0.0
     */V:86,/**
     * The W key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.W
     * @type {integer}
     * @since 3.0.0
     */W:87,/**
     * The X key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.X
     * @type {integer}
     * @since 3.0.0
     */X:88,/**
     * The Y key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.Y
     * @type {integer}
     * @since 3.0.0
     */Y:89,/**
     * The Z key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.Z
     * @type {integer}
     * @since 3.0.0
     */Z:90,/**
     * The F1 key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F1
     * @type {integer}
     * @since 3.0.0
     */F1:112,/**
     * The F2 key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F2
     * @type {integer}
     * @since 3.0.0
     */F2:113,/**
     * The F3 key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F3
     * @type {integer}
     * @since 3.0.0
     */F3:114,/**
     * The F4 key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F4
     * @type {integer}
     * @since 3.0.0
     */F4:115,/**
     * The F5 key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F5
     * @type {integer}
     * @since 3.0.0
     */F5:116,/**
     * The F6 key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F6
     * @type {integer}
     * @since 3.0.0
     */F6:117,/**
     * The F7 key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F7
     * @type {integer}
     * @since 3.0.0
     */F7:118,/**
     * The F8 key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F8
     * @type {integer}
     * @since 3.0.0
     */F8:119,/**
     * The F9 key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F9
     * @type {integer}
     * @since 3.0.0
     */F9:120,/**
     * The F10 key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F10
     * @type {integer}
     * @since 3.0.0
     */F10:121,/**
     * The F11 key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F11
     * @type {integer}
     * @since 3.0.0
     */F11:122,/**
     * The F12 key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.F12
     * @type {integer}
     * @since 3.0.0
     */F12:123,/**
     * The SEMICOLON key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.SEMICOLON
     * @type {integer}
     * @since 3.0.0
     */SEMICOLON:186,/**
     * The PLUS key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.PLUS
     * @type {integer}
     * @since 3.0.0
     */PLUS:187,/**
     * The COMMA key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.COMMA
     * @type {integer}
     * @since 3.0.0
     */COMMA:188,/**
     * The MINUS key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.MINUS
     * @type {integer}
     * @since 3.0.0
     */MINUS:189,/**
     * The PERIOD key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.PERIOD
     * @type {integer}
     * @since 3.0.0
     */PERIOD:190,/**
     * The FORWARD_SLASH key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.FORWARD_SLASH
     * @type {integer}
     * @since 3.0.0
     */FORWARD_SLASH:191,/**
     * The BACK_SLASH key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.BACK_SLASH
     * @type {integer}
     * @since 3.0.0
     */BACK_SLASH:220,/**
     * The QUOTES key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.QUOTES
     * @type {integer}
     * @since 3.0.0
     */QUOTES:222,/**
     * The BACKTICK key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.BACKTICK
     * @type {integer}
     * @since 3.0.0
     */BACKTICK:192,/**
     * The OPEN_BRACKET key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.OPEN_BRACKET
     * @type {integer}
     * @since 3.0.0
     */OPEN_BRACKET:219,/**
     * The CLOSED_BRACKET key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.CLOSED_BRACKET
     * @type {integer}
     * @since 3.0.0
     */CLOSED_BRACKET:221,/**
     * The SEMICOLON_FIREFOX key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.SEMICOLON_FIREFOX
     * @type {integer}
     * @since 3.0.0
     */SEMICOLON_FIREFOX:59,/**
     * The COLON key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.COLON
     * @type {integer}
     * @since 3.0.0
     */COLON:58,/**
     * The COMMA_FIREFOX_WINDOWS key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.COMMA_FIREFOX_WINDOWS
     * @type {integer}
     * @since 3.0.0
     */COMMA_FIREFOX_WINDOWS:60,/**
     * The COMMA_FIREFOX key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.COMMA_FIREFOX
     * @type {integer}
     * @since 3.0.0
     */COMMA_FIREFOX:62,/**
     * The BRACKET_RIGHT_FIREFOX key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.BRACKET_RIGHT_FIREFOX
     * @type {integer}
     * @since 3.0.0
     */BRACKET_RIGHT_FIREFOX:174,/**
     * The BRACKET_LEFT_FIREFOX key.
     * 
     * @name Phaser.Input.Keyboard.KeyCodes.BRACKET_LEFT_FIREFOX
     * @type {integer}
     * @since 3.0.0
     */BRACKET_LEFT_FIREFOX:175}}),r("jy9yA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("9t9UB"),r=s("2nOjn"),i=s("jwj1g"),o=new i({initialize:function(t){/**
         * A reference to the Input Manager.
         *
         * @name Phaser.Input.Mouse.MouseManager#manager
         * @type {Phaser.Input.InputManager}
         * @since 3.0.0
         */this.manager=t,/**
         * If true the DOM mouse events will have event.preventDefault applied to them, if false they will propagate fully.
         *
         * @name Phaser.Input.Mouse.MouseManager#capture
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.capture=!0,/**
         * A boolean that controls if the Mouse Manager is enabled or not.
         * Can be toggled on the fly.
         *
         * @name Phaser.Input.Mouse.MouseManager#enabled
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.enabled=!1,/**
         * The Mouse target, as defined in the Game Config.
         * Typically the canvas to which the game is rendering, but can be any interactive DOM element.
         *
         * @name Phaser.Input.Mouse.MouseManager#target
         * @type {any}
         * @since 3.0.0
         */this.target,/**
         * If the mouse has been pointer locked successfully this will be set to true.
         *
         * @name Phaser.Input.Mouse.MouseManager#locked
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.locked=!1,/**
         * The Mouse Move Event handler.
         * This function is sent the native DOM MouseEvent.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Mouse.MouseManager#onMouseMove
         * @type {function}
         * @since 3.10.0
         */this.onMouseMove=i,/**
         * The Mouse Down Event handler.
         * This function is sent the native DOM MouseEvent.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Mouse.MouseManager#onMouseDown
         * @type {function}
         * @since 3.10.0
         */this.onMouseDown=i,/**
         * The Mouse Up Event handler.
         * This function is sent the native DOM MouseEvent.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Mouse.MouseManager#onMouseUp
         * @type {function}
         * @since 3.10.0
         */this.onMouseUp=i,/**
         * The Mouse Down Event handler specifically for events on the Window.
         * This function is sent the native DOM MouseEvent.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Mouse.MouseManager#onMouseDownWindow
         * @type {function}
         * @since 3.17.0
         */this.onMouseDownWindow=i,/**
         * The Mouse Up Event handler specifically for events on the Window.
         * This function is sent the native DOM MouseEvent.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Mouse.MouseManager#onMouseUpWindow
         * @type {function}
         * @since 3.17.0
         */this.onMouseUpWindow=i,/**
         * The Mouse Over Event handler.
         * This function is sent the native DOM MouseEvent.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Mouse.MouseManager#onMouseOver
         * @type {function}
         * @since 3.16.0
         */this.onMouseOver=i,/**
         * The Mouse Out Event handler.
         * This function is sent the native DOM MouseEvent.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Mouse.MouseManager#onMouseOut
         * @type {function}
         * @since 3.16.0
         */this.onMouseOut=i,/**
         * The Mouse Wheel Event handler.
         * This function is sent the native DOM MouseEvent.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Mouse.MouseManager#onMouseWheel
         * @type {function}
         * @since 3.18.0
         */this.onMouseWheel=i,/**
         * Internal pointerLockChange handler.
         * This function is sent the native DOM MouseEvent.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Mouse.MouseManager#pointerLockChange
         * @type {function}
         * @since 3.0.0
         */this.pointerLockChange=i,t.events.once(r.MANAGER_BOOT,this.boot,this)},/**
     * The Touch Manager boot process.
     *
     * @method Phaser.Input.Mouse.MouseManager#boot
     * @private
     * @since 3.0.0
     */boot:function(){var t=this.manager.config;this.enabled=t.inputMouse,this.target=t.inputMouseEventTarget,this.capture=t.inputMouseCapture,this.target?"string"==typeof this.target&&(this.target=document.getElementById(this.target)):this.target=this.manager.game.canvas,t.disableContextMenu&&this.disableContextMenu(),this.enabled&&this.target&&this.startListeners()},/**
     * Attempts to disable the context menu from appearing if you right-click on the browser.
     * 
     * Works by listening for the `contextmenu` event and prevent defaulting it.
     * 
     * Use this if you need to enable right-button mouse support in your game, and the browser
     * menu keeps getting in the way.
     *
     * @method Phaser.Input.Mouse.MouseManager#disableContextMenu
     * @since 3.0.0
     *
     * @return {this} This Mouse Manager instance.
     */disableContextMenu:function(){return document.body.addEventListener("contextmenu",function(t){return t.preventDefault(),!1}),this},/**
     * If the browser supports it, you can request that the pointer be locked to the browser window.
     *
     * This is classically known as 'FPS controls', where the pointer can't leave the browser until
     * the user presses an exit key.
     *
     * If the browser successfully enters a locked state, a `POINTER_LOCK_CHANGE_EVENT` will be dispatched,
     * from the games Input Manager, with an `isPointerLocked` property.
     *
     * It is important to note that pointer lock can only be enabled after an 'engagement gesture',
     * see: https://w3c.github.io/pointerlock/#dfn-engagement-gesture.
     *
     * @method Phaser.Input.Mouse.MouseManager#requestPointerLock
     * @since 3.0.0
     */requestPointerLock:function(){if(n.pointerLock){var t=this.target;t.requestPointerLock=t.requestPointerLock||t.mozRequestPointerLock||t.webkitRequestPointerLock,t.requestPointerLock()}},/**
     * If the browser supports pointer lock, this will request that the pointer lock is released. If
     * the browser successfully enters a locked state, a 'POINTER_LOCK_CHANGE_EVENT' will be
     * dispatched - from the game's input manager - with an `isPointerLocked` property.
     *
     * @method Phaser.Input.Mouse.MouseManager#releasePointerLock
     * @since 3.0.0
     */releasePointerLock:function(){n.pointerLock&&(document.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock||document.webkitExitPointerLock,document.exitPointerLock())},/**
     * Starts the Mouse Event listeners running.
     * This is called automatically and does not need to be manually invoked.
     *
     * @method Phaser.Input.Mouse.MouseManager#startListeners
     * @since 3.0.0
     */startListeners:function(){var t=this,e=this.manager.canvas,i=window&&window.focus&&this.manager.game.config.autoFocus;this.onMouseMove=function(e){!e.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&(t.manager.onMouseMove(e),t.capture&&e.preventDefault())},this.onMouseDown=function(n){i&&window.focus(),!n.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&(t.manager.onMouseDown(n),t.capture&&n.target===e&&n.preventDefault())},this.onMouseDownWindow=function(i){!i.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&i.target!==e&&t.manager.onMouseDown(i)},this.onMouseUp=function(i){!i.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&(t.manager.onMouseUp(i),t.capture&&i.target===e&&i.preventDefault())},this.onMouseUpWindow=function(i){!i.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&i.target!==e&&t.manager.onMouseUp(i)},this.onMouseOver=function(e){!e.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&t.manager.setCanvasOver(e)},this.onMouseOut=function(e){!e.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&t.manager.setCanvasOut(e)},this.onMouseWheel=function(e){!e.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&t.manager.onMouseWheel(e)};var s=this.target;if(s){var r={passive:!0},o={passive:!1};s.addEventListener("mousemove",this.onMouseMove,this.capture?o:r),s.addEventListener("mousedown",this.onMouseDown,this.capture?o:r),s.addEventListener("mouseup",this.onMouseUp,this.capture?o:r),s.addEventListener("mouseover",this.onMouseOver,this.capture?o:r),s.addEventListener("mouseout",this.onMouseOut,this.capture?o:r),s.addEventListener("wheel",this.onMouseWheel,this.capture?o:r),window&&this.manager.game.config.inputWindowEvents&&(window.addEventListener("mousedown",this.onMouseDownWindow,o),window.addEventListener("mouseup",this.onMouseUpWindow,o)),n.pointerLock&&(this.pointerLockChange=function(e){var i=t.target;t.locked=document.pointerLockElement===i||document.mozPointerLockElement===i||document.webkitPointerLockElement===i,t.manager.onPointerLockChange(e)},document.addEventListener("pointerlockchange",this.pointerLockChange,!0),document.addEventListener("mozpointerlockchange",this.pointerLockChange,!0),document.addEventListener("webkitpointerlockchange",this.pointerLockChange,!0)),this.enabled=!0}},/**
     * Stops the Mouse Event listeners.
     * This is called automatically and does not need to be manually invoked.
     *
     * @method Phaser.Input.Mouse.MouseManager#stopListeners
     * @since 3.0.0
     */stopListeners:function(){var t=this.target;t.removeEventListener("mousemove",this.onMouseMove),t.removeEventListener("mousedown",this.onMouseDown),t.removeEventListener("mouseup",this.onMouseUp),t.removeEventListener("mouseover",this.onMouseOver),t.removeEventListener("mouseout",this.onMouseOut),window&&(window.removeEventListener("mousedown",this.onMouseDownWindow),window.removeEventListener("mouseup",this.onMouseUpWindow)),n.pointerLock&&(document.removeEventListener("pointerlockchange",this.pointerLockChange,!0),document.removeEventListener("mozpointerlockchange",this.pointerLockChange,!0),document.removeEventListener("webkitpointerlockchange",this.pointerLockChange,!0))},/**
     * Destroys this Mouse Manager instance.
     *
     * @method Phaser.Input.Mouse.MouseManager#destroy
     * @since 3.0.0
     */destroy:function(){this.stopListeners(),this.target=null,this.enabled=!1,this.manager=null}});t.exports=o}),r("1Oao7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("n95vh"),n=s("jwj1g"),r=s("bwLQh"),o=s("4cohD"),a=s("gLlh1"),h=s("7SBSk"),l=new n({initialize:function(t,e){/**
         * A reference to the Input Manager.
         *
         * @name Phaser.Input.Pointer#manager
         * @type {Phaser.Input.InputManager}
         * @since 3.0.0
         */this.manager=t,/**
         * The internal ID of this Pointer.
         *
         * @name Phaser.Input.Pointer#id
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.id=e,/**
         * The most recent native DOM Event this Pointer has processed.
         *
         * @name Phaser.Input.Pointer#event
         * @type {(TouchEvent|MouseEvent)}
         * @since 3.0.0
         */this.event,/**
         * The DOM element the Pointer was pressed down on, taken from the DOM event.
         * In a default set-up this will be the Canvas that Phaser is rendering to, or the Window element.
         *
         * @name Phaser.Input.Pointer#downElement
         * @type {any}
         * @readonly
         * @since 3.16.0
         */this.downElement,/**
         * The DOM element the Pointer was released on, taken from the DOM event.
         * In a default set-up this will be the Canvas that Phaser is rendering to, or the Window element.
         *
         * @name Phaser.Input.Pointer#upElement
         * @type {any}
         * @readonly
         * @since 3.16.0
         */this.upElement,/**
         * The camera the Pointer interacted with during its last update.
         * 
         * A Pointer can only ever interact with one camera at once, which will be the top-most camera
         * in the list should multiple cameras be positioned on-top of each other.
         *
         * @name Phaser.Input.Pointer#camera
         * @type {Phaser.Cameras.Scene2D.Camera}
         * @default null
         * @since 3.0.0
         */this.camera=null,/**
         * A read-only property that indicates which button was pressed, or released, on the pointer
         * during the most recent event. It is only set during `up` and `down` events.
         * 
         * On Touch devices the value is always 0.
         * 
         * Users may change the configuration of buttons on their pointing device so that if an event's button property
         * is zero, it may not have been caused by the button that is physically leftmost on the pointing device;
         * however, it should behave as if the left button was clicked in the standard button layout.
         *
         * @name Phaser.Input.Pointer#button
         * @type {integer}
         * @readonly
         * @default 0
         * @since 3.18.0
         */this.button=0,/**
         * 0: No button or un-initialized
         * 1: Left button
         * 2: Right button
         * 4: Wheel button or middle button
         * 8: 4th button (typically the "Browser Back" button)
         * 16: 5th button (typically the "Browser Forward" button)
         * 
         * For a mouse configured for left-handed use, the button actions are reversed.
         * In this case, the values are read from right to left.
         *
         * @name Phaser.Input.Pointer#buttons
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.buttons=0,/**
         * The position of the Pointer in screen space.
         *
         * @name Phaser.Input.Pointer#position
         * @type {Phaser.Math.Vector2}
         * @readonly
         * @since 3.0.0
         */this.position=new h,/**
         * The previous position of the Pointer in screen space.
         * 
         * The old x and y values are stored in here during the InputManager.transformPointer call.
         * 
         * Use the properties `velocity`, `angle` and `distance` to create your own gesture recognition.
         *
         * @name Phaser.Input.Pointer#prevPosition
         * @type {Phaser.Math.Vector2}
         * @readonly
         * @since 3.11.0
         */this.prevPosition=new h,/**
         * An internal vector used for calculations of the pointer speed and angle.
         *
         * @name Phaser.Input.Pointer#midPoint
         * @type {Phaser.Math.Vector2}
         * @private
         * @since 3.16.0
         */this.midPoint=new h(-1,-1),/**
         * The current velocity of the Pointer, based on its current and previous positions.
         * 
         * This value is smoothed out each frame, according to the `motionFactor` property.
         * 
         * This property is updated whenever the Pointer moves, regardless of any button states. In other words,
         * it changes based on movement alone - a button doesn't have to be pressed first.
         *
         * @name Phaser.Input.Pointer#velocity
         * @type {Phaser.Math.Vector2}
         * @readonly
         * @since 3.16.0
         */this.velocity=new h,/**
         * The current angle the Pointer is moving, in radians, based on its previous and current position.
         * 
         * The angle is based on the old position facing to the current position.
         * 
         * This property is updated whenever the Pointer moves, regardless of any button states. In other words,
         * it changes based on movement alone - a button doesn't have to be pressed first.
         *
         * @name Phaser.Input.Pointer#angle
         * @type {number}
         * @readonly
         * @since 3.16.0
         */this.angle=0,/**
         * The distance the Pointer has moved, based on its previous and current position.
         * 
         * This value is smoothed out each frame, according to the `motionFactor` property.
         * 
         * This property is updated whenever the Pointer moves, regardless of any button states. In other words,
         * it changes based on movement alone - a button doesn't have to be pressed first.
         * 
         * If you need the total distance travelled since the primary buttons was pressed down,
         * then use the `Pointer.getDistance` method.
         *
         * @name Phaser.Input.Pointer#distance
         * @type {number}
         * @readonly
         * @since 3.16.0
         */this.distance=0,/**
         * The smoothing factor to apply to the Pointer position.
         * 
         * Due to their nature, pointer positions are inherently noisy. While this is fine for lots of games, if you need cleaner positions
         * then you can set this value to apply an automatic smoothing to the positions as they are recorded.
         * 
         * The default value of zero means 'no smoothing'.
         * Set to a small value, such as 0.2, to apply an average level of smoothing between positions. You can do this by changing this
         * value directly, or by setting the `input.smoothFactor` property in the Game Config.
         * 
         * Positions are only smoothed when the pointer moves. If the primary button on this Pointer enters an Up or Down state, then the position
         * is always precise, and not smoothed.
         *
         * @name Phaser.Input.Pointer#smoothFactor
         * @type {number}
         * @default 0
         * @since 3.16.0
         */this.smoothFactor=0,/**
         * The factor applied to the motion smoothing each frame.
         * 
         * This value is passed to the Smooth Step Interpolation that is used to calculate the velocity,
         * angle and distance of the Pointer. It's applied every frame, until the midPoint reaches the current
         * position of the Pointer. 0.2 provides a good average but can be increased if you need a
         * quicker update and are working in a high performance environment. Never set this value to
         * zero.
         *
         * @name Phaser.Input.Pointer#motionFactor
         * @type {number}
         * @default 0.2
         * @since 3.16.0
         */this.motionFactor=.2,/**
         * The x position of this Pointer, translated into the coordinate space of the most recent Camera it interacted with.
         * 
         * If you wish to use this value _outside_ of an input event handler then you should update it first by calling
         * the `Pointer.updateWorldPoint` method.
         *
         * @name Phaser.Input.Pointer#worldX
         * @type {number}
         * @default 0
         * @since 3.10.0
         */this.worldX=0,/**
         * The y position of this Pointer, translated into the coordinate space of the most recent Camera it interacted with.
         * 
         * If you wish to use this value _outside_ of an input event handler then you should update it first by calling
         * the `Pointer.updateWorldPoint` method.
         *
         * @name Phaser.Input.Pointer#worldY
         * @type {number}
         * @default 0
         * @since 3.10.0
         */this.worldY=0,/**
         * Time when this Pointer was most recently moved (regardless of the state of its buttons, if any)
         *
         * @name Phaser.Input.Pointer#moveTime
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.moveTime=0,/**
         * X coordinate of the Pointer when Button 1 (left button), or Touch, was pressed, used for dragging objects.
         *
         * @name Phaser.Input.Pointer#downX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.downX=0,/**
         * Y coordinate of the Pointer when Button 1 (left button), or Touch, was pressed, used for dragging objects.
         *
         * @name Phaser.Input.Pointer#downY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.downY=0,/**
         * Time when Button 1 (left button), or Touch, was pressed, used for dragging objects.
         *
         * @name Phaser.Input.Pointer#downTime
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.downTime=0,/**
         * X coordinate of the Pointer when Button 1 (left button), or Touch, was released, used for dragging objects.
         *
         * @name Phaser.Input.Pointer#upX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.upX=0,/**
         * Y coordinate of the Pointer when Button 1 (left button), or Touch, was released, used for dragging objects.
         *
         * @name Phaser.Input.Pointer#upY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.upY=0,/**
         * Time when Button 1 (left button), or Touch, was released, used for dragging objects.
         *
         * @name Phaser.Input.Pointer#upTime
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.upTime=0,/**
         * Is the primary button down? (usually button 0, the left mouse button)
         *
         * @name Phaser.Input.Pointer#primaryDown
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.primaryDown=!1,/**
         * Is _any_ button on this pointer considered as being down?
         *
         * @name Phaser.Input.Pointer#isDown
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.isDown=!1,/**
         * Did the previous input event come from a Touch input (true) or Mouse? (false)
         *
         * @name Phaser.Input.Pointer#wasTouch
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.wasTouch=!1,/**
         * Did this Pointer get canceled by a touchcancel event?
         * 
         * Note: "canceled" is the American-English spelling of "cancelled". Please don't submit PRs correcting it!
         *
         * @name Phaser.Input.Pointer#wasCanceled
         * @type {boolean}
         * @default false
         * @since 3.15.0
         */this.wasCanceled=!1,/**
         * If the mouse is locked, the horizontal relative movement of the Pointer in pixels since last frame.
         *
         * @name Phaser.Input.Pointer#movementX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.movementX=0,/**
         * If the mouse is locked, the vertical relative movement of the Pointer in pixels since last frame.
         *
         * @name Phaser.Input.Pointer#movementY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.movementY=0,/**
         * The identifier property of the Pointer as set by the DOM event when this Pointer is started.
         *
         * @name Phaser.Input.Pointer#identifier
         * @type {number}
         * @since 3.10.0
         */this.identifier=0,/**
         * The pointerId property of the Pointer as set by the DOM event when this Pointer is started.
         * The browser can and will recycle this value.
         *
         * @name Phaser.Input.Pointer#pointerId
         * @type {number}
         * @since 3.10.0
         */this.pointerId=null,/**
         * An active Pointer is one that is currently pressed down on the display.
         * A Mouse is always considered as active.
         *
         * @name Phaser.Input.Pointer#active
         * @type {boolean}
         * @since 3.10.0
         */this.active=0===e,/**
         * Is this pointer Pointer Locked?
         * 
         * Only a mouse pointer can be locked and it only becomes locked when requested via
         * the browsers Pointer Lock API.
         * 
         * You can request this by calling the `this.input.mouse.requestPointerLock()` method from
         * a `pointerdown` or `pointerup` event handler.
         *
         * @name Phaser.Input.Pointer#locked
         * @readonly
         * @type {boolean}
         * @since 3.19.0
         */this.locked=!1,/**
         * The horizontal scroll amount that occurred due to the user moving a mouse wheel or similar input device.
         *
         * @name Phaser.Input.Pointer#deltaX
         * @type {number}
         * @default 0
         * @since 3.18.0
         */this.deltaX=0,/**
         * The vertical scroll amount that occurred due to the user moving a mouse wheel or similar input device.
         * This value will typically be less than 0 if the user scrolls up and greater than zero if scrolling down.
         *
         * @name Phaser.Input.Pointer#deltaY
         * @type {number}
         * @default 0
         * @since 3.18.0
         */this.deltaY=0,/**
         * The z-axis scroll amount that occurred due to the user moving a mouse wheel or similar input device.
         *
         * @name Phaser.Input.Pointer#deltaZ
         * @type {number}
         * @default 0
         * @since 3.18.0
         */this.deltaZ=0},/**
     * Takes a Camera and updates this Pointer's `worldX` and `worldY` values so they are
     * the result of a translation through the given Camera.
     * 
     * Note that the values will be automatically replaced the moment the Pointer is
     * updated by an input event, such as a mouse move, so should be used immediately.
     *
     * @method Phaser.Input.Pointer#updateWorldPoint
     * @since 3.19.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera which is being tested against.
     *
     * @return {this} This Pointer object.
     */updateWorldPoint:function(t){var e=this.x,i=this.y;1!==t.resolution&&(e+=t._x,i+=t._y);//  Stores the world point inside of tempPoint
var n=t.getWorldPoint(e,i);return this.worldX=n.x,this.worldY=n.y,this},/**
     * Takes a Camera and returns a Vector2 containing the translated position of this Pointer
     * within that Camera. This can be used to convert this Pointers position into camera space.
     *
     * @method Phaser.Input.Pointer#positionToCamera
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the translation.
     * @param {(Phaser.Math.Vector2|object)} [output] - A Vector2-like object in which to store the translated position.
     *
     * @return {(Phaser.Math.Vector2|object)} A Vector2 containing the translated coordinates of this Pointer, based on the given camera.
     */positionToCamera:function(t,e){return t.getWorldPoint(this.x,this.y,e)},/**
     * Calculates the motion of this Pointer, including its velocity and angle of movement.
     * This method is called automatically each frame by the Input Manager.
     *
     * @method Phaser.Input.Pointer#updateMotion
     * @private
     * @since 3.16.0
     */updateMotion:function(){var t=this.position.x,e=this.position.y,n=this.midPoint.x,s=this.midPoint.y;if(t!==n||e!==s){//  Moving towards our goal ...
var r=a(this.motionFactor,n,t),h=a(this.motionFactor,s,e);o(r,t,.1)&&(r=t),o(h,e,.1)&&(h=e),this.midPoint.set(r,h);var l=t-r,u=e-h;this.velocity.set(l,u),this.angle=i(r,h,t,e),this.distance=Math.sqrt(l*l+u*u)}},/**
     * Internal method to handle a Mouse Up Event.
     *
     * @method Phaser.Input.Pointer#up
     * @private
     * @since 3.0.0
     *
     * @param {MouseEvent} event - The Mouse Event to process.
     */up:function(t){"buttons"in t&&(this.buttons=t.buttons),this.event=t,this.button=t.button,this.upElement=t.target,//  Sets the local x/y properties
this.manager.transformPointer(this,t.pageX,t.pageY,!1),0===t.button&&(this.primaryDown=!1,this.upX=this.x,this.upY=this.y,this.upTime=t.timeStamp),this.isDown=!1,this.wasTouch=!1},/**
     * Internal method to handle a Mouse Down Event.
     *
     * @method Phaser.Input.Pointer#down
     * @private
     * @since 3.0.0
     *
     * @param {MouseEvent} event - The Mouse Event to process.
     */down:function(t){"buttons"in t&&(this.buttons=t.buttons),this.event=t,this.button=t.button,this.downElement=t.target,//  Sets the local x/y properties
this.manager.transformPointer(this,t.pageX,t.pageY,!1),0===t.button&&(this.primaryDown=!0,this.downX=this.x,this.downY=this.y,this.downTime=t.timeStamp),this.isDown=!0,this.wasTouch=!1},/**
     * Internal method to handle a Mouse Move Event.
     *
     * @method Phaser.Input.Pointer#move
     * @private
     * @since 3.0.0
     *
     * @param {MouseEvent} event - The Mouse Event to process.
     */move:function(t){"buttons"in t&&(this.buttons=t.buttons),this.event=t,//  Sets the local x/y properties
this.manager.transformPointer(this,t.pageX,t.pageY,!0),this.locked&&(//  Multiple DOM events may occur within one frame, but only one Phaser event will fire
this.movementX=t.movementX||t.mozMovementX||t.webkitMovementX||0,this.movementY=t.movementY||t.mozMovementY||t.webkitMovementY||0),this.moveTime=t.timeStamp,this.wasTouch=!1},/**
     * Internal method to handle a Mouse Wheel Event.
     *
     * @method Phaser.Input.Pointer#wheel
     * @private
     * @since 3.18.0
     *
     * @param {WheelEvent} event - The Wheel Event to process.
     */wheel:function(t){"buttons"in t&&(this.buttons=t.buttons),this.event=t,//  Sets the local x/y properties
this.manager.transformPointer(this,t.pageX,t.pageY,!1),this.deltaX=t.deltaX,this.deltaY=t.deltaY,this.deltaZ=t.deltaZ,this.wasTouch=!1},/**
     * Internal method to handle a Touch Start Event.
     *
     * @method Phaser.Input.Pointer#touchstart
     * @private
     * @since 3.0.0
     *
     * @param {Touch} touch - The Changed Touch from the Touch Event.
     * @param {TouchEvent} event - The full Touch Event.
     */touchstart:function(t,e){t.pointerId&&(this.pointerId=t.pointerId),this.identifier=t.identifier,this.target=t.target,this.active=!0,this.buttons=1,this.event=e,this.downElement=t.target,//  Sets the local x/y properties
this.manager.transformPointer(this,t.pageX,t.pageY,!1),this.primaryDown=!0,this.downX=this.x,this.downY=this.y,this.downTime=e.timeStamp,this.isDown=!0,this.wasTouch=!0,this.wasCanceled=!1,this.updateMotion()},/**
     * Internal method to handle a Touch Move Event.
     *
     * @method Phaser.Input.Pointer#touchmove
     * @private
     * @since 3.0.0
     *
     * @param {Touch} touch - The Changed Touch from the Touch Event.
     * @param {TouchEvent} event - The full Touch Event.
     */touchmove:function(t,e){this.event=e,//  Sets the local x/y properties
this.manager.transformPointer(this,t.pageX,t.pageY,!0),this.moveTime=e.timeStamp,this.wasTouch=!0,this.updateMotion()},/**
     * Internal method to handle a Touch End Event.
     *
     * @method Phaser.Input.Pointer#touchend
     * @private
     * @since 3.0.0
     *
     * @param {Touch} touch - The Changed Touch from the Touch Event.
     * @param {TouchEvent} event - The full Touch Event.
     */touchend:function(t,e){this.buttons=0,this.event=e,this.upElement=t.target,//  Sets the local x/y properties
this.manager.transformPointer(this,t.pageX,t.pageY,!1),this.primaryDown=!1,this.upX=this.x,this.upY=this.y,this.upTime=e.timeStamp,this.isDown=!1,this.wasTouch=!0,this.wasCanceled=!1,this.active=!1,this.updateMotion()},/**
     * Internal method to handle a Touch Cancel Event.
     *
     * @method Phaser.Input.Pointer#touchcancel
     * @private
     * @since 3.15.0
     *
     * @param {Touch} touch - The Changed Touch from the Touch Event.
     * @param {TouchEvent} event - The full Touch Event.
     */touchcancel:function(t,e){this.buttons=0,this.event=e,this.upElement=t.target,//  Sets the local x/y properties
this.manager.transformPointer(this,t.pageX,t.pageY,!1),this.primaryDown=!1,this.upX=this.x,this.upY=this.y,this.upTime=e.timeStamp,this.isDown=!1,this.wasTouch=!0,this.wasCanceled=!0,this.active=!1},/**
     * Checks to see if any buttons are being held down on this Pointer.
     *
     * @method Phaser.Input.Pointer#noButtonDown
     * @since 3.0.0
     *
     * @return {boolean} `true` if no buttons are being held down.
     */noButtonDown:function(){return 0===this.buttons},/**
     * Checks to see if the left button is being held down on this Pointer.
     *
     * @method Phaser.Input.Pointer#leftButtonDown
     * @since 3.0.0
     *
     * @return {boolean} `true` if the left button is being held down.
     */leftButtonDown:function(){return!!(1&this.buttons)},/**
     * Checks to see if the right button is being held down on this Pointer.
     *
     * @method Phaser.Input.Pointer#rightButtonDown
     * @since 3.0.0
     *
     * @return {boolean} `true` if the right button is being held down.
     */rightButtonDown:function(){return!!(2&this.buttons)},/**
     * Checks to see if the middle button is being held down on this Pointer.
     *
     * @method Phaser.Input.Pointer#middleButtonDown
     * @since 3.0.0
     *
     * @return {boolean} `true` if the middle button is being held down.
     */middleButtonDown:function(){return!!(4&this.buttons)},/**
     * Checks to see if the back button is being held down on this Pointer.
     *
     * @method Phaser.Input.Pointer#backButtonDown
     * @since 3.0.0
     *
     * @return {boolean} `true` if the back button is being held down.
     */backButtonDown:function(){return!!(8&this.buttons)},/**
     * Checks to see if the forward button is being held down on this Pointer.
     *
     * @method Phaser.Input.Pointer#forwardButtonDown
     * @since 3.0.0
     *
     * @return {boolean} `true` if the forward button is being held down.
     */forwardButtonDown:function(){return!!(16&this.buttons)},/**
     * Checks to see if the left button was just released on this Pointer.
     *
     * @method Phaser.Input.Pointer#leftButtonReleased
     * @since 3.18.0
     *
     * @return {boolean} `true` if the left button was just released.
     */leftButtonReleased:function(){return 0===this.button&&!this.isDown},/**
     * Checks to see if the right button was just released on this Pointer.
     *
     * @method Phaser.Input.Pointer#rightButtonReleased
     * @since 3.18.0
     *
     * @return {boolean} `true` if the right button was just released.
     */rightButtonReleased:function(){return 2===this.button&&!this.isDown},/**
     * Checks to see if the middle button was just released on this Pointer.
     *
     * @method Phaser.Input.Pointer#middleButtonReleased
     * @since 3.18.0
     *
     * @return {boolean} `true` if the middle button was just released.
     */middleButtonReleased:function(){return 1===this.button&&!this.isDown},/**
     * Checks to see if the back button was just released on this Pointer.
     *
     * @method Phaser.Input.Pointer#backButtonReleased
     * @since 3.18.0
     *
     * @return {boolean} `true` if the back button was just released.
     */backButtonReleased:function(){return 3===this.button&&!this.isDown},/**
     * Checks to see if the forward button was just released on this Pointer.
     *
     * @method Phaser.Input.Pointer#forwardButtonReleased
     * @since 3.18.0
     *
     * @return {boolean} `true` if the forward button was just released.
     */forwardButtonReleased:function(){return 4===this.button&&!this.isDown},/**
     * If the Pointer has a button pressed down at the time this method is called, it will return the
     * distance between the Pointer's `downX` and `downY` values and the current position.
     * 
     * If no button is held down, it will return the last recorded distance, based on where
     * the Pointer was when the button was released.
     * 
     * If you wish to get the distance being travelled currently, based on the velocity of the Pointer,
     * then see the `Pointer.distance` property.
     *
     * @method Phaser.Input.Pointer#getDistance
     * @since 3.13.0
     *
     * @return {number} The distance the Pointer moved.
     */getDistance:function(){return this.isDown?r(this.downX,this.downY,this.x,this.y):r(this.downX,this.downY,this.upX,this.upY)},/**
     * If the Pointer has a button pressed down at the time this method is called, it will return the
     * horizontal distance between the Pointer's `downX` and `downY` values and the current position.
     * 
     * If no button is held down, it will return the last recorded horizontal distance, based on where
     * the Pointer was when the button was released.
     *
     * @method Phaser.Input.Pointer#getDistanceX
     * @since 3.16.0
     *
     * @return {number} The horizontal distance the Pointer moved.
     */getDistanceX:function(){return this.isDown?Math.abs(this.downX-this.x):Math.abs(this.downX-this.upX)},/**
     * If the Pointer has a button pressed down at the time this method is called, it will return the
     * vertical distance between the Pointer's `downX` and `downY` values and the current position.
     * 
     * If no button is held down, it will return the last recorded vertical distance, based on where
     * the Pointer was when the button was released.
     *
     * @method Phaser.Input.Pointer#getDistanceY
     * @since 3.16.0
     *
     * @return {number} The vertical distance the Pointer moved.
     */getDistanceY:function(){return this.isDown?Math.abs(this.downY-this.y):Math.abs(this.downY-this.upY)},/**
     * If the Pointer has a button pressed down at the time this method is called, it will return the
     * duration since the button was pressed down.
     * 
     * If no button is held down, it will return the last recorded duration, based on the time
     * the Pointer button was released.
     *
     * @method Phaser.Input.Pointer#getDuration
     * @since 3.16.0
     *
     * @return {number} The duration the Pointer was held down for in milliseconds.
     */getDuration:function(){return this.isDown?this.manager.time-this.downTime:this.upTime-this.downTime},/**
     * If the Pointer has a button pressed down at the time this method is called, it will return the
     * angle between the Pointer's `downX` and `downY` values and the current position.
     * 
     * If no button is held down, it will return the last recorded angle, based on where
     * the Pointer was when the button was released.
     * 
     * The angle is based on the old position facing to the current position.
     * 
     * If you wish to get the current angle, based on the velocity of the Pointer, then
     * see the `Pointer.angle` property.
     *
     * @method Phaser.Input.Pointer#getAngle
     * @since 3.16.0
     *
     * @return {number} The angle between the Pointer's coordinates in radians.
     */getAngle:function(){return this.isDown?i(this.downX,this.downY,this.x,this.y):i(this.downX,this.downY,this.upX,this.upY)},/**
     * Takes the previous and current Pointer positions and then generates an array of interpolated values between
     * the two. The array will be populated up to the size of the `steps` argument.
     * 
     * ```javaScript
     * var points = pointer.getInterpolatedPosition(4);
     * 
     * // points[0] = { x: 0, y: 0 }
     * // points[1] = { x: 2, y: 1 }
     * // points[2] = { x: 3, y: 2 }
     * // points[3] = { x: 6, y: 3 }
     * ```
     * 
     * Use this if you need to get smoothed values between the previous and current pointer positions. DOM pointer
     * events can often fire faster than the main browser loop, and this will help you avoid janky movement
     * especially if you have an object following a Pointer.
     * 
     * Note that if you provide an output array it will only be populated up to the number of steps provided.
     * It will not clear any previous data that may have existed beyond the range of the steps count.
     * 
     * Internally it uses the Smooth Step interpolation calculation.
     *
     * @method Phaser.Input.Pointer#getInterpolatedPosition
     * @since 3.11.0
     * 
     * @param {integer} [steps=10] - The number of interpolation steps to use.
     * @param {array} [out] - An array to store the results in. If not provided a new one will be created.
     * 
     * @return {array} An array of interpolated values.
     */getInterpolatedPosition:function(t,e){void 0===t&&(t=10),void 0===e&&(e=[]);for(var i=this.prevPosition.x,n=this.prevPosition.y,s=this.position.x,r=this.position.y,o=0;o<t;o++){var h=1/t*o;e[o]={x:a(h,i,s),y:a(h,n,r)}}return e},/**
     * Destroys this Pointer instance and resets its external references.
     *
     * @method Phaser.Input.Pointer#destroy
     * @since 3.0.0
     */destroy:function(){this.camera=null,this.manager=null,this.position=null},/**
     * The x position of this Pointer.
     * The value is in screen space.
     * See `worldX` to get a camera converted position.
     *
     * @name Phaser.Input.Pointer#x
     * @type {number}
     * @since 3.0.0
     */x:{get:function(){return this.position.x},set:function(t){this.position.x=t}},/**
     * The y position of this Pointer.
     * The value is in screen space.
     * See `worldY` to get a camera converted position.
     *
     * @name Phaser.Input.Pointer#y
     * @type {number}
     * @since 3.0.0
     */y:{get:function(){return this.position.y},set:function(t){this.position.y=t}},/**
     * Time when this Pointer was most recently updated by a DOM Event.
     * This comes directly from the `event.timeStamp` property.
     * If no event has yet taken place, it will return zero.
     *
     * @name Phaser.Input.Pointer#time
     * @type {number}
     * @readonly
     * @since 3.16.0
     */time:{get:function(){return this.event?this.event.timeStamp:0}}});t.exports=l}),r("d3PYD",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("2nOjn"),r=s("13GYA"),o=new i({initialize:function(t){/**
         * A reference to the Input Manager.
         *
         * @name Phaser.Input.Touch.TouchManager#manager
         * @type {Phaser.Input.InputManager}
         * @since 3.0.0
         */this.manager=t,/**
         * If true the DOM events will have event.preventDefault applied to them, if false they will propagate fully.
         *
         * @name Phaser.Input.Touch.TouchManager#capture
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.capture=!0,/**
         * A boolean that controls if the Touch Manager is enabled or not.
         * Can be toggled on the fly.
         *
         * @name Phaser.Input.Touch.TouchManager#enabled
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.enabled=!1,/**
         * The Touch Event target, as defined in the Game Config.
         * Typically the canvas to which the game is rendering, but can be any interactive DOM element.
         *
         * @name Phaser.Input.Touch.TouchManager#target
         * @type {any}
         * @since 3.0.0
         */this.target,/**
         * The Touch Start event handler function.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Touch.TouchManager#onTouchStart
         * @type {function}
         * @since 3.0.0
         */this.onTouchStart=r,/**
         * The Touch Start event handler function specifically for events on the Window.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Touch.TouchManager#onTouchStartWindow
         * @type {function}
         * @since 3.17.0
         */this.onTouchStartWindow=r,/**
         * The Touch Move event handler function.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Touch.TouchManager#onTouchMove
         * @type {function}
         * @since 3.0.0
         */this.onTouchMove=r,/**
         * The Touch End event handler function.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Touch.TouchManager#onTouchEnd
         * @type {function}
         * @since 3.0.0
         */this.onTouchEnd=r,/**
         * The Touch End event handler function specifically for events on the Window.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Touch.TouchManager#onTouchEndWindow
         * @type {function}
         * @since 3.17.0
         */this.onTouchEndWindow=r,/**
         * The Touch Cancel event handler function.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Touch.TouchManager#onTouchCancel
         * @type {function}
         * @since 3.15.0
         */this.onTouchCancel=r,/**
         * The Touch Cancel event handler function specifically for events on the Window.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Touch.TouchManager#onTouchCancelWindow
         * @type {function}
         * @since 3.18.0
         */this.onTouchCancelWindow=r,/**
         * The Touch Over event handler function.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Touch.TouchManager#onTouchOver
         * @type {function}
         * @since 3.16.0
         */this.onTouchOver=r,/**
         * The Touch Out event handler function.
         * Initially empty and bound in the `startListeners` method.
         *
         * @name Phaser.Input.Touch.TouchManager#onTouchOut
         * @type {function}
         * @since 3.16.0
         */this.onTouchOut=r,t.events.once(n.MANAGER_BOOT,this.boot,this)},/**
     * The Touch Manager boot process.
     *
     * @method Phaser.Input.Touch.TouchManager#boot
     * @private
     * @since 3.0.0
     */boot:function(){var t=this.manager.config;this.enabled=t.inputTouch,this.target=t.inputTouchEventTarget,this.capture=t.inputTouchCapture,this.target||(this.target=this.manager.game.canvas),t.disableContextMenu&&this.disableContextMenu(),this.enabled&&this.target&&this.startListeners()},/**
     * Attempts to disable the context menu from appearing if you touch-hold on the browser.
     * 
     * Works by listening for the `contextmenu` event and prevent defaulting it.
     * 
     * Use this if you need to disable the OS context menu on mobile.
     *
     * @method Phaser.Input.Touch.TouchManager#disableContextMenu
     * @since 3.20.0
     *
     * @return {this} This Touch Manager instance.
     */disableContextMenu:function(){return document.body.addEventListener("contextmenu",function(t){return t.preventDefault(),!1}),this},/**
     * Starts the Touch Event listeners running as long as an input target is set.
     * 
     * This method is called automatically if Touch Input is enabled in the game config,
     * which it is by default. However, you can call it manually should you need to
     * delay input capturing until later in the game.
     *
     * @method Phaser.Input.Touch.TouchManager#startListeners
     * @since 3.0.0
     */startListeners:function(){var t=this,e=this.manager.canvas,i=window&&window.focus&&this.manager.game.config.autoFocus;this.onTouchStart=function(n){i&&window.focus(),!n.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&(t.manager.onTouchStart(n),t.capture&&n.cancelable&&n.target===e&&n.preventDefault())},this.onTouchStartWindow=function(i){!i.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&i.target!==e&&t.manager.onTouchStart(i)},this.onTouchMove=function(e){!e.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&(t.manager.onTouchMove(e),t.capture&&e.cancelable&&e.preventDefault())},this.onTouchEnd=function(i){!i.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&(t.manager.onTouchEnd(i),t.capture&&i.cancelable&&i.target===e&&i.preventDefault())},this.onTouchEndWindow=function(i){!i.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&i.target!==e&&t.manager.onTouchEnd(i)},this.onTouchCancel=function(e){!e.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&(t.manager.onTouchCancel(e),t.capture&&e.preventDefault())},this.onTouchCancelWindow=function(e){!e.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&t.manager.onTouchCancel(e)},this.onTouchOver=function(e){!e.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&t.manager.setCanvasOver(e)},this.onTouchOut=function(e){!e.defaultPrevented&&t.enabled&&t.manager&&t.manager.enabled&&t.manager.setCanvasOut(e)};var n=this.target;if(n){var s={passive:!0},r={passive:!1};n.addEventListener("touchstart",this.onTouchStart,this.capture?r:s),n.addEventListener("touchmove",this.onTouchMove,this.capture?r:s),n.addEventListener("touchend",this.onTouchEnd,this.capture?r:s),n.addEventListener("touchcancel",this.onTouchCancel,this.capture?r:s),n.addEventListener("touchover",this.onTouchOver,this.capture?r:s),n.addEventListener("touchout",this.onTouchOut,this.capture?r:s),window&&this.manager.game.config.inputWindowEvents&&(window.addEventListener("touchstart",this.onTouchStartWindow,r),window.addEventListener("touchend",this.onTouchEndWindow,r),window.addEventListener("touchcancel",this.onTouchCancelWindow,r)),this.enabled=!0}},/**
     * Stops the Touch Event listeners.
     * This is called automatically and does not need to be manually invoked.
     *
     * @method Phaser.Input.Touch.TouchManager#stopListeners
     * @since 3.0.0
     */stopListeners:function(){var t=this.target;t.removeEventListener("touchstart",this.onTouchStart),t.removeEventListener("touchmove",this.onTouchMove),t.removeEventListener("touchend",this.onTouchEnd),t.removeEventListener("touchcancel",this.onTouchCancel),t.removeEventListener("touchover",this.onTouchOver),t.removeEventListener("touchout",this.onTouchOut),window&&(window.removeEventListener("touchstart",this.onTouchStartWindow),window.removeEventListener("touchend",this.onTouchEndWindow))},/**
     * Destroys this Touch Manager instance.
     *
     * @method Phaser.Input.Touch.TouchManager#destroy
     * @since 3.0.0
     */destroy:function(){this.stopListeners(),this.target=null,this.enabled=!1,this.manager=null}});t.exports=o}),r("brulE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("aqcI1"),r=s("3vRz3"),o=s("9csvT"),a=s("ebQQp"),h=s("kge7H"),l=s("7BSWl"),u=s("7AzQW"),c=s("2SW6f"),d=new i({Extends:r,initialize:function(t){r.call(this),/**
         * The game instance that owns this Plugin Manager.
         *
         * @name Phaser.Plugins.PluginManager#game
         * @type {Phaser.Game}
         * @since 3.0.0
         */this.game=t,/**
         * The global plugins currently running and managed by this Plugin Manager.
         * A plugin must have been started at least once in order to appear in this list.
         *
         * @name Phaser.Plugins.PluginManager#plugins
         * @type {Phaser.Types.Plugins.GlobalPlugin[]}
         * @since 3.8.0
         */this.plugins=[],/**
         * A list of plugin keys that should be installed into Scenes as well as the Core Plugins.
         *
         * @name Phaser.Plugins.PluginManager#scenePlugins
         * @type {string[]}
         * @since 3.8.0
         */this.scenePlugins=[],/**
         * A temporary list of plugins to install when the game has booted.
         *
         * @name Phaser.Plugins.PluginManager#_pendingGlobal
         * @private
         * @type {array}
         * @since 3.8.0
         */this._pendingGlobal=[],/**
         * A temporary list of scene plugins to install when the game has booted.
         *
         * @name Phaser.Plugins.PluginManager#_pendingScene
         * @private
         * @type {array}
         * @since 3.8.0
         */this._pendingScene=[],t.isBooted?this.boot():t.events.once(n.BOOT,this.boot,this)},/**
     * Run once the game has booted and installs all of the plugins configured in the Game Config.
     *
     * @method Phaser.Plugins.PluginManager#boot
     * @protected
     * @since 3.0.0
     */boot:function(){var t,e,i,s,r,o,a,h=this.game.config,u=h.installGlobalPlugins;for(t=0,//  Any plugins added outside of the game config, but before the game booted?
u=u.concat(this._pendingGlobal);t<u.length;t++)// { key: 'TestPlugin', plugin: TestPlugin, start: true, mapping: 'test', data: { msg: 'The plugin is alive' } }
i=l(e=u[t],"key",null),s=l(e,"plugin",null),r=l(e,"start",!1),o=l(e,"mapping",null),a=l(e,"data",null),i&&(s?this.install(i,s,r,o,a):console.warn("Missing `plugin` for key: "+i));for(t=0,//  Any plugins added outside of the game config, but before the game booted?
u=//  Any scene plugins to install?
(u=h.installScenePlugins).concat(this._pendingScene);t<u.length;t++)// { key: 'moveSpritePlugin', plugin: MoveSpritePlugin, , mapping: 'move' }
i=l(e=u[t],"key",null),s=l(e,"plugin",null),o=l(e,"mapping",null),i&&(s?this.installScenePlugin(i,s,o):console.warn("Missing `plugin` for key: "+i));this._pendingGlobal=[],this._pendingScene=[],this.game.events.once(n.DESTROY,this.destroy,this)},/**
     * Called by the Scene Systems class. Tells the plugin manager to install all Scene plugins into it.
     *
     * First it will install global references, i.e. references from the Game systems into the Scene Systems (and Scene if mapped.)
     * Then it will install Core Scene Plugins followed by Scene Plugins registered with the PluginManager.
     * Finally it will install any references to Global Plugins that have a Scene mapping property into the Scene itself.
     *
     * @method Phaser.Plugins.PluginManager#addToScene
     * @protected
     * @since 3.8.0
     *
     * @param {Phaser.Scenes.Systems} sys - The Scene Systems class to install all the plugins in to.
     * @param {array} globalPlugins - An array of global plugins to install.
     * @param {array} scenePlugins - An array of scene plugins to install.
     */addToScene:function(t,e,i){var n,s,r,o=this.game,a=t.scene,h=t.settings.map,l=t.settings.isBooted;//  Reference the GlobalPlugins from Game into Scene.Systems
for(n=0;n<e.length;n++)o[s=e[n]]?(t[s]=o[s],h.hasOwnProperty(s)&&(a[h[s]]=t[s])):"game"===s&&h.hasOwnProperty(s)&&(a[h[s]]=o);for(var c=0;c<i.length;c++)for(n=0,r=i[c];n<r.length;n++)if(s=r[n],u.hasCore(s)){var d=u.getCore(s),f=new d.plugin(a,this);t[d.mapping]=f,d.custom?a[d.mapping]=f:h.hasOwnProperty(d.mapping)&&(a[h[d.mapping]]=f),l&&f.boot()}for(n=0,//  And finally, inject any 'global scene plugins'
r=this.plugins;n<r.length;n++){var p=r[n];p.mapping&&(a[p.mapping]=p.plugin)}},/**
     * Called by the Scene Systems class. Returns a list of plugins to be installed.
     *
     * @method Phaser.Plugins.PluginManager#getDefaultScenePlugins
     * @protected
     * @since 3.8.0
     *
     * @return {string[]} A list keys of all the Scene Plugins to install.
     */getDefaultScenePlugins:function(){return this.game.config.defaultPlugins.concat(this.scenePlugins)},/**
     * Installs a new Scene Plugin into the Plugin Manager and optionally adds it
     * to the given Scene as well. A Scene Plugin added to the manager in this way
     * will be automatically installed into all new Scenes using the key and mapping given.
     *
     * The `key` property is what the plugin is injected into Scene.Systems as.
     * The `mapping` property is optional, and if specified is what the plugin is installed into
     * the Scene as. For example:
     *
     * ```javascript
     * this.plugins.installScenePlugin('powerupsPlugin', pluginCode, 'powerups');
     * 
     * // and from within the scene:
     * this.sys.powerupsPlugin; // key value
     * this.powerups; // mapping value
     * ```
     *
     * This method is called automatically by Phaser if you install your plugins using either the
     * Game Configuration object, or by preloading them via the Loader.
     *
     * @method Phaser.Plugins.PluginManager#installScenePlugin
     * @since 3.8.0
     *
     * @param {string} key - The property key that will be used to add this plugin to Scene.Systems.
     * @param {function} plugin - The plugin code. This should be the non-instantiated version.
     * @param {string} [mapping] - If this plugin is injected into the Phaser.Scene class, this is the property key to use.
     * @param {Phaser.Scene} [addToScene] - Optionally automatically add this plugin to the given Scene.
     * @param {boolean} [fromLoader=false] - Is this being called by the Loader?
     */installScenePlugin:function(t,e,i,n,s){if(void 0===s&&(s=!1),"function"!=typeof e){console.warn("Invalid Scene Plugin: "+t);return}if(u.hasCore(t)){if(!s&&u.hasCore(t)){//  Plugin wasn't from the loader but already exists
console.warn("Scene Plugin key in use: "+t);return}}else //  Plugin is freshly loaded
u.register(t,e,i,!0),this.scenePlugins.push(t);if(n){var r=new e(n,this);n.sys[t]=r,i&&""!==i&&(n[i]=r),r.boot()}},/**
     * Installs a new Global Plugin into the Plugin Manager and optionally starts it running.
     * A global plugin belongs to the Plugin Manager, rather than a specific Scene, and can be accessed
     * and used by all Scenes in your game.
     *
     * The `key` property is what you use to access this plugin from the Plugin Manager.
     *
     * ```javascript
     * this.plugins.install('powerupsPlugin', pluginCode);
     * 
     * // and from within the scene:
     * this.plugins.get('powerupsPlugin');
     * ```
     *
     * This method is called automatically by Phaser if you install your plugins using either the
     * Game Configuration object, or by preloading them via the Loader.
     *
     * The same plugin can be installed multiple times into the Plugin Manager by simply giving each
     * instance its own unique key.
     *
     * @method Phaser.Plugins.PluginManager#install
     * @since 3.8.0
     * 
     * @param {string} key - The unique handle given to this plugin within the Plugin Manager.
     * @param {function} plugin - The plugin code. This should be the non-instantiated version.
     * @param {boolean} [start=false] - Automatically start the plugin running? This is always `true` if you provide a mapping value.
     * @param {string} [mapping] - If this plugin is injected into the Phaser.Scene class, this is the property key to use.
     * @param {any} [data] - A value passed to the plugin's `init` method.
     *
     * @return {?Phaser.Plugins.BasePlugin} The plugin that was started, or `null` if `start` was false, or game isn't yet booted.
     */install:function(t,e,i,n,s){if(void 0===i&&(i=!1),void 0===n&&(n=null),void 0===s&&(s=null),"function"!=typeof e)return console.warn("Invalid Plugin: "+t),null;if(u.hasCustom(t))return console.warn("Plugin key in use: "+t),null;if(null!==n&&(i=!0),this.game.isBooted){if(//  Add it to the plugin store
u.registerCustom(t,e,n,s),i)return this.start(t)}else this._pendingGlobal.push({key:t,plugin:e,start:i,mapping:n,data:s});return null},/**
     * Gets an index of a global plugin based on the given key.
     *
     * @method Phaser.Plugins.PluginManager#getIndex
     * @protected
     * @since 3.8.0
     *
     * @param {string} key - The unique plugin key.
     *
     * @return {integer} The index of the plugin within the plugins array.
     */getIndex:function(t){for(var e=this.plugins,i=0;i<e.length;i++)if(e[i].key===t)return i;return -1},/**
     * Gets a global plugin based on the given key.
     *
     * @method Phaser.Plugins.PluginManager#getEntry
     * @protected
     * @since 3.8.0
     *
     * @param {string} key - The unique plugin key.
     *
     * @return {Phaser.Types.Plugins.GlobalPlugin} The plugin entry.
     */getEntry:function(t){var e=this.getIndex(t);if(-1!==e)return this.plugins[e]},/**
     * Checks if the given global plugin, based on its key, is active or not.
     *
     * @method Phaser.Plugins.PluginManager#isActive
     * @since 3.8.0
     *
     * @param {string} key - The unique plugin key.
     *
     * @return {boolean} `true` if the plugin is active, otherwise `false`.
     */isActive:function(t){var e=this.getEntry(t);return e&&e.active},/**
     * Starts a global plugin running.
     *
     * If the plugin was previously active then calling `start` will reset it to an active state and then
     * call its `start` method.
     *
     * If the plugin has never been run before a new instance of it will be created within the Plugin Manager,
     * its active state set and then both of its `init` and `start` methods called, in that order.
     *
     * If the plugin is already running under the given key then nothing happens.
     *
     * @method Phaser.Plugins.PluginManager#start
     * @since 3.8.0
     *
     * @param {string} key - The key of the plugin to start.
     * @param {string} [runAs] - Run the plugin under a new key. This allows you to run one plugin multiple times.
     *
     * @return {?Phaser.Plugins.BasePlugin} The plugin that was started, or `null` if invalid key given or plugin is already stopped.
     */start:function(t,e){void 0===e&&(e=t);var i=this.getEntry(e);return i&&!i.active?(//  It exists, we just need to start it up again
i.active=!0,i.plugin.start()):i||(i=this.createEntry(t,e)),i?i.plugin:null},/**
     * Creates a new instance of a global plugin, adds an entry into the plugins array and returns it.
     *
     * @method Phaser.Plugins.PluginManager#createEntry
     * @private
     * @since 3.9.0
     *
     * @param {string} key - The key of the plugin to create an instance of.
     * @param {string} [runAs] - Run the plugin under a new key. This allows you to run one plugin multiple times.
     *
     * @return {?Phaser.Plugins.BasePlugin} The plugin that was started, or `null` if invalid key given.
     */createEntry:function(t,e){var i=u.getCustom(t);if(i){var n=new i.plugin(this);i={key:e,plugin:n,active:!0,mapping:i.mapping,data:i.data},this.plugins.push(i),n.init(i.data),n.start()}return i},/**
     * Stops a global plugin from running.
     *
     * If the plugin is active then its active state will be set to false and the plugins `stop` method
     * will be called.
     *
     * If the plugin is not already running, nothing will happen.
     *
     * @method Phaser.Plugins.PluginManager#stop
     * @since 3.8.0
     *
     * @param {string} key - The key of the plugin to stop.
     *
     * @return {this} The Plugin Manager.
     */stop:function(t){var e=this.getEntry(t);return e&&e.active&&(e.active=!1,e.plugin.stop()),this},/**
     * Gets a global plugin from the Plugin Manager based on the given key and returns it.
     *
     * If it cannot find an active plugin based on the key, but there is one in the Plugin Cache with the same key,
     * then it will create a new instance of the cached plugin and return that.
     *
     * @method Phaser.Plugins.PluginManager#get
     * @since 3.8.0
     *
     * @param {string} key - The key of the plugin to get.
     * @param {boolean} [autoStart=true] - Automatically start a new instance of the plugin if found in the cache, but not actively running.
     *
     * @return {?(Phaser.Plugins.BasePlugin|function)} The plugin, or `null` if no plugin was found matching the key.
     */get:function(t,e){void 0===e&&(e=!0);var i=this.getEntry(t);if(i)return i.plugin;var n=this.getClass(t);return n&&e?(i=this.createEntry(t,t))?i.plugin:null:n||null},/**
     * Returns the plugin class from the cache.
     * Used internally by the Plugin Manager.
     *
     * @method Phaser.Plugins.PluginManager#getClass
     * @since 3.8.0
     *
     * @param {string} key - The key of the plugin to get.
     *
     * @return {Phaser.Plugins.BasePlugin} A Plugin object
     */getClass:function(t){return u.getCustomClass(t)},/**
     * Removes a global plugin from the Plugin Manager and Plugin Cache.
     *
     * It is up to you to remove all references to this plugin that you may hold within your game code.
     *
     * @method Phaser.Plugins.PluginManager#removeGlobalPlugin
     * @since 3.8.0
     *
     * @param {string} key - The key of the plugin to remove.
     */removeGlobalPlugin:function(t){var e=this.getEntry(t);e&&c(this.plugins,e),u.removeCustom(t)},/**
     * Removes a scene plugin from the Plugin Manager and Plugin Cache.
     *
     * This will not remove the plugin from any active Scenes that are already using it.
     *
     * It is up to you to remove all references to this plugin that you may hold within your game code.
     *
     * @method Phaser.Plugins.PluginManager#removeScenePlugin
     * @since 3.8.0
     *
     * @param {string} key - The key of the plugin to remove.
     */removeScenePlugin:function(t){c(this.scenePlugins,t),u.remove(t)},/**
     * Registers a new type of Game Object with the global Game Object Factory and / or Creator.
     * This is usually called from within your Plugin code and is a helpful short-cut for creating
     * new Game Objects.
     *
     * The key is the property that will be injected into the factories and used to create the
     * Game Object. For example:
     *
     * ```javascript
     * this.plugins.registerGameObject('clown', clownFactoryCallback, clownCreatorCallback);
     * // later in your game code:
     * this.add.clown();
     * this.make.clown();
     * ```
     * 
     * The callbacks are what are called when the factories try to create a Game Object
     * matching the given key. It's important to understand that the callbacks are invoked within
     * the context of the GameObjectFactory. In this context there are several properties available
     * to use:
     * 
     * this.scene - A reference to the Scene that owns the GameObjectFactory.
     * this.displayList - A reference to the Display List the Scene owns.
     * this.updateList - A reference to the Update List the Scene owns.
     * 
     * See the GameObjectFactory and GameObjectCreator classes for more details.
     * Any public property or method listed is available from your callbacks under `this`.
     *
     * @method Phaser.Plugins.PluginManager#registerGameObject
     * @since 3.8.0
     *
     * @param {string} key - The key of the Game Object that the given callbacks will create, i.e. `image`, `sprite`.
     * @param {function} [factoryCallback] - The callback to invoke when the Game Object Factory is called.
     * @param {function} [creatorCallback] - The callback to invoke when the Game Object Creator is called.
     */registerGameObject:function(t,e,i){return e&&h.register(t,e),i&&a.register(t,i),this},/**
     * Removes a previously registered Game Object from the global Game Object Factory and / or Creator.
     * This is usually called from within your Plugin destruction code to help clean-up after your plugin has been removed.
     *
     * @method Phaser.Plugins.PluginManager#removeGameObject
     * @since 3.19.0
     *
     * @param {string} key - The key of the Game Object to be removed from the factories.
     * @param {boolean} [removeFromFactory=true] - Should the Game Object be removed from the Game Object Factory?
     * @param {boolean} [removeFromCreator=true] - Should the Game Object be removed from the Game Object Creator?
     */removeGameObject:function(t,e,i){return void 0===e&&(e=!0),void 0===i&&(i=!0),e&&h.remove(t),i&&a.remove(t),this},/**
     * Registers a new file type with the global File Types Manager, making it available to all Loader
     * Plugins created after this.
     * 
     * This is usually called from within your Plugin code and is a helpful short-cut for creating
     * new loader file types.
     *
     * The key is the property that will be injected into the Loader Plugin and used to load the
     * files. For example:
     *
     * ```javascript
     * this.plugins.registerFileType('wad', doomWadLoaderCallback);
     * // later in your preload code:
     * this.load.wad();
     * ```
     * 
     * The callback is what is called when the loader tries to load a file  matching the given key.
     * It's important to understand that the callback is invoked within
     * the context of the LoaderPlugin. In this context there are several properties / methods available
     * to use:
     * 
     * this.addFile - A method to add the new file to the load queue.
     * this.scene - The Scene that owns the Loader Plugin instance.
     *
     * See the LoaderPlugin class for more details. Any public property or method listed is available from
     * your callback under `this`.
     *
     * @method Phaser.Plugins.PluginManager#registerFileType
     * @since 3.8.0
     *
     * @param {string} key - The key of the Game Object that the given callbacks will create, i.e. `image`, `sprite`.
     * @param {function} callback - The callback to invoke when the Game Object Factory is called.
     * @param {Phaser.Scene} [addToScene] - Optionally add this file type into the Loader Plugin owned by the given Scene.
     */registerFileType:function(t,e,i){o.register(t,e),i&&i.sys.load&&(i.sys.load[t]=e)},/**
     * Destroys this Plugin Manager and all associated plugins.
     * It will iterate all plugins found and call their `destroy` methods.
     * 
     * The PluginCache will remove all custom plugins.
     *
     * @method Phaser.Plugins.PluginManager#destroy
     * @since 3.8.0
     */destroy:function(){for(var t=0;t<this.plugins.length;t++)this.plugins[t].plugin.destroy();u.destroyCustomPlugins(),this.game.noReturn&&u.destroyCorePlugins(),this.game=null,this.plugins=[],this.scenePlugins=[]}});/*
 * "Sometimes, the elegant implementation is just a function.
 * Not a method. Not a class. Not a framework. Just a function."
 *  -- John Carmack
 */t.exports=d}),r("9csvT",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i={};t.exports={/**
     * Static method called when a LoaderPlugin is created.
     * 
     * Loops through the local types object and injects all of them as
     * properties into the LoaderPlugin instance.
     *
     * @method Phaser.Loader.FileTypesManager.install
     * @since 3.0.0
     * 
     * @param {Phaser.Loader.LoaderPlugin} loader - The LoaderPlugin to install the types into.
     */install:function(t){for(var e in i)t[e]=i[e]},/**
     * Static method called directly by the File Types.
     * 
     * The key is a reference to the function used to load the files via the Loader, i.e. `image`.
     *
     * @method Phaser.Loader.FileTypesManager.register
     * @since 3.0.0
     * 
     * @param {string} key - The key that will be used as the method name in the LoaderPlugin.
     * @param {function} factoryFunction - The function that will be called when LoaderPlugin.key is invoked.
     */register:function(t,e){i[t]=e},/**
     * Removed all associated file types.
     *
     * @method Phaser.Loader.FileTypesManager.destroy
     * @since 3.0.0
     */destroy:function(){i={}}}}),r("ebQQp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7AzQW"),r=s("4rtgc"),o=new i({initialize:function(t){/**
         * The Scene to which this Game Object Creator belongs.
         *
         * @name Phaser.GameObjects.GameObjectCreator#scene
         * @type {Phaser.Scene}
         * @protected
         * @since 3.0.0
         */this.scene=t,/**
         * A reference to the Scene.Systems.
         *
         * @name Phaser.GameObjects.GameObjectCreator#systems
         * @type {Phaser.Scenes.Systems}
         * @protected
         * @since 3.0.0
         */this.systems=t.sys,/**
         * A reference to the Scene Display List.
         *
         * @name Phaser.GameObjects.GameObjectCreator#displayList
         * @type {Phaser.GameObjects.DisplayList}
         * @protected
         * @since 3.0.0
         */this.displayList,/**
         * A reference to the Scene Update List.
         *
         * @name Phaser.GameObjects.GameObjectCreator#updateList
         * @type {Phaser.GameObjects.UpdateList}
         * @protected
         * @since 3.0.0
         */this.updateList,t.sys.events.once(r.BOOT,this.boot,this),t.sys.events.on(r.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.GameObjects.GameObjectCreator#boot
     * @private
     * @since 3.5.1
     */boot:function(){this.displayList=this.systems.displayList,this.updateList=this.systems.updateList,this.systems.events.once(r.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.GameObjects.GameObjectCreator#start
     * @private
     * @since 3.5.0
     */start:function(){this.systems.events.once(r.SHUTDOWN,this.shutdown,this)},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.GameObjects.GameObjectCreator#shutdown
     * @private
     * @since 3.0.0
     */shutdown:function(){this.systems.events.off(r.SHUTDOWN,this.shutdown,this)},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.GameObjects.GameObjectCreator#destroy
     * @private
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.scene.sys.events.off(r.START,this.start,this),this.scene=null,this.systems=null,this.displayList=null,this.updateList=null}});//  Static method called directly by the Game Object creator functions
o.register=function(t,e){o.prototype.hasOwnProperty(t)||(o.prototype[t]=e)},o.remove=function(t){o.prototype.hasOwnProperty(t)&&delete o.prototype[t]},n.register("GameObjectCreator",o,"make"),t.exports=o}),r("861Bh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("dlsVr"),n=s("jwj1g"),r=s("3vRz3"),o=s("jPI3B"),a=s("aqcI1"),h=s("9YEK2"),l=s("ckyH1"),u=s("6rG19"),c=s("13GYA"),d=s("cwr8X"),f=s("ehRgb"),p=s("jcIaO"),g=s("7SBSk"),v=new n({Extends:r,initialize:function(t){r.call(this),/**
         * A reference to the Phaser.Game instance.
         *
         * @name Phaser.Scale.ScaleManager#game
         * @type {Phaser.Game}
         * @readonly
         * @since 3.15.0
         */this.game=t,/**
         * A reference to the HTML Canvas Element that Phaser uses to render the game.
         *
         * @name Phaser.Scale.ScaleManager#canvas
         * @type {HTMLCanvasElement}
         * @since 3.16.0
         */this.canvas,/**
         * The DOM bounds of the canvas element.
         *
         * @name Phaser.Scale.ScaleManager#canvasBounds
         * @type {Phaser.Geom.Rectangle}
         * @since 3.16.0
         */this.canvasBounds=new d,/**
         * The parent object of the Canvas. Often a div, or the browser window, or nothing in non-browser environments.
         * 
         * This is set in the Game Config as the `parent` property. If undefined (or just not present), it will default
         * to use the document body. If specifically set to `null` Phaser will ignore all parent operations.
         *
         * @name Phaser.Scale.ScaleManager#parent
         * @type {?any}
         * @since 3.16.0
         */this.parent=null,/**
         * Is the parent element the browser window?
         *
         * @name Phaser.Scale.ScaleManager#parentIsWindow
         * @type {boolean}
         * @since 3.16.0
         */this.parentIsWindow=!1,/**
         * The Parent Size component.
         *
         * @name Phaser.Scale.ScaleManager#parentSize
         * @type {Phaser.Structs.Size}
         * @since 3.16.0
         */this.parentSize=new f,/**
         * The Game Size component.
         * 
         * The un-modified game size, as requested in the game config (the raw width / height),
         * as used for world bounds, cameras, etc
         *
         * @name Phaser.Scale.ScaleManager#gameSize
         * @type {Phaser.Structs.Size}
         * @since 3.16.0
         */this.gameSize=new f,/**
         * The Base Size component.
         * 
         * The modified game size, which is the gameSize * resolution, used to set the canvas width and height
         * (but not the CSS style)
         *
         * @name Phaser.Scale.ScaleManager#baseSize
         * @type {Phaser.Structs.Size}
         * @since 3.16.0
         */this.baseSize=new f,/**
         * The Display Size component.
         * 
         * The size used for the canvas style, factoring in the scale mode, parent and other values.
         *
         * @name Phaser.Scale.ScaleManager#displaySize
         * @type {Phaser.Structs.Size}
         * @since 3.16.0
         */this.displaySize=new f,/**
         * The game scale mode.
         *
         * @name Phaser.Scale.ScaleManager#scaleMode
         * @type {Phaser.Scale.ScaleModeType}
         * @since 3.16.0
         */this.scaleMode=i.SCALE_MODE.NONE,/**
         * The canvas resolution.
         * 
         * This is hard-coded to a value of 1 in the 3.16 release of Phaser and will be enabled at a later date.
         *
         * @name Phaser.Scale.ScaleManager#resolution
         * @type {number}
         * @since 3.16.0
         */this.resolution=1,/**
         * The game zoom factor.
         * 
         * This value allows you to multiply your games base size by the given zoom factor.
         * This is then used when calculating the display size, even in `NONE` situations.
         * If you don't want Phaser to touch the canvas style at all, this value should be 1.
         * 
         * Can also be set to `MAX_ZOOM` in which case the zoom value will be derived based
         * on the game size and available space within the parent.
         *
         * @name Phaser.Scale.ScaleManager#zoom
         * @type {number}
         * @since 3.16.0
         */this.zoom=1,/**
         * Internal flag set when the game zoom factor is modified.
         *
         * @name Phaser.Scale.ScaleManager#_resetZoom
         * @type {boolean}
         * @readonly
         * @since 3.19.0
         */this._resetZoom=!1,/**
         * The scale factor between the baseSize and the canvasBounds.
         *
         * @name Phaser.Scale.ScaleManager#displayScale
         * @type {Phaser.Math.Vector2}
         * @since 3.16.0
         */this.displayScale=new g(1,1),/**
         * If set, the canvas sizes will be automatically passed through Math.floor.
         * This results in rounded pixel display values, which is important for performance on legacy
         * and low powered devices, but at the cost of not achieving a 'perfect' fit in some browser windows.
         *
         * @name Phaser.Scale.ScaleManager#autoRound
         * @type {boolean}
         * @since 3.16.0
         */this.autoRound=!1,/**
         * Automatically center the canvas within the parent? The different centering modes are:
         * 
         * 1. No centering.
         * 2. Center both horizontally and vertically.
         * 3. Center horizontally.
         * 4. Center vertically.
         * 
         * Please be aware that in order to center the game canvas, you must have specified a parent
         * that has a size set, or the canvas parent is the document.body.
         *
         * @name Phaser.Scale.ScaleManager#autoCenter
         * @type {Phaser.Scale.CenterType}
         * @since 3.16.0
         */this.autoCenter=i.CENTER.NO_CENTER,/**
         * The current device orientation.
         * 
         * Orientation events are dispatched via the Device Orientation API, typically only on mobile browsers.
         *
         * @name Phaser.Scale.ScaleManager#orientation
         * @type {Phaser.Scale.OrientationType}
         * @since 3.16.0
         */this.orientation=i.ORIENTATION.LANDSCAPE,/**
         * A reference to the Device.Fullscreen object.
         *
         * @name Phaser.Scale.ScaleManager#fullscreen
         * @type {Phaser.Device.Fullscreen}
         * @since 3.16.0
         */this.fullscreen,/**
         * The DOM Element which is sent into fullscreen mode.
         *
         * @name Phaser.Scale.ScaleManager#fullscreenTarget
         * @type {?any}
         * @since 3.16.0
         */this.fullscreenTarget=null,/**
         * Did Phaser create the fullscreen target div, or was it provided in the game config?
         *
         * @name Phaser.Scale.ScaleManager#_createdFullscreenTarget
         * @type {boolean}
         * @private
         * @since 3.16.0
         */this._createdFullscreenTarget=!1,/**
         * The dirty state of the Scale Manager.
         * Set if there is a change between the parent size and the current size.
         *
         * @name Phaser.Scale.ScaleManager#dirty
         * @type {boolean}
         * @since 3.16.0
         */this.dirty=!1,/**
         * How many milliseconds should elapse before checking if the browser size has changed?
         * 
         * Most modern browsers dispatch a 'resize' event, which the Scale Manager will listen for.
         * However, older browsers fail to do this, or do it consistently, so we fall back to a
         * more traditional 'size check' based on a time interval. You can control how often it is
         * checked here.
         *
         * @name Phaser.Scale.ScaleManager#resizeInterval
         * @type {integer}
         * @since 3.16.0
         */this.resizeInterval=500,/**
         * Internal size interval tracker.
         *
         * @name Phaser.Scale.ScaleManager#_lastCheck
         * @type {integer}
         * @private
         * @since 3.16.0
         */this._lastCheck=0,/**
         * Internal flag to check orientation state.
         *
         * @name Phaser.Scale.ScaleManager#_checkOrientation
         * @type {boolean}
         * @private
         * @since 3.16.0
         */this._checkOrientation=!1,/**
         * Internal object containing our defined event listeners.
         *
         * @name Phaser.Scale.ScaleManager#listeners
         * @type {object}
         * @private
         * @since 3.16.0
         */this.listeners={orientationChange:c,windowResize:c,fullScreenChange:c,fullScreenError:c}},/**
     * Called _before_ the canvas object is created and added to the DOM.
     *
     * @method Phaser.Scale.ScaleManager#preBoot
     * @protected
     * @listens Phaser.Core.Events#BOOT
     * @since 3.16.0
     */preBoot:function(){//  Parse the config to get the scaling values we need
this.parseConfig(this.game.config),this.game.events.once("boot",this.boot,this)},/**
     * The Boot handler is called by Phaser.Game when it first starts up.
     * The renderer is available by now and the canvas has been added to the DOM.
     *
     * @method Phaser.Scale.ScaleManager#boot
     * @protected
     * @fires Phaser.Scale.Events#RESIZE
     * @since 3.16.0
     */boot:function(){var t=this.game;this.canvas=t.canvas,this.fullscreen=t.device.fullscreen,this.scaleMode!==i.SCALE_MODE.RESIZE&&this.displaySize.setAspectMode(this.scaleMode),this.scaleMode===i.SCALE_MODE.NONE?this.resize(this.width,this.height):(this.getParentBounds(),this.parentSize.width>0&&this.parentSize.height>0&&this.displaySize.setParent(this.parentSize),this.refresh()),t.events.on(a.PRE_STEP,this.step,this),t.events.once(a.DESTROY,this.destroy,this),this.startListeners()},/**
     * Parses the game configuration to set-up the scale defaults.
     *
     * @method Phaser.Scale.ScaleManager#parseConfig
     * @protected
     * @since 3.16.0
     * 
     * @param {Phaser.Types.Core.GameConfig} config - The Game configuration object.
     */parseConfig:function(t){//  Get the parent element, if any
this.getParent(t),//  Get the size of the parent element
//  This can often set a height of zero (especially for un-styled divs)
this.getParentBounds();var e=t.width,n=t.height,s=t.scaleMode,r=t.resolution,o=t.zoom,a=t.autoRound;//  If width = '100%', or similar value
if("string"==typeof e){//  If we have a parent with a height, we'll work it out from that
var h=this.parentSize.width;0===h&&(h=window.innerWidth),e=Math.floor(h*(parseInt(e,10)/100))}//  If height = '100%', or similar value
if("string"==typeof n){//  If we have a parent with a height, we'll work it out from that
var l=this.parentSize.height;0===l&&(l=window.innerHeight),n=Math.floor(l*(parseInt(n,10)/100))}//  This is fixed at 1 on purpose.
//  Changing it will break all user input.
//  Wait for another release to solve this issue.
this.resolution=1,this.scaleMode=s,this.autoRound=a,this.autoCenter=t.autoCenter,this.resizeInterval=t.resizeInterval,a&&(e=Math.floor(e),n=Math.floor(n)),//  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc
this.gameSize.setSize(e,n),o===i.ZOOM.MAX_ZOOM&&(o=this.getMaxZoom()),this.zoom=o,1!==o&&(this._resetZoom=!0),//  The modified game size, which is the w/h * resolution
this.baseSize.setSize(e*r,n*r),a&&(this.baseSize.width=Math.floor(this.baseSize.width),this.baseSize.height=Math.floor(this.baseSize.height)),t.minWidth>0&&this.displaySize.setMin(t.minWidth*o,t.minHeight*o),t.maxWidth>0&&this.displaySize.setMax(t.maxWidth*o,t.maxHeight*o),//  The size used for the canvas style, factoring in the scale mode and parent and zoom value
//  We just use the w/h here as this is what sets the aspect ratio (which doesn't then change)
this.displaySize.setSize(e,n),this.orientation=u(e,n)},/**
     * Determines the parent element of the game canvas, if any, based on the game configuration.
     *
     * @method Phaser.Scale.ScaleManager#getParent
     * @since 3.16.0
     * 
     * @param {Phaser.Types.Core.GameConfig} config - The Game configuration object.
     */getParent:function(t){var e=t.parent;if(null!==e){if(this.parent=l(e),this.parentIsWindow=this.parent===document.body,t.expandParent&&t.scaleMode!==i.SCALE_MODE.NONE){var n=this.parent.getBoundingClientRect();(this.parentIsWindow||0===n.height)&&(document.documentElement.style.height="100%",document.body.style.height="100%",n=this.parent.getBoundingClientRect(),this.parentIsWindow||0!==n.height||(this.parent.style.overflow="hidden",this.parent.style.width="100%",this.parent.style.height="100%"))}t.fullscreenTarget&&!this.fullscreenTarget&&(this.fullscreenTarget=l(t.fullscreenTarget))}},/**
     * Calculates the size of the parent bounds and updates the `parentSize` component, if the canvas has a dom parent.
     *
     * @method Phaser.Scale.ScaleManager#getParentBounds
     * @since 3.16.0
     * 
     * @return {boolean} `true` if the parent bounds have changed size, otherwise `false`.
     */getParentBounds:function(){if(!this.parent)return!1;var t=this.parentSize,e=this.parent.getBoundingClientRect();this.parentIsWindow&&this.game.device.os.iOS&&(e.height=h(!0));var i=this.resolution,n=e.width*i,s=e.height*i;return(t.width!==n||t.height!==s)&&(t.setSize(n,s),!0)},/**
     * Attempts to lock the orientation of the web browser using the Screen Orientation API.
     * 
     * This API is only available on modern mobile browsers.
     * See https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation for details.
     *
     * @method Phaser.Scale.ScaleManager#lockOrientation
     * @since 3.16.0
     * 
     * @param {string} orientation - The orientation you'd like to lock the browser in. Should be an API string such as 'landscape', 'landscape-primary', 'portrait', etc.
     * 
     * @return {boolean} `true` if the orientation was successfully locked, otherwise `false`.
     */lockOrientation:function(t){var e=screen.lockOrientation||screen.mozLockOrientation||screen.msLockOrientation;return!!e&&e.call(screen,t)},/**
     * This method will set the size of the Parent Size component, which is used in scaling
     * and centering calculations. You only need to call this method if you have explicitly
     * disabled the use of a parent in your game config, but still wish to take advantage of
     * other Scale Manager features.
     *
     * @method Phaser.Scale.ScaleManager#setParentSize
     * @fires Phaser.Scale.Events#RESIZE
     * @since 3.16.0
     * 
     * @param {number} width - The new width of the parent.
     * @param {number} height - The new height of the parent.
     * 
     * @return {this} The Scale Manager instance.
     */setParentSize:function(t,e){return this.parentSize.setSize(t,e),this.refresh()},/**
     * This method will set a new size for your game.
     * 
     * It should only be used if you're looking to change the base size of your game and are using
     * one of the Scale Manager scaling modes, i.e. `FIT`. If you're using `NONE` and wish to
     * change the game and canvas size directly, then please use the `resize` method instead.
     *
     * @method Phaser.Scale.ScaleManager#setGameSize
     * @fires Phaser.Scale.Events#RESIZE
     * @since 3.16.0
     * 
     * @param {number} width - The new width of the game.
     * @param {number} height - The new height of the game.
     * 
     * @return {this} The Scale Manager instance.
     */setGameSize:function(t,e){var i=this.autoRound,n=this.resolution;i&&(t=Math.floor(t),e=Math.floor(e));var s=this.width,r=this.height;return(//  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc
this.gameSize.resize(t,e),//  The modified game size, which is the w/h * resolution
this.baseSize.resize(t*n,e*n),i&&(this.baseSize.width=Math.floor(this.baseSize.width),this.baseSize.height=Math.floor(this.baseSize.height)),//  The size used for the canvas style, factoring in the scale mode and parent and zoom value
//  Update the aspect ratio
this.displaySize.setAspectRatio(t/e),this.canvas.width=this.baseSize.width,this.canvas.height=this.baseSize.height,this.refresh(s,r))},/**
     * Call this to modify the size of the Phaser canvas element directly.
     * You should only use this if you are using the `NONE` scale mode,
     * it will update all internal components completely.
     * 
     * If all you want to do is change the size of the parent, see the `setParentSize` method.
     * 
     * If all you want is to change the base size of the game, but still have the Scale Manager
     * manage all the scaling (i.e. you're **not** using `NONE`), then see the `setGameSize` method.
     * 
     * This method will set the `gameSize`, `baseSize` and `displaySize` components to the given
     * dimensions. It will then resize the canvas width and height to the values given, by
     * directly setting the properties. Finally, if you have set the Scale Manager zoom value
     * to anything other than 1 (the default), it will set the canvas CSS width and height to
     * be the given size multiplied by the zoom factor (the canvas pixel size remains untouched).
     * 
     * If you have enabled `autoCenter`, it is then passed to the `updateCenter` method and
     * the margins are set, allowing the canvas to be centered based on its parent element
     * alone. Finally, the `displayScale` is adjusted and the RESIZE event dispatched.
     *
     * @method Phaser.Scale.ScaleManager#resize
     * @fires Phaser.Scale.Events#RESIZE
     * @since 3.16.0
     * 
     * @param {number} width - The new width of the game.
     * @param {number} height - The new height of the game.
     * 
     * @return {this} The Scale Manager instance.
     */resize:function(t,e){var i=this.zoom,n=this.resolution,s=this.autoRound;s&&(t=Math.floor(t),e=Math.floor(e));var r=this.width,o=this.height;//  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc
this.gameSize.resize(t,e),//  The modified game size, which is the w/h * resolution
this.baseSize.resize(t*n,e*n),s&&(this.baseSize.width=Math.floor(this.baseSize.width),this.baseSize.height=Math.floor(this.baseSize.height)),//  The size used for the canvas style, factoring in the scale mode and parent and zoom value
//  We just use the w/h here as this is what sets the aspect ratio (which doesn't then change)
this.displaySize.setSize(t*i*n,e*i*n),this.canvas.width=this.baseSize.width,this.canvas.height=this.baseSize.height;var a=this.canvas.style,h=t*i,l=e*i;return s&&(h=Math.floor(h),l=Math.floor(l)),(h!==t||l!==e)&&(a.width=h+"px",a.height=l+"px"),this.refresh(r,o)},/**
     * Sets the zoom value of the Scale Manager.
     *
     * @method Phaser.Scale.ScaleManager#setZoom
     * @fires Phaser.Scale.Events#RESIZE
     * @since 3.16.0
     * 
     * @param {integer} value - The new zoom value of the game.
     * 
     * @return {this} The Scale Manager instance.
     */setZoom:function(t){return this.zoom=t,this._resetZoom=!0,this.refresh()},/**
     * Sets the zoom to be the maximum possible based on the _current_ parent size.
     *
     * @method Phaser.Scale.ScaleManager#setMaxZoom
     * @fires Phaser.Scale.Events#RESIZE
     * @since 3.16.0
     * 
     * @return {this} The Scale Manager instance.
     */setMaxZoom:function(){return this.zoom=this.getMaxZoom(),this._resetZoom=!0,this.refresh()},/**
     * Refreshes the internal scale values, bounds sizes and orientation checks.
     * 
     * Once finished, dispatches the resize event.
     * 
     * This is called automatically by the Scale Manager when the browser window size changes,
     * as long as it is using a Scale Mode other than 'NONE'.
     *
     * @method Phaser.Scale.ScaleManager#refresh
     * @fires Phaser.Scale.Events#RESIZE
     * @since 3.16.0
     * 
     * @param {number} [previousWidth] - The previous width of the game. Only set if the gameSize has changed.
     * @param {number} [previousHeight] - The previous height of the game. Only set if the gameSize has changed.
     * 
     * @return {this} The Scale Manager instance.
     */refresh:function(t,e){void 0===t&&(t=this.width),void 0===e&&(e=this.height),this.updateScale(),this.updateBounds(),this.updateOrientation(),this.displayScale.set(this.baseSize.width/this.canvasBounds.width,this.baseSize.height/this.canvasBounds.height);var i=this.game.domContainer;if(i){this.baseSize.setCSS(i);var n=this.canvas.style,s=i.style;s.transform="scale("+this.displaySize.width/this.baseSize.width+","+this.displaySize.height/this.baseSize.height+")",s.marginLeft=n.marginLeft,s.marginTop=n.marginTop}return this.emit(o.RESIZE,this.gameSize,this.baseSize,this.displaySize,this.resolution,t,e),this},/**
     * Internal method that checks the current screen orientation, only if the internal check flag is set.
     * 
     * If the orientation has changed it updates the orientation property and then dispatches the orientation change event.
     *
     * @method Phaser.Scale.ScaleManager#updateOrientation
     * @fires Phaser.Scale.Events#ORIENTATION_CHANGE
     * @since 3.16.0
     */updateOrientation:function(){if(this._checkOrientation){this._checkOrientation=!1;var t=u(this.width,this.height);t!==this.orientation&&(this.orientation=t,this.emit(o.ORIENTATION_CHANGE,t))}},/**
     * Internal method that manages updating the size components based on the scale mode.
     *
     * @method Phaser.Scale.ScaleManager#updateScale
     * @since 3.16.0
     */updateScale:function(){var t,e,n=this.canvas.style,s=this.gameSize.width,r=this.gameSize.height,o=this.zoom,a=this.autoRound;this.scaleMode===i.SCALE_MODE.NONE?(//  No scale
this.displaySize.setSize(s*o*1,r*o*1),t=this.displaySize.width/1,e=this.displaySize.height/1,a&&(t=Math.floor(t),e=Math.floor(e)),this._resetZoom&&(n.width=t+"px",n.height=e+"px",this._resetZoom=!1)):this.scaleMode===i.SCALE_MODE.RESIZE?(//  Resize to match parent
//  This will constrain using min/max
this.displaySize.setSize(this.parentSize.width,this.parentSize.height),this.gameSize.setSize(this.displaySize.width,this.displaySize.height),this.baseSize.setSize(1*this.displaySize.width,1*this.displaySize.height),t=this.displaySize.width/1,e=this.displaySize.height/1,a&&(t=Math.floor(t),e=Math.floor(e)),this.canvas.width=t,this.canvas.height=e):(//  All other scale modes
this.displaySize.setSize(this.parentSize.width,this.parentSize.height),t=this.displaySize.width/1,e=this.displaySize.height/1,a&&(t=Math.floor(t),e=Math.floor(e)),n.width=t+"px",n.height=e+"px"),//  Update the parentSize in case the canvas / style change modified it
this.getParentBounds(),//  Finally, update the centering
this.updateCenter()},/**
     * Calculates and returns the largest possible zoom factor, based on the current
     * parent and game sizes. If the parent has no dimensions (i.e. an unstyled div),
     * or is smaller than the un-zoomed game, then this will return a value of 1 (no zoom)
     *
     * @method Phaser.Scale.ScaleManager#getMaxZoom
     * @since 3.16.0
     * 
     * @return {integer} The maximum possible zoom factor. At a minimum this value is always at least 1.
     */getMaxZoom:function(){return Math.max(Math.min(p(this.parentSize.width,this.gameSize.width,0,!0),p(this.parentSize.height,this.gameSize.height,0,!0)),1)},/**
     * Calculates and updates the canvas CSS style in order to center it within the
     * bounds of its parent. If you have explicitly set parent to be `null` in your
     * game config then this method will likely give incorrect results unless you have called the
     * `setParentSize` method first.
     * 
     * It works by modifying the canvas CSS `marginLeft` and `marginTop` properties.
     * 
     * If they have already been set by your own style sheet, or code, this will overwrite them.
     * 
     * To prevent the Scale Manager from centering the canvas, either do not set the
     * `autoCenter` property in your game config, or make sure it is set to `NO_CENTER`.
     *
     * @method Phaser.Scale.ScaleManager#updateCenter
     * @since 3.16.0
     */updateCenter:function(){var t=this.autoCenter;if(t!==i.CENTER.NO_CENTER){var e=this.canvas,n=e.style,s=e.getBoundingClientRect(),r=s.width,o=s.height,a=Math.floor((this.parentSize.width-r)/2),h=Math.floor((this.parentSize.height-o)/2);t===i.CENTER.CENTER_HORIZONTALLY?h=0:t===i.CENTER.CENTER_VERTICALLY&&(a=0),n.marginLeft=a+"px",n.marginTop=h+"px"}},/**
     * Updates the `canvasBounds` rectangle to match the bounding client rectangle of the
     * canvas element being used to track input events.
     *
     * @method Phaser.Scale.ScaleManager#updateBounds
     * @since 3.16.0
     */updateBounds:function(){var t=this.canvasBounds,e=this.canvas.getBoundingClientRect();t.x=e.left+(window.pageXOffset||0)-(document.documentElement.clientLeft||0),t.y=e.top+(window.pageYOffset||0)-(document.documentElement.clientTop||0),t.width=e.width,t.height=e.height},/**
     * Transforms the pageX value into the scaled coordinate space of the Scale Manager.
     *
     * @method Phaser.Scale.ScaleManager#transformX
     * @since 3.16.0
     *
     * @param {number} pageX - The DOM pageX value.
     *
     * @return {number} The translated value.
     */transformX:function(t){return(t-this.canvasBounds.left)*this.displayScale.x},/**
     * Transforms the pageY value into the scaled coordinate space of the Scale Manager.
     *
     * @method Phaser.Scale.ScaleManager#transformY
     * @since 3.16.0
     *
     * @param {number} pageY - The DOM pageY value.
     *
     * @return {number} The translated value.
     */transformY:function(t){return(t-this.canvasBounds.top)*this.displayScale.y},/**
     * Sends a request to the browser to ask it to go in to full screen mode, using the {@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API Fullscreen API}.
     * 
     * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.
     * 
     * This method _must_ be called from a user-input gesture, such as `pointerup`. You cannot launch
     * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked
     * from fullscreen unless the iframe has the `allowfullscreen` attribute.
     * 
     * On touch devices, such as Android and iOS Safari, you should always use `pointerup` and NOT `pointerdown`,
     * otherwise the request will fail unless the document in which your game is embedded has already received
     * some form of touch input, which you cannot guarantee. Activating fullscreen via `pointerup` circumvents
     * this issue.
     * 
     * Performing an action that navigates to another page, or opens another tab, will automatically cancel
     * fullscreen mode, as will the user pressing the ESC key. To cancel fullscreen mode directly from your game,
     * i.e. by clicking an icon, call the `stopFullscreen` method.
     * 
     * A browser can only send one DOM element into fullscreen. You can control which element this is by
     * setting the `fullscreenTarget` property in your game config, or changing the property in the Scale Manager.
     * Note that the game canvas _must_ be a child of the target. If you do not give a target, Phaser will
     * automatically create a blank `<div>` element and move the canvas into it, before going fullscreen.
     * When it leaves fullscreen, the div will be removed.
     *
     * @method Phaser.Scale.ScaleManager#startFullscreen
     * @fires Phaser.Scale.Events#ENTER_FULLSCREEN
     * @fires Phaser.Scale.Events#FULLSCREEN_FAILED
     * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED
     * @fires Phaser.Scale.Events#RESIZE
     * @since 3.16.0
     * 
     * @param {object} [fullscreenOptions] - The FullscreenOptions dictionary is used to provide configuration options when entering full screen.
     */startFullscreen:function(t){void 0===t&&(t={navigationUI:"hide"});var e=this.fullscreen;if(!e.available){this.emit(o.FULLSCREEN_UNSUPPORTED);return}if(!e.active){var i,n=this.getFullscreenTarget();(i=e.keyboard?n[e.request](Element.ALLOW_KEYBOARD_INPUT):n[e.request](t))?i.then(this.fullscreenSuccessHandler.bind(this)).catch(this.fullscreenErrorHandler.bind(this)):e.active?this.fullscreenSuccessHandler():this.fullscreenErrorHandler()}},/**
     * The browser has successfully entered fullscreen mode.
     *
     * @method Phaser.Scale.ScaleManager#fullscreenSuccessHandler
     * @private
     * @fires Phaser.Scale.Events#ENTER_FULLSCREEN
     * @fires Phaser.Scale.Events#RESIZE
     * @since 3.17.0
     */fullscreenSuccessHandler:function(){this.getParentBounds(),this.refresh(),this.emit(o.ENTER_FULLSCREEN)},/**
     * The browser failed to enter fullscreen mode.
     *
     * @method Phaser.Scale.ScaleManager#fullscreenErrorHandler
     * @private
     * @fires Phaser.Scale.Events#FULLSCREEN_FAILED
     * @fires Phaser.Scale.Events#RESIZE
     * @since 3.17.0
     * 
     * @param {any} error - The DOM error event.
     */fullscreenErrorHandler:function(t){this.removeFullscreenTarget(),this.emit(o.FULLSCREEN_FAILED,t)},/**
     * An internal method that gets the target element that is used when entering fullscreen mode.
     *
     * @method Phaser.Scale.ScaleManager#getFullscreenTarget
     * @since 3.16.0
     * 
     * @return {object} The fullscreen target element.
     */getFullscreenTarget:function(){if(!this.fullscreenTarget){var t=document.createElement("div");t.style.margin="0",t.style.padding="0",t.style.width="100%",t.style.height="100%",this.fullscreenTarget=t,this._createdFullscreenTarget=!0}return this._createdFullscreenTarget&&(this.canvas.parentNode.insertBefore(this.fullscreenTarget,this.canvas),this.fullscreenTarget.appendChild(this.canvas)),this.fullscreenTarget},/**
     * Removes the fullscreen target that was added to the DOM.
     *
     * @method Phaser.Scale.ScaleManager#removeFullscreenTarget
     * @since 3.17.0
     */removeFullscreenTarget:function(){if(this._createdFullscreenTarget){var t=this.fullscreenTarget;if(t&&t.parentNode){var e=t.parentNode;e.insertBefore(this.canvas,t),e.removeChild(t)}}},/**
     * Calling this method will cancel fullscreen mode, if the browser has entered it.
     *
     * @method Phaser.Scale.ScaleManager#stopFullscreen
     * @fires Phaser.Scale.Events#LEAVE_FULLSCREEN
     * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED
     * @since 3.16.0
     */stopFullscreen:function(){var t=this.fullscreen;if(!t.available)return this.emit(o.FULLSCREEN_UNSUPPORTED),!1;t.active&&document[t.cancel](),this.removeFullscreenTarget(),//  Get the parent size again as it will have changed
this.getParentBounds(),this.emit(o.LEAVE_FULLSCREEN),this.refresh()},/**
     * Toggles the fullscreen mode. If already in fullscreen, calling this will cancel it.
     * If not in fullscreen, this will request the browser to enter fullscreen mode.
     * 
     * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.
     * 
     * This method _must_ be called from a user-input gesture, such as `pointerdown`. You cannot launch
     * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked
     * from fullscreen unless the iframe has the `allowfullscreen` attribute.
     *
     * @method Phaser.Scale.ScaleManager#toggleFullscreen
     * @fires Phaser.Scale.Events#ENTER_FULLSCREEN
     * @fires Phaser.Scale.Events#LEAVE_FULLSCREEN
     * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED
     * @fires Phaser.Scale.Events#RESIZE
     * @since 3.16.0
     * 
     * @param {object} [fullscreenOptions] - The FullscreenOptions dictionary is used to provide configuration options when entering full screen.
     */toggleFullscreen:function(t){this.fullscreen.active?this.stopFullscreen():this.startFullscreen(t)},/**
     * An internal method that starts the different DOM event listeners running.
     *
     * @method Phaser.Scale.ScaleManager#startListeners
     * @since 3.16.0
     */startListeners:function(){var t=this,e=this.listeners;e.orientationChange=function(){t._checkOrientation=!0,t.dirty=!0},e.windowResize=function(){t.dirty=!0},//  Only dispatched on mobile devices
window.addEventListener("orientationchange",e.orientationChange,!1),window.addEventListener("resize",e.windowResize,!1),this.fullscreen.available&&(e.fullScreenChange=function(e){return t.onFullScreenChange(e)},e.fullScreenError=function(e){return t.onFullScreenError(e)},["webkit","moz",""].forEach(function(t){document.addEventListener(t+"fullscreenchange",e.fullScreenChange,!1),document.addEventListener(t+"fullscreenerror",e.fullScreenError,!1)}),//  MS Specific
document.addEventListener("MSFullscreenChange",e.fullScreenChange,!1),document.addEventListener("MSFullscreenError",e.fullScreenError,!1))},/**
     * Triggered when a fullscreenchange event is dispatched by the DOM.
     *
     * @method Phaser.Scale.ScaleManager#onFullScreenChange
     * @since 3.16.0
     */onFullScreenChange:function(){//  They pressed ESC while in fullscreen mode
document.fullscreenElement||document.webkitFullscreenElement||document.msFullscreenElement||document.mozFullScreenElement||this.stopFullscreen()},/**
     * Triggered when a fullscreenerror event is dispatched by the DOM.
     *
     * @method Phaser.Scale.ScaleManager#onFullScreenError
     * @since 3.16.0
     */onFullScreenError:function(){this.removeFullscreenTarget()},/**
     * Internal method, called automatically by the game step.
     * Monitors the elapsed time and resize interval to see if a parent bounds check needs to take place.
     *
     * @method Phaser.Scale.ScaleManager#step
     * @since 3.16.0
     *
     * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().
     * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.
     */step:function(t,e){this.parent&&(this._lastCheck+=e,(this.dirty||this._lastCheck>this.resizeInterval)&&(this.getParentBounds()&&this.refresh(),this.dirty=!1,this._lastCheck=0))},/**
     * Stops all DOM event listeners.
     *
     * @method Phaser.Scale.ScaleManager#stopListeners
     * @since 3.16.0
     */stopListeners:function(){var t=this.listeners;window.removeEventListener("orientationchange",t.orientationChange,!1),window.removeEventListener("resize",t.windowResize,!1),["webkit","moz",""].forEach(function(e){document.removeEventListener(e+"fullscreenchange",t.fullScreenChange,!1),document.removeEventListener(e+"fullscreenerror",t.fullScreenError,!1)}),//  MS Specific
document.removeEventListener("MSFullscreenChange",t.fullScreenChange,!1),document.removeEventListener("MSFullscreenError",t.fullScreenError,!1)},/**
     * Destroys this Scale Manager, releasing all references to external resources.
     * Once destroyed, the Scale Manager cannot be used again.
     *
     * @method Phaser.Scale.ScaleManager#destroy
     * @since 3.16.0
     */destroy:function(){this.removeAllListeners(),this.stopListeners(),this.game=null,this.canvas=null,this.canvasBounds=null,this.parent=null,this.fullscreenTarget=null,this.parentSize.destroy(),this.gameSize.destroy(),this.baseSize.destroy(),this.displaySize.destroy()},/**
     * Is the browser currently in fullscreen mode or not?
     *
     * @name Phaser.Scale.ScaleManager#isFullscreen
     * @type {boolean}
     * @readonly
     * @since 3.16.0
     */isFullscreen:{get:function(){return this.fullscreen.active}},/**
     * The game width.
     * 
     * This is typically the size given in the game configuration.
     *
     * @name Phaser.Scale.ScaleManager#width
     * @type {number}
     * @readonly
     * @since 3.16.0
     */width:{get:function(){return this.gameSize.width}},/**
     * The game height.
     * 
     * This is typically the size given in the game configuration.
     *
     * @name Phaser.Scale.ScaleManager#height
     * @type {number}
     * @readonly
     * @since 3.16.0
     */height:{get:function(){return this.gameSize.height}},/**
     * Is the device in a portrait orientation as reported by the Orientation API?
     * This value is usually only available on mobile devices.
     *
     * @name Phaser.Scale.ScaleManager#isPortrait
     * @type {boolean}
     * @readonly
     * @since 3.16.0
     */isPortrait:{get:function(){return this.orientation===i.ORIENTATION.PORTRAIT}},/**
     * Is the device in a landscape orientation as reported by the Orientation API?
     * This value is usually only available on mobile devices.
     *
     * @name Phaser.Scale.ScaleManager#isLandscape
     * @type {boolean}
     * @readonly
     * @since 3.16.0
     */isLandscape:{get:function(){return this.orientation===i.ORIENTATION.LANDSCAPE}},/**
     * Are the game dimensions portrait? (i.e. taller than they are wide)
     * 
     * This is different to the device itself being in a portrait orientation.
     *
     * @name Phaser.Scale.ScaleManager#isGamePortrait
     * @type {boolean}
     * @readonly
     * @since 3.16.0
     */isGamePortrait:{get:function(){return this.height>this.width}},/**
     * Are the game dimensions landscape? (i.e. wider than they are tall)
     * 
     * This is different to the device itself being in a landscape orientation.
     *
     * @name Phaser.Scale.ScaleManager#isGameLandscape
     * @type {boolean}
     * @readonly
     * @since 3.16.0
     */isGameLandscape:{get:function(){return this.width>this.height}}});t.exports=v}),r("9YEK2",function(t,e){t.exports=function(t){if(!t)return window.innerHeight;var e=Math.abs(window.orientation),i={w:0,h:0},n=document.createElement("div");return(n.setAttribute("style","position: fixed; height: 100vh; width: 0; top: 0"),document.documentElement.appendChild(n),i.w=90===e?n.offsetHeight:window.innerWidth,i.h=90===e?window.innerWidth:n.offsetHeight,document.documentElement.removeChild(n),n=null,90!==Math.abs(window.orientation))?i.h:i.w}}),r("ehRgb",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iEUUO"),n=s("jwj1g"),r=s("jcIaO"),o=s("7SBSk"),a=new n({initialize:function(t,e,i,n){void 0===t&&(t=0),void 0===e&&(e=t),void 0===i&&(i=0),void 0===n&&(n=null),/**
         * Internal width value.
         *
         * @name Phaser.Structs.Size#_width
         * @type {number}
         * @private
         * @since 3.16.0
         */this._width=t,/**
         * Internal height value.
         *
         * @name Phaser.Structs.Size#_height
         * @type {number}
         * @private
         * @since 3.16.0
         */this._height=e,/**
         * Internal parent reference.
         *
         * @name Phaser.Structs.Size#_parent
         * @type {any}
         * @private
         * @since 3.16.0
         */this._parent=n,/**
         * The aspect mode this Size component will use when calculating its dimensions.
         * This property is read-only. To change it use the `setAspectMode` method.
         *
         * @name Phaser.Structs.Size#aspectMode
         * @type {integer}
         * @readonly
         * @since 3.16.0
         */this.aspectMode=i,/**
         * The proportional relationship between the width and height.
         * 
         * This property is read-only and is updated automatically when either the `width` or `height` properties are changed,
         * depending on the aspect mode.
         *
         * @name Phaser.Structs.Size#aspectRatio
         * @type {number}
         * @readonly
         * @since 3.16.0
         */this.aspectRatio=0===e?1:t/e,/**
         * The minimum allowed width.
         * Cannot be less than zero.
         * This value is read-only. To change it see the `setMin` method.
         *
         * @name Phaser.Structs.Size#minWidth
         * @type {number}
         * @readonly
         * @since 3.16.0
         */this.minWidth=0,/**
         * The minimum allowed height.
         * Cannot be less than zero.
         * This value is read-only. To change it see the `setMin` method.
         *
         * @name Phaser.Structs.Size#minHeight
         * @type {number}
         * @readonly
         * @since 3.16.0
         */this.minHeight=0,/**
         * The maximum allowed width.
         * This value is read-only. To change it see the `setMax` method.
         *
         * @name Phaser.Structs.Size#maxWidth
         * @type {number}
         * @readonly
         * @since 3.16.0
         */this.maxWidth=Number.MAX_VALUE,/**
         * The maximum allowed height.
         * This value is read-only. To change it see the `setMax` method.
         *
         * @name Phaser.Structs.Size#maxHeight
         * @type {number}
         * @readonly
         * @since 3.16.0
         */this.maxHeight=Number.MAX_VALUE,/**
         * A Vector2 containing the horizontal and vertical snap values, which the width and height are snapped to during resizing.
         * 
         * By default this is disabled.
         * 
         * This property is read-only. To change it see the `setSnap` method.
         *
         * @name Phaser.Structs.Size#snapTo
         * @type {Phaser.Math.Vector2}
         * @readonly
         * @since 3.16.0
         */this.snapTo=new o},/**
     * Sets the aspect mode of this Size component.
     * 
     * The aspect mode controls what happens when you modify the `width` or `height` properties, or call `setSize`.
     * 
     * It can be a number from 0 to 4, or a Size constant:
     * 
     * 0. NONE = Do not make the size fit the aspect ratio. Change the ratio when the size changes.
     * 1. WIDTH_CONTROLS_HEIGHT = The height is automatically adjusted based on the width.
     * 2. HEIGHT_CONTROLS_WIDTH = The width is automatically adjusted based on the height.
     * 3. FIT = The width and height are automatically adjusted to fit inside the given target area, while keeping the aspect ratio. Depending on the aspect ratio there may be some space inside the area which is not covered.
     * 4. ENVELOP = The width and height are automatically adjusted to make the size cover the entire target area while keeping the aspect ratio. This may extend further out than the target size.
     * 
     * Calling this method automatically recalculates the `width` and the `height`, if required.
     * 
     * @method Phaser.Structs.Size#setAspectMode
     * @since 3.16.0
     *
     * @param {integer} [value=0] - The aspect mode value.
     *
     * @return {this} This Size component instance.
     */setAspectMode:function(t){return void 0===t&&(t=0),this.aspectMode=t,this.setSize(this._width,this._height)},/**
     * By setting a Snap To value when this Size component is modified its dimensions will automatically
     * by snapped to the nearest grid slice, using floor. For example, if you have snap value of 16,
     * and the width changes to 68, then it will snap down to 64 (the closest multiple of 16 when floored)
     * 
     * Note that snapping takes place before adjustments by the parent, or the min / max settings. If these
     * values are not multiples of the given snap values, then this can result in un-snapped dimensions.
     * 
     * Call this method with no arguments to reset the snap values.
     * 
     * Calling this method automatically recalculates the `width` and the `height`, if required.
     * 
     * @method Phaser.Structs.Size#setSnap
     * @since 3.16.0
     *
     * @param {number} [snapWidth=0] - The amount to snap the width to. If you don't want to snap the width, pass a value of zero.
     * @param {number} [snapHeight=snapWidth] - The amount to snap the height to. If not provided it will use the `snapWidth` value. If you don't want to snap the height, pass a value of zero.
     *
     * @return {this} This Size component instance.
     */setSnap:function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),this.snapTo.set(t,e),this.setSize(this._width,this._height)},/**
     * Sets, or clears, the parent of this Size component.
     * 
     * To clear the parent call this method with no arguments.
     * 
     * The parent influences the maximum extents to which this Size component can expand,
     * based on the aspect mode:
     * 
     * NONE - The parent clamps both the width and height.
     * WIDTH_CONTROLS_HEIGHT - The parent clamps just the width.
     * HEIGHT_CONTROLS_WIDTH - The parent clamps just the height.
     * FIT - The parent clamps whichever axis is required to ensure the size fits within it.
     * ENVELOP - The parent is used to ensure the size fully envelops the parent.
     * 
     * Calling this method automatically calls `setSize`.
     *
     * @method Phaser.Structs.Size#setParent
     * @since 3.16.0
     *
     * @param {any} [parent] - Sets the parent of this Size component. Don't provide a value to clear an existing parent.
     *
     * @return {this} This Size component instance.
     */setParent:function(t){return this._parent=t,this.setSize(this._width,this._height)},/**
     * Set the minimum width and height values this Size component will allow.
     * 
     * The minimum values can never be below zero, or greater than the maximum values.
     * 
     * Setting this will automatically adjust both the `width` and `height` properties to ensure they are within range.
     * 
     * Note that based on the aspect mode, and if this Size component has a parent set or not, the minimums set here
     * _can_ be exceed in some situations.
     *
     * @method Phaser.Structs.Size#setMin
     * @since 3.16.0
     *
     * @param {number} [width=0] - The minimum allowed width of the Size component.
     * @param {number} [height=width] - The minimum allowed height of the Size component. If not given, it will use the `width`.
     *
     * @return {this} This Size component instance.
     */setMin:function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),this.minWidth=i(t,0,this.maxWidth),this.minHeight=i(e,0,this.maxHeight),this.setSize(this._width,this._height)},/**
     * Set the maximum width and height values this Size component will allow.
     * 
     * Setting this will automatically adjust both the `width` and `height` properties to ensure they are within range.
     * 
     * Note that based on the aspect mode, and if this Size component has a parent set or not, the maximums set here
     * _can_ be exceed in some situations.
     *
     * @method Phaser.Structs.Size#setMax
     * @since 3.16.0
     *
     * @param {number} [width=Number.MAX_VALUE] - The maximum allowed width of the Size component.
     * @param {number} [height=width] - The maximum allowed height of the Size component. If not given, it will use the `width`.
     *
     * @return {this} This Size component instance.
     */setMax:function(t,e){return void 0===t&&(t=Number.MAX_VALUE),void 0===e&&(e=t),this.maxWidth=i(t,this.minWidth,Number.MAX_VALUE),this.maxHeight=i(e,this.minHeight,Number.MAX_VALUE),this.setSize(this._width,this._height)},/**
     * Sets the width and height of this Size component based on the aspect mode.
     * 
     * If the aspect mode is 'none' then calling this method will change the aspect ratio, otherwise the current
     * aspect ratio is honored across all other modes.
     * 
     * If snapTo values have been set then the given width and height are snapped first, prior to any further
     * adjustment via min/max values, or a parent.
     * 
     * If minimum and/or maximum dimensions have been specified, the values given to this method will be clamped into
     * that range prior to adjustment, but may still exceed them depending on the aspect mode.
     * 
     * If this Size component has a parent set, and the aspect mode is `fit` or `envelop`, then the given sizes will
     * be clamped to the range specified by the parent.
     *
     * @method Phaser.Structs.Size#setSize
     * @since 3.16.0
     *
     * @param {number} [width=0] - The new width of the Size component.
     * @param {number} [height=width] - The new height of the Size component. If not given, it will use the `width`.
     *
     * @return {this} This Size component instance.
     */setSize:function(t,e){switch(void 0===t&&(t=0),void 0===e&&(e=t),this.aspectMode){case a.NONE:this._width=this.getNewWidth(r(t,this.snapTo.x)),this._height=this.getNewHeight(r(e,this.snapTo.y)),this.aspectRatio=0===this._height?1:this._width/this._height;break;case a.WIDTH_CONTROLS_HEIGHT:this._width=this.getNewWidth(r(t,this.snapTo.x)),this._height=this.getNewHeight(this._width*(1/this.aspectRatio),!1);break;case a.HEIGHT_CONTROLS_WIDTH:this._height=this.getNewHeight(r(e,this.snapTo.y)),this._width=this.getNewWidth(this._height*this.aspectRatio,!1);break;case a.FIT:this.constrain(t,e,!0);break;case a.ENVELOP:this.constrain(t,e,!1)}return this},/**
     * Sets a new aspect ratio, overriding what was there previously.
     * 
     * It then calls `setSize` immediately using the current dimensions.
     *
     * @method Phaser.Structs.Size#setAspectRatio
     * @since 3.16.0
     *
     * @param {number} ratio - The new aspect ratio.
     *
     * @return {this} This Size component instance.
     */setAspectRatio:function(t){return this.aspectRatio=t,this.setSize(this._width,this._height)},/**
     * Sets a new width and height for this Size component and updates the aspect ratio based on them.
     * 
     * It _doesn't_ change the `aspectMode` and still factors in size limits such as the min max and parent bounds.
     *
     * @method Phaser.Structs.Size#resize
     * @since 3.16.0
     *
     * @param {number} width - The new width of the Size component.
     * @param {number} [height=width] - The new height of the Size component. If not given, it will use the `width`.
     *
     * @return {this} This Size component instance.
     */resize:function(t,e){return this._width=this.getNewWidth(r(t,this.snapTo.x)),this._height=this.getNewHeight(r(e,this.snapTo.y)),this.aspectRatio=0===this._height?1:this._width/this._height,this},/**
     * Takes a new width and passes it through the min/max clamp and then checks it doesn't exceed the parent width.
     *
     * @method Phaser.Structs.Size#getNewWidth
     * @since 3.16.0
     *
     * @param {number} value - The value to clamp and check.
     * @param {boolean} [checkParent=true] - Check the given value against the parent, if set.
     *
     * @return {number} The modified width value.
     */getNewWidth:function(t,e){return void 0===e&&(e=!0),t=i(t,this.minWidth,this.maxWidth),e&&this._parent&&t>this._parent.width&&(t=Math.max(this.minWidth,this._parent.width)),t},/**
     * Takes a new height and passes it through the min/max clamp and then checks it doesn't exceed the parent height.
     *
     * @method Phaser.Structs.Size#getNewHeight
     * @since 3.16.0
     *
     * @param {number} value - The value to clamp and check.
     * @param {boolean} [checkParent=true] - Check the given value against the parent, if set.
     *
     * @return {number} The modified height value.
     */getNewHeight:function(t,e){return void 0===e&&(e=!0),t=i(t,this.minHeight,this.maxHeight),e&&this._parent&&t>this._parent.height&&(t=Math.max(this.minHeight,this._parent.height)),t},/**
     * The current `width` and `height` are adjusted to fit inside the given dimensions, while keeping the aspect ratio.
     * 
     * If `fit` is true there may be some space inside the target area which is not covered if its aspect ratio differs.
     * If `fit` is false the size may extend further out than the target area if the aspect ratios differ.
     * 
     * If this Size component has a parent set, then the width and height passed to this method will be clamped so
     * it cannot exceed that of the parent.
     *
     * @method Phaser.Structs.Size#constrain
     * @since 3.16.0
     *
     * @param {number} [width=0] - The new width of the Size component.
     * @param {number} [height] - The new height of the Size component. If not given, it will use the width value.
     * @param {boolean} [fit=true] - Perform a `fit` (true) constraint, or an `envelop` (false) constraint.
     *
     * @return {this} This Size component instance.
     */constrain:function(t,e,i){void 0===t&&(t=0),void 0===e&&(e=t),void 0===i&&(i=!0),t=this.getNewWidth(t),e=this.getNewHeight(e);var n=this.snapTo,s=0===e?1:t/e;return i&&this.aspectRatio>s||!i&&this.aspectRatio<s?(e=//  We need to change the height to fit the width
(t=r(t,n.x))/this.aspectRatio,n.y>0&&//  Reduce the width accordingly
(t=(e=r(e,n.y))*this.aspectRatio)):(i&&this.aspectRatio<s||!i&&this.aspectRatio>s)&&(t=//  We need to change the width to fit the height
(e=r(e,n.y))*this.aspectRatio,n.x>0&&//  Reduce the height accordingly
(e=(t=r(t,n.x))*(1/this.aspectRatio))),this._width=t,this._height=e,this},/**
     * The current `width` and `height` are adjusted to fit inside the given dimensions, while keeping the aspect ratio.
     * 
     * There may be some space inside the target area which is not covered if its aspect ratio differs.
     * 
     * If this Size component has a parent set, then the width and height passed to this method will be clamped so
     * it cannot exceed that of the parent.
     *
     * @method Phaser.Structs.Size#fitTo
     * @since 3.16.0
     *
     * @param {number} [width=0] - The new width of the Size component.
     * @param {number} [height] - The new height of the Size component. If not given, it will use the width value.
     *
     * @return {this} This Size component instance.
     */fitTo:function(t,e){return this.constrain(t,e,!0)},/**
     * The current `width` and `height` are adjusted so that they fully envelope the given dimensions, while keeping the aspect ratio.
     * 
     * The size may extend further out than the target area if the aspect ratios differ.
     * 
     * If this Size component has a parent set, then the values are clamped so that it never exceeds the parent
     * on the longest axis.
     *
     * @method Phaser.Structs.Size#envelop
     * @since 3.16.0
     *
     * @param {number} [width=0] - The new width of the Size component.
     * @param {number} [height] - The new height of the Size component. If not given, it will use the width value.
     *
     * @return {this} This Size component instance.
     */envelop:function(t,e){return this.constrain(t,e,!1)},/**
     * Sets the width of this Size component.
     * 
     * Depending on the aspect mode, changing the width may also update the height and aspect ratio.
     *
     * @method Phaser.Structs.Size#setWidth
     * @since 3.16.0
     *
     * @param {number} width - The new width of the Size component.
     *
     * @return {this} This Size component instance.
     */setWidth:function(t){return this.setSize(t,this._height)},/**
     * Sets the height of this Size component.
     * 
     * Depending on the aspect mode, changing the height may also update the width and aspect ratio.
     *
     * @method Phaser.Structs.Size#setHeight
     * @since 3.16.0
     *
     * @param {number} height - The new height of the Size component.
     *
     * @return {this} This Size component instance.
     */setHeight:function(t){return this.setSize(this._width,t)},/**
     * Returns a string representation of this Size component.
     *
     * @method Phaser.Structs.Size#toString
     * @since 3.16.0
     *
     * @return {string} A string representation of this Size component.
     */toString:function(){return"[{ Size (width="+this._width+" height="+this._height+" aspectRatio="+this.aspectRatio+" aspectMode="+this.aspectMode+") }]"},/**
     * Sets the values of this Size component to the `element.style.width` and `height`
     * properties of the given DOM Element. The properties are set as `px` values.
     *
     * @method Phaser.Structs.Size#setCSS
     * @since 3.17.0
     *
     * @param {HTMLElement} element - The DOM Element to set the CSS style on.
     */setCSS:function(t){t&&t.style&&(t.style.width=this._width+"px",t.style.height=this._height+"px")},/**
     * Copies the aspect mode, aspect ratio, width and height from this Size component
     * to the given Size component. Note that the parent, if set, is not copied across.
     *
     * @method Phaser.Structs.Size#copy
     * @since 3.16.0
     * 
     * @param {Phaser.Structs.Size} destination - The Size component to copy the values to.
     *
     * @return {Phaser.Structs.Size} The updated destination Size component.
     */copy:function(t){return t.setAspectMode(this.aspectMode),t.aspectRatio=this.aspectRatio,t.setSize(this.width,this.height)},/**
     * Destroys this Size component.
     * 
     * This clears the local properties and any parent object, if set.
     * 
     * A destroyed Size component cannot be re-used.
     *
     * @method Phaser.Structs.Size#destroy
     * @since 3.16.0
     */destroy:function(){this._parent=null,this.snapTo=null},/**
     * The width of this Size component.
     * 
     * This value is clamped to the range specified by `minWidth` and `maxWidth`, if enabled.
     * 
     * A width can never be less than zero.
     * 
     * Changing this value will automatically update the `height` if the aspect ratio lock is enabled.
     * You can also use the `setWidth` and `getWidth` methods.
     *
     * @name Phaser.Structs.Size#width
     * @type {number}
     * @since 3.16.0
     */width:{get:function(){return this._width},set:function(t){this.setSize(t,this._height)}},/**
     * The height of this Size component.
     * 
     * This value is clamped to the range specified by `minHeight` and `maxHeight`, if enabled.
     * 
     * A height can never be less than zero.
     * 
     * Changing this value will automatically update the `width` if the aspect ratio lock is enabled.
     * You can also use the `setHeight` and `getHeight` methods.
     *
     * @name Phaser.Structs.Size#height
     * @type {number}
     * @since 3.16.0
     */height:{get:function(){return this._height},set:function(t){this.setSize(this._width,t)}}});/**
 * Do not make the size fit the aspect ratio. Change the ratio when the size changes.
 * 
 * @name Phaser.Structs.Size.NONE
 * @constant
 * @type {integer}
 * @since 3.16.0
 */a.NONE=0,/**
 * The height is automatically adjusted based on the width.
 * 
 * @name Phaser.Structs.Size.WIDTH_CONTROLS_HEIGHT
 * @constant
 * @type {integer}
 * @since 3.16.0
 */a.WIDTH_CONTROLS_HEIGHT=1,/**
 * The width is automatically adjusted based on the height.
 * 
 * @name Phaser.Structs.Size.HEIGHT_CONTROLS_WIDTH
 * @constant
 * @type {integer}
 * @since 3.16.0
 */a.HEIGHT_CONTROLS_WIDTH=2,/**
 * The width and height are automatically adjusted to fit inside the given target area, while keeping the aspect ratio. Depending on the aspect ratio there may be some space inside the area which is not covered.
 * 
 * @name Phaser.Structs.Size.FIT
 * @constant
 * @type {integer}
 * @since 3.16.0
 */a.FIT=3,/**
 * The width and height are automatically adjusted to make the size cover the entire target area while keeping the aspect ratio. This may extend further out than the target size.
 * 
 * @name Phaser.Structs.Size.ENVELOP
 * @constant
 * @type {integer}
 * @since 3.16.0
 */a.ENVELOP=4,t.exports=a}),r("TOZF7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("anFCw"),r=s("4rtgc"),o=s("aqcI1"),a=s("5pMDk"),h=s("ls69h"),l=s("13GYA"),u=s("iXVlb"),c=s("jgSN1"),d=new i({initialize:function(t,e){if(/**
         * The Game that this SceneManager belongs to.
         *
         * @name Phaser.Scenes.SceneManager#game
         * @type {Phaser.Game}
         * @since 3.0.0
         */this.game=t,/**
         * An object that maps the keys to the scene so we can quickly get a scene from a key without iteration.
         *
         * @name Phaser.Scenes.SceneManager#keys
         * @type {object}
         * @since 3.0.0
         */this.keys={},/**
         * The array in which all of the scenes are kept.
         *
         * @name Phaser.Scenes.SceneManager#scenes
         * @type {array}
         * @since 3.0.0
         */this.scenes=[],/**
         * Scenes pending to be added are stored in here until the manager has time to add it.
         *
         * @name Phaser.Scenes.SceneManager#_pending
         * @type {array}
         * @private
         * @since 3.0.0
         */this._pending=[],/**
         * An array of scenes waiting to be started once the game has booted.
         *
         * @name Phaser.Scenes.SceneManager#_start
         * @type {array}
         * @private
         * @since 3.0.0
         */this._start=[],/**
         * An operations queue, because we don't manipulate the scenes array during processing.
         *
         * @name Phaser.Scenes.SceneManager#_queue
         * @type {array}
         * @private
         * @since 3.0.0
         */this._queue=[],/**
         * Boot time data to merge.
         *
         * @name Phaser.Scenes.SceneManager#_data
         * @type {object}
         * @private
         * @since 3.4.0
         */this._data={},/**
         * Is the Scene Manager actively processing the Scenes list?
         *
         * @name Phaser.Scenes.SceneManager#isProcessing
         * @type {boolean}
         * @default false
         * @readonly
         * @since 3.0.0
         */this.isProcessing=!1,/**
         * Has the Scene Manager properly started?
         *
         * @name Phaser.Scenes.SceneManager#isBooted
         * @type {boolean}
         * @default false
         * @readonly
         * @since 3.4.0
         */this.isBooted=!1,/**
         * Do any of the Cameras in any of the Scenes require a custom viewport?
         * If not we can skip scissor tests.
         *
         * @name Phaser.Scenes.SceneManager#customViewports
         * @type {number}
         * @default 0
         * @since 3.12.0
         */this.customViewports=0,e){Array.isArray(e)||(e=[e]);for(var i=0;i<e.length;i++)this._pending.push({key:"default",scene:e[i],autoStart:0===i,data:{}})}t.events.once(o.READY,this.bootQueue,this)},/**
     * Internal first-time Scene boot handler.
     *
     * @method Phaser.Scenes.SceneManager#bootQueue
     * @private
     * @since 3.2.0
     */bootQueue:function(){var t,e,i,n,s;if(!this.isBooted){for(t=0;t<this._pending.length;t++)i=(e=this._pending[t]).key,(n=e.scene)instanceof u?s=this.createSceneFromInstance(i,n):"object"==typeof n?s=this.createSceneFromObject(i,n):"function"==typeof n&&(s=this.createSceneFromFunction(i,n)),//  Replace key in case the scene changed it
i=s.sys.settings.key,this.keys[i]=s,this.scenes.push(s),this._data[i]&&(s.sys.settings.data=this._data[i].data,this._data[i].autoStart&&(e.autoStart=!0)),(e.autoStart||s.sys.settings.active)&&this._start.push(i);//  _start might have been populated by the above
for(t=0,//  Clear the pending lists
this._pending.length=0,this._data={},this.isBooted=!0;t<this._start.length;t++)e=this._start[t],this.start(e);this._start.length=0}},/**
     * Process the Scene operations queue.
     *
     * @method Phaser.Scenes.SceneManager#processQueue
     * @since 3.0.0
     */processQueue:function(){var t,e,i=this._pending.length,n=this._queue.length;if(0!==i||0!==n){if(i){for(t=0;t<i;t++)e=this._pending[t],this.add(e.key,e.scene,e.autoStart,e.data);//  _start might have been populated by this.add
for(t=0;t<this._start.length;t++)e=this._start[t],this.start(e);//  Clear the pending lists
this._start.length=0,this._pending.length=0;return}for(t=0;t<this._queue.length;t++)this[(e=this._queue[t]).op](e.keyA,e.keyB);this._queue.length=0}},/**
     * Adds a new Scene into the SceneManager.
     * You must give each Scene a unique key by which you'll identify it.
     *
     * The `sceneConfig` can be:
     *
     * * A `Phaser.Scene` object, or an object that extends it.
     * * A plain JavaScript object
     * * A JavaScript ES6 Class that extends `Phaser.Scene`
     * * A JavaScript ES5 prototype based Class
     * * A JavaScript function
     *
     * If a function is given then a new Scene will be created by calling it.
     *
     * @method Phaser.Scenes.SceneManager#add
     * @since 3.0.0
     *
     * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.
     * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig|function)} sceneConfig - The config for the Scene
     * @param {boolean} [autoStart=false] - If `true` the Scene will be started immediately after being added.
     * @param {object} [data] - Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.
     *
     * @return {?Phaser.Scene} The added Scene, if it was added immediately, otherwise `null`.
     */add:function(t,e,i,n){var s;return(//  If processing or not booted then put scene into a holding pattern
(void 0===i&&(i=!1),void 0===n&&(n={}),this.isProcessing||!this.isBooted)?(this._pending.push({key:t,scene:e,autoStart:i,data:n}),this.isBooted||(this._data[t]={data:n}),null):(t=this.getKey(t,e),e instanceof u?s=this.createSceneFromInstance(t,e):"object"==typeof e?(e.key=t,s=this.createSceneFromObject(t,e)):"function"==typeof e&&(s=this.createSceneFromFunction(t,e)),//  Any data to inject?
s.sys.settings.data=n,//  Replace key in case the scene changed it
t=s.sys.settings.key,this.keys[t]=s,this.scenes.push(s),(i||s.sys.settings.active)&&(this._pending.length?this._start.push(t):this.start(t)),s))},/**
     * Removes a Scene from the SceneManager.
     *
     * The Scene is removed from the local scenes array, it's key is cleared from the keys
     * cache and Scene.Systems.destroy is then called on it.
     *
     * If the SceneManager is processing the Scenes when this method is called it will
     * queue the operation for the next update sequence.
     *
     * @method Phaser.Scenes.SceneManager#remove
     * @since 3.2.0
     *
     * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */remove:function(t){if(this.isProcessing)this._queue.push({op:"remove",keyA:t,keyB:null});else{var e=this.getScene(t);if(!e||e.sys.isTransitioning())return this;var i=this.scenes.indexOf(e),n=e.sys.settings.key;i>-1&&(delete this.keys[n],this.scenes.splice(i,1),this._start.indexOf(n)>-1&&(i=this._start.indexOf(n),this._start.splice(i,1)),e.sys.destroy())}return this},/**
     * Boot the given Scene.
     *
     * @method Phaser.Scenes.SceneManager#bootScene
     * @private
     * @fires Phaser.Scenes.Events#TRANSITION_INIT
     * @since 3.0.0
     *
     * @param {Phaser.Scene} scene - The Scene to boot.
     */bootScene:function(t){var e,i=t.sys,s=i.settings;i.sceneUpdate=l,t.init&&(t.init.call(t,s.data),s.status=n.INIT,s.isTransition&&i.events.emit(r.TRANSITION_INIT,s.transitionFrom,s.transitionDuration)),i.load&&(e=i.load).reset(),e&&t.preload?(t.preload.call(t),0===e.list.size?this.create(t):(s.status=n.LOADING,//  Start the loader going as we have something in the queue
e.once(h.COMPLETE,this.loadComplete,this),e.start())):this.create(t)},/**
     * Handles load completion for a Scene's Loader.
     *
     * Starts the Scene that the Loader belongs to.
     *
     * @method Phaser.Scenes.SceneManager#loadComplete
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading.
     */loadComplete:function(t){var e=t.scene;this.game.sound&&this.game.sound.onBlurPausedSounds&&this.game.sound.unlock(),this.create(e)},/**
     * Handle payload completion for a Scene.
     *
     * @method Phaser.Scenes.SceneManager#payloadComplete
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading its Scene's payload.
     */payloadComplete:function(t){this.bootScene(t.scene)},/**
     * Updates the Scenes.
     *
     * @method Phaser.Scenes.SceneManager#update
     * @since 3.0.0
     *
     * @param {number} time - Time elapsed.
     * @param {number} delta - Delta time from the last update.
     */update:function(t,e){this.processQueue(),this.isProcessing=!0;//  Loop through the active scenes in reverse order
for(var i=this.scenes.length-1;i>=0;i--){var s=this.scenes[i].sys;s.settings.status>n.START&&s.settings.status<=n.RUNNING&&s.step(t,e)}},/**
     * Renders the Scenes.
     *
     * @method Phaser.Scenes.SceneManager#render
     * @since 3.0.0
     *
     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer to use.
     */render:function(t){//  Loop through the scenes in forward order
for(var e=0;e<this.scenes.length;e++){var i=this.scenes[e].sys;i.settings.visible&&i.settings.status>=n.LOADING&&i.settings.status<n.SLEEPING&&i.render(t)}this.isProcessing=!1},/**
     * Calls the given Scene's {@link Phaser.Scene#create} method and updates its status.
     *
     * @method Phaser.Scenes.SceneManager#create
     * @private
     * @fires Phaser.Scenes.Events#CREATE
     * @fires Phaser.Scenes.Events#TRANSITION_INIT
     * @since 3.0.0
     *
     * @param {Phaser.Scene} scene - The Scene to create.
     */create:function(t){var e=t.sys,i=e.settings;t.create&&(i.status=n.CREATING,t.create.call(t,i.data),i.status===n.DESTROYED)||(i.isTransition&&e.events.emit(r.TRANSITION_START,i.transitionFrom,i.transitionDuration),t.update&&(e.sceneUpdate=t.update),i.status=n.RUNNING,e.events.emit(r.CREATE,t))},/**
     * Creates and initializes a Scene from a function.
     *
     * @method Phaser.Scenes.SceneManager#createSceneFromFunction
     * @private
     * @since 3.0.0
     *
     * @param {string} key - The key of the Scene.
     * @param {function} scene - The function to create the Scene from.
     *
     * @return {Phaser.Scene} The created Scene.
     */createSceneFromFunction:function(t,e){var i=new e;if(!(i instanceof u))return i.sys=new c(i),i.sys.settings.key=t,i.sys.init(this.game),i;var n=i.sys.settings.key;if(""!==n&&(t=n),this.keys.hasOwnProperty(t))throw Error("Cannot add a Scene with duplicate key: "+t);return this.createSceneFromInstance(t,i)},/**
     * Creates and initializes a Scene instance.
     *
     * @method Phaser.Scenes.SceneManager#createSceneFromInstance
     * @private
     * @since 3.0.0
     *
     * @param {string} key - The key of the Scene.
     * @param {Phaser.Scene} newScene - The Scene instance.
     *
     * @return {Phaser.Scene} The created Scene.
     */createSceneFromInstance:function(t,e){var i=e.sys.settings.key;return""!==i?t=i:e.sys.settings.key=t,e.sys.init(this.game),e},/**
     * Creates and initializes a Scene from an Object definition.
     *
     * @method Phaser.Scenes.SceneManager#createSceneFromObject
     * @private
     * @since 3.0.0
     *
     * @param {string} key - The key of the Scene.
     * @param {(string|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig)} sceneConfig - The Scene config.
     *
     * @return {Phaser.Scene} The created Scene.
     */createSceneFromObject:function(t,e){var i=new u(e),n=i.sys.settings.key;""!==n?t=n:i.sys.settings.key=t,i.sys.init(this.game);for(var s=["init","preload","create","update","render"],r=0;r<s.length;r++){var o=a(e,s[r],null);o&&(i[s[r]]=o)}//  Now let's move across any other functions or properties that may exist in the extend object:
/*
        scene: {
            preload: preload,
            create: create,
            extend: {
                hello: 1,
                test: 'atari',
                addImage: addImage
            }
        }
        */if(e.hasOwnProperty("extend")){for(var h in e.extend)if(e.extend.hasOwnProperty(h)){var l=e.extend[h];"data"===h&&i.hasOwnProperty("data")&&"object"==typeof l?i.data.merge(l):"sys"!==h&&(i[h]=l)}}return i},/**
     * Retrieves the key of a Scene from a Scene config.
     *
     * @method Phaser.Scenes.SceneManager#getKey
     * @private
     * @since 3.0.0
     *
     * @param {string} key - The key to check in the Scene config.
     * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|function)} sceneConfig - The Scene config.
     *
     * @return {string} The Scene key.
     */getKey:function(t,e){if(t||(t="default"),"function"==typeof e||(e instanceof u?t=e.sys.settings.key:"object"==typeof e&&e.hasOwnProperty("key")&&(t=e.key),!this.keys.hasOwnProperty(t)))return t;throw Error("Cannot add a Scene with duplicate key: "+t)},/**
     * Returns an array of all the current Scenes being managed by this Scene Manager.
     *
     * You can filter the output by the active state of the Scene and choose to have
     * the array returned in normal or reversed order.
     *
     * @method Phaser.Scenes.SceneManager#getScenes
     * @since 3.16.0
     *
     * @param {boolean} [isActive=true] - Only include Scene's that are currently active?
     * @param {boolean} [inReverse=false] - Return the array of Scenes in reverse?
     *
     * @return {Phaser.Scene[]} An array containing all of the Scenes in the Scene Manager.
     */getScenes:function(t,e){void 0===t&&(t=!0),void 0===e&&(e=!1);for(var i=[],n=this.scenes,s=0;s<n.length;s++){var r=n[s];r&&(!t||t&&r.sys.isActive())&&i.push(r)}return e?i.reverse():i},/**
     * Retrieves a Scene.
     *
     * @method Phaser.Scenes.SceneManager#getScene
     * @since 3.0.0
     *
     * @param {string|Phaser.Scene} key - The Scene to retrieve.
     *
     * @return {?Phaser.Scene} The Scene.
     */getScene:function(t){if("string"==typeof t){if(this.keys[t])return this.keys[t]}else for(var e=0;e<this.scenes.length;e++)if(t===this.scenes[e])return t;return null},/**
     * Determines whether a Scene is running.
     *
     * @method Phaser.Scenes.SceneManager#isActive
     * @since 3.0.0
     *
     * @param {string} key - The Scene to check.
     *
     * @return {boolean} Whether the Scene is running.
     */isActive:function(t){var e=this.getScene(t);return e?e.sys.isActive():null},/**
     * Determines whether a Scene is paused.
     *
     * @method Phaser.Scenes.SceneManager#isPaused
     * @since 3.17.0
     *
     * @param {string} key - The Scene to check.
     *
     * @return {boolean} Whether the Scene is paused.
     */isPaused:function(t){var e=this.getScene(t);return e?e.sys.isPaused():null},/**
     * Determines whether a Scene is visible.
     *
     * @method Phaser.Scenes.SceneManager#isVisible
     * @since 3.0.0
     *
     * @param {string} key - The Scene to check.
     *
     * @return {boolean} Whether the Scene is visible.
     */isVisible:function(t){var e=this.getScene(t);return e?e.sys.isVisible():null},/**
     * Determines whether a Scene is sleeping.
     *
     * @method Phaser.Scenes.SceneManager#isSleeping
     * @since 3.0.0
     *
     * @param {string} key - The Scene to check.
     *
     * @return {boolean} Whether the Scene is sleeping.
     */isSleeping:function(t){var e=this.getScene(t);return e?e.sys.isSleeping():null},/**
     * Pauses the given Scene.
     *
     * @method Phaser.Scenes.SceneManager#pause
     * @since 3.0.0
     *
     * @param {string} key - The Scene to pause.
     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its pause event.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */pause:function(t,e){var i=this.getScene(t);return i&&i.sys.pause(e),this},/**
     * Resumes the given Scene.
     *
     * @method Phaser.Scenes.SceneManager#resume
     * @since 3.0.0
     *
     * @param {string} key - The Scene to resume.
     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its resume event.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */resume:function(t,e){var i=this.getScene(t);return i&&i.sys.resume(e),this},/**
     * Puts the given Scene to sleep.
     *
     * @method Phaser.Scenes.SceneManager#sleep
     * @since 3.0.0
     *
     * @param {string} key - The Scene to put to sleep.
     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its sleep event.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */sleep:function(t,e){var i=this.getScene(t);return i&&!i.sys.isTransitioning()&&i.sys.sleep(e),this},/**
     * Awakens the given Scene.
     *
     * @method Phaser.Scenes.SceneManager#wake
     * @since 3.0.0
     *
     * @param {string} key - The Scene to wake up.
     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its wake event.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */wake:function(t,e){var i=this.getScene(t);return i&&i.sys.wake(e),this},/**
     * Runs the given Scene.
     *
     * If the given Scene is paused, it will resume it. If sleeping, it will wake it.
     * If not running at all, it will be started.
     *
     * Use this if you wish to open a modal Scene by calling `pause` on the current
     * Scene, then `run` on the modal Scene.
     *
     * @method Phaser.Scenes.SceneManager#run
     * @since 3.10.0
     *
     * @param {string} key - The Scene to run.
     * @param {object} [data] - A data object that will be passed to the Scene on start, wake, or resume.
     *
     * @return {Phaser.Scenes.SceneManager} This Scene Manager.
     */run:function(t,e){var i=this.getScene(t);if(!i){for(var n=0;n<this._pending.length;n++)if(this._pending[n].key===t){this.queueOp("start",t,e);break}return this}i.sys.isSleeping()?i.sys.wake(e):i.sys.isPaused()?i.sys.resume(e):this.start(t,e)},/**
     * Starts the given Scene.
     *
     * @method Phaser.Scenes.SceneManager#start
     * @since 3.0.0
     *
     * @param {string} key - The Scene to start.
     * @param {object} [data] - Optional data object to pass to Scene.Settings and Scene.init.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */start:function(t,e){//  If the Scene Manager is not running, then put the Scene into a holding pattern
if(!this.isBooted)return this._data[t]={autoStart:!0,data:e},this;var i,s=this.getScene(t);if(s){//  If the Scene is already running (perhaps they called start from a launched sub-Scene?)
//  then we close it down before starting it again.
if(s.sys.isActive()||s.sys.isPaused())s.sys.shutdown(),s.sys.start(e);else //  Files payload?
if(s.sys.start(e),s.sys.load&&(i=s.sys.load),i&&s.sys.settings.hasOwnProperty("pack")&&(i.reset(),i.addPack({payload:s.sys.settings.pack})))return s.sys.settings.status=n.LOADING,i.once(h.COMPLETE,this.payloadComplete,this),i.start(),this;this.bootScene(s)}return this},/**
     * Stops the given Scene.
     *
     * @method Phaser.Scenes.SceneManager#stop
     * @since 3.0.0
     *
     * @param {string} key - The Scene to stop.
     * @param {object} [data] - Optional data object to pass to Scene.shutdown.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */stop:function(t,e){var i=this.getScene(t);return i&&!i.sys.isTransitioning()&&i.sys.shutdown(e),this},/**
     * Sleeps one one Scene and starts the other.
     *
     * @method Phaser.Scenes.SceneManager#switch
     * @since 3.0.0
     *
     * @param {string} from - The Scene to sleep.
     * @param {string} to - The Scene to start.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */switch:function(t,e){var i=this.getScene(t),n=this.getScene(e);return i&&n&&i!==n&&(this.sleep(t),this.isSleeping(e)?this.wake(e):this.start(e)),this},/**
     * Retrieves a Scene by numeric index.
     *
     * @method Phaser.Scenes.SceneManager#getAt
     * @since 3.0.0
     *
     * @param {integer} index - The index of the Scene to retrieve.
     *
     * @return {(Phaser.Scene|undefined)} The Scene.
     */getAt:function(t){return this.scenes[t]},/**
     * Retrieves the numeric index of a Scene.
     *
     * @method Phaser.Scenes.SceneManager#getIndex
     * @since 3.0.0
     *
     * @param {(string|Phaser.Scene)} key - The key of the Scene.
     *
     * @return {integer} The index of the Scene.
     */getIndex:function(t){var e=this.getScene(t);return this.scenes.indexOf(e)},/**
     * Brings a Scene to the top of the Scenes list.
     *
     * This means it will render above all other Scenes.
     *
     * @method Phaser.Scenes.SceneManager#bringToTop
     * @since 3.0.0
     *
     * @param {(string|Phaser.Scene)} key - The Scene to move.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */bringToTop:function(t){if(this.isProcessing)this._queue.push({op:"bringToTop",keyA:t,keyB:null});else{var e=this.getIndex(t);if(-1!==e&&e<this.scenes.length){var i=this.getScene(t);this.scenes.splice(e,1),this.scenes.push(i)}}return this},/**
     * Sends a Scene to the back of the Scenes list.
     *
     * This means it will render below all other Scenes.
     *
     * @method Phaser.Scenes.SceneManager#sendToBack
     * @since 3.0.0
     *
     * @param {(string|Phaser.Scene)} key - The Scene to move.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */sendToBack:function(t){if(this.isProcessing)this._queue.push({op:"sendToBack",keyA:t,keyB:null});else{var e=this.getIndex(t);if(-1!==e&&e>0){var i=this.getScene(t);this.scenes.splice(e,1),this.scenes.unshift(i)}}return this},/**
     * Moves a Scene down one position in the Scenes list.
     *
     * @method Phaser.Scenes.SceneManager#moveDown
     * @since 3.0.0
     *
     * @param {(string|Phaser.Scene)} key - The Scene to move.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */moveDown:function(t){if(this.isProcessing)this._queue.push({op:"moveDown",keyA:t,keyB:null});else{var e=this.getIndex(t);if(e>0){var i=e-1,n=this.getScene(t),s=this.getAt(i);this.scenes[e]=s,this.scenes[i]=n}}return this},/**
     * Moves a Scene up one position in the Scenes list.
     *
     * @method Phaser.Scenes.SceneManager#moveUp
     * @since 3.0.0
     *
     * @param {(string|Phaser.Scene)} key - The Scene to move.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */moveUp:function(t){if(this.isProcessing)this._queue.push({op:"moveUp",keyA:t,keyB:null});else{var e=this.getIndex(t);if(e<this.scenes.length-1){var i=e+1,n=this.getScene(t),s=this.getAt(i);this.scenes[e]=s,this.scenes[i]=n}}return this},/**
     * Moves a Scene so it is immediately above another Scene in the Scenes list.
     *
     * This means it will render over the top of the other Scene.
     *
     * @method Phaser.Scenes.SceneManager#moveAbove
     * @since 3.2.0
     *
     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.
     * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */moveAbove:function(t,e){if(t===e)return this;if(this.isProcessing)this._queue.push({op:"moveAbove",keyA:t,keyB:e});else{var i=this.getIndex(t),n=this.getIndex(e);if(-1!==i&&-1!==n){var s=this.getAt(n);//  Remove
this.scenes.splice(n,1),//  Add in new location
this.scenes.splice(i+1,0,s)}}return this},/**
     * Moves a Scene so it is immediately below another Scene in the Scenes list.
     *
     * This means it will render behind the other Scene.
     *
     * @method Phaser.Scenes.SceneManager#moveBelow
     * @since 3.2.0
     *
     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.
     * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */moveBelow:function(t,e){if(t===e)return this;if(this.isProcessing)this._queue.push({op:"moveBelow",keyA:t,keyB:e});else{var i=this.getIndex(t),n=this.getIndex(e);if(-1!==i&&-1!==n){var s=this.getAt(n);//  Remove
this.scenes.splice(n,1),0===i?this.scenes.unshift(s):this.scenes.splice(i,0,s)}}return this},/**
     * Queue a Scene operation for the next update.
     *
     * @method Phaser.Scenes.SceneManager#queueOp
     * @private
     * @since 3.0.0
     *
     * @param {string} op - The operation to perform.
     * @param {(string|Phaser.Scene)} keyA - Scene A.
     * @param {(any|string|Phaser.Scene)} [keyB] - Scene B, or a data object.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */queueOp:function(t,e,i){return this._queue.push({op:t,keyA:e,keyB:i}),this},/**
     * Swaps the positions of two Scenes in the Scenes list.
     *
     * @method Phaser.Scenes.SceneManager#swapPosition
     * @since 3.0.0
     *
     * @param {(string|Phaser.Scene)} keyA - The first Scene to swap.
     * @param {(string|Phaser.Scene)} keyB - The second Scene to swap.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */swapPosition:function(t,e){if(t===e)return this;if(this.isProcessing)this._queue.push({op:"swapPosition",keyA:t,keyB:e});else{var i=this.getIndex(t),n=this.getIndex(e);if(i!==n&&-1!==i&&-1!==n){var s=this.getAt(i);this.scenes[i]=this.scenes[n],this.scenes[n]=s}}return this},/**
     * Dumps debug information about each Scene to the developer console.
     *
     * @method Phaser.Scenes.SceneManager#dump
     * @since 3.2.0
     */dump:function(){for(var t=[],e=["pending","init","start","loading","creating","running","paused","sleeping","shutdown","destroyed"],i=0;i<this.scenes.length;i++){var s=this.scenes[i].sys,r=s.settings.visible&&(s.settings.status===n.RUNNING||s.settings.status===n.PAUSED)?"[*] ":"[-] ";r+=s.settings.key+" ("+e[s.settings.status]+")",t.push(r)}console.log(t.join("\n"))},/**
     * Destroy the SceneManager and all of its Scene's systems.
     *
     * @method Phaser.Scenes.SceneManager#destroy
     * @since 3.0.0
     */destroy:function(){for(var t=0;t<this.scenes.length;t++)this.scenes[t].sys.destroy();this.update=l,this.scenes=[],this._pending=[],this._start=[],this._queue=[],this.game=null}});t.exports=d}),r("anFCw",function(t,e){t.exports={/**
     * Scene state.
     * 
     * @name Phaser.Scenes.PENDING
     * @readonly
     * @type {integer}
     * @since 3.0.0
     */PENDING:0,/**
     * Scene state.
     * 
     * @name Phaser.Scenes.INIT
     * @readonly
     * @type {integer}
     * @since 3.0.0
     */INIT:1,/**
     * Scene state.
     * 
     * @name Phaser.Scenes.START
     * @readonly
     * @type {integer}
     * @since 3.0.0
     */START:2,/**
     * Scene state.
     * 
     * @name Phaser.Scenes.LOADING
     * @readonly
     * @type {integer}
     * @since 3.0.0
     */LOADING:3,/**
     * Scene state.
     * 
     * @name Phaser.Scenes.CREATING
     * @readonly
     * @type {integer}
     * @since 3.0.0
     */CREATING:4,/**
     * Scene state.
     * 
     * @name Phaser.Scenes.RUNNING
     * @readonly
     * @type {integer}
     * @since 3.0.0
     */RUNNING:5,/**
     * Scene state.
     * 
     * @name Phaser.Scenes.PAUSED
     * @readonly
     * @type {integer}
     * @since 3.0.0
     */PAUSED:6,/**
     * Scene state.
     * 
     * @name Phaser.Scenes.SLEEPING
     * @readonly
     * @type {integer}
     * @since 3.0.0
     */SLEEPING:7,/**
     * Scene state.
     * 
     * @name Phaser.Scenes.SHUTDOWN
     * @readonly
     * @type {integer}
     * @since 3.0.0
     */SHUTDOWN:8,/**
     * Scene state.
     * 
     * @name Phaser.Scenes.DESTROYED
     * @readonly
     * @type {integer}
     * @since 3.0.0
     */DESTROYED:9}}),r("ls69h",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Loader.Events
 */t.exports={ADD:s("4gfRD"),COMPLETE:s("i1ZcM"),FILE_COMPLETE:s("6PHQY"),FILE_KEY_COMPLETE:s("eplKm"),FILE_LOAD_ERROR:s("dQA3F"),FILE_LOAD:s("FkPeg"),FILE_PROGRESS:s("ehiNc"),POST_PROCESS:s("9OSOB"),PROGRESS:s("4hDiu"),START:s("iJYBJ")}}),r("4gfRD",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Loader Plugin Add File Event.
 * 
 * This event is dispatched when a new file is successfully added to the Loader and placed into the load queue.
 * 
 * Listen to it from a Scene using: `this.load.on('addfile', listener)`.
 * 
 * If you add lots of files to a Loader from a `preload` method, it will dispatch this event for each one of them.
 *
 * @event Phaser.Loader.Events#ADD
 * @since 3.0.0
 * 
 * @param {string} key - The unique key of the file that was added to the Loader.
 * @param {string} type - The [file type]{@link Phaser.Loader.File#type} string of the file that was added to the Loader, i.e. `image`.
 * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.
 * @param {Phaser.Loader.File} file - A reference to the File which was added to the Loader.
 */t.exports="addfile"}),r("i1ZcM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Loader Plugin Complete Event.
 * 
 * This event is dispatched when the Loader has fully processed everything in the load queue.
 * By this point every loaded file will now be in its associated cache and ready for use.
 * 
 * Listen to it from a Scene using: `this.load.on('complete', listener)`.
 *
 * @event Phaser.Loader.Events#COMPLETE
 * @since 3.0.0
 * 
 * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.
 * @param {integer} totalComplete - The total number of files that successfully loaded.
 * @param {integer} totalFailed - The total number of files that failed to load.
 */t.exports="complete"}),r("6PHQY",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The File Load Complete Event.
 * 
 * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.
 * 
 * Listen to it from a Scene using: `this.load.on('filecomplete', listener)`.
 * 
 * You can also listen for the completion of a specific file. See the [FILE_KEY_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_KEY_COMPLETE} event.
 *
 * @event Phaser.Loader.Events#FILE_COMPLETE
 * @since 3.0.0
 * 
 * @param {string} key - The key of the file that just loaded and finished processing.
 * @param {string} type - The [file type]{@link Phaser.Loader.File#type} of the file that just loaded, i.e. `image`.
 * @param {any} data - The raw data the file contained.
 */t.exports="filecomplete"}),r("eplKm",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The File Load Complete Event.
 * 
 * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.
 * 
 * It uses a special dynamic event name constructed from the key and type of the file.
 * 
 * For example, if you have loaded an `image` with a key of `monster`, you can listen for it
 * using the following:
 *
 * ```javascript
 * this.load.on('filecomplete-image-monster', function (key, type, data) {
 *     // Your handler code
 * });
 * ```
 *
 * Or, if you have loaded a texture `atlas` with a key of `Level1`:
 * 
 * ```javascript
 * this.load.on('filecomplete-atlas-Level1', function (key, type, data) {
 *     // Your handler code
 * });
 * ```
 * 
 * Or, if you have loaded a sprite sheet with a key of `Explosion` and a prefix of `GAMEOVER`:
 * 
 * ```javascript
 * this.load.on('filecomplete-spritesheet-GAMEOVERExplosion', function (key, type, data) {
 *     // Your handler code
 * });
 * ```
 * 
 * You can also listen for the generic completion of files. See the [FILE_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_COMPLETE} event.
 *
 * @event Phaser.Loader.Events#FILE_KEY_COMPLETE
 * @since 3.0.0
 * 
 * @param {string} key - The key of the file that just loaded and finished processing.
 * @param {string} type - The [file type]{@link Phaser.Loader.File#type} of the file that just loaded, i.e. `image`.
 * @param {any} data - The raw data the file contained.
 */t.exports="filecomplete-"}),r("dQA3F",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The File Load Error Event.
 * 
 * This event is dispatched by the Loader Plugin when a file fails to load.
 * 
 * Listen to it from a Scene using: `this.load.on('loaderror', listener)`.
 *
 * @event Phaser.Loader.Events#FILE_LOAD_ERROR
 * @since 3.0.0
 * 
 * @param {Phaser.Loader.File} file - A reference to the File which errored during load.
 */t.exports="loaderror"}),r("FkPeg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The File Load Event.
 * 
 * This event is dispatched by the Loader Plugin when a file finishes loading,
 * but _before_ it is processed and added to the internal Phaser caches.
 * 
 * Listen to it from a Scene using: `this.load.on('load', listener)`.
 *
 * @event Phaser.Loader.Events#FILE_LOAD
 * @since 3.0.0
 * 
 * @param {Phaser.Loader.File} file - A reference to the File which just finished loading.
 */t.exports="load"}),r("ehiNc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The File Load Progress Event.
 * 
 * This event is dispatched by the Loader Plugin during the load of a file, if the browser receives a DOM ProgressEvent and
 * the `lengthComputable` event property is true. Depending on the size of the file and browser in use, this may, or may not happen.
 * 
 * Listen to it from a Scene using: `this.load.on('fileprogress', listener)`.
 *
 * @event Phaser.Loader.Events#FILE_PROGRESS
 * @since 3.0.0
 * 
 * @param {Phaser.Loader.File} file - A reference to the File which errored during load.
 * @param {number} percentComplete - A value between 0 and 1 indicating how 'complete' this file is.
 */t.exports="fileprogress"}),r("9OSOB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Loader Plugin Post Process Event.
 * 
 * This event is dispatched by the Loader Plugin when the Loader has finished loading everything in the load queue.
 * It is dispatched before the internal lists are cleared and each File is destroyed.
 * 
 * Use this hook to perform any last minute processing of files that can only happen once the
 * Loader has completed, but prior to it emitting the `complete` event.
 * 
 * Listen to it from a Scene using: `this.load.on('postprocess', listener)`.
 *
 * @event Phaser.Loader.Events#POST_PROCESS
 * @since 3.0.0
 * 
 * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.
 */t.exports="postprocess"}),r("4hDiu",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Loader Plugin Progress Event.
 * 
 * This event is dispatched when the Loader updates its load progress, typically as a result of a file having completed loading.
 * 
 * Listen to it from a Scene using: `this.load.on('progress', listener)`.
 *
 * @event Phaser.Loader.Events#PROGRESS
 * @since 3.0.0
 * 
 * @param {number} progress - The current progress of the load. A value between 0 and 1.
 */t.exports="progress"}),r("iJYBJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Loader Plugin Start Event.
 * 
 * This event is dispatched when the Loader starts running. At this point load progress is zero.
 * 
 * This event is dispatched even if there aren't any files in the load queue.
 * 
 * Listen to it from a Scene using: `this.load.on('start', listener)`.
 *
 * @event Phaser.Loader.Events#START
 * @since 3.0.0
 * 
 * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.
 */t.exports="start"}),r("iXVlb",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jgSN1"),r=new i({initialize:function(t){/**
         * The Scene Systems. You must never overwrite this property, or all hell will break lose.
         *
         * @name Phaser.Scene#sys
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.sys=new n(this,t),/**
         * A reference to the Phaser.Game instance.
         * This property will only be available if defined in the Scene Injection Map.
         *
         * @name Phaser.Scene#game
         * @type {Phaser.Game}
         * @since 3.0.0
         */this.game,/**
         * A reference to the global Animation Manager.
         * This property will only be available if defined in the Scene Injection Map.
         *
         * @name Phaser.Scene#anims
         * @type {Phaser.Animations.AnimationManager}
         * @since 3.0.0
         */this.anims,/**
         * A reference to the global Cache.
         * This property will only be available if defined in the Scene Injection Map.
         *
         * @name Phaser.Scene#cache
         * @type {Phaser.Cache.CacheManager}
         * @since 3.0.0
         */this.cache,/**
         * A reference to the game level Data Manager.
         * This property will only be available if defined in the Scene Injection Map.
         *
         * @name Phaser.Scene#registry
         * @type {Phaser.Data.DataManager}
         * @since 3.0.0
         */this.registry,/**
         * A reference to the Sound Manager.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         *
         * @name Phaser.Scene#sound
         * @type {Phaser.Sound.BaseSoundManager}
         * @since 3.0.0
         */this.sound,/**
         * A reference to the Texture Manager.
         * This property will only be available if defined in the Scene Injection Map.
         *
         * @name Phaser.Scene#textures
         * @type {Phaser.Textures.TextureManager}
         * @since 3.0.0
         */this.textures,/**
         * A scene level Event Emitter.
         * This property will only be available if defined in the Scene Injection Map.
         *
         * @name Phaser.Scene#events
         * @type {Phaser.Events.EventEmitter}
         * @since 3.0.0
         */this.events,/**
         * A scene level Camera System.
         * This property will only be available if defined in the Scene Injection Map.
         *
         * @name Phaser.Scene#cameras
         * @type {Phaser.Cameras.Scene2D.CameraManager}
         * @since 3.0.0
         */this.cameras,/**
         * A scene level Game Object Factory.
         * This property will only be available if defined in the Scene Injection Map.
         *
         * @name Phaser.Scene#add
         * @type {Phaser.GameObjects.GameObjectFactory}
         * @since 3.0.0
         */this.add,/**
         * A scene level Game Object Creator.
         * This property will only be available if defined in the Scene Injection Map.
         *
         * @name Phaser.Scene#make
         * @type {Phaser.GameObjects.GameObjectCreator}
         * @since 3.0.0
         */this.make,/**
         * A reference to the Scene Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map.
         *
         * @name Phaser.Scene#scene
         * @type {Phaser.Scenes.ScenePlugin}
         * @since 3.0.0
         */this.scene,/**
         * A scene level Game Object Display List.
         * This property will only be available if defined in the Scene Injection Map.
         *
         * @name Phaser.Scene#children
         * @type {Phaser.GameObjects.DisplayList}
         * @since 3.0.0
         */this.children,/**
         * A scene level Lights Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         *
         * @name Phaser.Scene#lights
         * @type {Phaser.GameObjects.LightsManager}
         * @since 3.0.0
         */this.lights,/**
         * A scene level Data Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         *
         * @name Phaser.Scene#data
         * @type {Phaser.Data.DataManager}
         * @since 3.0.0
         */this.data,/**
         * A scene level Input Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         *
         * @name Phaser.Scene#input
         * @type {Phaser.Input.InputPlugin}
         * @since 3.0.0
         */this.input,/**
         * A scene level Loader Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         *
         * @name Phaser.Scene#load
         * @type {Phaser.Loader.LoaderPlugin}
         * @since 3.0.0
         */this.load,/**
         * A scene level Time and Clock Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         *
         * @name Phaser.Scene#time
         * @type {Phaser.Time.Clock}
         * @since 3.0.0
         */this.time,/**
         * A scene level Tween Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         *
         * @name Phaser.Scene#tweens
         * @type {Phaser.Tweens.TweenManager}
         * @since 3.0.0
         */this.tweens,/**
         * A scene level Arcade Physics Plugin.
         * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.
         *
         * @name Phaser.Scene#physics
         * @type {Phaser.Physics.Arcade.ArcadePhysics}
         * @since 3.0.0
         */this.physics,/**
         * A scene level Matter Physics Plugin.
         * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.
         *
         * @name Phaser.Scene#matter
         * @type {Phaser.Physics.Matter.MatterPhysics}
         * @since 3.0.0
         */this.matter,/**
             * A scene level Facebook Instant Games Plugin.
             * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.
             *
             * @name Phaser.Scene#facebook
             * @type {Phaser.FacebookInstantGamesPlugin}
             * @since 3.12.0
             */this.facebook,/**
         * A reference to the global Scale Manager.
         * This property will only be available if defined in the Scene Injection Map.
         *
         * @name Phaser.Scene#scale
         * @type {Phaser.Scale.ScaleManager}
         * @since 3.16.2
         */this.scale,/**
         * A reference to the Plugin Manager.
         *
         * The Plugin Manager is a global system that allows plugins to register themselves with it, and can then install
         * those plugins into Scenes as required.
         *
         * @name Phaser.Scene#plugins
         * @type {Phaser.Plugins.PluginManager}
         * @since 3.0.0
         */this.plugins},/**
     * Should be overridden by your own Scenes.
     * This method is called once per game step while the scene is running.
     *
     * @method Phaser.Scene#update
     * @since 3.0.0
     *
     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     */update:function(){}});t.exports=r}),r("jgSN1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("anFCw"),r=s("488fh"),o=s("4rtgc"),a=s("dXsU1"),h=s("hq9AL"),l=s("13GYA"),u=s("i9d1I"),c=new i({initialize:function(t,e){/**
         * A reference to the Scene that these Systems belong to.
         *
         * @name Phaser.Scenes.Systems#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * A reference to the Phaser Game instance.
         *
         * @name Phaser.Scenes.Systems#game
         * @type {Phaser.Game}
         * @since 3.0.0
         */this.game,/**
         * A reference to either the Canvas or WebGL Renderer that this Game is using.
         *
         * @name Phaser.Scenes.Systems#renderer
         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}
         * @since 3.17.0
         */this.renderer,/**
             * The Facebook Instant Games Plugin.
             *
             * @name Phaser.Scenes.Systems#facebook
             * @type {Phaser.FacebookInstantGamesPlugin}
             * @since 3.12.0
             */this.facebook,/**
         * The Scene Configuration object, as passed in when creating the Scene.
         *
         * @name Phaser.Scenes.Systems#config
         * @type {(string|Phaser.Types.Scenes.SettingsConfig)}
         * @since 3.0.0
         */this.config=e,/**
         * The Scene Settings. This is the parsed output based on the Scene configuration.
         *
         * @name Phaser.Scenes.Systems#settings
         * @type {Phaser.Types.Scenes.SettingsObject}
         * @since 3.0.0
         */this.settings=u.create(e),/**
         * A handy reference to the Scene canvas / context.
         *
         * @name Phaser.Scenes.Systems#canvas
         * @type {HTMLCanvasElement}
         * @since 3.0.0
         */this.canvas,/**
         * A reference to the Canvas Rendering Context being used by the renderer.
         *
         * @name Phaser.Scenes.Systems#context
         * @type {CanvasRenderingContext2D}
         * @since 3.0.0
         */this.context,//  Global Systems - these are single-instance global managers that belong to Game
/**
         * A reference to the global Animations Manager.
         *
         * In the default set-up you can access this from within a Scene via the `this.anims` property.
         *
         * @name Phaser.Scenes.Systems#anims
         * @type {Phaser.Animations.AnimationManager}
         * @since 3.0.0
         */this.anims,/**
         * A reference to the global Cache. The Cache stores all files bought in to Phaser via
         * the Loader, with the exception of images. Images are stored in the Texture Manager.
         *
         * In the default set-up you can access this from within a Scene via the `this.cache` property.
         *
         * @name Phaser.Scenes.Systems#cache
         * @type {Phaser.Cache.CacheManager}
         * @since 3.0.0
         */this.cache,/**
         * A reference to the global Plugins Manager.
         *
         * In the default set-up you can access this from within a Scene via the `this.plugins` property.
         *
         * @name Phaser.Scenes.Systems#plugins
         * @type {Phaser.Plugins.PluginManager}
         * @since 3.0.0
         */this.plugins,/**
         * A reference to the global registry. This is a game-wide instance of the Data Manager, allowing
         * you to exchange data between Scenes via a universal and shared point.
         *
         * In the default set-up you can access this from within a Scene via the `this.registry` property.
         *
         * @name Phaser.Scenes.Systems#registry
         * @type {Phaser.Data.DataManager}
         * @since 3.0.0
         */this.registry,/**
         * A reference to the global Scale Manager.
         *
         * In the default set-up you can access this from within a Scene via the `this.scale` property.
         *
         * @name Phaser.Scenes.Systems#scale
         * @type {Phaser.Scale.ScaleManager}
         * @since 3.15.0
         */this.scale,/**
         * A reference to the global Sound Manager.
         *
         * In the default set-up you can access this from within a Scene via the `this.sound` property.
         *
         * @name Phaser.Scenes.Systems#sound
         * @type {(Phaser.Sound.NoAudioSoundManager|Phaser.Sound.HTML5AudioSoundManager|Phaser.Sound.WebAudioSoundManager)}
         * @since 3.0.0
         */this.sound,/**
         * A reference to the global Texture Manager.
         *
         * In the default set-up you can access this from within a Scene via the `this.textures` property.
         *
         * @name Phaser.Scenes.Systems#textures
         * @type {Phaser.Textures.TextureManager}
         * @since 3.0.0
         */this.textures,//  Core Plugins - these are non-optional Scene plugins, needed by lots of the other systems
/**
         * A reference to the Scene's Game Object Factory.
         *
         * Use this to quickly and easily create new Game Object's.
         *
         * In the default set-up you can access this from within a Scene via the `this.add` property.
         *
         * @name Phaser.Scenes.Systems#add
         * @type {Phaser.GameObjects.GameObjectFactory}
         * @since 3.0.0
         */this.add,/**
         * A reference to the Scene's Camera Manager.
         *
         * Use this to manipulate and create Cameras for this specific Scene.
         *
         * In the default set-up you can access this from within a Scene via the `this.cameras` property.
         *
         * @name Phaser.Scenes.Systems#cameras
         * @type {Phaser.Cameras.Scene2D.CameraManager}
         * @since 3.0.0
         */this.cameras,/**
         * A reference to the Scene's Display List.
         *
         * Use this to organize the children contained in the display list.
         *
         * In the default set-up you can access this from within a Scene via the `this.children` property.
         *
         * @name Phaser.Scenes.Systems#displayList
         * @type {Phaser.GameObjects.DisplayList}
         * @since 3.0.0
         */this.displayList,/**
         * A reference to the Scene's Event Manager.
         *
         * Use this to listen for Scene specific events, such as `pause` and `shutdown`.
         *
         * In the default set-up you can access this from within a Scene via the `this.events` property.
         *
         * @name Phaser.Scenes.Systems#events
         * @type {Phaser.Events.EventEmitter}
         * @since 3.0.0
         */this.events,/**
         * A reference to the Scene's Game Object Creator.
         *
         * Use this to quickly and easily create new Game Object's. The difference between this and the
         * Game Object Factory, is that the Creator just creates and returns Game Object instances, it
         * doesn't then add them to the Display List or Update List.
         *
         * In the default set-up you can access this from within a Scene via the `this.make` property.
         *
         * @name Phaser.Scenes.Systems#make
         * @type {Phaser.GameObjects.GameObjectCreator}
         * @since 3.0.0
         */this.make,/**
         * A reference to the Scene Manager Plugin.
         *
         * Use this to manipulate both this and other Scene's in your game, for example to launch a parallel Scene,
         * or pause or resume a Scene, or switch from this Scene to another.
         *
         * In the default set-up you can access this from within a Scene via the `this.scene` property.
         *
         * @name Phaser.Scenes.Systems#scenePlugin
         * @type {Phaser.Scenes.ScenePlugin}
         * @since 3.0.0
         */this.scenePlugin,/**
         * A reference to the Scene's Update List.
         *
         * Use this to organize the children contained in the update list.
         *
         * The Update List is responsible for managing children that need their `preUpdate` methods called,
         * in order to process so internal components, such as Sprites with Animations.
         *
         * In the default set-up there is no reference to this from within the Scene itself.
         *
         * @name Phaser.Scenes.Systems#updateList
         * @type {Phaser.GameObjects.UpdateList}
         * @since 3.0.0
         */this.updateList,/**
         * The Scene Update function.
         *
         * This starts out as NOOP during init, preload and create, and at the end of create
         * it swaps to be whatever the Scene.update function is.
         *
         * @name Phaser.Scenes.Systems#sceneUpdate
         * @type {function}
         * @private
         * @since 3.10.0
         */this.sceneUpdate=l},/**
     * This method is called only once by the Scene Manager when the Scene is instantiated.
     * It is responsible for setting up all of the Scene plugins and references.
     * It should never be called directly.
     *
     * @method Phaser.Scenes.Systems#init
     * @protected
     * @fires Phaser.Scenes.Events#BOOT
     * @since 3.0.0
     *
     * @param {Phaser.Game} game - A reference to the Phaser Game instance.
     */init:function(t){this.settings.status=n.INIT,//  This will get replaced by the SceneManager with the actual update function, if it exists, once create is over.
this.sceneUpdate=l,this.game=t,this.renderer=t.renderer,this.canvas=t.canvas,this.context=t.context;var e=t.plugins;this.plugins=e,e.addToScene(this,r.Global,[r.CoreScene,h(this),a(this)]),this.events.emit(o.BOOT,this),this.settings.isBooted=!0},/**
     * Called by a plugin, it tells the System to install the plugin locally.
     *
     * @method Phaser.Scenes.Systems#install
     * @private
     * @since 3.0.0
     *
     * @param {array} plugin - An array of plugins to install into this Scene.
     */install:function(t){Array.isArray(t)||(t=[t]),this.plugins.installLocal(this,t)},/**
     * A single game step. Called automatically by the Scene Manager as a result of a Request Animation
     * Frame or Set Timeout call to the main Game instance.
     *
     * @method Phaser.Scenes.Systems#step
     * @fires Phaser.Scenes.Events#PRE_UPDATE
     * @fires Phaser.Scenes.Events#UPDATE
     * @fires Phaser.Scenes.Events#POST_UPDATE
     * @since 3.0.0
     *
     * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().
     * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.
     */step:function(t,e){this.events.emit(o.PRE_UPDATE,t,e),this.events.emit(o.UPDATE,t,e),this.sceneUpdate.call(this.scene,t,e),this.events.emit(o.POST_UPDATE,t,e)},/**
     * Called automatically by the Scene Manager.
     * Instructs the Scene to render itself via its Camera Manager to the renderer given.
     *
     * @method Phaser.Scenes.Systems#render
     * @fires Phaser.Scenes.Events#RENDER
     * @since 3.0.0
     *
     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer that invoked the render call.
     */render:function(t){var e=this.displayList;e.depthSort(),this.cameras.render(t,e),this.events.emit(o.RENDER,t)},/**
     * Force a sort of the display list on the next render.
     *
     * @method Phaser.Scenes.Systems#queueDepthSort
     * @since 3.0.0
     */queueDepthSort:function(){this.displayList.queueDepthSort()},/**
     * Immediately sorts the display list if the flag is set.
     *
     * @method Phaser.Scenes.Systems#depthSort
     * @since 3.0.0
     */depthSort:function(){this.displayList.depthSort()},/**
     * Pause this Scene.
     * A paused Scene still renders, it just doesn't run ANY of its update handlers or systems.
     *
     * @method Phaser.Scenes.Systems#pause
     * @fires Phaser.Scenes.Events#PAUSE
     * @since 3.0.0
     *
     * @param {object} [data] - A data object that will be passed in the 'pause' event.
     *
     * @return {Phaser.Scenes.Systems} This Systems object.
     */pause:function(t){return this.settings.active&&(this.settings.status=n.PAUSED,this.settings.active=!1,this.events.emit(o.PAUSE,this,t)),this},/**
     * Resume this Scene from a paused state.
     *
     * @method Phaser.Scenes.Systems#resume
     * @fires Phaser.Scenes.Events#RESUME
     * @since 3.0.0
     *
     * @param {object} [data] - A data object that will be passed in the 'resume' event.
     *
     * @return {Phaser.Scenes.Systems} This Systems object.
     */resume:function(t){return this.settings.active||(this.settings.status=n.RUNNING,this.settings.active=!0,this.events.emit(o.RESUME,this,t)),this},/**
     * Send this Scene to sleep.
     *
     * A sleeping Scene doesn't run its update step or render anything, but it also isn't shut down
     * or has any of its systems or children removed, meaning it can be re-activated at any point and
     * will carry on from where it left off. It also keeps everything in memory and events and callbacks
     * from other Scenes may still invoke changes within it, so be careful what is left active.
     *
     * @method Phaser.Scenes.Systems#sleep
     * @fires Phaser.Scenes.Events#SLEEP
     * @since 3.0.0
     *
     * @param {object} [data] - A data object that will be passed in the 'sleep' event.
     *
     * @return {Phaser.Scenes.Systems} This Systems object.
     */sleep:function(t){return this.settings.status=n.SLEEPING,this.settings.active=!1,this.settings.visible=!1,this.events.emit(o.SLEEP,this,t),this},/**
     * Wake-up this Scene if it was previously asleep.
     *
     * @method Phaser.Scenes.Systems#wake
     * @fires Phaser.Scenes.Events#WAKE
     * @since 3.0.0
     *
     * @param {object} [data] - A data object that will be passed in the 'wake' event.
     *
     * @return {Phaser.Scenes.Systems} This Systems object.
     */wake:function(t){var e=this.settings;return e.status=n.RUNNING,e.active=!0,e.visible=!0,this.events.emit(o.WAKE,this,t),e.isTransition&&this.events.emit(o.TRANSITION_WAKE,e.transitionFrom,e.transitionDuration),this},/**
     * Returns any data that was sent to this Scene by another Scene.
     *
     * The data is also passed to `Scene.init` and in various Scene events, but
     * you can access it at any point via this method.
     *
     * @method Phaser.Scenes.Systems#getData
     * @since 3.22.0
     *
     * @return {any}
     */getData:function(){return this.settings.data},/**
     * Is this Scene sleeping?
     *
     * @method Phaser.Scenes.Systems#isSleeping
     * @since 3.0.0
     *
     * @return {boolean} `true` if this Scene is asleep, otherwise `false`.
     */isSleeping:function(){return this.settings.status===n.SLEEPING},/**
     * Is this Scene running?
     *
     * @method Phaser.Scenes.Systems#isActive
     * @since 3.0.0
     *
     * @return {boolean} `true` if this Scene is running, otherwise `false`.
     */isActive:function(){return this.settings.status===n.RUNNING},/**
     * Is this Scene paused?
     *
     * @method Phaser.Scenes.Systems#isPaused
     * @since 3.13.0
     *
     * @return {boolean} `true` if this Scene is paused, otherwise `false`.
     */isPaused:function(){return this.settings.status===n.PAUSED},/**
     * Is this Scene currently transitioning out to, or in from another Scene?
     *
     * @method Phaser.Scenes.Systems#isTransitioning
     * @since 3.5.0
     *
     * @return {boolean} `true` if this Scene is currently transitioning, otherwise `false`.
     */isTransitioning:function(){return this.settings.isTransition||null!==this.scenePlugin._target},/**
     * Is this Scene currently transitioning out from itself to another Scene?
     *
     * @method Phaser.Scenes.Systems#isTransitionOut
     * @since 3.5.0
     *
     * @return {boolean} `true` if this Scene is in transition to another Scene, otherwise `false`.
     */isTransitionOut:function(){return null!==this.scenePlugin._target&&this.scenePlugin._duration>0},/**
     * Is this Scene currently transitioning in from another Scene?
     *
     * @method Phaser.Scenes.Systems#isTransitionIn
     * @since 3.5.0
     *
     * @return {boolean} `true` if this Scene is transitioning in from another Scene, otherwise `false`.
     */isTransitionIn:function(){return this.settings.isTransition},/**
     * Is this Scene visible and rendering?
     *
     * @method Phaser.Scenes.Systems#isVisible
     * @since 3.0.0
     *
     * @return {boolean} `true` if this Scene is visible, otherwise `false`.
     */isVisible:function(){return this.settings.visible},/**
     * Sets the visible state of this Scene.
     * An invisible Scene will not render, but will still process updates.
     *
     * @method Phaser.Scenes.Systems#setVisible
     * @since 3.0.0
     *
     * @param {boolean} value - `true` to render this Scene, otherwise `false`.
     *
     * @return {Phaser.Scenes.Systems} This Systems object.
     */setVisible:function(t){return this.settings.visible=t,this},/**
     * Set the active state of this Scene.
     *
     * An active Scene will run its core update loop.
     *
     * @method Phaser.Scenes.Systems#setActive
     * @since 3.0.0
     *
     * @param {boolean} value - If `true` the Scene will be resumed, if previously paused. If `false` it will be paused.
     * @param {object} [data] - A data object that will be passed in the 'resume' or 'pause' events.
     *
     * @return {Phaser.Scenes.Systems} This Systems object.
     */setActive:function(t,e){return t?this.resume(e):this.pause(e)},/**
     * Start this Scene running and rendering.
     * Called automatically by the SceneManager.
     *
     * @method Phaser.Scenes.Systems#start
     * @fires Phaser.Scenes.Events#START
     * @fires Phaser.Scenes.Events#READY
     * @since 3.0.0
     *
     * @param {object} data - Optional data object that may have been passed to this Scene from another.
     */start:function(t){t&&(this.settings.data=t),this.settings.status=n.START,this.settings.active=!0,this.settings.visible=!0,//  For plugins to listen out for
this.events.emit(o.START,this),//  For user-land code to listen out for
this.events.emit(o.READY,this,t)},/**
     * Shutdown this Scene and send a shutdown event to all of its systems.
     * A Scene that has been shutdown will not run its update loop or render, but it does
     * not destroy any of its plugins or references. It is put into hibernation for later use.
     * If you don't ever plan to use this Scene again, then it should be destroyed instead
     * to free-up resources.
     *
     * @method Phaser.Scenes.Systems#shutdown
     * @fires Phaser.Scenes.Events#SHUTDOWN
     * @since 3.0.0
     *
     * @param {object} [data] - A data object that will be passed in the 'shutdown' event.
     */shutdown:function(t){this.events.off(o.TRANSITION_INIT),this.events.off(o.TRANSITION_START),this.events.off(o.TRANSITION_COMPLETE),this.events.off(o.TRANSITION_OUT),this.settings.status=n.SHUTDOWN,this.settings.active=!1,this.settings.visible=!1,this.events.emit(o.SHUTDOWN,this,t)},/**
     * Destroy this Scene and send a destroy event all of its systems.
     * A destroyed Scene cannot be restarted.
     * You should not call this directly, instead use `SceneManager.remove`.
     *
     * @method Phaser.Scenes.Systems#destroy
     * @private
     * @fires Phaser.Scenes.Events#DESTROY
     * @since 3.0.0
     */destroy:function(){this.settings.status=n.DESTROYED,this.settings.active=!1,this.settings.visible=!1,this.events.emit(o.DESTROY,this),this.events.removeAllListeners();for(var t=["scene","game","anims","cache","plugins","registry","sound","textures","add","camera","displayList","events","make","scenePlugin","updateList"],e=0;e<t.length;e++)this[t[e]]=null}});t.exports=c}),r("dXsU1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7BSWl"),n=s("aEzMt");t.exports=function(t){var e=t.game.config.defaultPhysicsSystem,s=i(t.settings,"physics",!1);if(e||s){//  Let's build the systems array
var r=[];if(e&&r.push(n(e+"Physics")),s)for(var o in s)o=n(o.concat("Physics")),-1===r.indexOf(o)&&r.push(o);//  An array of Physics systems to start for this Scene
return r}}}),r("aEzMt",function(t,e){t.exports=function(t){return t&&t[0].toUpperCase()+t.slice(1)}}),r("hq9AL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7BSWl");t.exports=function(t){var e=t.plugins.getDefaultScenePlugins(),n=i(t.settings,"plugins",!1);return(//  Scene Plugins always override Default Plugins
Array.isArray(n)?n:e||[])}}),r("i9d1I",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("anFCw"),n=s("5pMDk"),r=s("awyQk"),o=s("2LV6U");t.exports={/**
     * Takes a Scene configuration object and returns a fully formed System Settings object.
     *
     * @function Phaser.Scenes.Settings.create
     * @since 3.0.0
     *
     * @param {(string|Phaser.Types.Scenes.SettingsConfig)} config - The Scene configuration object used to create this Scene Settings.
     *
     * @return {Phaser.Types.Scenes.SettingsObject} The Scene Settings object created as a result of the config and default settings.
     */create:function(t){return"string"==typeof t?t={key:t}:void 0===t&&(t={}),{status:i.PENDING,key:n(t,"key",""),active:n(t,"active",!1),visible:n(t,"visible",!0),isBooted:!1,isTransition:!1,transitionFrom:null,transitionDuration:0,transitionAllowInput:!0,//  Loader payload array
data:{},pack:n(t,"pack",!1),//  Cameras
cameras:n(t,"cameras",null),//  Scene Property Injection Map
map:n(t,"map",r(o,n(t,"mapAdd",{}))),//  Physics
physics:n(t,"physics",{}),//  Loader
loader:n(t,"loader",{}),//  Plugins
plugins:n(t,"plugins",!1),//  Input
input:n(t,"input",{})}}}}),r("awyQk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5pqmQ");t.exports=function(t,e){var n=i(t);for(var s in e)n.hasOwnProperty(s)||(n[s]=e[s]);return n}}),r("5pqmQ",function(t,e){t.exports=function(t){var e={};for(var i in t)Array.isArray(t[i])?e[i]=t[i].slice(0):e[i]=t[i];return e}}),r("2LV6U",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  These properties get injected into the Scene and map to local systems
//  The map value is the property that is injected into the Scene, the key is the Scene.Systems reference.
//  These defaults can be modified via the Scene config object
//          var config = {
//            map: {
//                add: 'makeStuff',
//                load: 'loader'
//            }
//        };
var i={game:"game",anims:"anims",cache:"cache",plugins:"plugins",registry:"registry",scale:"scale",sound:"sound",textures:"textures",events:"events",cameras:"cameras",add:"add",make:"make",scenePlugin:"scene",displayList:"children",lights:"lights",data:"data",input:"input",load:"load",time:"time",tweens:"tweens",arcadePhysics:"physics",impactPhysics:"impact",matterPhysics:"matter"};i.cameras3d="cameras3d",i.facebook="facebook",t.exports=i}),r("5QcEl",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kKoer"),n=s("demvd"),r=s("jwj1g"),o=s("pqNJR"),a=s("bRAqZ"),h=s("3vRz3"),l=s("6R4Pe"),u=s("aqcI1"),c=s("gRl5V"),d=s("5pMDk"),f=s("jx0HO"),p=s("cCQL0"),g=new r({Extends:h,initialize:function(t){h.call(this),/**
         * The Game that this TextureManager belongs to.
         *
         * @name Phaser.Textures.TextureManager#game
         * @type {Phaser.Game}
         * @since 3.0.0
         */this.game=t,/**
         * The name of this manager.
         *
         * @name Phaser.Textures.TextureManager#name
         * @type {string}
         * @since 3.0.0
         */this.name="TextureManager",/**
         * An object that has all of textures that Texture Manager creates.
         * Textures are assigned to keys so we can access to any texture that this object has directly by key value without iteration.
         *
         * @name Phaser.Textures.TextureManager#list
         * @type {object}
         * @default {}
         * @since 3.0.0
         */this.list={},/**
         * The temporary canvas element to save an pixel data of an arbitrary texture in getPixel() and getPixelAlpha() method.
         *
         * @name Phaser.Textures.TextureManager#_tempCanvas
         * @type {HTMLCanvasElement}
         * @private
         * @since 3.0.0
         */this._tempCanvas=i.create2D(this,1,1),/**
         * The context of the temporary canvas element made to save an pixel data in getPixel() and getPixelAlpha() method.
         *
         * @name Phaser.Textures.TextureManager#_tempContext
         * @type {CanvasRenderingContext2D}
         * @private
         * @since 3.0.0
         */this._tempContext=this._tempCanvas.getContext("2d"),/**
         * An counting value used for emitting 'ready' event after all of managers in game is loaded.
         *
         * @name Phaser.Textures.TextureManager#_pending
         * @type {integer}
         * @private
         * @default 0
         * @since 3.0.0
         */this._pending=0,t.events.once(u.BOOT,this.boot,this)},/**
     * The Boot Handler called by Phaser.Game when it first starts up.
     *
     * @method Phaser.Textures.TextureManager#boot
     * @private
     * @since 3.0.0
     */boot:function(){this._pending=2,this.on(l.LOAD,this.updatePending,this),this.on(l.ERROR,this.updatePending,this),this.addBase64("__DEFAULT",this.game.config.defaultImage),this.addBase64("__MISSING",this.game.config.missingImage),this.game.events.once(u.DESTROY,this.destroy,this)},/**
     * After 'onload' or 'onerror' invoked twice, emit 'ready' event.
     *
     * @method Phaser.Textures.TextureManager#updatePending
     * @private
     * @since 3.0.0
     */updatePending:function(){this._pending--,0===this._pending&&(this.off(l.LOAD),this.off(l.ERROR),this.emit(l.READY))},/**
     * Checks the given texture key and throws a console.warn if the key is already in use, then returns false.
     * If you wish to avoid the console.warn then use `TextureManager.exists` instead.
     *
     * @method Phaser.Textures.TextureManager#checkKey
     * @since 3.7.0
     *
     * @param {string} key - The texture key to check.
     *
     * @return {boolean} `true` if it's safe to use the texture key, otherwise `false`.
     */checkKey:function(t){return!this.exists(t)||(// eslint-disable-next-line no-console
console.error("Texture key already in use: "+t),!1)},/**
     * Removes a Texture from the Texture Manager and destroys it. This will immediately
     * clear all references to it from the Texture Manager, and if it has one, destroy its
     * WebGLTexture. This will emit a `removetexture` event.
     *
     * Note: If you have any Game Objects still using this texture they will start throwing
     * errors the next time they try to render. Make sure that removing the texture is the final
     * step when clearing down to avoid this.
     *
     * @method Phaser.Textures.TextureManager#remove
     * @fires Phaser.Textures.Events#REMOVE
     * @since 3.7.0
     *
     * @param {(string|Phaser.Textures.Texture)} key - The key of the Texture to remove, or a reference to it.
     *
     * @return {Phaser.Textures.TextureManager} The Texture Manager.
     */remove:function(t){if("string"==typeof t){if(!this.exists(t))return console.warn("No texture found matching key: "+t),this;t=this.get(t)}return this.list.hasOwnProperty(t.key)&&(t.destroy(),this.emit(l.REMOVE,t.key)),this},/**
     * Removes a key from the Texture Manager but does not destroy the Texture that was using the key.
     *
     * @method Phaser.Textures.TextureManager#removeKey
     * @since 3.17.0
     *
     * @param {string} key - The key to remove from the texture list.
     *
     * @return {Phaser.Textures.TextureManager} The Texture Manager.
     */removeKey:function(t){return this.list.hasOwnProperty(t)&&delete this.list[t],this},/**
     * Adds a new Texture to the Texture Manager created from the given Base64 encoded data.
     *
     * @method Phaser.Textures.TextureManager#addBase64
     * @fires Phaser.Textures.Events#ADD
     * @fires Phaser.Textures.Events#ERROR
     * @fires Phaser.Textures.Events#LOAD
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {*} data - The Base64 encoded data.
     * 
     * @return {this} This Texture Manager instance.
     */addBase64:function(t,e){if(this.checkKey(t)){var i=this,n=new Image;n.onerror=function(){i.emit(l.ERROR,t)},n.onload=function(){var e=i.create(t,n);f.Image(e,0),i.emit(l.ADD,t,e),i.emit(l.LOAD,t,e)},n.src=e}return this},/**
     * Gets an existing texture frame and converts it into a base64 encoded image and returns the base64 data.
     * 
     * You can also provide the image type and encoder options.
     * 
     * This will only work with bitmap based texture frames, such as those created from Texture Atlases.
     * It will not work with GL Texture objects, such as Shaders, or Render Textures. For those please
     * see the WebGL Snapshot function instead.
     *
     * @method Phaser.Textures.TextureManager#getBase64
     * @since 3.12.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {(string|integer)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.
     * @param {string} [type='image/png'] - A DOMString indicating the image format. The default format type is image/png.
     * @param {number} [encoderOptions=0.92] - A Number between 0 and 1 indicating the image quality to use for image formats that use lossy compression such as image/jpeg and image/webp. If this argument is anything else, the default value for image quality is used. The default value is 0.92. Other arguments are ignored.
     * 
     * @return {string} The base64 encoded data, or an empty string if the texture frame could not be found.
     */getBase64:function(t,e,n,s){void 0===n&&(n="image/png"),void 0===s&&(s=.92);var r="",o=this.getFrame(t,e);if(o&&(o.source.isRenderTexture||o.source.isGLTexture))console.warn("Cannot getBase64 from WebGL Texture");else if(o){var a=o.canvasData,h=i.create2D(this,a.width,a.height);h.getContext("2d").drawImage(o.source.image,a.x,a.y,a.width,a.height,0,0,a.width,a.height),r=h.toDataURL(n,s),i.remove(h)}return r},/**
     * Adds a new Texture to the Texture Manager created from the given Image element.
     *
     * @method Phaser.Textures.TextureManager#addImage
     * @fires Phaser.Textures.Events#ADD
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {HTMLImageElement} source - The source Image element.
     * @param {HTMLImageElement|HTMLCanvasElement} [dataSource] - An optional data Image element.
     *
     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.
     */addImage:function(t,e,i){var n=null;return this.checkKey(t)&&(n=this.create(t,e),f.Image(n,0),i&&n.setDataSource(i),this.emit(l.ADD,t,n)),n},/**
     * Takes a WebGL Texture and creates a Phaser Texture from it, which is added to the Texture Manager using the given key.
     * 
     * This allows you to then use the Texture as a normal texture for texture based Game Objects like Sprites.
     * 
     * This is a WebGL only feature.
     *
     * @method Phaser.Textures.TextureManager#addGLTexture
     * @fires Phaser.Textures.Events#ADD
     * @since 3.19.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {WebGLTexture} glTexture - The source Render Texture.
     * @param {number} width - The new width of the Texture.
     * @param {number} height - The new height of the Texture.
     *
     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.
     */addGLTexture:function(t,e,i,n){var s=null;return this.checkKey(t)&&((s=this.create(t,e,i,n)).add("__BASE",0,0,0,i,n),this.emit(l.ADD,t,s)),s},/**
     * Adds a Render Texture to the Texture Manager using the given key.
     * This allows you to then use the Render Texture as a normal texture for texture based Game Objects like Sprites.
     *
     * @method Phaser.Textures.TextureManager#addRenderTexture
     * @fires Phaser.Textures.Events#ADD
     * @since 3.12.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {Phaser.GameObjects.RenderTexture} renderTexture - The source Render Texture.
     *
     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.
     */addRenderTexture:function(t,e){var i=null;return this.checkKey(t)&&((i=this.create(t,e)).add("__BASE",0,0,0,e.width,e.height),this.emit(l.ADD,t,i)),i},/**
     * Creates a new Texture using the given config values.
     * 
     * Generated textures consist of a Canvas element to which the texture data is drawn.
     * 
     * Generates a texture based on the given Create configuration object.
     * 
     * The texture is drawn using a fixed-size indexed palette of 16 colors, where the hex value in the
     * data cells map to a single color. For example, if the texture config looked like this:
     *
     * ```javascript
     * var star = [
     *   '.....828.....',
     *   '....72227....',
     *   '....82228....',
     *   '...7222227...',
     *   '2222222222222',
     *   '8222222222228',
     *   '.72222222227.',
     *   '..787777787..',
     *   '..877777778..',
     *   '.78778887787.',
     *   '.27887.78872.',
     *   '.787.....787.'
     * ];
     * 
     * this.textures.generate('star', { data: star, pixelWidth: 4 });
     * ```
     * 
     * Then it would generate a texture that is 52 x 48 pixels in size, because each cell of the data array
     * represents 1 pixel multiplied by the `pixelWidth` value. The cell values, such as `8`, maps to color
     * number 8 in the palette. If a cell contains a period character `.` then it is transparent.
     * 
     * The default palette is Arne16, but you can specify your own using the `palette` property.
     *
     * @method Phaser.Textures.TextureManager#generate
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {Phaser.Types.Create.GenerateTextureConfig} config - The configuration object needed to generate the texture.
     *
     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.
     */generate:function(t,e){if(!this.checkKey(t))return null;var n=i.create(this,1,1);return e.canvas=n,c(e),this.addCanvas(t,n)},/**
     * Creates a new Texture using a blank Canvas element of the size given.
     *
     * Canvas elements are automatically pooled and calling this method will
     * extract a free canvas from the CanvasPool, or create one if none are available.
     *
     * @method Phaser.Textures.TextureManager#createCanvas
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {integer} [width=256] - The width of the Canvas element.
     * @param {integer} [height=256] - The height of the Canvas element.
     *
     * @return {?Phaser.Textures.CanvasTexture} The Canvas Texture that was created, or `null` if the key is already in use.
     */createCanvas:function(t,e,n){if(void 0===e&&(e=256),void 0===n&&(n=256),this.checkKey(t)){var s=i.create(this,e,n,a.CANVAS,!0);return this.addCanvas(t,s)}return null},/**
     * Creates a new Canvas Texture object from an existing Canvas element
     * and adds it to this Texture Manager, unless `skipCache` is true.
     *
     * @method Phaser.Textures.TextureManager#addCanvas
     * @fires Phaser.Textures.Events#ADD
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {HTMLCanvasElement} source - The Canvas element to form the base of the new Texture.
     * @param {boolean} [skipCache=false] - Skip adding this Texture into the Cache?
     *
     * @return {?Phaser.Textures.CanvasTexture} The Canvas Texture that was created, or `null` if the key is already in use.
     */addCanvas:function(t,e,i){void 0===i&&(i=!1);var s=null;return i?s=new n(this,t,e,e.width,e.height):this.checkKey(t)&&(s=new n(this,t,e,e.width,e.height),this.list[t]=s,this.emit(l.ADD,t,s)),s},/**
     * Adds a new Texture Atlas to this Texture Manager.
     * It can accept either JSON Array or JSON Hash formats, as exported by Texture Packer and similar software.
     *
     * @method Phaser.Textures.TextureManager#addAtlas
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {HTMLImageElement} source - The source Image element.
     * @param {object} data - The Texture Atlas data.
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.
     *
     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.
     */addAtlas:function(t,e,i,n){return(//  New Texture Packer format?
Array.isArray(i.textures)||Array.isArray(i.frames)?this.addAtlasJSONArray(t,e,i,n):this.addAtlasJSONHash(t,e,i,n))},/**
     * Adds a Texture Atlas to this Texture Manager.
     * The frame data of the atlas must be stored in an Array within the JSON.
     * This is known as a JSON Array in software such as Texture Packer.
     *
     * @method Phaser.Textures.TextureManager#addAtlasJSONArray
     * @fires Phaser.Textures.Events#ADD
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {(HTMLImageElement|HTMLImageElement[])} source - The source Image element/s.
     * @param {(object|object[])} data - The Texture Atlas data/s.
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.
     *
     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.
     */addAtlasJSONArray:function(t,e,i,n){var s=null;if(this.checkKey(t)){//  Multi-Atlas?
if(s=this.create(t,e),Array.isArray(i))//  !! Assumes the textures are in the same order in the source array as in the json data !!
for(var r=1===i.length,o=0;o<s.source.length;o++){var a=r?i[0]:i[o];f.JSONArray(s,o,a)}else f.JSONArray(s,0,i);n&&s.setDataSource(n),this.emit(l.ADD,t,s)}return s},/**
     * Adds a Texture Atlas to this Texture Manager.
     * The frame data of the atlas must be stored in an Object within the JSON.
     * This is known as a JSON Hash in software such as Texture Packer.
     *
     * @method Phaser.Textures.TextureManager#addAtlasJSONHash
     * @fires Phaser.Textures.Events#ADD
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {HTMLImageElement} source - The source Image element.
     * @param {object} data - The Texture Atlas data.
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.
     *
     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.
     */addAtlasJSONHash:function(t,e,i,n){var s=null;if(this.checkKey(t)){if(s=this.create(t,e),Array.isArray(i))for(var r=0;r<i.length;r++)f.JSONHash(s,r,i[r]);else f.JSONHash(s,0,i);n&&s.setDataSource(n),this.emit(l.ADD,t,s)}return s},/**
     * Adds a Texture Atlas to this Texture Manager, where the atlas data is given
     * in the XML format.
     *
     * @method Phaser.Textures.TextureManager#addAtlasXML
     * @fires Phaser.Textures.Events#ADD
     * @since 3.7.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {HTMLImageElement} source - The source Image element.
     * @param {object} data - The Texture Atlas XML data.
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.
     *
     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.
     */addAtlasXML:function(t,e,i,n){var s=null;return this.checkKey(t)&&(s=this.create(t,e),f.AtlasXML(s,0,i),n&&s.setDataSource(n),this.emit(l.ADD,t,s)),s},/**
     * Adds a Unity Texture Atlas to this Texture Manager.
     * The data must be in the form of a Unity YAML file.
     *
     * @method Phaser.Textures.TextureManager#addUnityAtlas
     * @fires Phaser.Textures.Events#ADD
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {HTMLImageElement} source - The source Image element.
     * @param {object} data - The Texture Atlas data.
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.
     *
     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.
     */addUnityAtlas:function(t,e,i,n){var s=null;return this.checkKey(t)&&(s=this.create(t,e),f.UnityYAML(s,0,i),n&&s.setDataSource(n),this.emit(l.ADD,t,s)),s},/**
     * Adds a Sprite Sheet to this Texture Manager.
     *
     * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact
     * same size and cannot be trimmed or rotated.
     *
     * @method Phaser.Textures.TextureManager#addSpriteSheet
     * @fires Phaser.Textures.Events#ADD
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {HTMLImageElement} source - The source Image element.
     * @param {Phaser.Types.Textures.SpriteSheetConfig} config - The configuration object for this Sprite Sheet.
     *
     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.
     */addSpriteSheet:function(t,e,i){var n=null;if(this.checkKey(t)){var s=(n=this.create(t,e)).source[0].width,r=n.source[0].height;f.SpriteSheet(n,0,0,0,s,r,i),this.emit(l.ADD,t,n)}return n},/**
     * Adds a Sprite Sheet to this Texture Manager, where the Sprite Sheet exists as a Frame within a Texture Atlas.
     *
     * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact
     * same size and cannot be trimmed or rotated.
     *
     * @method Phaser.Textures.TextureManager#addSpriteSheetFromAtlas
     * @fires Phaser.Textures.Events#ADD
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {Phaser.Types.Textures.SpriteSheetFromAtlasConfig} config - The configuration object for this Sprite Sheet.
     *
     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.
     */addSpriteSheetFromAtlas:function(t,e){if(!this.checkKey(t))return null;var i=d(e,"atlas",null),n=d(e,"frame",null);if(i&&n){var s=this.get(i).get(n);if(s){var r=this.create(t,s.source.image);return s.trimmed?f.SpriteSheetFromAtlas(r,s,e):f.SpriteSheet(r,0,s.cutX,s.cutY,s.cutWidth,s.cutHeight,e),this.emit(l.ADD,t,r),r}}},/**
     * Creates a new Texture using the given source and dimensions.
     *
     * @method Phaser.Textures.TextureManager#create
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {HTMLImageElement} source - The source Image element.
     * @param {integer} width - The width of the Texture.
     * @param {integer} height - The height of the Texture.
     *
     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.
     */create:function(t,e,i,n){var s=null;return this.checkKey(t)&&(s=new p(this,t,e,i,n),this.list[t]=s),s},/**
     * Checks the given key to see if a Texture using it exists within this Texture Manager.
     *
     * @method Phaser.Textures.TextureManager#exists
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     *
     * @return {boolean} Returns `true` if a Texture matching the given key exists in this Texture Manager.
     */exists:function(t){return this.list.hasOwnProperty(t)},/**
     * Returns a Texture from the Texture Manager that matches the given key.
     * 
     * If the key is `undefined` it will return the `__DEFAULT` Texture.
     * 
     * If the key is an instance of a Texture, it will return the key directly.
     * 
     * Finally. if the key is given, but not found and not a Texture instance, it will return the `__MISSING` Texture.
     *
     * @method Phaser.Textures.TextureManager#get
     * @since 3.0.0
     *
     * @param {(string|Phaser.Textures.Texture)} key - The unique string-based key of the Texture, or a Texture instance.
     *
     * @return {Phaser.Textures.Texture} The Texture that was created.
     */get:function(t){return(void 0===t&&(t="__DEFAULT"),this.list[t])?this.list[t]:t instanceof p?t:this.list.__MISSING},/**
     * Takes a Texture key and Frame name and returns a clone of that Frame if found.
     *
     * @method Phaser.Textures.TextureManager#cloneFrame
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {(string|integer)} frame - The string or index of the Frame to be cloned.
     *
     * @return {Phaser.Textures.Frame} A Clone of the given Frame.
     */cloneFrame:function(t,e){if(this.list[t])return this.list[t].get(e).clone()},/**
     * Takes a Texture key and Frame name and returns a reference to that Frame, if found.
     *
     * @method Phaser.Textures.TextureManager#getFrame
     * @since 3.0.0
     *
     * @param {string} key - The unique string-based key of the Texture.
     * @param {(string|integer)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.
     *
     * @return {Phaser.Textures.Frame} A Texture Frame object.
     */getFrame:function(t,e){if(this.list[t])return this.list[t].get(e)},/**
     * Returns an array with all of the keys of all Textures in this Texture Manager.
     * The output array will exclude the `__DEFAULT` and `__MISSING` keys.
     *
     * @method Phaser.Textures.TextureManager#getTextureKeys
     * @since 3.0.0
     *
     * @return {string[]} An array containing all of the Texture keys stored in this Texture Manager.
     */getTextureKeys:function(){var t=[];for(var e in this.list)"__DEFAULT"!==e&&"__MISSING"!==e&&t.push(e);return t},/**
     * Given a Texture and an `x` and `y` coordinate this method will return a new
     * Color object that has been populated with the color and alpha values of the pixel
     * at that location in the Texture.
     *
     * @method Phaser.Textures.TextureManager#getPixel
     * @since 3.0.0
     *
     * @param {integer} x - The x coordinate of the pixel within the Texture.
     * @param {integer} y - The y coordinate of the pixel within the Texture.
     * @param {string} key - The unique string-based key of the Texture.
     * @param {(string|integer)} [frame] - The string or index of the Frame.
     *
     * @return {?Phaser.Display.Color} A Color object populated with the color values of the requested pixel,
     * or `null` if the coordinates were out of bounds.
     */getPixel:function(t,e,i,n){var s=this.getFrame(i,n);if(s){//  Adjust for trim (if not trimmed x and y are just zero)
t-=s.x,e-=s.y;var r=s.data.cut;if(t+=r.x,e+=r.y,t>=r.x&&t<r.r&&e>=r.y&&e<r.b){var a=this._tempContext;a.clearRect(0,0,1,1),a.drawImage(s.source.image,t,e,1,1,0,0,1,1);var h=a.getImageData(0,0,1,1);return new o(h.data[0],h.data[1],h.data[2],h.data[3])}}return null},/**
     * Given a Texture and an `x` and `y` coordinate this method will return a value between 0 and 255
     * corresponding to the alpha value of the pixel at that location in the Texture. If the coordinate
     * is out of bounds it will return null.
     *
     * @method Phaser.Textures.TextureManager#getPixelAlpha
     * @since 3.10.0
     *
     * @param {integer} x - The x coordinate of the pixel within the Texture.
     * @param {integer} y - The y coordinate of the pixel within the Texture.
     * @param {string} key - The unique string-based key of the Texture.
     * @param {(string|integer)} [frame] - The string or index of the Frame.
     *
     * @return {integer} A value between 0 and 255, or `null` if the coordinates were out of bounds.
     */getPixelAlpha:function(t,e,i,n){var s=this.getFrame(i,n);if(s){//  Adjust for trim (if not trimmed x and y are just zero)
t-=s.x,e-=s.y;var r=s.data.cut;if(t+=r.x,e+=r.y,t>=r.x&&t<r.r&&e>=r.y&&e<r.b){var o=this._tempContext;return o.clearRect(0,0,1,1),o.drawImage(s.source.image,t,e,1,1,0,0,1,1),o.getImageData(0,0,1,1).data[3]}}return null},/**
     * Sets the given Game Objects `texture` and `frame` properties so that it uses
     * the Texture and Frame specified in the `key` and `frame` arguments to this method.
     *
     * @method Phaser.Textures.TextureManager#setTexture
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object the texture would be set on.
     * @param {string} key - The unique string-based key of the Texture.
     * @param {(string|integer)} [frame] - The string or index of the Frame.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object the texture was set on.
     */setTexture:function(t,e,i){return this.list[e]&&(t.texture=this.list[e],t.frame=t.texture.get(i)),t},/**
     * Changes the key being used by a Texture to the new key provided.
     * 
     * The old key is removed, allowing it to be re-used.
     * 
     * Game Objects are linked to Textures by a reference to the Texture object, so
     * all existing references will be retained.
     *
     * @method Phaser.Textures.TextureManager#renameTexture
     * @since 3.12.0
     *
     * @param {string} currentKey - The current string-based key of the Texture you wish to rename.
     * @param {string} newKey - The new unique string-based key to use for the Texture.
     *
     * @return {boolean} `true` if the Texture key was successfully renamed, otherwise `false`.
     */renameTexture:function(t,e){var i=this.get(t);return!!i&&t!==e&&(i.key=e,this.list[e]=i,delete this.list[t],!0)},/**
     * Passes all Textures to the given callback.
     *
     * @method Phaser.Textures.TextureManager#each
     * @since 3.0.0
     *
     * @param {EachTextureCallback} callback - The callback function to be sent the Textures.
     * @param {object} scope - The value to use as `this` when executing the callback.
     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.
     */each:function(t,e){for(var i=[null],n=1;n<arguments.length;n++)i.push(arguments[n]);for(var s in this.list)i[0]=this.list[s],t.apply(e,i)},/**
     * Destroys the Texture Manager and all Textures stored within it.
     *
     * @method Phaser.Textures.TextureManager#destroy
     * @since 3.0.0
     */destroy:function(){for(var t in this.list)this.list[t].destroy();this.list={},this.game=null,i.remove(this._tempCanvas)}});t.exports=g}),r("demvd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("iEUUO"),r=s("pqNJR"),o=s("bRAqZ"),a=s("gV9Y0"),h=s("cCQL0"),l=new i({Extends:h,initialize:function(t,e,i,n,s){h.call(this,t,e,i,n,s),this.add("__BASE",0,0,0,n,s),/**
         * A reference to the Texture Source of this Canvas.
         *
         * @name Phaser.Textures.CanvasTexture#_source
         * @type {Phaser.Textures.TextureSource}
         * @private
         * @since 3.7.0
         */this._source=this.frames.__BASE.source,/**
         * The source Canvas Element.
         *
         * @name Phaser.Textures.CanvasTexture#canvas
         * @readonly
         * @type {HTMLCanvasElement}
         * @since 3.7.0
         */this.canvas=this._source.image,/**
         * The 2D Canvas Rendering Context.
         *
         * @name Phaser.Textures.CanvasTexture#context
         * @readonly
         * @type {CanvasRenderingContext2D}
         * @since 3.7.0
         */this.context=this.canvas.getContext("2d"),/**
         * The width of the Canvas.
         * This property is read-only, if you wish to change it use the `setSize` method.
         *
         * @name Phaser.Textures.CanvasTexture#width
         * @readonly
         * @type {integer}
         * @since 3.7.0
         */this.width=n,/**
         * The height of the Canvas.
         * This property is read-only, if you wish to change it use the `setSize` method.
         *
         * @name Phaser.Textures.CanvasTexture#height
         * @readonly
         * @type {integer}
         * @since 3.7.0
         */this.height=s,/**
         * The context image data.
         * Use the `update` method to populate this when the canvas changes.
         *
         * @name Phaser.Textures.CanvasTexture#imageData
         * @type {ImageData}
         * @since 3.13.0
         */this.imageData=this.context.getImageData(0,0,n,s),/**
         * A Uint8ClampedArray view into the `buffer`.
         * Use the `update` method to populate this when the canvas changes.
         * Note that this is unavailable in some browsers, such as Epic Browser, due to their security restrictions.
         *
         * @name Phaser.Textures.CanvasTexture#data
         * @type {Uint8ClampedArray}
         * @since 3.13.0
         */this.data=null,this.imageData&&(this.data=this.imageData.data),/**
         * An Uint32Array view into the `buffer`.
         *
         * @name Phaser.Textures.CanvasTexture#pixels
         * @type {Uint32Array}
         * @since 3.13.0
         */this.pixels=null,/**
         * An ArrayBuffer the same size as the context ImageData.
         *
         * @name Phaser.Textures.CanvasTexture#buffer
         * @type {ArrayBuffer}
         * @since 3.13.0
         */this.buffer,this.data&&(this.imageData.data.buffer?(this.buffer=this.imageData.data.buffer,this.pixels=new Uint32Array(this.buffer)):window.ArrayBuffer?(this.buffer=new ArrayBuffer(this.imageData.data.length),this.pixels=new Uint32Array(this.buffer)):this.pixels=this.imageData.data)},/**
     * This re-creates the `imageData` from the current context.
     * It then re-builds the ArrayBuffer, the `data` Uint8ClampedArray reference and the `pixels` Int32Array.
     *
     * Warning: This is a very expensive operation, so use it sparingly.
     *
     * @method Phaser.Textures.CanvasTexture#update
     * @since 3.13.0
     *
     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.
     */update:function(){return this.imageData=this.context.getImageData(0,0,this.width,this.height),this.data=this.imageData.data,this.imageData.data.buffer?(this.buffer=this.imageData.data.buffer,this.pixels=new Uint32Array(this.buffer)):window.ArrayBuffer?(this.buffer=new ArrayBuffer(this.imageData.data.length),this.pixels=new Uint32Array(this.buffer)):this.pixels=this.imageData.data,this.manager.game.config.renderType===o.WEBGL&&this.refresh(),this},/**
     * Draws the given Image or Canvas element to this CanvasTexture, then updates the internal
     * ImageData buffer and arrays.
     *
     * @method Phaser.Textures.CanvasTexture#draw
     * @since 3.13.0
     * 
     * @param {integer} x - The x coordinate to draw the source at.
     * @param {integer} y - The y coordinate to draw the source at.
     * @param {(HTMLImageElement|HTMLCanvasElement)} source - The element to draw to this canvas.
     * 
     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.
     */draw:function(t,e,i){return this.context.drawImage(i,t,e),this.update()},/**
     * Draws the given texture frame to this CanvasTexture, then updates the internal
     * ImageData buffer and arrays.
     *
     * @method Phaser.Textures.CanvasTexture#drawFrame
     * @since 3.16.0
     * 
     * @param {string} key - The unique string-based key of the Texture.
     * @param {(string|integer)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.
     * @param {integer} [x=0] - The x coordinate to draw the source at.
     * @param {integer} [y=0] - The y coordinate to draw the source at.
     * 
     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.
     */drawFrame:function(t,e,i,n){void 0===i&&(i=0),void 0===n&&(n=0);var s=this.manager.getFrame(t,e);if(!s)return this;var r=s.canvasData,o=s.cutWidth,a=s.cutHeight,h=s.source.resolution;return this.context.drawImage(s.source.image,r.x,r.y,o,a,i,n,o/h,a/h),this.update()},/**
     * Sets a pixel in the CanvasTexture to the given color and alpha values.
     *
     * This is an expensive operation to run in large quantities, so use sparingly.
     *
     * @method Phaser.Textures.CanvasTexture#setPixel
     * @since 3.16.0
     * 
     * @param {integer} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.
     * @param {integer} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.
     * @param {integer} red - The red color value. A number between 0 and 255.
     * @param {integer} green - The green color value. A number between 0 and 255.
     * @param {integer} blue - The blue color value. A number between 0 and 255.
     * @param {integer} [alpha=255] - The alpha value. A number between 0 and 255.
     * 
     * @return {this} This CanvasTexture.
     */setPixel:function(t,e,i,n,s,r){if(void 0===r&&(r=255),t=Math.abs(Math.floor(t)),e=Math.abs(Math.floor(e)),this.getIndex(t,e)>-1){var o=this.context.getImageData(t,e,1,1);o.data[0]=i,o.data[1]=n,o.data[2]=s,o.data[3]=r,this.context.putImageData(o,t,e)}return this},/**
     * Puts the ImageData into the context of this CanvasTexture at the given coordinates.
     *
     * @method Phaser.Textures.CanvasTexture#putData
     * @since 3.16.0
     * 
     * @param {ImageData} imageData - The ImageData to put at the given location.
     * @param {integer} x - The x coordinate to put the imageData. Must lay within the dimensions of this CanvasTexture and be an integer.
     * @param {integer} y - The y coordinate to put the imageData. Must lay within the dimensions of this CanvasTexture and be an integer.
     * @param {integer} [dirtyX=0] - Horizontal position (x coordinate) of the top-left corner from which the image data will be extracted.
     * @param {integer} [dirtyY=0] - Vertical position (x coordinate) of the top-left corner from which the image data will be extracted.
     * @param {integer} [dirtyWidth] - Width of the rectangle to be painted. Defaults to the width of the image data.
     * @param {integer} [dirtyHeight] - Height of the rectangle to be painted. Defaults to the height of the image data.
     * 
     * @return {this} This CanvasTexture.
     */putData:function(t,e,i,n,s,r,o){return void 0===n&&(n=0),void 0===s&&(s=0),void 0===r&&(r=t.width),void 0===o&&(o=t.height),this.context.putImageData(t,e,i,n,s,r,o),this},/**
     * Gets an ImageData region from this CanvasTexture from the position and size specified.
     * You can write this back using `CanvasTexture.putData`, or manipulate it.
     *
     * @method Phaser.Textures.CanvasTexture#getData
     * @since 3.16.0
     * 
     * @param {integer} x - The x coordinate of the top-left of the area to get the ImageData from. Must lay within the dimensions of this CanvasTexture and be an integer.
     * @param {integer} y - The y coordinate of the top-left of the area to get the ImageData from. Must lay within the dimensions of this CanvasTexture and be an integer.
     * @param {integer} width - The width of the rectangle from which the ImageData will be extracted. Positive values are to the right, and negative to the left.
     * @param {integer} height - The height of the rectangle from which the ImageData will be extracted. Positive values are down, and negative are up.
     * 
     * @return {ImageData} The ImageData extracted from this CanvasTexture.
     */getData:function(t,e,i,s){return t=n(Math.floor(t),0,this.width-1),e=n(Math.floor(e),0,this.height-1),i=n(i,1,this.width-t),s=n(s,1,this.height-e),this.context.getImageData(t,e,i,s)},/**
     * Get the color of a specific pixel from this texture and store it in a Color object.
     * 
     * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,
     * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.
     *
     * @method Phaser.Textures.CanvasTexture#getPixel
     * @since 3.13.0
     * 
     * @param {integer} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.
     * @param {integer} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.
     * @param {Phaser.Display.Color} [out] - A Color object to store the pixel values in. If not provided a new Color object will be created.
     * 
     * @return {Phaser.Display.Color} An object with the red, green, blue and alpha values set in the r, g, b and a properties.
     */getPixel:function(t,e,i){i||(i=new r);var n=this.getIndex(t,e);if(n>-1){var s=this.data,o=s[n+0],a=s[n+1],h=s[n+2],l=s[n+3];i.setTo(o,a,h,l)}return i},/**
     * Returns an array containing all of the pixels in the given region.
     *
     * If the requested region extends outside the bounds of this CanvasTexture,
     * the region is truncated to fit.
     * 
     * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,
     * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.
     *
     * @method Phaser.Textures.CanvasTexture#getPixels
     * @since 3.16.0
     * 
     * @param {integer} [x=0] - The x coordinate of the top-left of the region. Must lay within the dimensions of this CanvasTexture and be an integer.
     * @param {integer} [y=0] - The y coordinate of the top-left of the region. Must lay within the dimensions of this CanvasTexture and be an integer.
     * @param {integer} [width] - The width of the region to get. Must be an integer. Defaults to the canvas width if not given.
     * @param {integer} [height] - The height of the region to get. Must be an integer. If not given will be set to the `width`.
     * 
     * @return {Phaser.Types.Textures.PixelConfig[][]} A 2d array of Pixel objects.
     */getPixels:function(t,e,i,s){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=this.width),void 0===s&&(s=i),t=Math.abs(Math.round(t)),e=Math.abs(Math.round(e));for(var o=n(t,0,this.width),a=n(t+i,0,this.width),h=n(e,0,this.height),l=n(e+s,0,this.height),u=new r,c=[],d=h;d<l;d++){for(var f=[],p=o;p<a;p++)u=this.getPixel(p,d,u),f.push({x:p,y:d,color:u.color,alpha:u.alphaGL});c.push(f)}return c},/**
     * Returns the Image Data index for the given pixel in this CanvasTexture.
     *
     * The index can be used to read directly from the `this.data` array.
     *
     * The index points to the red value in the array. The subsequent 3 indexes
     * point to green, blue and alpha respectively.
     *
     * @method Phaser.Textures.CanvasTexture#getIndex
     * @since 3.16.0
     * 
     * @param {integer} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.
     * @param {integer} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.
     * 
     * @return {integer} 
     */getIndex:function(t,e){return(t=Math.abs(Math.round(t)),e=Math.abs(Math.round(e)),t<this.width&&e<this.height)?(t+e*this.width)*4:-1},/**
     * This should be called manually if you are running under WebGL.
     * It will refresh the WebGLTexture from the Canvas source. Only call this if you know that the
     * canvas has changed, as there is a significant GPU texture allocation cost involved in doing so.
     *
     * @method Phaser.Textures.CanvasTexture#refresh
     * @since 3.7.0
     *
     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.
     */refresh:function(){return this._source.update(),this},/**
     * Gets the Canvas Element.
     *
     * @method Phaser.Textures.CanvasTexture#getCanvas
     * @since 3.7.0
     *
     * @return {HTMLCanvasElement} The Canvas DOM element this texture is using.
     */getCanvas:function(){return this.canvas},/**
     * Gets the 2D Canvas Rendering Context.
     *
     * @method Phaser.Textures.CanvasTexture#getContext
     * @since 3.7.0
     *
     * @return {CanvasRenderingContext2D} The Canvas Rendering Context this texture is using.
     */getContext:function(){return this.context},/**
     * Clears the given region of this Canvas Texture, resetting it back to transparent.
     * If no region is given, the whole Canvas Texture is cleared.
     *
     * @method Phaser.Textures.CanvasTexture#clear
     * @since 3.7.0
     * 
     * @param {integer} [x=0] - The x coordinate of the top-left of the region to clear.
     * @param {integer} [y=0] - The y coordinate of the top-left of the region to clear.
     * @param {integer} [width] - The width of the region.
     * @param {integer} [height] - The height of the region.
     *
     * @return {Phaser.Textures.CanvasTexture} The Canvas Texture.
     */clear:function(t,e,i,n){return void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=this.width),void 0===n&&(n=this.height),this.context.clearRect(t,e,i,n),this.update()},/**
     * Changes the size of this Canvas Texture.
     *
     * @method Phaser.Textures.CanvasTexture#setSize
     * @since 3.7.0
     *
     * @param {integer} width - The new width of the Canvas.
     * @param {integer} [height] - The new height of the Canvas. If not given it will use the width as the height.
     *
     * @return {Phaser.Textures.CanvasTexture} The Canvas Texture.
     */setSize:function(t,e){return void 0===e&&(e=t),(t!==this.width||e!==this.height)&&(//  Update the Canvas
this.canvas.width=t,this.canvas.height=e,//  Update the Texture Source
this._source.width=t,this._source.height=e,this._source.isPowerOf2=a(t,e),//  Update the Frame
this.frames.__BASE.setSize(t,e,0,0),//  Update this
this.width=t,this.height=e,this.refresh()),this},/**
     * Destroys this Texture and releases references to its sources and frames.
     *
     * @method Phaser.Textures.CanvasTexture#destroy
     * @since 3.16.0
     */destroy:function(){h.prototype.destroy.call(this),this._source=null,this.canvas=null,this.context=null,this.imageData=null,this.data=null,this.pixels=null,this.buffer=null}});t.exports=l}),r("cCQL0",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7O4PF"),r=s("k25Vv"),o="Texture.frame missing: ",a=new i({initialize:function(t,e,i,n,s){Array.isArray(i)||(i=[i]),/**
         * A reference to the Texture Manager this Texture belongs to.
         *
         * @name Phaser.Textures.Texture#manager
         * @type {Phaser.Textures.TextureManager}
         * @since 3.0.0
         */this.manager=t,/**
         * The unique string-based key of this Texture.
         *
         * @name Phaser.Textures.Texture#key
         * @type {string}
         * @since 3.0.0
         */this.key=e,/**
         * An array of TextureSource instances.
         * These are unique to this Texture and contain the actual Image (or Canvas) data.
         *
         * @name Phaser.Textures.Texture#source
         * @type {Phaser.Textures.TextureSource[]}
         * @since 3.0.0
         */this.source=[],/**
         * An array of TextureSource data instances.
         * Used to store additional data images, such as normal maps or specular maps.
         *
         * @name Phaser.Textures.Texture#dataSource
         * @type {array}
         * @since 3.0.0
         */this.dataSource=[],/**
         * A key-value object pair associating the unique Frame keys with the Frames objects.
         *
         * @name Phaser.Textures.Texture#frames
         * @type {object}
         * @since 3.0.0
         */this.frames={},/**
         * Any additional data that was set in the source JSON (if any),
         * or any extra data you'd like to store relating to this texture
         *
         * @name Phaser.Textures.Texture#customData
         * @type {object}
         * @since 3.0.0
         */this.customData={},/**
         * The name of the first frame of the Texture.
         *
         * @name Phaser.Textures.Texture#firstFrame
         * @type {string}
         * @since 3.0.0
         */this.firstFrame="__BASE",/**
         * The total number of Frames in this Texture, including the `__BASE` frame.
         * 
         * A Texture will always contain at least 1 frame because every Texture contains a `__BASE` frame by default,
         * in addition to any extra frames that have been added to it, such as when parsing a Sprite Sheet or Texture Atlas.
         *
         * @name Phaser.Textures.Texture#frameTotal
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.frameTotal=0;//  Load the Sources
for(var o=0;o<i.length;o++)this.source.push(new r(this,i[o],n,s))},/**
     * Adds a new Frame to this Texture.
     *
     * A Frame is a rectangular region of a TextureSource with a unique index or string-based key.
     * 
     * The name given must be unique within this Texture. If it already exists, this method will return `null`.
     *
     * @method Phaser.Textures.Texture#add
     * @since 3.0.0
     *
     * @param {(integer|string)} name - The name of this Frame. The name is unique within the Texture.
     * @param {integer} sourceIndex - The index of the TextureSource that this Frame is a part of.
     * @param {number} x - The x coordinate of the top-left of this Frame.
     * @param {number} y - The y coordinate of the top-left of this Frame.
     * @param {number} width - The width of this Frame.
     * @param {number} height - The height of this Frame.
     *
     * @return {?Phaser.Textures.Frame} The Frame that was added to this Texture, or `null` if the given name already exists.
     */add:function(t,e,i,s,r,o){if(this.has(t))return null;var a=new n(this,t,e,i,s,r,o);return this.frames[t]=a,"__BASE"===this.firstFrame&&(this.firstFrame=t),this.frameTotal++,a},/**
     * Removes the given Frame from this Texture. The Frame is destroyed immediately.
     * 
     * Any Game Objects using this Frame should stop using it _before_ you remove it,
     * as it does not happen automatically.
     *
     * @method Phaser.Textures.Texture#remove
     * @since 3.19.0
     *
     * @param {string} name - The key of the Frame to remove.
     *
     * @return {boolean} True if a Frame with the matching key was removed from this Texture.
     */remove:function(t){return!!this.has(t)&&(this.get(t).destroy(),delete this.frames[t],!0)},/**
     * Checks to see if a Frame matching the given key exists within this Texture.
     *
     * @method Phaser.Textures.Texture#has
     * @since 3.0.0
     *
     * @param {string} name - The key of the Frame to check for.
     *
     * @return {boolean} True if a Frame with the matching key exists in this Texture.
     */has:function(t){return this.frames[t]},/**
     * Gets a Frame from this Texture based on either the key or the index of the Frame.
     *
     * In a Texture Atlas Frames are typically referenced by a key.
     * In a Sprite Sheet Frames are referenced by an index.
     * Passing no value for the name returns the base texture.
     *
     * @method Phaser.Textures.Texture#get
     * @since 3.0.0
     *
     * @param {(string|integer)} [name] - The string-based name, or integer based index, of the Frame to get from this Texture.
     *
     * @return {Phaser.Textures.Frame} The Texture Frame.
     */get:function(t){t||(t=this.firstFrame);var e=this.frames[t];return e||(console.warn(o+t),e=this.frames[this.firstFrame]),e},/**
     * Takes the given TextureSource and returns the index of it within this Texture.
     * If it's not in this Texture, it returns -1.
     * Unless this Texture has multiple TextureSources, such as with a multi-atlas, this
     * method will always return zero or -1.
     *
     * @method Phaser.Textures.Texture#getTextureSourceIndex
     * @since 3.0.0
     *
     * @param {Phaser.Textures.TextureSource} source - The TextureSource to check.
     *
     * @return {integer} The index of the TextureSource within this Texture, or -1 if not in this Texture.
     */getTextureSourceIndex:function(t){for(var e=0;e<this.source.length;e++)if(this.source[e]===t)return e;return -1},/**
     * Returns an array of all the Frames in the given TextureSource.
     *
     * @method Phaser.Textures.Texture#getFramesFromTextureSource
     * @since 3.0.0
     *
     * @param {integer} sourceIndex - The index of the TextureSource to get the Frames from.
     * @param {boolean} [includeBase=false] - Include the `__BASE` Frame in the output array?
     *
     * @return {Phaser.Textures.Frame[]} An array of Texture Frames.
     */getFramesFromTextureSource:function(t,e){void 0===e&&(e=!1);var i=[];for(var n in this.frames)if("__BASE"!==n||e){var s=this.frames[n];s.sourceIndex===t&&i.push(s)}return i},/**
     * Returns an array with all of the names of the Frames in this Texture.
     *
     * Useful if you want to randomly assign a Frame to a Game Object, as you can
     * pick a random element from the returned array.
     *
     * @method Phaser.Textures.Texture#getFrameNames
     * @since 3.0.0
     *
     * @param {boolean} [includeBase=false] - Include the `__BASE` Frame in the output array?
     *
     * @return {string[]} An array of all Frame names in this Texture.
     */getFrameNames:function(t){void 0===t&&(t=!1);var e=Object.keys(this.frames);if(!t){var i=e.indexOf("__BASE");-1!==i&&e.splice(i,1)}return e},/**
     * Given a Frame name, return the source image it uses to render with.
     *
     * This will return the actual DOM Image or Canvas element.
     *
     * @method Phaser.Textures.Texture#getSourceImage
     * @since 3.0.0
     *
     * @param {(string|integer)} [name] - The string-based name, or integer based index, of the Frame to get from this Texture.
     *
     * @return {(HTMLImageElement|HTMLCanvasElement|Phaser.GameObjects.RenderTexture)} The DOM Image, Canvas Element or Render Texture.
     */getSourceImage:function(t){(null==t||1===this.frameTotal)&&(t="__BASE");var e=this.frames[t];return e?e.source.image:(console.warn(o+t),this.frames.__BASE.source.image)},/**
     * Given a Frame name, return the data source image it uses to render with.
     * You can use this to get the normal map for an image for example.
     *
     * This will return the actual DOM Image.
     *
     * @method Phaser.Textures.Texture#getDataSourceImage
     * @since 3.7.0
     *
     * @param {(string|integer)} [name] - The string-based name, or integer based index, of the Frame to get from this Texture.
     *
     * @return {(HTMLImageElement|HTMLCanvasElement)} The DOM Image or Canvas Element.
     */getDataSourceImage:function(t){(null==t||1===this.frameTotal)&&(t="__BASE");var e,i=this.frames[t];return i?e=i.sourceIndex:(console.warn(o+t),e=this.frames.__BASE.sourceIndex),this.dataSource[e].image},/**
     * Adds a data source image to this Texture.
     *
     * An example of a data source image would be a normal map, where all of the Frames for this Texture
     * equally apply to the normal map.
     *
     * @method Phaser.Textures.Texture#setDataSource
     * @since 3.0.0
     *
     * @param {(HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[])} data - The source image.
     */setDataSource:function(t){Array.isArray(t)||(t=[t]);for(var e=0;e<t.length;e++){var i=this.source[e];this.dataSource.push(new r(this,t[e],i.width,i.height))}},/**
     * Sets the Filter Mode for this Texture.
     *
     * The mode can be either Linear, the default, or Nearest.
     *
     * For pixel-art you should use Nearest.
     *
     * The mode applies to the entire Texture, not just a specific Frame of it.
     *
     * @method Phaser.Textures.Texture#setFilter
     * @since 3.0.0
     *
     * @param {Phaser.Textures.FilterMode} filterMode - The Filter Mode.
     */setFilter:function(t){var e;for(e=0;e<this.source.length;e++)this.source[e].setFilter(t);for(e=0;e<this.dataSource.length;e++)this.dataSource[e].setFilter(t)},/**
     * Destroys this Texture and releases references to its sources and frames.
     *
     * @method Phaser.Textures.Texture#destroy
     * @since 3.0.0
     */destroy:function(){var t;for(t=0;t<this.source.length;t++)this.source[t].destroy();for(t=0;t<this.dataSource.length;t++)this.dataSource[t].destroy();for(var e in this.frames)this.frames[e].destroy();this.source=[],this.dataSource=[],this.frames={},this.manager.removeKey(this.key),this.manager=null}});t.exports=a}),r("7O4PF",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("iEUUO"),r=s("hVk4C"),o=new i({initialize:function(t,e,i,n,s,r,o){/**
         * The Texture this Frame is a part of.
         *
         * @name Phaser.Textures.Frame#texture
         * @type {Phaser.Textures.Texture}
         * @since 3.0.0
         */this.texture=t,/**
         * The name of this Frame.
         * The name is unique within the Texture.
         *
         * @name Phaser.Textures.Frame#name
         * @type {string}
         * @since 3.0.0
         */this.name=e,/**
         * The TextureSource this Frame is part of.
         *
         * @name Phaser.Textures.Frame#source
         * @type {Phaser.Textures.TextureSource}
         * @since 3.0.0
         */this.source=t.source[i],/**
         * The index of the TextureSource in the Texture sources array.
         *
         * @name Phaser.Textures.Frame#sourceIndex
         * @type {integer}
         * @since 3.0.0
         */this.sourceIndex=i,/**
         * A reference to the Texture Source WebGL Texture that this Frame is using.
         *
         * @name Phaser.Textures.Frame#glTexture
         * @type {?WebGLTexture}
         * @default null
         * @since 3.11.0
         */this.glTexture=this.source.glTexture,/**
         * X position within the source image to cut from.
         *
         * @name Phaser.Textures.Frame#cutX
         * @type {integer}
         * @since 3.0.0
         */this.cutX,/**
         * Y position within the source image to cut from.
         *
         * @name Phaser.Textures.Frame#cutY
         * @type {integer}
         * @since 3.0.0
         */this.cutY,/**
         * The width of the area in the source image to cut.
         *
         * @name Phaser.Textures.Frame#cutWidth
         * @type {integer}
         * @since 3.0.0
         */this.cutWidth,/**
         * The height of the area in the source image to cut.
         *
         * @name Phaser.Textures.Frame#cutHeight
         * @type {integer}
         * @since 3.0.0
         */this.cutHeight,/**
         * The X rendering offset of this Frame, taking trim into account.
         *
         * @name Phaser.Textures.Frame#x
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.x=0,/**
         * The Y rendering offset of this Frame, taking trim into account.
         *
         * @name Phaser.Textures.Frame#y
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.y=0,/**
         * The rendering width of this Frame, taking trim into account.
         *
         * @name Phaser.Textures.Frame#width
         * @type {integer}
         * @since 3.0.0
         */this.width,/**
         * The rendering height of this Frame, taking trim into account.
         *
         * @name Phaser.Textures.Frame#height
         * @type {integer}
         * @since 3.0.0
         */this.height,/**
         * Half the width, floored.
         * Precalculated for the renderer.
         *
         * @name Phaser.Textures.Frame#halfWidth
         * @type {integer}
         * @since 3.0.0
         */this.halfWidth,/**
         * Half the height, floored.
         * Precalculated for the renderer.
         *
         * @name Phaser.Textures.Frame#halfHeight
         * @type {integer}
         * @since 3.0.0
         */this.halfHeight,/**
         * The x center of this frame, floored.
         *
         * @name Phaser.Textures.Frame#centerX
         * @type {integer}
         * @since 3.0.0
         */this.centerX,/**
         * The y center of this frame, floored.
         *
         * @name Phaser.Textures.Frame#centerY
         * @type {integer}
         * @since 3.0.0
         */this.centerY,/**
         * The horizontal pivot point of this Frame.
         *
         * @name Phaser.Textures.Frame#pivotX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.pivotX=0,/**
         * The vertical pivot point of this Frame.
         *
         * @name Phaser.Textures.Frame#pivotY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.pivotY=0,/**
         * Does this Frame have a custom pivot point?
         *
         * @name Phaser.Textures.Frame#customPivot
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.customPivot=!1,/**
         * **CURRENTLY UNSUPPORTED**
         *
         * Is this frame is rotated or not in the Texture?
         * Rotation allows you to use rotated frames in texture atlas packing.
         * It has nothing to do with Sprite rotation.
         *
         * @name Phaser.Textures.Frame#rotated
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.rotated=!1,/**
         * Over-rides the Renderer setting.
         * -1 = use Renderer Setting
         * 0 = No rounding
         * 1 = Round
         *
         * @name Phaser.Textures.Frame#autoRound
         * @type {integer}
         * @default -1
         * @since 3.0.0
         */this.autoRound=-1,/**
         * Any Frame specific custom data can be stored here.
         *
         * @name Phaser.Textures.Frame#customData
         * @type {object}
         * @since 3.0.0
         */this.customData={},/**
         * WebGL UV u0 value.
         *
         * @name Phaser.Textures.Frame#u0
         * @type {number}
         * @default 0
         * @since 3.11.0
         */this.u0=0,/**
         * WebGL UV v0 value.
         *
         * @name Phaser.Textures.Frame#v0
         * @type {number}
         * @default 0
         * @since 3.11.0
         */this.v0=0,/**
         * WebGL UV u1 value.
         *
         * @name Phaser.Textures.Frame#u1
         * @type {number}
         * @default 0
         * @since 3.11.0
         */this.u1=0,/**
         * WebGL UV v1 value.
         *
         * @name Phaser.Textures.Frame#v1
         * @type {number}
         * @default 0
         * @since 3.11.0
         */this.v1=0,/**
         * The un-modified source frame, trim and UV data.
         *
         * @name Phaser.Textures.Frame#data
         * @type {object}
         * @private
         * @since 3.0.0
         */this.data={cut:{x:0,y:0,w:0,h:0,r:0,b:0},trim:!1,sourceSize:{w:0,h:0},spriteSourceSize:{x:0,y:0,w:0,h:0,r:0,b:0},radius:0,drawImage:{x:0,y:0,width:0,height:0}},this.setSize(r,o,n,s)},/**
     * Sets the width, height, x and y of this Frame.
     * 
     * This is called automatically by the constructor
     * and should rarely be changed on-the-fly.
     *
     * @method Phaser.Textures.Frame#setSize
     * @since 3.7.0
     *
     * @param {integer} width - The width of the frame before being trimmed.
     * @param {integer} height - The height of the frame before being trimmed.
     * @param {integer} [x=0] - The x coordinate of the top-left of this Frame.
     * @param {integer} [y=0] - The y coordinate of the top-left of this Frame.
     *
     * @return {Phaser.Textures.Frame} This Frame object.
     */setSize:function(t,e,i,n){void 0===i&&(i=0),void 0===n&&(n=0),this.cutX=i,this.cutY=n,this.cutWidth=t,this.cutHeight=e,this.width=t,this.height=e,this.halfWidth=Math.floor(.5*t),this.halfHeight=Math.floor(.5*e),this.centerX=Math.floor(t/2),this.centerY=Math.floor(e/2);var s=this.data,r=s.cut;r.x=i,r.y=n,r.w=t,r.h=e,r.r=i+t,r.b=n+e,s.sourceSize.w=t,s.sourceSize.h=e,s.spriteSourceSize.w=t,s.spriteSourceSize.h=e,s.radius=.5*Math.sqrt(t*t+e*e);var o=s.drawImage;return o.x=i,o.y=n,o.width=t,o.height=e,this.updateUVs()},/**
     * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.
     *
     * @method Phaser.Textures.Frame#setTrim
     * @since 3.0.0
     *
     * @param {number} actualWidth - The width of the frame before being trimmed.
     * @param {number} actualHeight - The height of the frame before being trimmed.
     * @param {number} destX - The destination X position of the trimmed frame for display.
     * @param {number} destY - The destination Y position of the trimmed frame for display.
     * @param {number} destWidth - The destination width of the trimmed frame for display.
     * @param {number} destHeight - The destination height of the trimmed frame for display.
     *
     * @return {Phaser.Textures.Frame} This Frame object.
     */setTrim:function(t,e,i,n,s,r){var o=this.data,a=o.spriteSourceSize;return(//  Store actual values
o.trim=!0,o.sourceSize.w=t,o.sourceSize.h=e,a.x=i,a.y=n,a.w=s,a.h=r,a.r=i+s,a.b=n+r,//  Adjust properties
this.x=i,this.y=n,this.width=s,this.height=r,this.halfWidth=.5*s,this.halfHeight=.5*r,this.centerX=Math.floor(s/2),this.centerY=Math.floor(r/2),this.updateUVs())},/**
     * Takes a crop data object and, based on the rectangular region given, calculates the
     * required UV coordinates in order to crop this Frame for WebGL and Canvas rendering.
     * 
     * This is called directly by the Game Object Texture Components `setCrop` method.
     * Please use that method to crop a Game Object.
     *
     * @method Phaser.Textures.Frame#setCropUVs
     * @since 3.11.0
     * 
     * @param {object} crop - The crop data object. This is the `GameObject._crop` property.
     * @param {number} x - The x coordinate to start the crop from. Cannot be negative or exceed the Frame width.
     * @param {number} y - The y coordinate to start the crop from. Cannot be negative or exceed the Frame height.
     * @param {number} width - The width of the crop rectangle. Cannot exceed the Frame width.
     * @param {number} height - The height of the crop rectangle. Cannot exceed the Frame height.
     * @param {boolean} flipX - Does the parent Game Object have flipX set?
     * @param {boolean} flipY - Does the parent Game Object have flipY set?
     *
     * @return {object} The updated crop data object.
     */setCropUVs:function(t,e,i,s,r,o,a){//  Clamp the input values
var h=this.cutX,l=this.cutY,u=this.cutWidth,c=this.cutHeight,d=this.realWidth,f=this.realHeight;e=n(e,0,d),i=n(i,0,f),s=n(s,0,d-e),r=n(r,0,f-i);var p=h+e,g=l+i,v=s,m=r,y=this.data;if(y.trim){var x=y.spriteSourceSize;//  Need to check for intersection between the cut area and the crop area
//  If there is none, we set UV to be empty, otherwise set it to be the intersection area
s=n(s,0,u-e),r=n(r,0,c-i);var w=e+s,T=i+r;if(x.r<e||x.b<i||x.x>w||x.y>T)p=0,g=0,v=0,m=0;else{var b=Math.max(x.x,e),S=Math.max(x.y,i),A=Math.min(x.r,w)-b,E=Math.min(x.b,T)-S;v=A,m=E,p=o?h+(u-(b-x.x)-A):h+(b-x.x),g=a?l+(c-(S-x.y)-E):l+(S-x.y),e=b,i=S,s=A,r=E}}else o&&(p=h+(u-e-s)),a&&(g=l+(c-i-r));var _=this.source.width,C=this.source.height;return(//  Map the given coordinates into UV space, clamping to the 0-1 range.
t.u0=Math.max(0,p/_),t.v0=Math.max(0,g/C),t.u1=Math.min(1,(p+v)/_),t.v1=Math.min(1,(g+m)/C),t.x=e,t.y=i,t.cx=p,t.cy=g,t.cw=v,t.ch=m,t.width=s,t.height=r,t.flipX=o,t.flipY=a,t)},/**
     * Takes a crop data object and recalculates the UVs based on the dimensions inside the crop object.
     * Called automatically by `setFrame`.
     *
     * @method Phaser.Textures.Frame#updateCropUVs
     * @since 3.11.0
     * 
     * @param {object} crop - The crop data object. This is the `GameObject._crop` property.
     * @param {boolean} flipX - Does the parent Game Object have flipX set?
     * @param {boolean} flipY - Does the parent Game Object have flipY set?
     *
     * @return {object} The updated crop data object.
     */updateCropUVs:function(t,e,i){return this.setCropUVs(t,t.x,t.y,t.width,t.height,e,i)},/**
     * Updates the internal WebGL UV cache and the drawImage cache.
     *
     * @method Phaser.Textures.Frame#updateUVs
     * @since 3.0.0
     *
     * @return {Phaser.Textures.Frame} This Frame object.
     */updateUVs:function(){var t=this.cutX,e=this.cutY,i=this.cutWidth,n=this.cutHeight,s=this.data.drawImage;s.width=i,s.height=n;//  WebGL data
var r=this.source.width,o=this.source.height;return this.u0=t/r,this.v0=e/o,this.u1=(t+i)/r,this.v1=(e+n)/o,this},/**
     * Updates the internal WebGL UV cache.
     *
     * @method Phaser.Textures.Frame#updateUVsInverted
     * @since 3.0.0
     *
     * @return {Phaser.Textures.Frame} This Frame object.
     */updateUVsInverted:function(){var t=this.source.width,e=this.source.height;return this.u0=(this.cutX+this.cutHeight)/t,this.v0=this.cutY/e,this.u1=this.cutX/t,this.v1=(this.cutY+this.cutWidth)/e,this},/**
     * Clones this Frame into a new Frame object.
     *
     * @method Phaser.Textures.Frame#clone
     * @since 3.0.0
     *
     * @return {Phaser.Textures.Frame} A clone of this Frame.
     */clone:function(){var t=new o(this.texture,this.name,this.sourceIndex);return t.cutX=this.cutX,t.cutY=this.cutY,t.cutWidth=this.cutWidth,t.cutHeight=this.cutHeight,t.x=this.x,t.y=this.y,t.width=this.width,t.height=this.height,t.halfWidth=this.halfWidth,t.halfHeight=this.halfHeight,t.centerX=this.centerX,t.centerY=this.centerY,t.rotated=this.rotated,t.data=r(!0,t.data,this.data),t.updateUVs(),t},/**
     * Destroys this Frame by nulling its reference to the parent Texture and and data objects.
     *
     * @method Phaser.Textures.Frame#destroy
     * @since 3.0.0
     */destroy:function(){this.source=null,this.texture=null,this.glTexture=null,this.customData=null,this.data=null},/**
     * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
     * before being packed.
     *
     * @name Phaser.Textures.Frame#realWidth
     * @type {number}
     * @readonly
     * @since 3.0.0
     */realWidth:{get:function(){return this.data.sourceSize.w}},/**
     * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
     * before being packed.
     *
     * @name Phaser.Textures.Frame#realHeight
     * @type {number}
     * @readonly
     * @since 3.0.0
     */realHeight:{get:function(){return this.data.sourceSize.h}},/**
     * The radius of the Frame (derived from sqrt(w * w + h * h) / 2)
     *
     * @name Phaser.Textures.Frame#radius
     * @type {number}
     * @readonly
     * @since 3.0.0
     */radius:{get:function(){return this.data.radius}},/**
     * Is the Frame trimmed or not?
     *
     * @name Phaser.Textures.Frame#trimmed
     * @type {boolean}
     * @readonly
     * @since 3.0.0
     */trimmed:{get:function(){return this.data.trim}},/**
     * The Canvas drawImage data object.
     *
     * @name Phaser.Textures.Frame#canvasData
     * @type {object}
     * @readonly
     * @since 3.0.0
     */canvasData:{get:function(){return this.data.drawImage}}});t.exports=o}),r("k25Vv",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kKoer"),n=s("jwj1g"),r=s("gV9Y0"),o=s("1iebW"),a=new n({initialize:function(t,e,i,n,s){void 0===s&&(s=!1);var a=t.manager.game;/**
         * The Texture this TextureSource belongs to.
         *
         * @name Phaser.Textures.TextureSource#renderer
         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}
         * @since 3.7.0
         */this.renderer=a.renderer,/**
         * The Texture this TextureSource belongs to.
         *
         * @name Phaser.Textures.TextureSource#texture
         * @type {Phaser.Textures.Texture}
         * @since 3.0.0
         */this.texture=t,/**
         * The source of the image data.
         * 
         * This is either an Image Element, a Canvas Element, a Video Element, a RenderTexture or a WebGLTexture.
         *
         * @name Phaser.Textures.TextureSource#source
         * @type {(HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|Phaser.GameObjects.RenderTexture|WebGLTexture)}
         * @since 3.12.0
         */this.source=e,/**
         * The image data.
         * 
         * This is either an Image element, Canvas element or a Video Element.
         *
         * @name Phaser.Textures.TextureSource#image
         * @type {(HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)}
         * @since 3.0.0
         */this.image=e,/**
         * Currently un-used.
         *
         * @name Phaser.Textures.TextureSource#compressionAlgorithm
         * @type {integer}
         * @default null
         * @since 3.0.0
         */this.compressionAlgorithm=null,/**
         * The resolution of the source image.
         *
         * @name Phaser.Textures.TextureSource#resolution
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.resolution=1,/**
         * The width of the source image. If not specified in the constructor it will check
         * the `naturalWidth` and then `width` properties of the source image.
         *
         * @name Phaser.Textures.TextureSource#width
         * @type {integer}
         * @since 3.0.0
         */this.width=i||e.naturalWidth||e.videoWidth||e.width||0,/**
         * The height of the source image. If not specified in the constructor it will check
         * the `naturalHeight` and then `height` properties of the source image.
         *
         * @name Phaser.Textures.TextureSource#height
         * @type {integer}
         * @since 3.0.0
         */this.height=n||e.naturalHeight||e.videoHeight||e.height||0,/**
         * The Scale Mode the image will use when rendering.
         * Either Linear or Nearest.
         *
         * @name Phaser.Textures.TextureSource#scaleMode
         * @type {number}
         * @since 3.0.0
         */this.scaleMode=o.DEFAULT,/**
         * Is the source image a Canvas Element?
         *
         * @name Phaser.Textures.TextureSource#isCanvas
         * @type {boolean}
         * @since 3.0.0
         */this.isCanvas=e instanceof HTMLCanvasElement,/**
         * Is the source image a Video Element?
         *
         * @name Phaser.Textures.TextureSource#isVideo
         * @type {boolean}
         * @since 3.20.0
         */this.isVideo=window.hasOwnProperty("HTMLVideoElement")&&e instanceof HTMLVideoElement,/**
         * Is the source image a Render Texture?
         *
         * @name Phaser.Textures.TextureSource#isRenderTexture
         * @type {boolean}
         * @since 3.12.0
         */this.isRenderTexture="RenderTexture"===e.type,/**
         * Is the source image a WebGLTexture?
         *
         * @name Phaser.Textures.TextureSource#isGLTexture
         * @type {boolean}
         * @since 3.19.0
         */this.isGLTexture=window.hasOwnProperty("WebGLTexture")&&e instanceof WebGLTexture,/**
         * Are the source image dimensions a power of two?
         *
         * @name Phaser.Textures.TextureSource#isPowerOf2
         * @type {boolean}
         * @since 3.0.0
         */this.isPowerOf2=r(this.width,this.height),/**
         * The WebGL Texture of the source image. If this TextureSource is driven from a WebGLTexture
         * already, then this is a reference to that WebGLTexture.
         *
         * @name Phaser.Textures.TextureSource#glTexture
         * @type {?WebGLTexture}
         * @default null
         * @since 3.0.0
         */this.glTexture=null,/**
         * Sets the `UNPACK_FLIP_Y_WEBGL` flag the WebGL Texture uses during upload.
         *
         * @name Phaser.Textures.TextureSource#flipY
         * @type {boolean}
         * @since 3.20.0
         */this.flipY=s,this.init(a)},/**
     * Creates a WebGL Texture, if required, and sets the Texture filter mode.
     *
     * @method Phaser.Textures.TextureSource#init
     * @since 3.0.0
     *
     * @param {Phaser.Game} game - A reference to the Phaser Game instance.
     */init:function(t){this.renderer&&(this.renderer.gl?this.isCanvas?this.glTexture=this.renderer.createCanvasTexture(this.image,!1,this.flipY):this.isVideo?this.glTexture=this.renderer.createVideoTexture(this.image,!1,this.flipY):this.isRenderTexture?(this.image=this.source.canvas,this.glTexture=this.renderer.createTextureFromSource(null,this.width,this.height,this.scaleMode)):this.isGLTexture?this.glTexture=this.source:this.glTexture=this.renderer.createTextureFromSource(this.image,this.width,this.height,this.scaleMode):this.isRenderTexture&&(this.image=this.source.canvas)),t.config.antialias||this.setFilter(1)},/**
     * Sets the Filter Mode for this Texture.
     *
     * The mode can be either Linear, the default, or Nearest.
     *
     * For pixel-art you should use Nearest.
     *
     * @method Phaser.Textures.TextureSource#setFilter
     * @since 3.0.0
     *
     * @param {Phaser.Textures.FilterMode} filterMode - The Filter Mode.
     */setFilter:function(t){this.renderer.gl&&this.renderer.setTextureFilter(this.glTexture,t),this.scaleMode=t},/**
     * Sets the `UNPACK_FLIP_Y_WEBGL` flag for the WebGL Texture during texture upload.
     *
     * @method Phaser.Textures.TextureSource#setFlipY
     * @since 3.20.0
     *
     * @param {boolean} [value=true] - Should the WebGL Texture be flipped on the Y axis on texture upload or not?
     */setFlipY:function(t){return void 0===t&&(t=!0),this.flipY=t,this},/**
     * If this TextureSource is backed by a Canvas and is running under WebGL,
     * it updates the WebGLTexture using the canvas data.
     *
     * @method Phaser.Textures.TextureSource#update
     * @since 3.7.0
     */update:function(){var t=this.renderer.gl;t&&this.isCanvas?this.glTexture=this.renderer.updateCanvasTexture(this.image,this.glTexture,this.flipY):t&&this.isVideo&&(this.glTexture=this.renderer.updateVideoTexture(this.image,this.glTexture,this.flipY))},/**
     * Destroys this Texture Source and nulls the references.
     *
     * @method Phaser.Textures.TextureSource#destroy
     * @since 3.0.0
     */destroy:function(){this.glTexture&&this.renderer.deleteTexture(this.glTexture),this.isCanvas&&i.remove(this.image),this.renderer=null,this.texture=null,this.source=null,this.image=null,this.glTexture=null}});t.exports=a}),r("jx0HO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Textures.Parsers
 */t.exports={AtlasXML:s("7a76q"),Canvas:s("bz440"),Image:s("5pLtu"),JSONArray:s("daSEJ"),JSONHash:s("hJexV"),SpriteSheet:s("ftOGv"),SpriteSheetFromAtlas:s("aeqbU"),UnityYAML:s("efYKh")}}),r("7a76q",function(t,e){t.exports=function(t,e,i){//  Malformed?
if(!i.getElementsByTagName("TextureAtlas")){console.warn("Invalid Texture Atlas XML given");return}//  Add in a __BASE entry (for the entire atlas)
var n,s=t.source[e];t.add("__BASE",e,0,0,s.width,s.height);for(var r=i.getElementsByTagName("SubTexture"),o=0;o<r.length;o++){var a=r[o].attributes,h=a.name.value,l=parseInt(a.x.value,10),u=parseInt(a.y.value,10),c=parseInt(a.width.value,10),d=parseInt(a.height.value,10);//  These are the original (non-trimmed) sprite values
if(//  The frame values are the exact coordinates to cut the frame out of the atlas from
n=t.add(h,e,l,u,c,d),a.frameX){var f=Math.abs(parseInt(a.frameX.value,10)),p=Math.abs(parseInt(a.frameY.value,10)),g=parseInt(a.frameWidth.value,10),v=parseInt(a.frameHeight.value,10);n.setTrim(c,d,f,p,g,v)}}return t}}),r("bz440",function(t,e){t.exports=function(t,e){var i=t.source[e];return t.add("__BASE",e,0,0,i.width,i.height),t}}),r("5pLtu",function(t,e){t.exports=function(t,e){var i=t.source[e];return t.add("__BASE",e,0,0,i.width,i.height),t}}),r("daSEJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5pqmQ");t.exports=function(t,e,n){//  Malformed?
if(!n.frames&&!n.textures){console.warn("Invalid Texture Atlas JSON Array");return}//  Add in a __BASE entry (for the entire atlas)
var s,r=t.source[e];t.add("__BASE",e,0,0,r.width,r.height);for(var o=Array.isArray(n.textures)?n.textures[e].frames:n.frames,a=0;a<o.length;a++){var h=o[a];//  The frame values are the exact coordinates to cut the frame out of the atlas from
s=t.add(h.filename,e,h.frame.x,h.frame.y,h.frame.w,h.frame.h),h.trimmed&&s.setTrim(h.sourceSize.w,h.sourceSize.h,h.spriteSourceSize.x,h.spriteSourceSize.y,h.spriteSourceSize.w,h.spriteSourceSize.h),h.rotated&&(s.rotated=!0,s.updateUVsInverted());var l=h.anchor||h.pivot;l&&(s.customPivot=!0,s.pivotX=l.x,s.pivotY=l.y),//  Copy over any extra data
s.customData=i(h)}//  Copy over any additional data that was in the JSON to Texture.customData
for(var u in n)"frames"!==u&&(Array.isArray(n[u])?t.customData[u]=n[u].slice(0):t.customData[u]=n[u]);return t}}),r("hJexV",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5pqmQ");t.exports=function(t,e,n){//  Malformed?
if(!n.frames){console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object");return}//  Add in a __BASE entry (for the entire atlas)
var s,r=t.source[e];t.add("__BASE",e,0,0,r.width,r.height);//  By this stage frames is a fully parsed Object
var o=n.frames;for(var a in o){var h=o[a];//  The frame values are the exact coordinates to cut the frame out of the atlas from
s=t.add(a,e,h.frame.x,h.frame.y,h.frame.w,h.frame.h),h.trimmed&&s.setTrim(h.sourceSize.w,h.sourceSize.h,h.spriteSourceSize.x,h.spriteSourceSize.y,h.spriteSourceSize.w,h.spriteSourceSize.h),h.rotated&&(s.rotated=!0,s.updateUVsInverted());var l=h.anchor||h.pivot;l&&(s.customPivot=!0,s.pivotX=l.x,s.pivotY=l.y),//  Copy over any extra data
s.customData=i(h)}//  Copy over any additional data that was in the JSON to Texture.customData
for(var u in n)"frames"!==u&&(Array.isArray(n[u])?t.customData[u]=n[u].slice(0):t.customData[u]=n[u]);return t}}),r("ftOGv",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7BSWl");t.exports=function(t,e,n,s,r,o,a){var h=i(a,"frameWidth",null),l=i(a,"frameHeight",h);//  If missing we can't proceed
if(null===h)throw Error("TextureManager.SpriteSheet: Invalid frameWidth given.");//  Add in a __BASE entry (for the entire atlas)
var u=t.source[e];t.add("__BASE",e,0,0,u.width,u.height);var c=i(a,"startFrame",0),d=i(a,"endFrame",-1),f=i(a,"margin",0),p=i(a,"spacing",0),g=Math.floor((r-f+p)/(h+p))*Math.floor((o-f+p)/(l+p));0===g&&console.warn("SpriteSheet frame dimensions will result in zero frames."),(c>g||c<-g)&&(c=0),c<0&&(c=g+c),-1!==d&&(g=c+(d+1));for(var v=f,m=f,y=0,x=0,w=0;w<g;w++){y=0,x=0;var T=v+h,b=m+l;T>r&&(y=T-r),b>o&&(x=b-o),t.add(w,e,n+v,s+m,h-y,l-x),(v+=h+p)+h>r&&(v=f,m+=l+p)}return t}}),r("aeqbU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7BSWl");t.exports=function(t,e,n){var s,r=i(n,"frameWidth",null),o=i(n,"frameHeight",r);//  If missing we can't proceed
if(!r)throw Error("TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.");//  Add in a __BASE entry (for the entire atlas frame)
var a=t.source[0];t.add("__BASE",0,0,0,a.width,a.height);var h=i(n,"startFrame",0),l=i(n,"endFrame",-1),u=i(n,"margin",0),c=i(n,"spacing",0),d=e.cutX,f=e.cutY,p=e.cutWidth,g=e.cutHeight,v=e.realWidth,m=e.realHeight,y=Math.floor((v-u+c)/(r+c)),x=Math.floor((m-u+c)/(o+c)),w=y*x,T=e.x,b=r-T,S=r-(v-p-T),A=e.y,E=o-A,_=o-(m-g-A);(h>w||h<-w)&&(h=0),h<0&&(h=w+h),-1!==l&&(w=h+(l+1));for(var C=u,M=u,P=0,O=e.sourceIndex,R=0;R<x;R++){for(var L=0===R,k=R===x-1,D=0;D<y;D++){var F=0===D,I=D===y-1;if(s=t.add(P,O,d+C,f+M,r,o),F||L||I||k){var B=F?T:0,N=L?A:0,Y=0,z=0;F&&(Y+=r-b),I&&(Y+=r-S),L&&(z+=o-E),k&&(z+=o-_);var j=r-Y,X=o-z;s.cutWidth=j,s.cutHeight=X,s.setTrim(r,o,B,N,j,X)}C+=c,F?C+=b:I?C+=S:C+=r,P++}C=u,M+=c,L?M+=E:k?M+=_:M+=o}return t}}),r("efYKh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=0,n=function(t,e,n,s){//  The frame values are the exact coordinates to cut the frame out of the atlas from
var r=i-s.y-s.height;t.add(n,e,s.x,r,s.width,s.height);//  These are the original (non-trimmed) sprite values
/*
    if (src.trimmed)
    {
        newFrame.setTrim(
            src.sourceSize.w,
            src.sourceSize.h,
            src.spriteSourceSize.x,
            src.spriteSourceSize.y,
            src.spriteSourceSize.w,
            src.spriteSourceSize.h
        );
    }
    */};t.exports=function(t,e,s){//  Add in a __BASE entry (for the entire atlas)
var r=t.source[e];t.add("__BASE",e,0,0,r.width,r.height),i=r.height;// var pivot = { x: 0, y: 0 };
// var border = { x: 0, y: 0, z: 0, w: 0 };
for(var o=s.split("\n"),a=/^[ ]*(- )*(\w+)+[: ]+(.*)/,h="",l="",u={x:0,y:0,width:0,height:0},c=0;c<o.length;c++){var d=o[c].match(a);if(d){var f="- "===d[1],p=d[2],g=d[3];if(f&&(l!==h&&(n(t,e,l,u),h=l),u={x:0,y:0,width:0,height:0}),"name"===p){//  Start new list
l=g;continue}switch(p){case"x":case"y":case"width":case"height":u[p]=parseInt(g,10)}}}return l!==h&&n(t,e,l,u),t};/*
Example data:

TextureImporter:
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  spriteSheet:
    sprites:
    - name: asteroids_0
      rect:
        serializedVersion: 2
        x: 5
        y: 328
        width: 65
        height: 82
      alignment: 0
      pivot: {x: 0, y: 0}
      border: {x: 0, y: 0, z: 0, w: 0}
    - name: asteroids_1
      rect:
        serializedVersion: 2
        x: 80
        y: 322
        width: 53
        height: 88
      alignment: 0
      pivot: {x: 0, y: 0}
      border: {x: 0, y: 0, z: 0, w: 0}
  spritePackingTag: Asteroids
*/}),r("jskqO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("4eU0A"),n=s("5wl8F"),r=s("d69lL");t.exports={create:function(t){var e=t.config.audio,s=t.device.audio;return e&&e.noAudio||!s.webAudio&&!s.audioData?new n(t):s.webAudio&&!(e&&e.disableWebAudio)?new r(t):new i(t)}}}),r("4eU0A",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hw6uH"),n=s("jwj1g"),r=s("kcpiS"),o=s("1jI3b"),a=new n({Extends:i,initialize:function(t){/**
         * Flag indicating whether if there are no idle instances of HTML5 Audio tag,
         * for any particular sound, if one of the used tags should be hijacked and used
         * for succeeding playback or if succeeding Phaser.Sound.HTML5AudioSound#play
         * call should be ignored.
         *
         * @name Phaser.Sound.HTML5AudioSoundManager#override
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.override=!0,/**
         * Value representing time difference, in seconds, between calling
         * play method on an audio tag and when it actually starts playing.
         * It is used to achieve more accurate delayed sound playback.
         *
         * You might need to tweak this value to get the desired results
         * since audio play delay varies depending on the browser/platform.
         *
         * @name Phaser.Sound.HTML5AudioSoundManager#audioPlayDelay
         * @type {number}
         * @default 0.1
         * @since 3.0.0
         */this.audioPlayDelay=.1,/**
         * A value by which we should offset the loop end marker of the
         * looping sound to compensate for lag, caused by changing audio
         * tag playback position, in order to achieve gapless looping.
         *
         * You might need to tweak this value to get the desired results
         * since loop lag varies depending on the browser/platform.
         *
         * @name Phaser.Sound.HTML5AudioSoundManager#loopEndOffset
         * @type {number}
         * @default 0.05
         * @since 3.0.0
         */this.loopEndOffset=.05,/**
         * An array for keeping track of all the sounds
         * that were paused when game lost focus.
         *
         * @name Phaser.Sound.HTML5AudioSoundManager#onBlurPausedSounds
         * @type {Phaser.Sound.HTML5AudioSound[]}
         * @private
         * @default []
         * @since 3.0.0
         */this.onBlurPausedSounds=[],this.locked="ontouchstart"in window,/**
         * A queue of all actions performed on sound objects while audio was locked.
         * Once the audio gets unlocked, after an explicit user interaction,
         * all actions will be performed in chronological order.
         * Array of object types: { sound: Phaser.Sound.HTML5AudioSound, name: string, value?: * }
         *
         * @name Phaser.Sound.HTML5AudioSoundManager#lockedActionsQueue
         * @type {array}
         * @private
         * @since 3.0.0
         */this.lockedActionsQueue=this.locked?[]:null,/**
         * Property that actually holds the value of global mute
         * for HTML5 Audio sound manager implementation.
         *
         * @name Phaser.Sound.HTML5AudioSoundManager#_mute
         * @type {boolean}
         * @private
         * @default false
         * @since 3.0.0
         */this._mute=!1,/**
         * Property that actually holds the value of global volume
         * for HTML5 Audio sound manager implementation.
         *
         * @name Phaser.Sound.HTML5AudioSoundManager#_volume
         * @type {boolean}
         * @private
         * @default 1
         * @since 3.0.0
         */this._volume=1,i.call(this,t)},/**
     * Adds a new sound into the sound manager.
     *
     * @method Phaser.Sound.HTML5AudioSoundManager#add
     * @since 3.0.0
     *
     * @param {string} key - Asset key for the sound.
     * @param {Phaser.Types.Sound.SoundConfig} [config] - An optional config object containing default sound settings.
     *
     * @return {Phaser.Sound.HTML5AudioSound} The new sound instance.
     */add:function(t,e){var i=new o(this,t,e);return this.sounds.push(i),i},/**
     * Unlocks HTML5 Audio loading and playback on mobile
     * devices on the initial explicit user interaction.
     *
     * @method Phaser.Sound.HTML5AudioSoundManager#unlock
     * @since 3.0.0
     */unlock:function(){this.locked=!1;var t=this;if(this.game.cache.audio.entries.each(function(e,i){for(var n=0;n<i.length;n++)if("true"===i[n].dataset.locked)return t.locked=!0,!1;return!0}),this.locked){var e=!1,i=function(){e=!0},n=function(){if(e){e=!1;return}document.body.removeEventListener("touchmove",i),document.body.removeEventListener("touchend",n);var s=[];if(t.game.cache.audio.entries.each(function(t,e){for(var i=0;i<e.length;i++){var n=e[i];"true"===n.dataset.locked&&s.push(n)}return!0}),0!==s.length){var r=s[s.length-1];r.oncanplaythrough=function(){r.oncanplaythrough=null,s.forEach(function(t){t.dataset.locked="false"}),t.unlocked=!0},s.forEach(function(t){t.load()})}};this.once(r.UNLOCKED,function(){for(this.forEachActiveSound(function(t){null===t.currentMarker&&0===t.duration&&(t.duration=t.tags[0].duration),t.totalDuration=t.tags[0].duration});this.lockedActionsQueue.length;){var t=this.lockedActionsQueue.shift();t.sound[t.prop].apply?t.sound[t.prop].apply(t.sound,t.value||[]):t.sound[t.prop]=t.value}},this),document.body.addEventListener("touchmove",i,!1),document.body.addEventListener("touchend",n,!1)}},/**
     * Method used internally for pausing sound manager if
     * Phaser.Sound.HTML5AudioSoundManager#pauseOnBlur is set to true.
     *
     * @method Phaser.Sound.HTML5AudioSoundManager#onBlur
     * @protected
     * @since 3.0.0
     */onBlur:function(){this.forEachActiveSound(function(t){t.isPlaying&&(this.onBlurPausedSounds.push(t),t.onBlur())})},/**
     * Method used internally for resuming sound manager if
     * Phaser.Sound.HTML5AudioSoundManager#pauseOnBlur is set to true.
     *
     * @method Phaser.Sound.HTML5AudioSoundManager#onFocus
     * @protected
     * @since 3.0.0
     */onFocus:function(){this.onBlurPausedSounds.forEach(function(t){t.onFocus()}),this.onBlurPausedSounds.length=0},/**
     * Calls Phaser.Sound.BaseSoundManager#destroy method
     * and cleans up all HTML5 Audio related stuff.
     *
     * @method Phaser.Sound.HTML5AudioSoundManager#destroy
     * @since 3.0.0
     */destroy:function(){i.prototype.destroy.call(this),this.onBlurPausedSounds.length=0,this.onBlurPausedSounds=null},/**
     * Method used internally by Phaser.Sound.HTML5AudioSound class methods and property setters
     * to check if sound manager is locked and then either perform action immediately or queue it
     * to be performed once the sound manager gets unlocked.
     *
     * @method Phaser.Sound.HTML5AudioSoundManager#isLocked
     * @protected
     * @since 3.0.0
     *
     * @param {Phaser.Sound.HTML5AudioSound} sound - Sound object on which to perform queued action.
     * @param {string} prop - Name of the method to be called or property to be assigned a value to.
     * @param {*} [value] - An optional parameter that either holds an array of arguments to be passed to the method call or value to be set to the property.
     *
     * @return {boolean} Whether the sound manager is locked.
     */isLocked:function(t,e,i){return"true"===t.tags[0].dataset.locked&&(this.lockedActionsQueue.push({sound:t,prop:e,value:i}),!0)},/**
     * Sets the muted state of all this Sound Manager.
     *
     * @method Phaser.Sound.HTML5AudioSoundManager#setMute
     * @fires Phaser.Sound.Events#GLOBAL_MUTE
     * @since 3.3.0
     *
     * @param {boolean} value - `true` to mute all sounds, `false` to unmute them.
     *
     * @return {Phaser.Sound.HTML5AudioSoundManager} This Sound Manager.
     */setMute:function(t){return this.mute=t,this},/**
     * @name Phaser.Sound.HTML5AudioSoundManager#mute
     * @type {boolean}
     * @fires Phaser.Sound.Events#GLOBAL_MUTE
     * @since 3.0.0
     */mute:{get:function(){return this._mute},set:function(t){this._mute=t,this.forEachActiveSound(function(t){t.updateMute()}),this.emit(r.GLOBAL_MUTE,this,t)}},/**
     * Sets the volume of this Sound Manager.
     *
     * @method Phaser.Sound.HTML5AudioSoundManager#setVolume
     * @fires Phaser.Sound.Events#GLOBAL_VOLUME
     * @since 3.3.0
     *
     * @param {number} value - The global volume of this Sound Manager.
     *
     * @return {Phaser.Sound.HTML5AudioSoundManager} This Sound Manager.
     */setVolume:function(t){return this.volume=t,this},/**
     * @name Phaser.Sound.HTML5AudioSoundManager#volume
     * @type {number}
     * @fires Phaser.Sound.Events#GLOBAL_VOLUME
     * @since 3.0.0
     */volume:{get:function(){return this._volume},set:function(t){this._volume=t,this.forEachActiveSound(function(t){t.updateVolume()}),this.emit(r.GLOBAL_VOLUME,this,t)}}});t.exports=a}),r("hw6uH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("5pqmQ"),r=s("3vRz3"),o=s("kcpiS"),a=s("aqcI1"),h=s("13GYA"),l=s("9CZay"),u=s("at5Hg"),c=new i({Extends:r,initialize:function(t){r.call(this),/**
         * Local reference to game.
         *
         * @name Phaser.Sound.BaseSoundManager#game
         * @type {Phaser.Game}
         * @readonly
         * @since 3.0.0
         */this.game=t,/**
         * Local reference to the JSON Cache, as used by Audio Sprites.
         *
         * @name Phaser.Sound.BaseSoundManager#jsonCache
         * @type {Phaser.Cache.BaseCache}
         * @readonly
         * @since 3.7.0
         */this.jsonCache=t.cache.json,/**
         * An array containing all added sounds.
         *
         * @name Phaser.Sound.BaseSoundManager#sounds
         * @type {Phaser.Sound.BaseSound[]}
         * @default []
         * @private
         * @since 3.0.0
         */this.sounds=[],/**
         * Global mute setting.
         *
         * @name Phaser.Sound.BaseSoundManager#mute
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.mute=!1,/**
         * Global volume setting.
         *
         * @name Phaser.Sound.BaseSoundManager#volume
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.volume=1,/**
         * Flag indicating if sounds should be paused when game looses focus,
         * for instance when user switches to another tab/program/app.
         *
         * @name Phaser.Sound.BaseSoundManager#pauseOnBlur
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.pauseOnBlur=!0,/**
         * Property that actually holds the value of global playback rate.
         *
         * @name Phaser.Sound.BaseSoundManager#_rate
         * @type {number}
         * @private
         * @default 1
         * @since 3.0.0
         */this._rate=1,/**
         * Property that actually holds the value of global detune.
         *
         * @name Phaser.Sound.BaseSoundManager#_detune
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._detune=0,/**
         * Mobile devices require sounds to be triggered from an explicit user action,
         * such as a tap, before any sound can be loaded/played on a web page.
         * Set to true if the audio system is currently locked awaiting user interaction.
         *
         * @name Phaser.Sound.BaseSoundManager#locked
         * @type {boolean}
         * @readonly
         * @since 3.0.0
         */this.locked=this.locked||!1,/**
         * Flag used internally for handling when the audio system
         * has been unlocked, if there ever was a need for it.
         *
         * @name Phaser.Sound.BaseSoundManager#unlocked
         * @type {boolean}
         * @default false
         * @private
         * @since 3.0.0
         */this.unlocked=!1,t.events.on(a.BLUR,this.onGameBlur,this),t.events.on(a.FOCUS,this.onGameFocus,this),t.events.on(a.PRE_STEP,this.update,this),t.events.once(a.DESTROY,this.destroy,this)},/**
     * Adds a new sound into the sound manager.
     *
     * @method Phaser.Sound.BaseSoundManager#add
     * @override
     * @since 3.0.0
     *
     * @param {string} key - Asset key for the sound.
     * @param {Phaser.Types.Sound.SoundConfig} [config] - An optional config object containing default sound settings.
     *
     * @return {Phaser.Sound.BaseSound} The new sound instance.
     */add:h,/**
     * Adds a new audio sprite sound into the sound manager.
     * Audio Sprites are a combination of audio files and a JSON configuration.
     * The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite
     *
     * @method Phaser.Sound.BaseSoundManager#addAudioSprite
     * @since 3.0.0
     *
     * @param {string} key - Asset key for the sound.
     * @param {Phaser.Types.Sound.SoundConfig} [config] - An optional config object containing default sound settings.
     *
     * @return {(Phaser.Sound.HTML5AudioSound|Phaser.Sound.WebAudioSound)} The new audio sprite sound instance.
     */addAudioSprite:function(t,e){void 0===e&&(e={});var i=this.add(t,e);for(var s in i.spritemap=this.jsonCache.get(t).spritemap,i.spritemap)if(i.spritemap.hasOwnProperty(s)){var r=n(e),o=i.spritemap[s];r.loop=!!o.hasOwnProperty("loop")&&o.loop,i.addMarker({name:s,start:o.start,duration:o.end-o.start,config:r})}return i},/**
     * Gets the first sound in the manager matching the given key, if any.
     *
     * @method Phaser.Sound.BaseSoundManager#get
     * @since 3.23.0
     *
     * @param {string} key - Sound asset key.
     *
     * @return {?Phaser.Sound.BaseSound} - The sound, or null.
     */get:function(t){return u(this.sounds,"key",t)},/**
     * Gets any sounds in the manager matching the given key.
     *
     * @method Phaser.Sound.BaseSoundManager#getAll
     * @since 3.23.0
     *
     * @param {string} key - Sound asset key.
     *
     * @return {Phaser.Sound.BaseSound[]} - The sounds, or an empty array.
     */getAll:function(t){return l(this.sounds,"key",t)},/**
     * Adds a new sound to the sound manager and plays it.
     * The sound will be automatically removed (destroyed) once playback ends.
     * This lets you play a new sound on the fly without the need to keep a reference to it.
     *
     * @method Phaser.Sound.BaseSoundManager#play
     * @listens Phaser.Sound.Events#COMPLETE
     * @since 3.0.0
     *
     * @param {string} key - Asset key for the sound.
     * @param {(Phaser.Types.Sound.SoundConfig|Phaser.Types.Sound.SoundMarker)} [extra] - An optional additional object containing settings to be applied to the sound. It could be either config or marker object.
     *
     * @return {boolean} Whether the sound started playing successfully.
     */play:function(t,e){var i=this.add(t);return(i.once(o.COMPLETE,i.destroy,i),e)?e.name?(i.addMarker(e),i.play(e.name)):i.play(e):i.play()},/**
     * Adds a new audio sprite sound to the sound manager and plays it.
     * The sprite will be automatically removed (destroyed) once playback ends.
     * This lets you play a new sound on the fly without the need to keep a reference to it.
     *
     * @method Phaser.Sound.BaseSoundManager#playAudioSprite
     * @listens Phaser.Sound.Events#COMPLETE
     * @since 3.0.0
     *
     * @param {string} key - Asset key for the sound.
     * @param {string} spriteName - The name of the sound sprite to play.
     * @param {Phaser.Types.Sound.SoundConfig} [config] - An optional config object containing default sound settings.
     *
     * @return {boolean} Whether the audio sprite sound started playing successfully.
     */playAudioSprite:function(t,e,i){var n=this.addAudioSprite(t);return n.once(o.COMPLETE,n.destroy,n),n.play(e,i)},/**
     * Removes a sound from the sound manager.
     * The removed sound is destroyed before removal.
     *
     * @method Phaser.Sound.BaseSoundManager#remove
     * @since 3.0.0
     *
     * @param {Phaser.Sound.BaseSound} sound - The sound object to remove.
     *
     * @return {boolean} True if the sound was removed successfully, otherwise false.
     */remove:function(t){var e=this.sounds.indexOf(t);return -1!==e&&(t.destroy(),this.sounds.splice(e,1),!0)},/**
     * Removes all sounds from the manager, destroying the sounds.
     *
     * @method Phaser.Sound.BaseSoundManager#removeAll
     * @since 3.23.0
     */removeAll:function(){this.sounds.forEach(function(t){t.destroy()}),this.sounds.length=0},/**
     * Removes all sounds from the sound manager that have an asset key matching the given value.
     * The removed sounds are destroyed before removal.
     *
     * @method Phaser.Sound.BaseSoundManager#removeByKey
     * @since 3.0.0
     *
     * @param {string} key - The key to match when removing sound objects.
     *
     * @return {number} The number of matching sound objects that were removed.
     */removeByKey:function(t){for(var e=0,i=this.sounds.length-1;i>=0;i--){var n=this.sounds[i];n.key===t&&(n.destroy(),this.sounds.splice(i,1),e++)}return e},/**
     * Pauses all the sounds in the game.
     *
     * @method Phaser.Sound.BaseSoundManager#pauseAll
     * @fires Phaser.Sound.Events#PAUSE_ALL
     * @since 3.0.0
     */pauseAll:function(){this.forEachActiveSound(function(t){t.pause()}),this.emit(o.PAUSE_ALL,this)},/**
     * Resumes all the sounds in the game.
     *
     * @method Phaser.Sound.BaseSoundManager#resumeAll
     * @fires Phaser.Sound.Events#RESUME_ALL
     * @since 3.0.0
     */resumeAll:function(){this.forEachActiveSound(function(t){t.resume()}),this.emit(o.RESUME_ALL,this)},/**
     * Stops all the sounds in the game.
     *
     * @method Phaser.Sound.BaseSoundManager#stopAll
     * @fires Phaser.Sound.Events#STOP_ALL
     * @since 3.0.0
     */stopAll:function(){this.forEachActiveSound(function(t){t.stop()}),this.emit(o.STOP_ALL,this)},/**
     * Stops any sounds matching the given key.
     *
     * @method Phaser.Sound.BaseSoundManager#stopByKey
     * @since 3.23.0
     *
     * @param {string} key - Sound asset key.
     *
     * @return {number} - How many sounds were stopped.
     */stopByKey:function(t){var e=0;return this.getAll(t).forEach(function(t){t.stop()&&e++}),e},/**
     * Method used internally for unlocking audio playback on devices that
     * require user interaction before any sound can be played on a web page.
     *
     * Read more about how this issue is handled here in [this article](https://medium.com/@pgoloskokovic/unlocking-web-audio-the-smarter-way-8858218c0e09).
     *
     * @method Phaser.Sound.BaseSoundManager#unlock
     * @override
     * @protected
     * @since 3.0.0
     */unlock:h,/**
     * Method used internally for pausing sound manager if
     * Phaser.Sound.BaseSoundManager#pauseOnBlur is set to true.
     *
     * @method Phaser.Sound.BaseSoundManager#onBlur
     * @override
     * @protected
     * @since 3.0.0
     */onBlur:h,/**
     * Method used internally for resuming sound manager if
     * Phaser.Sound.BaseSoundManager#pauseOnBlur is set to true.
     *
     * @method Phaser.Sound.BaseSoundManager#onFocus
     * @override
     * @protected
     * @since 3.0.0
     */onFocus:h,/**
     * Internal handler for Phaser.Core.Events#BLUR.
     *
     * @method Phaser.Sound.BaseSoundManager#onGameBlur
     * @private
     * @since 3.23.0
     */onGameBlur:function(){this.pauseOnBlur&&this.onBlur()},/**
     * Internal handler for Phaser.Core.Events#FOCUS.
     *
     * @method Phaser.Sound.BaseSoundManager#onGameFocus
     * @private
     * @since 3.23.0
     */onGameFocus:function(){this.pauseOnBlur&&this.onFocus()},/**
     * Update method called on every game step.
     * Removes destroyed sounds and updates every active sound in the game.
     *
     * @method Phaser.Sound.BaseSoundManager#update
     * @protected
     * @fires Phaser.Sound.Events#UNLOCKED
     * @since 3.0.0
     *
     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time elapsed since the last frame.
     */update:function(t,e){this.unlocked&&(this.unlocked=!1,this.locked=!1,this.emit(o.UNLOCKED,this));for(var i=this.sounds.length-1;i>=0;i--)this.sounds[i].pendingRemove&&this.sounds.splice(i,1);this.sounds.forEach(function(i){i.update(t,e)})},/**
     * Destroys all the sounds in the game and all associated events.
     *
     * @method Phaser.Sound.BaseSoundManager#destroy
     * @since 3.0.0
     */destroy:function(){this.game.events.off(a.BLUR,this.onGameBlur,this),this.game.events.off(a.FOCUS,this.onGameFocus,this),this.game.events.off(a.PRE_STEP,this.update,this),this.removeAllListeners(),this.removeAll(),this.sounds.length=0,this.sounds=null,this.game=null},/**
     * Method used internally for iterating only over active sounds and skipping sounds that are marked for removal.
     *
     * @method Phaser.Sound.BaseSoundManager#forEachActiveSound
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.Types.Sound.EachActiveSoundCallback} callback - Callback function. (manager: Phaser.Sound.BaseSoundManager, sound: Phaser.Sound.BaseSound, index: number, sounds: Phaser.Manager.BaseSound[]) => void
     * @param {*} [scope] - Callback context.
     */forEachActiveSound:function(t,e){var i=this;this.sounds.forEach(function(n,s){n&&!n.pendingRemove&&t.call(e||i,n,s,i.sounds)})},/**
     * Sets the global playback rate at which all the sounds will be played.
     *
     * For example, a value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
     * and 2.0 doubles the audios playback speed.
     *
     * @method Phaser.Sound.BaseSoundManager#setRate
     * @fires Phaser.Sound.Events#GLOBAL_RATE
     * @since 3.3.0
     *
     * @param {number} value - Global playback rate at which all the sounds will be played.
     *
     * @return {Phaser.Sound.BaseSoundManager} This Sound Manager.
     */setRate:function(t){return this.rate=t,this},/**
     * Global playback rate at which all the sounds will be played.
     * Value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
     * and 2.0 doubles the audio's playback speed.
     *
     * @name Phaser.Sound.BaseSoundManager#rate
     * @type {number}
     * @default 1
     * @since 3.0.0
     */rate:{get:function(){return this._rate},set:function(t){this._rate=t,this.forEachActiveSound(function(t){t.calculateRate()}),this.emit(o.GLOBAL_RATE,this,t)}},/**
     * Sets the global detuning of all sounds in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
     * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
     *
     * @method Phaser.Sound.BaseSoundManager#setDetune
     * @fires Phaser.Sound.Events#GLOBAL_DETUNE
     * @since 3.3.0
     *
     * @param {number} value - The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
     *
     * @return {Phaser.Sound.BaseSoundManager} This Sound Manager.
     */setDetune:function(t){return this.detune=t,this},/**
     * Global detuning of all sounds in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
     * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
     *
     * @name Phaser.Sound.BaseSoundManager#detune
     * @type {number}
     * @default 0
     * @since 3.0.0
     */detune:{get:function(){return this._detune},set:function(t){this._detune=t,this.forEachActiveSound(function(t){t.calculateRate()}),this.emit(o.GLOBAL_DETUNE,this,t)}}});t.exports=c}),r("kcpiS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Sound.Events
 */t.exports={COMPLETE:s("37dJ0"),DECODED:s("hmm9y"),DECODED_ALL:s("iTPXa"),DESTROY:s("7CVWc"),DETUNE:s("kQm6q"),GLOBAL_DETUNE:s("aF0Bz"),GLOBAL_MUTE:s("cjsKe"),GLOBAL_RATE:s("g9B9q"),GLOBAL_VOLUME:s("1ne4s"),LOOP:s("kNnwh"),LOOPED:s("gAwFJ"),MUTE:s("8I72u"),PAUSE_ALL:s("gfAKp"),PAUSE:s("1ZwMn"),PLAY:s("ehBWS"),RATE:s("mufzx"),RESUME_ALL:s("ebbYi"),RESUME:s("cyWBF"),SEEK:s("XUXAf"),STOP_ALL:s("1kg4E"),STOP:s("bQ7yl"),UNLOCKED:s("lOEVP"),VOLUME:s("gdzQ9")}}),r("37dJ0",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Complete Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they complete playback.
 * 
 * Listen to it from a Sound instance using `Sound.on('complete', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('complete', listener);
 * music.play();
 * ```
 *
 * @event Phaser.Sound.Events#COMPLETE
 * @since 3.16.1
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 */t.exports="complete"}),r("hmm9y",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Audio Data Decoded Event.
 * 
 * This event is dispatched by the Web Audio Sound Manager as a result of calling the `decodeAudio` method.
 * 
 * Listen to it from the Sound Manager in a Scene using `this.sound.on('decoded', listener)`, i.e.:
 * 
 * ```javascript
 * this.sound.on('decoded', handler);
 * this.sound.decodeAudio(key, audioData);
 * ```
 *
 * @event Phaser.Sound.Events#DECODED
 * @since 3.18.0
 * 
 * @param {string} key - The key of the audio file that was decoded and added to the audio cache.
 */t.exports="decoded"}),r("iTPXa",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Audio Data Decoded All Event.
 * 
 * This event is dispatched by the Web Audio Sound Manager as a result of calling the `decodeAudio` method,
 * once all files passed to the method have been decoded (or errored).
 * 
 * Use `Phaser.Sound.Events#DECODED` to listen for single sounds being decoded, and `DECODED_ALL` to
 * listen for them all completing.
 * 
 * Listen to it from the Sound Manager in a Scene using `this.sound.on('decodedall', listener)`, i.e.:
 * 
 * ```javascript
 * this.sound.once('decodedall', handler);
 * this.sound.decodeAudio([ audioFiles ]);
 * ```
 *
 * @event Phaser.Sound.Events#DECODED_ALL
 * @since 3.18.0
 */t.exports="decodedall"}),r("7CVWc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Destroy Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are destroyed, either
 * directly or via a Sound Manager.
 * 
 * Listen to it from a Sound instance using `Sound.on('destroy', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('destroy', listener);
 * music.destroy();
 * ```
 *
 * @event Phaser.Sound.Events#DESTROY
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 */t.exports="destroy"}),r("kQm6q",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Detune Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when their detune value changes.
 * 
 * Listen to it from a Sound instance using `Sound.on('detune', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('detune', listener);
 * music.play();
 * music.setDetune(200);
 * ```
 *
 * @event Phaser.Sound.Events#DETUNE
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 * @param {number} detune - The new detune value of the Sound.
 */t.exports="detune"}),r("aF0Bz",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Manager Global Detune Event.
 * 
 * This event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,
 * or the HTML5 Audio Manager. It is dispatched when the `detune` property of the Sound Manager is changed, which globally
 * adjusts the detuning of all active sounds.
 * 
 * Listen to it from a Scene using: `this.sound.on('rate', listener)`.
 *
 * @event Phaser.Sound.Events#GLOBAL_DETUNE
 * @since 3.0.0
 * 
 * @param {Phaser.Sound.BaseSoundManager} soundManager - A reference to the sound manager that emitted the event.
 * @param {number} detune - The updated detune value.
 */t.exports="detune"}),r("cjsKe",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Manager Global Mute Event.
 * 
 * This event is dispatched by the Sound Manager when its `mute` property is changed, either directly
 * or via the `setMute` method. This changes the mute state of all active sounds.
 * 
 * Listen to it from a Scene using: `this.sound.on('mute', listener)`.
 *
 * @event Phaser.Sound.Events#GLOBAL_MUTE
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSoundManager|Phaser.Sound.HTML5AudioSoundManager)} soundManager - A reference to the Sound Manager that emitted the event.
 * @param {boolean} mute - The mute value. `true` if the Sound Manager is now muted, otherwise `false`.
 */t.exports="mute"}),r("g9B9q",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Manager Global Rate Event.
 * 
 * This event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,
 * or the HTML5 Audio Manager. It is dispatched when the `rate` property of the Sound Manager is changed, which globally
 * adjusts the playback rate of all active sounds.
 * 
 * Listen to it from a Scene using: `this.sound.on('rate', listener)`.
 *
 * @event Phaser.Sound.Events#GLOBAL_RATE
 * @since 3.0.0
 * 
 * @param {Phaser.Sound.BaseSoundManager} soundManager - A reference to the sound manager that emitted the event.
 * @param {number} rate - The updated rate value.
 */t.exports="rate"}),r("1ne4s",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Manager Global Volume Event.
 * 
 * This event is dispatched by the Sound Manager when its `volume` property is changed, either directly
 * or via the `setVolume` method. This changes the volume of all active sounds.
 * 
 * Listen to it from a Scene using: `this.sound.on('volume', listener)`.
 *
 * @event Phaser.Sound.Events#GLOBAL_VOLUME
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSoundManager|Phaser.Sound.HTML5AudioSoundManager)} soundManager - A reference to the sound manager that emitted the event.
 * @param {number} volume - The new global volume of the Sound Manager.
 */t.exports="volume"}),r("kNnwh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Loop Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when their loop state is changed.
 * 
 * Listen to it from a Sound instance using `Sound.on('loop', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('loop', listener);
 * music.setLoop(true);
 * ```
 * 
 * This is not to be confused with the [LOOPED]{@linkcode Phaser.Sound.Events#event:LOOPED} event, which emits each time a Sound loops during playback.
 *
 * @event Phaser.Sound.Events#LOOP
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 * @param {boolean} loop - The new loop value. `true` if the Sound will loop, otherwise `false`.
 */t.exports="loop"}),r("gAwFJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Looped Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they loop during playback.
 * 
 * Listen to it from a Sound instance using `Sound.on('looped', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('looped', listener);
 * music.setLoop(true);
 * music.play();
 * ```
 * 
 * This is not to be confused with the [LOOP]{@linkcode Phaser.Sound.Events#event:LOOP} event, which only emits when the loop state of a Sound is changed.
 *
 * @event Phaser.Sound.Events#LOOPED
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 */t.exports="looped"}),r("8I72u",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Mute Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when their mute state changes.
 * 
 * Listen to it from a Sound instance using `Sound.on('mute', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('mute', listener);
 * music.play();
 * music.setMute(true);
 * ```
 *
 * @event Phaser.Sound.Events#MUTE
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 * @param {boolean} mute - The mute value. `true` if the Sound is now muted, otherwise `false`.
 */t.exports="mute"}),r("gfAKp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Pause All Sounds Event.
 * 
 * This event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,
 * or the HTML5 Audio Manager. It is dispatched when the `pauseAll` method is invoked and after all current Sounds
 * have been paused.
 * 
 * Listen to it from a Scene using: `this.sound.on('pauseall', listener)`.
 *
 * @event Phaser.Sound.Events#PAUSE_ALL
 * @since 3.0.0
 * 
 * @param {Phaser.Sound.BaseSoundManager} soundManager - A reference to the sound manager that emitted the event.
 */t.exports="pauseall"}),r("1ZwMn",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Pause Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are paused.
 * 
 * Listen to it from a Sound instance using `Sound.on('pause', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('pause', listener);
 * music.play();
 * music.pause();
 * ```
 *
 * @event Phaser.Sound.Events#PAUSE
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 */t.exports="pause"}),r("ehBWS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Play Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are played.
 * 
 * Listen to it from a Sound instance using `Sound.on('play', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('play', listener);
 * music.play();
 * ```
 *
 * @event Phaser.Sound.Events#PLAY
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 */t.exports="play"}),r("mufzx",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Rate Change Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when their rate changes.
 * 
 * Listen to it from a Sound instance using `Sound.on('rate', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('rate', listener);
 * music.play();
 * music.setRate(0.5);
 * ```
 *
 * @event Phaser.Sound.Events#RATE
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 * @param {number} rate - The new rate of the Sound.
 */t.exports="rate"}),r("ebbYi",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Resume All Sounds Event.
 * 
 * This event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,
 * or the HTML5 Audio Manager. It is dispatched when the `resumeAll` method is invoked and after all current Sounds
 * have been resumed.
 * 
 * Listen to it from a Scene using: `this.sound.on('resumeall', listener)`.
 *
 * @event Phaser.Sound.Events#RESUME_ALL
 * @since 3.0.0
 * 
 * @param {Phaser.Sound.BaseSoundManager} soundManager - A reference to the sound manager that emitted the event.
 */t.exports="resumeall"}),r("cyWBF",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Resume Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are resumed from a paused state.
 * 
 * Listen to it from a Sound instance using `Sound.on('resume', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('resume', listener);
 * music.play();
 * music.pause();
 * music.resume();
 * ```
 *
 * @event Phaser.Sound.Events#RESUME
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 */t.exports="resume"}),r("XUXAf",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Seek Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are seeked to a new position.
 * 
 * Listen to it from a Sound instance using `Sound.on('seek', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('seek', listener);
 * music.play();
 * music.setSeek(5000);
 * ```
 *
 * @event Phaser.Sound.Events#SEEK
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 * @param {number} detune - The new detune value of the Sound.
 */t.exports="seek"}),r("1kg4E",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Stop All Sounds Event.
 * 
 * This event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,
 * or the HTML5 Audio Manager. It is dispatched when the `stopAll` method is invoked and after all current Sounds
 * have been stopped.
 * 
 * Listen to it from a Scene using: `this.sound.on('stopall', listener)`.
 *
 * @event Phaser.Sound.Events#STOP_ALL
 * @since 3.0.0
 * 
 * @param {Phaser.Sound.BaseSoundManager} soundManager - A reference to the sound manager that emitted the event.
 */t.exports="stopall"}),r("bQ7yl",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Stop Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are stopped.
 * 
 * Listen to it from a Sound instance using `Sound.on('stop', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('stop', listener);
 * music.play();
 * music.stop();
 * ```
 *
 * @event Phaser.Sound.Events#STOP
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 */t.exports="stop"}),r("lOEVP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Manager Unlocked Event.
 * 
 * This event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,
 * or the HTML5 Audio Manager. It is dispatched during the update loop when the Sound Manager becomes unlocked. For
 * Web Audio this is on the first user gesture on the page.
 * 
 * Listen to it from a Scene using: `this.sound.on('unlocked', listener)`.
 *
 * @event Phaser.Sound.Events#UNLOCKED
 * @since 3.0.0
 * 
 * @param {Phaser.Sound.BaseSoundManager} soundManager - A reference to the sound manager that emitted the event.
 */t.exports="unlocked"}),r("gdzQ9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Sound Volume Event.
 * 
 * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when their volume changes.
 * 
 * Listen to it from a Sound instance using `Sound.on('volume', listener)`, i.e.:
 * 
 * ```javascript
 * var music = this.sound.add('key');
 * music.on('volume', listener);
 * music.play();
 * music.setVolume(0.5);
 * ```
 *
 * @event Phaser.Sound.Events#VOLUME
 * @since 3.0.0
 * 
 * @param {(Phaser.Sound.WebAudioSound|Phaser.Sound.HTML5AudioSound)} sound - A reference to the Sound that emitted the event.
 * @param {number} volume - The new volume of the Sound.
 */t.exports="volume"}),r("9CZay",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("9GGLm");t.exports=function(t,e,n,s,r){void 0===s&&(s=0),void 0===r&&(r=t.length);var o=[];if(i(t,s,r))for(var a=s;a<r;a++){var h=t[a];(!e||e&&void 0===n&&h.hasOwnProperty(e)||e&&void 0!==n&&h[e]===n)&&o.push(h)}return o}}),r("9GGLm",function(t,e){t.exports=function(t,e,i,n){var s=t.length;if(!(e<0)&&!(e>s)&&!(e>=i)&&!(i>s)&&!(e+i>s))return!0;if(n)throw Error("Range Error: Values outside acceptable range");return!1}}),r("at5Hg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("9GGLm");t.exports=function(t,e,n,s,r){if(void 0===s&&(s=0),void 0===r&&(r=t.length),i(t,s,r))for(var o=s;o<r;o++){var a=t[o];if(!e||e&&void 0===n&&a.hasOwnProperty(e)||e&&void 0!==n&&a[e]===n)return a}return null}}),r("1jI3b",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("4x7f5"),n=s("jwj1g"),r=s("kcpiS"),o=s("iEUUO"),a=new n({Extends:i,initialize:function(t,e,n){if(void 0===n&&(n={}),/**
         * An array containing all HTML5 Audio tags that could be used for individual
         * sound's playback. Number of instances depends on the config value passed
         * to the Loader#audio method call, default is 1.
         *
         * @name Phaser.Sound.HTML5AudioSound#tags
         * @type {HTMLAudioElement[]}
         * @private
         * @since 3.0.0
         */this.tags=t.game.cache.audio.get(e),!this.tags)throw Error('There is no audio asset with key "'+e+'" in the audio cache');/**
         * Reference to an HTML5 Audio tag used for playing sound.
         *
         * @name Phaser.Sound.HTML5AudioSound#audio
         * @type {HTMLAudioElement}
         * @private
         * @default null
         * @since 3.0.0
         */this.audio=null,/**
         * Timestamp as generated by the Request Animation Frame or SetTimeout
         * representing the time at which the delayed sound playback should start.
         * Set to 0 if sound playback is not delayed.
         *
         * @name Phaser.Sound.HTML5AudioSound#startTime
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this.startTime=0,/**
         * Audio tag's playback position recorded on previous
         * update method call. Set to 0 if sound is not playing.
         *
         * @name Phaser.Sound.HTML5AudioSound#previousTime
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this.previousTime=0,this.duration=this.tags[0].duration,this.totalDuration=this.tags[0].duration,i.call(this,t,e,n)},/**
     * Play this sound, or a marked section of it.
     * It always plays the sound from the start. If you want to start playback from a specific time
     * you can set 'seek' setting of the config object, provided to this call, to that value.
     *
     * @method Phaser.Sound.HTML5AudioSound#play
     * @fires Phaser.Sound.Events#PLAY
     * @since 3.0.0
     *
     * @param {(string|Phaser.Types.Sound.SoundConfig)} [markerName=''] - If you want to play a marker then provide the marker name here. Alternatively, this parameter can be a SoundConfig object.
     * @param {Phaser.Types.Sound.SoundConfig} [config] - Optional sound config object to be applied to this marker or entire sound if no marker name is provided. It gets memorized for future plays of current section of the sound.
     *
     * @return {boolean} Whether the sound started playing successfully.
     */play:function(t,e){return!!(!this.manager.isLocked(this,"play",[t,e])&&i.prototype.play.call(this,t,e)&&this.pickAndPlayAudioTag())&&(this.emit(r.PLAY,this),!0)},/**
     * Pauses the sound.
     *
     * @method Phaser.Sound.HTML5AudioSound#pause
     * @fires Phaser.Sound.Events#PAUSE
     * @since 3.0.0
     *
     * @return {boolean} Whether the sound was paused successfully.
     */pause:function(){return!this.manager.isLocked(this,"pause")&&!(this.startTime>0)&&!!i.prototype.pause.call(this)&&(//  \/\/\/ isPlaying = false, isPaused = true \/\/\/
this.currentConfig.seek=this.audio.currentTime-(this.currentMarker?this.currentMarker.start:0),this.stopAndReleaseAudioTag(),this.emit(r.PAUSE,this),!0)},/**
     * Resumes the sound.
     *
     * @method Phaser.Sound.HTML5AudioSound#resume
     * @fires Phaser.Sound.Events#RESUME
     * @since 3.0.0
     *
     * @return {boolean} Whether the sound was resumed successfully.
     */resume:function(){return!this.manager.isLocked(this,"resume")&&!(this.startTime>0)&&!!i.prototype.resume.call(this)&&!!this.pickAndPlayAudioTag()&&(this.emit(r.RESUME,this),!0)},/**
     * Stop playing this sound.
     *
     * @method Phaser.Sound.HTML5AudioSound#stop
     * @fires Phaser.Sound.Events#STOP
     * @since 3.0.0
     *
     * @return {boolean} Whether the sound was stopped successfully.
     */stop:function(){return!this.manager.isLocked(this,"stop")&&!!i.prototype.stop.call(this)&&(//  \/\/\/ isPlaying = false, isPaused = false \/\/\/
this.stopAndReleaseAudioTag(),this.emit(r.STOP,this),!0)},/**
     * Used internally to do what the name says.
     *
     * @method Phaser.Sound.HTML5AudioSound#pickAndPlayAudioTag
     * @private
     * @since 3.0.0
     *
     * @return {boolean} Whether the sound was assigned an audio tag successfully.
     */pickAndPlayAudioTag:function(){if(!this.pickAudioTag())return this.reset(),!1;var t=this.currentConfig.seek,e=this.currentConfig.delay,i=(this.currentMarker?this.currentMarker.start:0)+t;return this.previousTime=i,this.audio.currentTime=i,this.applyConfig(),0===e?(this.startTime=0,this.audio.paused&&this.playCatchPromise()):(this.startTime=window.performance.now()+1e3*e,this.audio.paused||this.audio.pause()),this.resetConfig(),!0},/**
     * This method performs the audio tag pooling logic. It first looks for
     * unused audio tag to assign to this sound object. If there are no unused
     * audio tags, based on HTML5AudioSoundManager#override property value, it
     * looks for sound with most advanced playback and hijacks its audio tag or
     * does nothing.
     *
     * @method Phaser.Sound.HTML5AudioSound#pickAudioTag
     * @private
     * @since 3.0.0
     *
     * @return {boolean} Whether the sound was assigned an audio tag successfully.
     */pickAudioTag:function(){if(this.audio)return!0;for(var t=0;t<this.tags.length;t++){var e=this.tags[t];if("false"===e.dataset.used)return e.dataset.used="true",this.audio=e,!0}if(!this.manager.override)return!1;var i=[];this.manager.forEachActiveSound(function(t){t.key===this.key&&t.audio&&i.push(t)},this),i.sort(function(t,e){return t.loop===e.loop?e.seek/e.duration-t.seek/t.duration:t.loop?1:-1});var n=i[0];return this.audio=n.audio,n.reset(),n.audio=null,n.startTime=0,n.previousTime=0,!0},/**
     * Method used for playing audio tag and catching possible exceptions
     * thrown from rejected Promise returned from play method call.
     *
     * @method Phaser.Sound.HTML5AudioSound#playCatchPromise
     * @private
     * @since 3.0.0
     */playCatchPromise:function(){var t=this.audio.play();t&&t.catch(function(t){console.warn(t)})},/**
     * Used internally to do what the name says.
     *
     * @method Phaser.Sound.HTML5AudioSound#stopAndReleaseAudioTag
     * @private
     * @since 3.0.0
     */stopAndReleaseAudioTag:function(){this.audio.pause(),this.audio.dataset.used="false",this.audio=null,this.startTime=0,this.previousTime=0},/**
     * Method used internally to reset sound state, usually when stopping sound
     * or when hijacking audio tag from another sound.
     *
     * @method Phaser.Sound.HTML5AudioSound#reset
     * @private
     * @since 3.0.0
     */reset:function(){i.prototype.stop.call(this)},/**
     * Method used internally by sound manager for pausing sound if
     * Phaser.Sound.HTML5AudioSoundManager#pauseOnBlur is set to true.
     *
     * @method Phaser.Sound.HTML5AudioSoundManager#onBlur
     * @private
     * @since 3.0.0
     */onBlur:function(){this.isPlaying=!1,this.isPaused=!0,this.currentConfig.seek=this.audio.currentTime-(this.currentMarker?this.currentMarker.start:0),this.currentConfig.delay=Math.max(0,(this.startTime-window.performance.now())/1e3),this.stopAndReleaseAudioTag()},/**
     * Method used internally by sound manager for resuming sound if
     * Phaser.Sound.HTML5AudioSoundManager#pauseOnBlur is set to true.
     *
     * @method Phaser.Sound.HTML5AudioSound#onFocus
     * @private
     * @since 3.0.0
     */onFocus:function(){this.isPlaying=!0,this.isPaused=!1,this.pickAndPlayAudioTag()},/**
     * Update method called automatically by sound manager on every game step.
     *
     * @method Phaser.Sound.HTML5AudioSound#update
     * @fires Phaser.Sound.Events#COMPLETE
     * @fires Phaser.Sound.Events#LOOPED
     * @protected
     * @since 3.0.0
     *
     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time elapsed since the last frame.
     */// eslint-disable-next-line no-unused-vars
update:function(t,e){if(this.isPlaying){// handling delayed playback
if(this.startTime>0){this.startTime<t-this.manager.audioPlayDelay&&(this.audio.currentTime+=Math.max(0,t-this.startTime)/1e3,this.startTime=0,this.previousTime=this.audio.currentTime,this.playCatchPromise());return}// handle looping and ending
var i=this.currentMarker?this.currentMarker.start:0,n=i+this.duration,s=this.audio.currentTime;if(this.currentConfig.loop)s>=n-this.manager.loopEndOffset?(this.audio.currentTime=i+Math.max(0,s-n),s=this.audio.currentTime):s<i&&(this.audio.currentTime+=i,s=this.audio.currentTime),s<this.previousTime&&this.emit(r.LOOPED,this);else if(s>=n){this.reset(),this.stopAndReleaseAudioTag(),this.emit(r.COMPLETE,this);return}this.previousTime=s}},/**
     * Calls Phaser.Sound.BaseSound#destroy method
     * and cleans up all HTML5 Audio related stuff.
     *
     * @method Phaser.Sound.HTML5AudioSound#destroy
     * @since 3.0.0
     */destroy:function(){i.prototype.destroy.call(this),this.tags=null,this.audio&&this.stopAndReleaseAudioTag()},/**
     * Method used internally to determine mute setting of the sound.
     *
     * @method Phaser.Sound.HTML5AudioSound#updateMute
     * @private
     * @since 3.0.0
     */updateMute:function(){this.audio&&(this.audio.muted=this.currentConfig.mute||this.manager.mute)},/**
     * Method used internally to calculate total volume of the sound.
     *
     * @method Phaser.Sound.HTML5AudioSound#updateVolume
     * @private
     * @since 3.0.0
     */updateVolume:function(){this.audio&&(this.audio.volume=o(this.currentConfig.volume*this.manager.volume,0,1))},/**
     * Method used internally to calculate total playback rate of the sound.
     *
     * @method Phaser.Sound.HTML5AudioSound#calculateRate
     * @protected
     * @since 3.0.0
     */calculateRate:function(){i.prototype.calculateRate.call(this),this.audio&&(this.audio.playbackRate=this.totalRate)},/**
     * Boolean indicating whether the sound is muted or not.
     * Gets or sets the muted state of this sound.
     * 
     * @name Phaser.Sound.HTML5AudioSound#mute
     * @type {boolean}
     * @default false
     * @fires Phaser.Sound.Events#MUTE
     * @since 3.0.0
     */mute:{get:function(){return this.currentConfig.mute},set:function(t){this.currentConfig.mute=t,this.manager.isLocked(this,"mute",t)||(this.updateMute(),this.emit(r.MUTE,this,t))}},/**
     * Sets the muted state of this Sound.
     *
     * @method Phaser.Sound.HTML5AudioSound#setMute
     * @fires Phaser.Sound.Events#MUTE
     * @since 3.4.0
     *
     * @param {boolean} value - `true` to mute this sound, `false` to unmute it.
     *
     * @return {Phaser.Sound.HTML5AudioSound} This Sound instance.
     */setMute:function(t){return this.mute=t,this},/**
     * Gets or sets the volume of this sound, a value between 0 (silence) and 1 (full volume).
     * 
     * @name Phaser.Sound.HTML5AudioSound#volume
     * @type {number}
     * @default 1
     * @fires Phaser.Sound.Events#VOLUME
     * @since 3.0.0
     */volume:{get:function(){return this.currentConfig.volume},set:function(t){this.currentConfig.volume=t,this.manager.isLocked(this,"volume",t)||(this.updateVolume(),this.emit(r.VOLUME,this,t))}},/**
     * Sets the volume of this Sound.
     *
     * @method Phaser.Sound.HTML5AudioSound#setVolume
     * @fires Phaser.Sound.Events#VOLUME
     * @since 3.4.0
     *
     * @param {number} value - The volume of the sound.
     *
     * @return {Phaser.Sound.HTML5AudioSound} This Sound instance.
     */setVolume:function(t){return this.volume=t,this},/**
     * Rate at which this Sound will be played.
     * Value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
     * and 2.0 doubles the audios playback speed.
     *
     * @name Phaser.Sound.HTML5AudioSound#rate
     * @type {number}
     * @default 1
     * @fires Phaser.Sound.Events#RATE
     * @since 3.0.0
     */rate:{get:function(){return this.currentConfig.rate},set:function(t){this.currentConfig.rate=t,this.manager.isLocked(this,r.RATE,t)||(this.calculateRate(),this.emit(r.RATE,this,t))}},/**
     * Sets the playback rate of this Sound.
     * 
     * For example, a value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
     * and 2.0 doubles the audios playback speed.
     *
     * @method Phaser.Sound.HTML5AudioSound#setRate
     * @fires Phaser.Sound.Events#RATE
     * @since 3.3.0
     *
     * @param {number} value - The playback rate at of this Sound.
     *
     * @return {Phaser.Sound.HTML5AudioSound} This Sound.
     */setRate:function(t){return this.rate=t,this},/**
     * The detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
     * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
     *
     * @name Phaser.Sound.HTML5AudioSound#detune
     * @type {number}
     * @default 0
     * @fires Phaser.Sound.Events#DETUNE
     * @since 3.0.0
     */detune:{get:function(){return this.currentConfig.detune},set:function(t){this.currentConfig.detune=t,this.manager.isLocked(this,r.DETUNE,t)||(this.calculateRate(),this.emit(r.DETUNE,this,t))}},/**
     * Sets the detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
     * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
     *
     * @method Phaser.Sound.HTML5AudioSound#setDetune
     * @fires Phaser.Sound.Events#DETUNE
     * @since 3.3.0
     *
     * @param {number} value - The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
     *
     * @return {Phaser.Sound.HTML5AudioSound} This Sound.
     */setDetune:function(t){return this.detune=t,this},/**
     * Property representing the position of playback for this sound, in seconds.
     * Setting it to a specific value moves current playback to that position.
     * The value given is clamped to the range 0 to current marker duration.
     * Setting seek of a stopped sound has no effect.
     * 
     * @name Phaser.Sound.HTML5AudioSound#seek
     * @type {number}
     * @fires Phaser.Sound.Events#SEEK
     * @since 3.0.0
     */seek:{get:function(){return this.isPlaying?this.audio.currentTime-(this.currentMarker?this.currentMarker.start:0):this.isPaused?this.currentConfig.seek:0},set:function(t){!this.manager.isLocked(this,"seek",t)&&!(this.startTime>0)&&(this.isPlaying||this.isPaused)&&(t=Math.min(Math.max(0,t),this.duration),this.isPlaying?(this.previousTime=t,this.audio.currentTime=t):this.isPaused&&(this.currentConfig.seek=t),this.emit(r.SEEK,this,t))}},/**
     * Seeks to a specific point in this sound.
     *
     * @method Phaser.Sound.HTML5AudioSound#setSeek
     * @fires Phaser.Sound.Events#SEEK
     * @since 3.4.0
     *
     * @param {number} value - The point in the sound to seek to.
     *
     * @return {Phaser.Sound.HTML5AudioSound} This Sound instance.
     */setSeek:function(t){return this.seek=t,this},/**
     * Flag indicating whether or not the sound or current sound marker will loop.
     * 
     * @name Phaser.Sound.HTML5AudioSound#loop
     * @type {boolean}
     * @default false
     * @fires Phaser.Sound.Events#LOOP
     * @since 3.0.0
     */loop:{get:function(){return this.currentConfig.loop},set:function(t){this.currentConfig.loop=t,this.manager.isLocked(this,"loop",t)||(this.audio&&(this.audio.loop=t),this.emit(r.LOOP,this,t))}},/**
     * Sets the loop state of this Sound.
     *
     * @method Phaser.Sound.HTML5AudioSound#setLoop
     * @fires Phaser.Sound.Events#LOOP
     * @since 3.4.0
     *
     * @param {boolean} value - `true` to loop this sound, `false` to not loop it.
     *
     * @return {Phaser.Sound.HTML5AudioSound} This Sound instance.
     */setLoop:function(t){return this.loop=t,this}});t.exports=a}),r("4x7f5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("3vRz3"),r=s("kcpiS"),o=s("hVk4C"),a=s("13GYA"),h=new i({Extends:n,initialize:function(t,e,i){n.call(this),/**
         * Local reference to the sound manager.
         *
         * @name Phaser.Sound.BaseSound#manager
         * @type {Phaser.Sound.BaseSoundManager}
         * @private
         * @since 3.0.0
         */this.manager=t,/**
         * Asset key for the sound.
         *
         * @name Phaser.Sound.BaseSound#key
         * @type {string}
         * @readonly
         * @since 3.0.0
         */this.key=e,/**
         * Flag indicating if sound is currently playing.
         *
         * @name Phaser.Sound.BaseSound#isPlaying
         * @type {boolean}
         * @default false
         * @readonly
         * @since 3.0.0
         */this.isPlaying=!1,/**
         * Flag indicating if sound is currently paused.
         *
         * @name Phaser.Sound.BaseSound#isPaused
         * @type {boolean}
         * @default false
         * @readonly
         * @since 3.0.0
         */this.isPaused=!1,/**
         * A property that holds the value of sound's actual playback rate,
         * after its rate and detune values has been combined with global
         * rate and detune values.
         *
         * @name Phaser.Sound.BaseSound#totalRate
         * @type {number}
         * @default 1
         * @readonly
         * @since 3.0.0
         */this.totalRate=1,/**
         * A value representing the duration, in seconds.
         * It could be total sound duration or a marker duration.
         *
         * @name Phaser.Sound.BaseSound#duration
         * @type {number}
         * @readonly
         * @since 3.0.0
         */this.duration=this.duration||0,/**
         * The total duration of the sound in seconds.
         *
         * @name Phaser.Sound.BaseSound#totalDuration
         * @type {number}
         * @readonly
         * @since 3.0.0
         */this.totalDuration=this.totalDuration||0,/**
         * A config object used to store default sound settings' values.
         * Default values will be set by properties' setters.
         *
         * @name Phaser.Sound.BaseSound#config
         * @type {Phaser.Types.Sound.SoundConfig}
         * @private
         * @since 3.0.0
         */this.config={mute:!1,volume:1,rate:1,detune:0,seek:0,loop:!1,delay:0},/**
         * Reference to the currently used config.
         * It could be default config or marker config.
         *
         * @name Phaser.Sound.BaseSound#currentConfig
         * @type {Phaser.Types.Sound.SoundConfig}
         * @private
         * @since 3.0.0
         */this.currentConfig=this.config,this.config=o(this.config,i),/**
         * Object containing markers definitions.
         *
         * @name Phaser.Sound.BaseSound#markers
         * @type {Object.<string, Phaser.Types.Sound.SoundMarker>}
         * @default {}
         * @readonly
         * @since 3.0.0
         */this.markers={},/**
         * Currently playing marker.
         * 'null' if whole sound is playing.
         *
         * @name Phaser.Sound.BaseSound#currentMarker
         * @type {Phaser.Types.Sound.SoundMarker}
         * @default null
         * @readonly
         * @since 3.0.0
         */this.currentMarker=null,/**
         * Flag indicating if destroy method was called on this sound.
         *
         * @name Phaser.Sound.BaseSound#pendingRemove
         * @type {boolean}
         * @private
         * @default false
         * @since 3.0.0
         */this.pendingRemove=!1},/**
     * Adds a marker into the current sound. A marker is represented by name, start time, duration, and optionally config object.
     * This allows you to bundle multiple sounds together into a single audio file and use markers to jump between them for playback.
     *
     * @method Phaser.Sound.BaseSound#addMarker
     * @since 3.0.0
     *
     * @param {Phaser.Types.Sound.SoundMarker} marker - Marker object.
     *
     * @return {boolean} Whether the marker was added successfully.
     */addMarker:function(t){return!!t&&!!t.name&&"string"==typeof t.name&&(this.markers[t.name]?(// eslint-disable-next-line no-console
console.error("addMarker "+t.name+" already exists in Sound"),!1):(t=o(!0,{name:"",start:0,duration:this.totalDuration-(t.start||0),config:{mute:!1,volume:1,rate:1,detune:0,seek:0,loop:!1,delay:0}},t),this.markers[t.name]=t,!0))},/**
     * Updates previously added marker.
     *
     * @method Phaser.Sound.BaseSound#updateMarker
     * @since 3.0.0
     *
     * @param {Phaser.Types.Sound.SoundMarker} marker - Marker object with updated values.
     *
     * @return {boolean} Whether the marker was updated successfully.
     */updateMarker:function(t){return!!t&&!!t.name&&"string"==typeof t.name&&(this.markers[t.name]?(this.markers[t.name]=o(!0,this.markers[t.name],t),!0):(// eslint-disable-next-line no-console
console.warn("Audio Marker: "+t.name+" missing in Sound: "+this.key),!1))},/**
     * Removes a marker from the sound.
     *
     * @method Phaser.Sound.BaseSound#removeMarker
     * @since 3.0.0
     *
     * @param {string} markerName - The name of the marker to remove.
     *
     * @return {?Phaser.Types.Sound.SoundMarker} Removed marker object or 'null' if there was no marker with provided name.
     */removeMarker:function(t){var e=this.markers[t];return e?(this.markers[t]=null,e):null},/**
     * Play this sound, or a marked section of it.
     * It always plays the sound from the start. If you want to start playback from a specific time
     * you can set 'seek' setting of the config object, provided to this call, to that value.
     *
     * @method Phaser.Sound.BaseSound#play
     * @since 3.0.0
     *
     * @param {(string|Phaser.Types.Sound.SoundConfig)} [markerName=''] - If you want to play a marker then provide the marker name here. Alternatively, this parameter can be a SoundConfig object.
     * @param {Phaser.Types.Sound.SoundConfig} [config] - Optional sound config object to be applied to this marker or entire sound if no marker name is provided. It gets memorized for future plays of current section of the sound.
     *
     * @return {boolean} Whether the sound started playing successfully.
     */play:function(t,e){if(void 0===t&&(t=""),"object"==typeof t&&(e=t,t=""),"string"!=typeof t)return!1;if(t){if(!this.markers[t])return(// eslint-disable-next-line no-console
console.warn("Marker: "+t+" missing in Sound: "+this.key),!1);this.currentMarker=this.markers[t],this.currentConfig=this.currentMarker.config,this.duration=this.currentMarker.duration}else this.currentMarker=null,this.currentConfig=this.config,this.duration=this.totalDuration;return this.resetConfig(),this.currentConfig=o(this.currentConfig,e),this.isPlaying=!0,this.isPaused=!1,!0},/**
     * Pauses the sound.
     *
     * @method Phaser.Sound.BaseSound#pause
     * @since 3.0.0
     *
     * @return {boolean} Whether the sound was paused successfully.
     */pause:function(){return!this.isPaused&&!!this.isPlaying&&(this.isPlaying=!1,this.isPaused=!0,!0)},/**
     * Resumes the sound.
     *
     * @method Phaser.Sound.BaseSound#resume
     * @since 3.0.0
     *
     * @return {boolean} Whether the sound was resumed successfully.
     */resume:function(){return!!this.isPaused&&!this.isPlaying&&(this.isPlaying=!0,this.isPaused=!1,!0)},/**
     * Stop playing this sound.
     *
     * @method Phaser.Sound.BaseSound#stop
     * @since 3.0.0
     *
     * @return {boolean} Whether the sound was stopped successfully.
     */stop:function(){return(!!this.isPaused||!!this.isPlaying)&&(this.isPlaying=!1,this.isPaused=!1,this.resetConfig(),!0)},/**
     * Method used internally for applying config values to some of the sound properties.
     *
     * @method Phaser.Sound.BaseSound#applyConfig
     * @protected
     * @since 3.0.0
     */applyConfig:function(){this.mute=this.currentConfig.mute,this.volume=this.currentConfig.volume,this.rate=this.currentConfig.rate,this.detune=this.currentConfig.detune,this.loop=this.currentConfig.loop},/**
     * Method used internally for resetting values of some of the config properties.
     *
     * @method Phaser.Sound.BaseSound#resetConfig
     * @protected
     * @since 3.0.0
     */resetConfig:function(){this.currentConfig.seek=0,this.currentConfig.delay=0},/**
     * Update method called automatically by sound manager on every game step.
     *
     * @method Phaser.Sound.BaseSound#update
     * @override
     * @protected
     * @since 3.0.0
     *
     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time elapsed since the last frame.
     */update:a,/**
     * Method used internally to calculate total playback rate of the sound.
     *
     * @method Phaser.Sound.BaseSound#calculateRate
     * @protected
     * @since 3.0.0
     */calculateRate:function(){var t=Math.pow(1.0005777895065548,this.currentConfig.detune+this.manager.detune);this.totalRate=this.currentConfig.rate*this.manager.rate*t},/**
     * Destroys this sound and all associated events and marks it for removal from the sound manager.
     *
     * @method Phaser.Sound.BaseSound#destroy
     * @fires Phaser.Sound.Events#DESTROY
     * @since 3.0.0
     */destroy:function(){this.pendingRemove||(this.emit(r.DESTROY,this),this.pendingRemove=!0,this.manager=null,this.key="",this.removeAllListeners(),this.isPlaying=!1,this.isPaused=!1,this.config=null,this.currentConfig=null,this.markers=null,this.currentMarker=null)}});t.exports=h}),r("5wl8F",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hw6uH"),n=s("jwj1g"),r=s("3vRz3"),o=s("4Z5ti"),a=s("13GYA"),h=new n({Extends:r,initialize:function(t){r.call(this),this.game=t,this.sounds=[],this.mute=!1,this.volume=1,this.rate=1,this.detune=0,this.pauseOnBlur=!0,this.locked=!1},add:function(t,e){var i=new o(this,t,e);return this.sounds.push(i),i},addAudioSprite:function(t,e){var i=this.add(t,e);return i.spritemap={},i},// eslint-disable-next-line no-unused-vars
play:function(t,e){return!1},// eslint-disable-next-line no-unused-vars
playAudioSprite:function(t,e,i){return!1},remove:function(t){return i.prototype.remove.call(this,t)},removeByKey:function(t){return i.prototype.removeByKey.call(this,t)},pauseAll:a,resumeAll:a,stopAll:a,update:a,setRate:a,setDetune:a,setMute:a,setVolume:a,forEachActiveSound:function(t,e){i.prototype.forEachActiveSound.call(this,t,e)},destroy:function(){i.prototype.destroy.call(this)}});t.exports=h}),r("4Z5ti",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("4x7f5"),n=s("jwj1g"),r=s("3vRz3"),o=s("hVk4C"),a=function(){return!1},h=function(){return this},l=new n({Extends:r,initialize:function(t,e,i){void 0===i&&(i={}),r.call(this),this.manager=t,this.key=e,this.isPlaying=!1,this.isPaused=!1,this.totalRate=1,this.duration=0,this.totalDuration=0,this.config=o({mute:!1,volume:1,rate:1,detune:0,seek:0,loop:!1,delay:0},i),this.currentConfig=this.config,this.mute=!1,this.volume=1,this.rate=1,this.detune=0,this.seek=0,this.loop=!1,this.markers={},this.currentMarker=null,this.pendingRemove=!1},/**
     * @method Phaser.Sound.NoAudioSound#addMarker
     * @since 3.0.0
     *
     * @param {Phaser.Types.Sound.SoundMarker} marker - Marker object.
     *
     * @return {boolean} false
     */// eslint-disable-next-line no-unused-vars
addMarker:a,/**
     * @method Phaser.Sound.NoAudioSound#updateMarker
     * @since 3.0.0
     *
     * @param {Phaser.Types.Sound.SoundMarker} marker - Marker object with updated values.
     *
     * @return {boolean} false
     */// eslint-disable-next-line no-unused-vars
updateMarker:a,/**
     * @method Phaser.Sound.NoAudioSound#removeMarker
     * @since 3.0.0
     *
     * @param {string} markerName - The name of the marker to remove.
     *
     * @return {null} null
     */removeMarker:function(){return null},/**
     * @method Phaser.Sound.NoAudioSound#play
     * @since 3.0.0
     *
     * @param {(string|Phaser.Types.Sound.SoundConfig)} [markerName=''] - If you want to play a marker then provide the marker name here. Alternatively, this parameter can be a SoundConfig object.
     * @param {Phaser.Types.Sound.SoundConfig} [config] - Optional sound config object to be applied to this marker or entire sound if no marker name is provided. It gets memorized for future plays of current section of the sound.
     *
     * @return {boolean} false
     */play:a,/**
     * @method Phaser.Sound.NoAudioSound#pause
     * @since 3.0.0
     *
     * @return {boolean} false
     */pause:a,/**
     * Resumes the sound.
     *
     * @method Phaser.Sound.NoAudioSound#resume
     * @since 3.0.0
     *
     * @return {boolean} false
     */resume:a,/**
     * Stop playing this sound.
     *
     * @method Phaser.Sound.NoAudioSound#stop
     * @since 3.0.0
     *
     * @return {boolean} false
     */stop:a,/**
     * Destroys this sound and all associated events and marks it for removal from the sound manager.
     *
     * @method Phaser.Sound.NoAudioSound#destroy
     * @fires Phaser.Sound.Events#DESTROY
     * @since 3.0.0
     */destroy:function(){i.prototype.destroy.call(this)},setMute:h,setVolume:h,setRate:h,setDetune:h,setSeek:h,setLoop:h});t.exports=l}),r("d69lL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("8wlD1"),n=s("hw6uH"),r=s("jwj1g"),o=s("kcpiS"),a=s("auhY5"),h=new r({Extends:n,initialize:function(t){/**
         * The AudioContext being used for playback.
         *
         * @name Phaser.Sound.WebAudioSoundManager#context
         * @type {AudioContext}
         * @private
         * @since 3.0.0
         */this.context=this.createAudioContext(t),/**
         * Gain node responsible for controlling global muting.
         *
         * @name Phaser.Sound.WebAudioSoundManager#masterMuteNode
         * @type {GainNode}
         * @private
         * @since 3.0.0
         */this.masterMuteNode=this.context.createGain(),/**
         * Gain node responsible for controlling global volume.
         *
         * @name Phaser.Sound.WebAudioSoundManager#masterVolumeNode
         * @type {GainNode}
         * @private
         * @since 3.0.0
         */this.masterVolumeNode=this.context.createGain(),this.masterMuteNode.connect(this.masterVolumeNode),this.masterVolumeNode.connect(this.context.destination),/**
         * Destination node for connecting individual sounds to.
         *
         * @name Phaser.Sound.WebAudioSoundManager#destination
         * @type {AudioNode}
         * @private
         * @since 3.0.0
         */this.destination=this.masterMuteNode,this.locked="suspended"===this.context.state&&("ontouchstart"in window||"onclick"in window),n.call(this,t),this.locked&&this.unlock()},/**
     * Method responsible for instantiating and returning AudioContext instance.
     * If an instance of an AudioContext class was provided through the game config,
     * that instance will be returned instead. This can come in handy if you are reloading
     * a Phaser game on a page that never properly refreshes (such as in an SPA project)
     * and you want to reuse already instantiated AudioContext.
     *
     * @method Phaser.Sound.WebAudioSoundManager#createAudioContext
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.Game} game - Reference to the current game instance.
     *
     * @return {AudioContext} The AudioContext instance to be used for playback.
     */createAudioContext:function(t){var e=t.config.audio;return e&&e.context?(e.context.resume(),e.context):new AudioContext},/**
     * This method takes a new AudioContext reference and then sets
     * this Sound Manager to use that context for all playback.
     *
     * As part of this call it also disconnects the master mute and volume
     * nodes and then re-creates them on the new given context.
     *
     * @method Phaser.Sound.WebAudioSoundManager#setAudioContext
     * @since 3.21.0
     *
     * @param {AudioContext} context - Reference to an already created AudioContext instance.
     *
     * @return {this} The WebAudioSoundManager instance.
     */setAudioContext:function(t){return this.context&&this.context.close(),this.masterMuteNode&&this.masterMuteNode.disconnect(),this.masterVolumeNode&&this.masterVolumeNode.disconnect(),this.context=t,this.masterMuteNode=t.createGain(),this.masterVolumeNode=t.createGain(),this.masterMuteNode.connect(this.masterVolumeNode),this.masterVolumeNode.connect(t.destination),this.destination=this.masterMuteNode,this},/**
     * Adds a new sound into the sound manager.
     *
     * @method Phaser.Sound.WebAudioSoundManager#add
     * @since 3.0.0
     *
     * @param {string} key - Asset key for the sound.
     * @param {Phaser.Types.Sound.SoundConfig} [config] - An optional config object containing default sound settings.
     *
     * @return {Phaser.Sound.WebAudioSound} The new sound instance.
     */add:function(t,e){var i=new a(this,t,e);return this.sounds.push(i),i},/**
     * Decode audio data into a format ready for playback via Web Audio.
     *
     * The audio data can be a base64 encoded string, an audio media-type data uri, or an ArrayBuffer instance.
     *
     * The `audioKey` is the key that will be used to save the decoded audio to the audio cache.
     *
     * Instead of passing a single entry you can instead pass an array of `Phaser.Types.Sound.DecodeAudioConfig`
     * objects as the first and only argument.
     *
     * Decoding is an async process, so be sure to listen for the events to know when decoding has completed.
     *
     * Once the audio has decoded it can be added to the Sound Manager or played via its key.
     *
     * @method Phaser.Sound.WebAudioSoundManager#decodeAudio
     * @fires Phaser.Sound.Events#DECODED
     * @fires Phaser.Sound.Events#DECODED_ALL
     * @since 3.18.0
     *
     * @param {(Phaser.Types.Sound.DecodeAudioConfig[]|string)} [audioKey] - The string-based key to be used to reference the decoded audio in the audio cache, or an array of audio config objects.
     * @param {(ArrayBuffer|string)} [audioData] - The audio data, either a base64 encoded string, an audio media-type data uri, or an ArrayBuffer instance.
     */decodeAudio:function(t,e){n=Array.isArray(t)?t:[{key:t,data:e}];for(var n,s=this.game.cache.audio,r=n.length,a=0;a<n.length;a++){var h=n[a],l=h.key,u=h.data;"string"==typeof u&&(u=i(u));var c=(function(t,e){s.add(t,e),this.emit(o.DECODED,t),0==--r&&this.emit(o.DECODED_ALL)}).bind(this,l),d=(function(t,e){//  eslint-disable-next-line no-console
console.error("Error decoding audio: "+t+" - ",e?e.message:""),0==--r&&this.emit(o.DECODED_ALL)}).bind(this,l);this.context.decodeAudioData(u,c,d)}},/**
     * Unlocks Web Audio API on the initial input event.
     *
     * Read more about how this issue is handled here in [this article](https://medium.com/@pgoloskokovic/unlocking-web-audio-the-smarter-way-8858218c0e09).
     *
     * @method Phaser.Sound.WebAudioSoundManager#unlock
     * @since 3.0.0
     */unlock:function(){var t=this,e=document.body,i=function i(){t.context&&t.context.resume().then(function(){e.removeEventListener("touchstart",i),e.removeEventListener("touchend",i),e.removeEventListener("click",i),e.removeEventListener("keydown",i),t.unlocked=!0},function(){e.removeEventListener("touchstart",i),e.removeEventListener("touchend",i),e.removeEventListener("click",i),e.removeEventListener("keydown",i)})};e&&(e.addEventListener("touchstart",i,!1),e.addEventListener("touchend",i,!1),e.addEventListener("click",i,!1),e.addEventListener("keydown",i,!1))},/**
     * Method used internally for pausing sound manager if
     * Phaser.Sound.WebAudioSoundManager#pauseOnBlur is set to true.
     *
     * @method Phaser.Sound.WebAudioSoundManager#onBlur
     * @protected
     * @since 3.0.0
     */onBlur:function(){this.locked||this.context.suspend()},/**
     * Method used internally for resuming sound manager if
     * Phaser.Sound.WebAudioSoundManager#pauseOnBlur is set to true.
     *
     * @method Phaser.Sound.WebAudioSoundManager#onFocus
     * @protected
     * @since 3.0.0
     */onFocus:function(){this.locked||this.context.resume()},/**
     * Calls Phaser.Sound.BaseSoundManager#destroy method
     * and cleans up all Web Audio API related stuff.
     *
     * @method Phaser.Sound.WebAudioSoundManager#destroy
     * @since 3.0.0
     */destroy:function(){if(this.destination=null,this.masterVolumeNode.disconnect(),this.masterVolumeNode=null,this.masterMuteNode.disconnect(),this.masterMuteNode=null,this.game.config.audio&&this.game.config.audio.context)this.context.suspend();else{var t=this;this.context.close().then(function(){t.context=null})}n.prototype.destroy.call(this)},/**
     * Sets the muted state of all this Sound Manager.
     *
     * @method Phaser.Sound.WebAudioSoundManager#setMute
     * @fires Phaser.Sound.Events#GLOBAL_MUTE
     * @since 3.3.0
     *
     * @param {boolean} value - `true` to mute all sounds, `false` to unmute them.
     *
     * @return {Phaser.Sound.WebAudioSoundManager} This Sound Manager.
     */setMute:function(t){return this.mute=t,this},/**
     * @name Phaser.Sound.WebAudioSoundManager#mute
     * @type {boolean}
     * @fires Phaser.Sound.Events#GLOBAL_MUTE
     * @since 3.0.0
     */mute:{get:function(){return 0===this.masterMuteNode.gain.value},set:function(t){this.masterMuteNode.gain.setValueAtTime(t?0:1,0),this.emit(o.GLOBAL_MUTE,this,t)}},/**
     * Sets the volume of this Sound Manager.
     *
     * @method Phaser.Sound.WebAudioSoundManager#setVolume
     * @fires Phaser.Sound.Events#GLOBAL_VOLUME
     * @since 3.3.0
     *
     * @param {number} value - The global volume of this Sound Manager.
     *
     * @return {Phaser.Sound.WebAudioSoundManager} This Sound Manager.
     */setVolume:function(t){return this.volume=t,this},/**
     * @name Phaser.Sound.WebAudioSoundManager#volume
     * @type {number}
     * @fires Phaser.Sound.Events#GLOBAL_VOLUME
     * @since 3.0.0
     */volume:{get:function(){return this.masterVolumeNode.gain.value},set:function(t){this.masterVolumeNode.gain.setValueAtTime(t,0),this.emit(o.GLOBAL_VOLUME,this,t)}}});t.exports=h}),r("8wlD1",function(t,e){for(var i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=new Uint8Array(256),s=0;s<i.length;s++)n[i.charCodeAt(s)]=s;t.exports=function(t){var e,i,s,r,o=//  Is it a data uri? if so, strip the header away
(t=t.substr(t.indexOf(",")+1)).length,a=.75*o,h=0;"="===t[o-1]&&(a--,"="===t[o-2]&&a--);for(var l=new ArrayBuffer(a),u=new Uint8Array(l),c=0;c<o;c+=4)e=n[t.charCodeAt(c)],i=n[t.charCodeAt(c+1)],s=n[t.charCodeAt(c+2)],r=n[t.charCodeAt(c+3)],u[h++]=e<<2|i>>4,u[h++]=(15&i)<<4|s>>2,u[h++]=(3&s)<<6|63&r;return l}}),r("auhY5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("4x7f5"),n=s("jwj1g"),r=s("kcpiS"),o=new n({Extends:i,initialize:function(t,e,n){if(void 0===n&&(n={}),/**
         * Audio buffer containing decoded data of the audio asset to be played.
         *
         * @name Phaser.Sound.WebAudioSound#audioBuffer
         * @type {AudioBuffer}
         * @private
         * @since 3.0.0
         */this.audioBuffer=t.game.cache.audio.get(e),!this.audioBuffer)throw Error('There is no audio asset with key "'+e+'" in the audio cache');/**
         * A reference to an audio source node used for playing back audio from
         * audio data stored in Phaser.Sound.WebAudioSound#audioBuffer.
         *
         * @name Phaser.Sound.WebAudioSound#source
         * @type {AudioBufferSourceNode}
         * @private
         * @default null
         * @since 3.0.0
         */this.source=null,/**
         * A reference to a second audio source used for gapless looped playback.
         *
         * @name Phaser.Sound.WebAudioSound#loopSource
         * @type {AudioBufferSourceNode}
         * @private
         * @default null
         * @since 3.0.0
         */this.loopSource=null,/**
         * Gain node responsible for controlling this sound's muting.
         *
         * @name Phaser.Sound.WebAudioSound#muteNode
         * @type {GainNode}
         * @private
         * @since 3.0.0
         */this.muteNode=t.context.createGain(),/**
         * Gain node responsible for controlling this sound's volume.
         *
         * @name Phaser.Sound.WebAudioSound#volumeNode
         * @type {GainNode}
         * @private
         * @since 3.0.0
         */this.volumeNode=t.context.createGain(),/**
         * The time at which the sound should have started playback from the beginning.
         * Based on BaseAudioContext.currentTime value.
         *
         * @name Phaser.Sound.WebAudioSound#playTime
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this.playTime=0,/**
         * The time at which the sound source should have actually started playback.
         * Based on BaseAudioContext.currentTime value.
         *
         * @name Phaser.Sound.WebAudioSound#startTime
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this.startTime=0,/**
         * The time at which the sound loop source should actually start playback.
         * Based on BaseAudioContext.currentTime value.
         *
         * @name Phaser.Sound.WebAudioSound#loopTime
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this.loopTime=0,/**
         * An array where we keep track of all rate updates during playback.
         * Array of object types: { time: number, rate: number }
         *
         * @name Phaser.Sound.WebAudioSound#rateUpdates
         * @type {array}
         * @private
         * @default []
         * @since 3.0.0
         */this.rateUpdates=[],/**
         * Used for keeping track when sound source playback has ended
         * so its state can be updated accordingly.
         *
         * @name Phaser.Sound.WebAudioSound#hasEnded
         * @type {boolean}
         * @private
         * @default false
         * @since 3.0.0
         */this.hasEnded=!1,/**
         * Used for keeping track when sound source has looped
         * so its state can be updated accordingly.
         *
         * @name Phaser.Sound.WebAudioSound#hasLooped
         * @type {boolean}
         * @private
         * @default false
         * @since 3.0.0
         */this.hasLooped=!1,this.muteNode.connect(this.volumeNode),this.volumeNode.connect(t.destination),this.duration=this.audioBuffer.duration,this.totalDuration=this.audioBuffer.duration,i.call(this,t,e,n)},/**
     * Play this sound, or a marked section of it.
     * 
     * It always plays the sound from the start. If you want to start playback from a specific time
     * you can set 'seek' setting of the config object, provided to this call, to that value.
     *
     * @method Phaser.Sound.WebAudioSound#play
     * @fires Phaser.Sound.Events#PLAY
     * @since 3.0.0
     *
     * @param {(string|Phaser.Types.Sound.SoundConfig)} [markerName=''] - If you want to play a marker then provide the marker name here. Alternatively, this parameter can be a SoundConfig object.
     * @param {Phaser.Types.Sound.SoundConfig} [config] - Optional sound config object to be applied to this marker or entire sound if no marker name is provided. It gets memorized for future plays of current section of the sound.
     *
     * @return {boolean} Whether the sound started playing successfully.
     */play:function(t,e){return!!i.prototype.play.call(this,t,e)&&(//  \/\/\/ isPlaying = true, isPaused = false \/\/\/
this.stopAndRemoveBufferSource(),this.createAndStartBufferSource(),this.emit(r.PLAY,this),!0)},/**
     * Pauses the sound.
     *
     * @method Phaser.Sound.WebAudioSound#pause
     * @fires Phaser.Sound.Events#PAUSE
     * @since 3.0.0
     *
     * @return {boolean} Whether the sound was paused successfully.
     */pause:function(){return!(this.manager.context.currentTime<this.startTime)&&!!i.prototype.pause.call(this)&&(//  \/\/\/ isPlaying = false, isPaused = true \/\/\/
this.currentConfig.seek=this.getCurrentTime(),this.stopAndRemoveBufferSource(),this.emit(r.PAUSE,this),!0)},/**
     * Resumes the sound.
     *
     * @method Phaser.Sound.WebAudioSound#resume
     * @fires Phaser.Sound.Events#RESUME
     * @since 3.0.0
     *
     * @return {boolean} Whether the sound was resumed successfully.
     */resume:function(){return!(this.manager.context.currentTime<this.startTime)&&!!i.prototype.resume.call(this)&&(//  \/\/\/ isPlaying = true, isPaused = false \/\/\/
this.createAndStartBufferSource(),this.emit(r.RESUME,this),!0)},/**
     * Stop playing this sound.
     *
     * @method Phaser.Sound.WebAudioSound#stop
     * @fires Phaser.Sound.Events#STOP
     * @since 3.0.0
     *
     * @return {boolean} Whether the sound was stopped successfully.
     */stop:function(){return!!i.prototype.stop.call(this)&&(//  \/\/\/ isPlaying = false, isPaused = false \/\/\/
this.stopAndRemoveBufferSource(),this.emit(r.STOP,this),!0)},/**
     * Used internally.
     *
     * @method Phaser.Sound.WebAudioSound#createAndStartBufferSource
     * @private
     * @since 3.0.0
     */createAndStartBufferSource:function(){var t=this.currentConfig.seek,e=this.currentConfig.delay,i=this.manager.context.currentTime+e,n=(this.currentMarker?this.currentMarker.start:0)+t,s=this.duration-t;this.playTime=i-t,this.startTime=i,this.source=this.createBufferSource(),this.applyConfig(),this.source.start(Math.max(0,i),Math.max(0,n),Math.max(0,s)),this.resetConfig()},/**
     * Used internally.
     *
     * @method Phaser.Sound.WebAudioSound#createAndStartLoopBufferSource
     * @private
     * @since 3.0.0
     */createAndStartLoopBufferSource:function(){var t=this.getLoopTime(),e=this.currentMarker?this.currentMarker.start:0,i=this.duration;this.loopTime=t,this.loopSource=this.createBufferSource(),this.loopSource.playbackRate.setValueAtTime(this.totalRate,0),this.loopSource.start(Math.max(0,t),Math.max(0,e),Math.max(0,i))},/**
     * Used internally.
     *
     * @method Phaser.Sound.WebAudioSound#createBufferSource
     * @private
     * @since 3.0.0
     *
     * @return {AudioBufferSourceNode}
     */createBufferSource:function(){var t=this,e=this.manager.context.createBufferSource();return e.buffer=this.audioBuffer,e.connect(this.muteNode),e.onended=function(e){e.target===t.source&&(t.currentConfig.loop?t.hasLooped=!0:t.hasEnded=!0);// else was stopped
},e},/**
     * Used internally.
     *
     * @method Phaser.Sound.WebAudioSound#stopAndRemoveBufferSource
     * @private
     * @since 3.0.0
     */stopAndRemoveBufferSource:function(){this.source&&(this.source.stop(),this.source.disconnect(),this.source=null),this.playTime=0,this.startTime=0,this.stopAndRemoveLoopBufferSource()},/**
     * Used internally.
     *
     * @method Phaser.Sound.WebAudioSound#stopAndRemoveLoopBufferSource
     * @private
     * @since 3.0.0
     */stopAndRemoveLoopBufferSource:function(){this.loopSource&&(this.loopSource.stop(),this.loopSource.disconnect(),this.loopSource=null),this.loopTime=0},/**
     * Method used internally for applying config values to some of the sound properties.
     *
     * @method Phaser.Sound.WebAudioSound#applyConfig
     * @protected
     * @since 3.0.0
     */applyConfig:function(){this.rateUpdates.length=0,this.rateUpdates.push({time:0,rate:1}),i.prototype.applyConfig.call(this)},/**
     * Update method called automatically by sound manager on every game step.
     *
     * @method Phaser.Sound.WebAudioSound#update
     * @fires Phaser.Sound.Events#COMPLETE
     * @fires Phaser.Sound.Events#LOOPED
     * @protected
     * @since 3.0.0
     *
     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time elapsed since the last frame.
     */// eslint-disable-next-line no-unused-vars
update:function(t,e){this.hasEnded?(this.hasEnded=!1,i.prototype.stop.call(this),this.stopAndRemoveBufferSource(),this.emit(r.COMPLETE,this)):this.hasLooped&&(this.hasLooped=!1,this.source=this.loopSource,this.loopSource=null,this.playTime=this.startTime=this.loopTime,this.rateUpdates.length=0,this.rateUpdates.push({time:0,rate:this.totalRate}),this.createAndStartLoopBufferSource(),this.emit(r.LOOPED,this))},/**
     * Calls Phaser.Sound.BaseSound#destroy method
     * and cleans up all Web Audio API related stuff.
     *
     * @method Phaser.Sound.WebAudioSound#destroy
     * @since 3.0.0
     */destroy:function(){i.prototype.destroy.call(this),this.audioBuffer=null,this.stopAndRemoveBufferSource(),this.muteNode.disconnect(),this.muteNode=null,this.volumeNode.disconnect(),this.volumeNode=null,this.rateUpdates.length=0,this.rateUpdates=null},/**
     * Method used internally to calculate total playback rate of the sound.
     *
     * @method Phaser.Sound.WebAudioSound#calculateRate
     * @protected
     * @since 3.0.0
     */calculateRate:function(){i.prototype.calculateRate.call(this);var t=this.manager.context.currentTime;this.source&&"number"==typeof this.totalRate&&this.source.playbackRate.setValueAtTime(this.totalRate,t),this.isPlaying&&(this.rateUpdates.push({time:Math.max(this.startTime,t)-this.playTime,rate:this.totalRate}),this.loopSource&&(this.stopAndRemoveLoopBufferSource(),this.createAndStartLoopBufferSource()))},/**
     * Method used internally for calculating current playback time of a playing sound.
     *
     * @method Phaser.Sound.WebAudioSound#getCurrentTime
     * @private
     * @since 3.0.0
     */getCurrentTime:function(){for(var t=0,e=0;e<this.rateUpdates.length;e++)t+=((e<this.rateUpdates.length-1?this.rateUpdates[e+1].time:this.manager.context.currentTime-this.playTime)-this.rateUpdates[e].time)*this.rateUpdates[e].rate;return t},/**
     * Method used internally for calculating the time
     * at witch the loop source should start playing.
     *
     * @method Phaser.Sound.WebAudioSound#getLoopTime
     * @private
     * @since 3.0.0
     */getLoopTime:function(){for(var t=0,e=0;e<this.rateUpdates.length-1;e++)t+=(this.rateUpdates[e+1].time-this.rateUpdates[e].time)*this.rateUpdates[e].rate;var i=this.rateUpdates[this.rateUpdates.length-1];return this.playTime+i.time+(this.duration-t)/i.rate},/**
     * Rate at which this Sound will be played.
     * Value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
     * and 2.0 doubles the audios playback speed.
     *
     * @name Phaser.Sound.WebAudioSound#rate
     * @type {number}
     * @default 1
     * @fires Phaser.Sound.Events#RATE
     * @since 3.0.0
     */rate:{get:function(){return this.currentConfig.rate},set:function(t){this.currentConfig.rate=t,this.calculateRate(),this.emit(r.RATE,this,t)}},/**
     * Sets the playback rate of this Sound.
     * 
     * For example, a value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
     * and 2.0 doubles the audios playback speed.
     *
     * @method Phaser.Sound.WebAudioSound#setRate
     * @fires Phaser.Sound.Events#RATE
     * @since 3.3.0
     *
     * @param {number} value - The playback rate at of this Sound.
     *
     * @return {Phaser.Sound.WebAudioSound} This Sound.
     */setRate:function(t){return this.rate=t,this},/**
     * The detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
     * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
     *
     * @name Phaser.Sound.WebAudioSound#detune
     * @type {number}
     * @default 0
     * @fires Phaser.Sound.Events#DETUNE
     * @since 3.0.0
     */detune:{get:function(){return this.currentConfig.detune},set:function(t){this.currentConfig.detune=t,this.calculateRate(),this.emit(r.DETUNE,this,t)}},/**
     * Sets the detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
     * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
     *
     * @method Phaser.Sound.WebAudioSound#setDetune
     * @fires Phaser.Sound.Events#DETUNE
     * @since 3.3.0
     *
     * @param {number} value - The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
     *
     * @return {Phaser.Sound.WebAudioSound} This Sound.
     */setDetune:function(t){return this.detune=t,this},/**
     * Boolean indicating whether the sound is muted or not.
     * Gets or sets the muted state of this sound.
     * 
     * @name Phaser.Sound.WebAudioSound#mute
     * @type {boolean}
     * @default false
     * @fires Phaser.Sound.Events#MUTE
     * @since 3.0.0
     */mute:{get:function(){return 0===this.muteNode.gain.value},set:function(t){this.currentConfig.mute=t,this.muteNode.gain.setValueAtTime(t?0:1,0),this.emit(r.MUTE,this,t)}},/**
     * Sets the muted state of this Sound.
     *
     * @method Phaser.Sound.WebAudioSound#setMute
     * @fires Phaser.Sound.Events#MUTE
     * @since 3.4.0
     *
     * @param {boolean} value - `true` to mute this sound, `false` to unmute it.
     *
     * @return {Phaser.Sound.WebAudioSound} This Sound instance.
     */setMute:function(t){return this.mute=t,this},/**
     * Gets or sets the volume of this sound, a value between 0 (silence) and 1 (full volume).
     * 
     * @name Phaser.Sound.WebAudioSound#volume
     * @type {number}
     * @default 1
     * @fires Phaser.Sound.Events#VOLUME
     * @since 3.0.0
     */volume:{get:function(){return this.volumeNode.gain.value},set:function(t){this.currentConfig.volume=t,this.volumeNode.gain.setValueAtTime(t,0),this.emit(r.VOLUME,this,t)}},/**
     * Sets the volume of this Sound.
     *
     * @method Phaser.Sound.WebAudioSound#setVolume
     * @fires Phaser.Sound.Events#VOLUME
     * @since 3.4.0
     *
     * @param {number} value - The volume of the sound.
     *
     * @return {Phaser.Sound.WebAudioSound} This Sound instance.
     */setVolume:function(t){return this.volume=t,this},/**
     * Property representing the position of playback for this sound, in seconds.
     * Setting it to a specific value moves current playback to that position.
     * The value given is clamped to the range 0 to current marker duration.
     * Setting seek of a stopped sound has no effect.
     * 
     * @name Phaser.Sound.WebAudioSound#seek
     * @type {number}
     * @fires Phaser.Sound.Events#SEEK
     * @since 3.0.0
     */seek:{get:function(){return this.isPlaying?this.manager.context.currentTime<this.startTime?this.startTime-this.playTime:this.getCurrentTime():this.isPaused?this.currentConfig.seek:0},set:function(t){!(this.manager.context.currentTime<this.startTime)&&(this.isPlaying||this.isPaused)&&(t=Math.min(Math.max(0,t),this.duration),this.currentConfig.seek=t,this.isPlaying&&(this.stopAndRemoveBufferSource(),this.createAndStartBufferSource()),this.emit(r.SEEK,this,t))}},/**
     * Seeks to a specific point in this sound.
     *
     * @method Phaser.Sound.WebAudioSound#setSeek
     * @fires Phaser.Sound.Events#SEEK
     * @since 3.4.0
     *
     * @param {number} value - The point in the sound to seek to.
     *
     * @return {Phaser.Sound.WebAudioSound} This Sound instance.
     */setSeek:function(t){return this.seek=t,this},/**
     * Flag indicating whether or not the sound or current sound marker will loop.
     * 
     * @name Phaser.Sound.WebAudioSound#loop
     * @type {boolean}
     * @default false
     * @fires Phaser.Sound.Events#LOOP
     * @since 3.0.0
     */loop:{get:function(){return this.currentConfig.loop},set:function(t){this.currentConfig.loop=t,this.isPlaying&&(this.stopAndRemoveLoopBufferSource(),t&&this.createAndStartLoopBufferSource()),this.emit(r.LOOP,this,t)}},/**
     * Sets the loop state of this Sound.
     *
     * @method Phaser.Sound.WebAudioSound#setLoop
     * @fires Phaser.Sound.Events#LOOP
     * @since 3.4.0
     *
     * @param {boolean} value - `true` to loop this sound, `false` to not loop it.
     *
     * @return {Phaser.Sound.WebAudioSound} This Sound instance.
     */setLoop:function(t){return this.loop=t,this}});t.exports=o}),r("LHpuq",function(t,e){/* eslint no-console: 0 *//**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */var i=s("6QMQ2"),n=s("jwj1g"),r=s("ewzDY"),o=s("3vRz3"),a=s("c0SEE"),h=s("czVpT"),l=s("2kdfq"),u=new n({Extends:o,initialize:function(t){o.call(this),/**
         * A reference to the Phaser.Game instance.
         *
         * @name Phaser.FacebookInstantGamesPlugin#game
         * @type {Phaser.Game}
         * @readOnly
         * @since 3.13.0
         */this.game=t,/**
         * A Data Manager instance.
         * It allows you to store, query and retrieve any key/value data you may need to store.
         * It's also used internally by the plugin to store FBIG API data.
         *
         * @name Phaser.FacebookInstantGamesPlugin#data
         * @type {Phaser.Data.DataManager}
         * @since 3.13.0
         */this.data=new r(this),this.on("setdata",this.setDataHandler,this),this.on("changedata",this.changeDataHandler,this),/**
         * Has the Facebook Instant Games API loaded yet?
         * This is set automatically during the boot process.
         *
         * @name Phaser.FacebookInstantGamesPlugin#hasLoaded
         * @type {boolean}
         * @since 3.13.0
         */this.hasLoaded=!1,/**
         * Is the Data Manager currently locked?
         *
         * @name Phaser.FacebookInstantGamesPlugin#dataLocked
         * @type {boolean}
         * @since 3.13.0
         */this.dataLocked=!1,/**
         * A list of the Facebook Instant Games APIs that are available,
         * based on the given platform, context and user privacy settings.
         * This value is populated automatically during boot.
         *
         * @name Phaser.FacebookInstantGamesPlugin#supportedAPIs
         * @type {string[]}
         * @since 3.13.0
         */this.supportedAPIs=[],/**
         * Holds the entry point that the game was launched from.
         * This value is populated automatically during boot.
         *
         * @name Phaser.FacebookInstantGamesPlugin#entryPoint
         * @type {string}
         * @since 3.13.0
         */this.entryPoint="",/**
         * An object that contains any data associated with the entry point that the game was launched from.
         * The contents of the object are developer-defined, and can occur from entry points on different platforms.
         * This will return null for older mobile clients, as well as when there is no data associated with the particular entry point.
         * This value is populated automatically during boot.
         *
         * @name Phaser.FacebookInstantGamesPlugin#entryPointData
         * @type {any}
         * @since 3.13.0
         */this.entryPointData=null,/**
         * A unique identifier for the current game context. This represents a specific context
         * that the game is being played in (for example, a particular messenger conversation or facebook post).
         * The identifier will be null if game is being played in a solo context.
         * This value is populated automatically during boot.
         *
         * @name Phaser.FacebookInstantGamesPlugin#contextID
         * @type {string}
         * @since 3.13.0
         */this.contextID=null,/**
         * The current context in which your game is running. This can be either `null` or
         * one of:
         * 
         * `POST` - The game is running inside of a Facebook post.
         * `THREAD` - The game is running inside a Facebook Messenger thread.
         * `GROUP` - The game is running inside a Facebook Group.
         * `SOLO` - This is the default context, the player is the only participant.
         * 
         * This value is populated automatically during boot.
         *
         * @name Phaser.FacebookInstantGamesPlugin#contextType
         * @type {?string}
         * @since 3.13.0
         */this.contextType=null,/**
         * The current locale.
         * See https://origincache.facebook.com/developers/resources/?id=FacebookLocales.xml for a complete list of supported locale values.
         * Use this to determine what languages the current game should be localized with.
         * This value is populated automatically during boot.
         *
         * @name Phaser.FacebookInstantGamesPlugin#locale
         * @type {?string}
         * @since 3.13.0
         */this.locale=null,/**
         * The platform on which the game is currently running, i.e. `IOS`.
         * This value is populated automatically during boot.
         *
         * @name Phaser.FacebookInstantGamesPlugin#platform
         * @type {?string}
         * @since 3.13.0
         */this.platform=null,/**
         * The string representation of the Facebook Instant Games SDK version being used.
         * This value is populated automatically during boot.
         *
         * @name Phaser.FacebookInstantGamesPlugin#version
         * @type {?string}
         * @since 3.13.0
         */this.version=null,/**
         * Holds the id of the player. This is a string based ID, the same as `FBInstant.player.getID()`.
         * This value is populated automatically during boot if the API is supported.
         *
         * @name Phaser.FacebookInstantGamesPlugin#playerID
         * @type {?string}
         * @since 3.13.0
         */this.playerID=null,/**
         * The player's localized display name.
         * This value is populated automatically during boot if the API is supported.
         *
         * @name Phaser.FacebookInstantGamesPlugin#playerName
         * @type {?string}
         * @since 3.13.0
         */this.playerName=null,/**
         * A url to the player's public profile photo. The photo will always be a square, and with dimensions
         * of at least 200x200. When rendering it in the game, the exact dimensions should never be assumed to be constant.
         * It's recommended to always scale the image to a desired size before rendering.
         * This value is populated automatically during boot if the API is supported.
         *
         * @name Phaser.FacebookInstantGamesPlugin#playerPhotoURL
         * @type {?string}
         * @since 3.13.0
         */this.playerPhotoURL=null,/**
         * Whether a player can subscribe to the game bot or not.
         *
         * @name Phaser.FacebookInstantGamesPlugin#playerCanSubscribeBot
         * @type {boolean}
         * @since 3.13.0
         */this.playerCanSubscribeBot=!1,/**
         * Does the current platform and context allow for use of the payments API?
         * Currently this is only available on Facebook.com and Android 6+.
         *
         * @name Phaser.FacebookInstantGamesPlugin#paymentsReady
         * @type {boolean}
         * @since 3.13.0
         */this.paymentsReady=!1,/**
         * The set of products that are registered to the game.
         *
         * @name Phaser.FacebookInstantGamesPlugin#catalog
         * @type {Product[]}
         * @since 3.13.0
         */this.catalog=[],/**
         * Contains all of the player's unconsumed purchases.
         * The game must fetch the current player's purchases as soon as the client indicates that it is ready to perform payments-related operations,
         * i.e. at game start. The game can then process and consume any purchases that are waiting to be consumed.
         *
         * @name Phaser.FacebookInstantGamesPlugin#purchases
         * @type {Purchase[]}
         * @since 3.13.0
         */this.purchases=[],/**
         * Contains all of the leaderboard data, as populated by the `getLeaderboard()` method.
         *
         * @name Phaser.FacebookInstantGamesPlugin#leaderboards
         * @type {Phaser.FacebookInstantGamesLeaderboard[]}
         * @since 3.13.0
         */this.leaderboards={},/**
         * Contains AdInstance objects, as created by the `preloadAds()` method.
         *
         * @name Phaser.FacebookInstantGamesPlugin#ads
         * @type {AdInstance[]}
         * @since 3.13.0
         */this.ads=[]},/**
     * Internal set data handler.
     *
     * @method Phaser.FacebookInstantGamesPlugin#setDataHandler
     * @private
     * @since 3.13.0
     *
     * @param {Phaser.Data.DataManager} parent - The parent Data Manager instance.
     * @param {string} key - The key of the data.
     * @param {any} value - The value of the data.
     */setDataHandler:function(t,e,i){if(!this.dataLocked){var n={};n[e]=i;var s=this;FBInstant.player.setDataAsync(n).then(function(){s.emit("savedata",n)})}},/**
     * Internal change data handler.
     *
     * @method Phaser.FacebookInstantGamesPlugin#changeDataHandler
     * @private
     * @since 3.13.0
     *
     * @param {Phaser.Data.DataManager} parent - The parent Data Manager instance.
     * @param {string} key - The key of the data.
     * @param {any} value - The value of the data.
     */changeDataHandler:function(t,e,i){if(!this.dataLocked){var n={};n[e]=i;var s=this;FBInstant.player.setDataAsync(n).then(function(){s.emit("savedata",n)})}},/**
     * Call this method from your `Scene.preload` in order to sync the load progress
     * of the Phaser Loader with the Facebook Instant Games loader display, i.e.:
     * 
     * ```javascript
     * this.facebook.showLoadProgress(this);
     * this.facebook.once('startgame', this.startGame, this);
     * ```
     *
     * @method Phaser.FacebookInstantGamesPlugin#showLoadProgress
     * @since 3.13.0
     *
     * @param {Phaser.Scene} scene - The Scene for which you want to show loader progress for.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */showLoadProgress:function(t){return t.load.on("progress",function(t){this.hasLoaded||FBInstant.setLoadingProgress(100*t)},this),t.load.on("complete",function(){this.hasLoaded||(this.hasLoaded=!0,FBInstant.startGameAsync().then(this.gameStartedHandler.bind(this)))},this),this},/**
     * This method is called automatically when the game has finished loading,
     * if you used the `showLoadProgress` method. If your game doesn't need to
     * load any assets, or you're managing the load yourself, then call this
     * method directly to start the API running.
     * 
     * When the API has finished starting this plugin will emit a `startgame` event
     * which you should listen for.
     *
     * @method Phaser.FacebookInstantGamesPlugin#gameStarted
     * @since 3.13.0
     */gameStarted:function(){this.hasLoaded?this.gameStartedHandler():(this.hasLoaded=!0,FBInstant.startGameAsync().then(this.gameStartedHandler.bind(this)))},/**
     * The internal gameStarted handler.
     * 
     * @method Phaser.FacebookInstantGamesPlugin#gameStartedHandler
     * @private
     * @since 3.20.0
     */gameStartedHandler:function(){var t=FBInstant.getSupportedAPIs(),e={},i=function(t){return t[1].toUpperCase()};t.forEach(function(t){e[t=t.replace(/\../g,i)]=!0}),this.supportedAPIs=e,this.getID(),this.getType(),this.getLocale(),this.getPlatform(),this.getSDKVersion(),this.getPlayerID(),this.getPlayerName(),this.getPlayerPhotoURL();var n=this;FBInstant.onPause(function(){n.emit("pause")}),FBInstant.getEntryPointAsync().then(function(t){n.entryPoint=t,n.entryPointData=FBInstant.getEntryPointData(),n.emit("startgame")}).catch(function(t){console.warn(t)}),this.supportedAPIs.paymentsPurchaseAsync&&FBInstant.payments.onReady(function(){n.paymentsReady=!0}).catch(function(t){console.warn(t)})},/**
     * Checks to see if a given Facebook Instant Games API is available or not.
     *
     * @method Phaser.FacebookInstantGamesPlugin#checkAPI
     * @since 3.13.0
     * 
     * @param {string} api - The API to check for, i.e. `player.getID`.
     * 
     * @return {boolean} `true` if the API is supported, otherwise `false`.
     */checkAPI:function(t){return!!this.supportedAPIs[t]},/**
     * Returns the unique identifier for the current game context. This represents a specific context
     * that the game is being played in (for example, a particular messenger conversation or facebook post).
     * The identifier will be null if game is being played in a solo context.
     * 
     * It is only populated if `contextGetID` is in the list of supported APIs.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getID
     * @since 3.13.0
     * 
     * @return {string} The context ID.
     */getID:function(){return!this.contextID&&this.supportedAPIs.contextGetID&&(this.contextID=FBInstant.context.getID()),this.contextID},/**
     * Returns the current context in which your game is running. This can be either `null` or one of:
     * 
     * `POST` - The game is running inside of a Facebook post.
     * `THREAD` - The game is running inside a Facebook Messenger thread.
     * `GROUP` - The game is running inside a Facebook Group.
     * `SOLO` - This is the default context, the player is the only participant.
     * 
     * It is only populated if `contextGetType` is in the list of supported APIs.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getType
     * @since 3.13.0
     * 
     * @return {?string} The context type.
     */getType:function(){return!this.contextType&&this.supportedAPIs.contextGetType&&(this.contextType=FBInstant.context.getType()),this.contextType},/**
     * Returns the current locale.
     * See https://origincache.facebook.com/developers/resources/?id=FacebookLocales.xml for a complete list of supported locale values.
     * Use this to determine what languages the current game should be localized with.
     * It is only populated if `getLocale` is in the list of supported APIs.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getLocale
     * @since 3.13.0
     * 
     * @return {?string} The current locale.
     */getLocale:function(){return!this.locale&&this.supportedAPIs.getLocale&&(this.locale=FBInstant.getLocale()),this.locale},/**
     * Returns the platform on which the game is currently running, i.e. `IOS`.
     * It is only populated if `getPlatform` is in the list of supported APIs.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getPlatform
     * @since 3.13.0
     * 
     * @return {?string} The current platform.
     */getPlatform:function(){return!this.platform&&this.supportedAPIs.getPlatform&&(this.platform=FBInstant.getPlatform()),this.platform},/**
     * Returns the string representation of the Facebook Instant Games SDK version being used.
     * It is only populated if `getSDKVersion` is in the list of supported APIs.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getSDKVersion
     * @since 3.13.0
     * 
     * @return {?string} The sdk version.
     */getSDKVersion:function(){return!this.version&&this.supportedAPIs.getSDKVersion&&(this.version=FBInstant.getSDKVersion()),this.version},/**
     * Returns the id of the player. This is a string based ID, the same as `FBInstant.player.getID()`.
     * It is only populated if `playerGetID` is in the list of supported APIs.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getPlayerID
     * @since 3.13.0
     * 
     * @return {?string} The player ID.
     */getPlayerID:function(){return!this.playerID&&this.supportedAPIs.playerGetID&&(this.playerID=FBInstant.player.getID()),this.playerID},/**
     * Returns the player's localized display name.
     * It is only populated if `playerGetName` is in the list of supported APIs.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getPlayerName
     * @since 3.13.0
     * 
     * @return {?string} The player's localized display name.
     */getPlayerName:function(){return!this.playerName&&this.supportedAPIs.playerGetName&&(this.playerName=FBInstant.player.getName()),this.playerName},/**
     * Returns the url to the player's public profile photo. The photo will always be a square, and with dimensions
     * of at least 200x200. When rendering it in the game, the exact dimensions should never be assumed to be constant.
     * It's recommended to always scale the image to a desired size before rendering.
     * It is only populated if `playerGetPhoto` is in the list of supported APIs.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getPlayerPhotoURL
     * @since 3.13.0
     * 
     * @return {?string} The player's photo url.
     */getPlayerPhotoURL:function(){return!this.playerPhotoURL&&this.supportedAPIs.playerGetPhoto&&(this.playerPhotoURL=FBInstant.player.getPhoto()),this.playerPhotoURL},/**
     * Load the player's photo and store it in the Texture Manager, ready for use in-game.
     * 
     * This method works by using a Scene Loader instance and then asking the Loader to
     * retrieve the image.
     * 
     * When complete the plugin will emit a `photocomplete` event, along with the key of the photo.
     * 
     * ```javascript
     * this.facebook.loadPlayerPhoto(this, 'player').once('photocomplete', function (key) {
     *   this.add.image(x, y, 'player');
     * }, this);
     * ```
     *
     * @method Phaser.FacebookInstantGamesPlugin#loadPlayerPhoto
     * @since 3.13.0
     * 
     * @param {Phaser.Scene} scene - The Scene that will be responsible for loading this photo.
     * @param {string} key - The key to use when storing the photo in the Texture Manager.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */loadPlayerPhoto:function(t,e){return this.playerPhotoURL&&(t.load.setCORS("anonymous"),t.load.image(e,this.playerPhotoURL),t.load.once("filecomplete-image-"+e,function(){this.emit("photocomplete",e)},this),t.load.start()),this},/**
     * Checks if the current player can subscribe to the game bot.
     * 
     * It makes an async call to the API, so the result isn't available immediately.
     * 
     * If they can subscribe, the `playerCanSubscribeBot` property is set to `true`
     * and this plugin will emit the `cansubscribebot` event.
     * 
     * If they cannot, i.e. it's not in the list of supported APIs, or the request
     * was rejected, it will emit a `cansubscribebotfail` event instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#canSubscribeBot
     * @since 3.13.0
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */canSubscribeBot:function(){if(this.supportedAPIs.playerCanSubscribeBotAsync){var t=this;FBInstant.player.canSubscribeBotAsync().then(function(){t.playerCanSubscribeBot=!0,t.emit("cansubscribebot")}).catch(function(e){t.emit("cansubscribebotfail",e)})}else this.emit("cansubscribebotfail");return this},/**
     * Subscribes the current player to the game bot.
     * 
     * It makes an async call to the API, so the result isn't available immediately.
     * 
     * If they are successfully subscribed this plugin will emit the `subscribebot` event.
     * 
     * If they cannot, i.e. it's not in the list of supported APIs, or the request
     * was rejected, it will emit a `subscribebotfail` event instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#subscribeBot
     * @since 3.13.0
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */subscribeBot:function(){if(this.playerCanSubscribeBot){var t=this;FBInstant.player.subscribeBotAsync().then(function(){t.emit("subscribebot")}).catch(function(e){t.emit("subscribebotfail",e)})}else this.emit("subscribebotfail");return this},/**
     * Gets the associated data from the player based on the given key, or array of keys.
     * 
     * The data is requested in an async call, so the result isn't available immediately.
     * 
     * When the call completes the data is set into this plugins Data Manager and the
     * `getdata` event will be emitted.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getData
     * @since 3.13.0
     * 
     * @param {(string|string[])} keys - The key/s of the data to retrieve.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */getData:function(t){if(!this.checkAPI("playerGetDataAsync"))return this;Array.isArray(t)||(t=[t]);var e=this;return FBInstant.player.getDataAsync(t).then(function(t){for(var i in e.dataLocked=!0,t)e.data.set(i,t[i]);e.dataLocked=!1,e.emit("getdata",t)}),this},/**
     * Set data to be saved to the designated cloud storage of the current player. The game can store up to 1MB of data for each unique player.
     * 
     * The data save is requested in an async call, so the result isn't available immediately.
     * 
     * Data managed via this plugins Data Manager instance is automatically synced with Facebook. However, you can call this
     * method directly if you need to replace the data object directly.
     * 
     * When the APIs `setDataAsync` call resolves it will emit the `savedata` event from this plugin. If the call fails for some
     * reason it will emit `savedatafail` instead.
     * 
     * The call resolving does not necessarily mean that the input has already been persisted. Rather, it means that the data was valid and
     * has been scheduled to be saved. It also guarantees that all values that were set are now available in `getData`.
     *
     * @method Phaser.FacebookInstantGamesPlugin#saveData
     * @since 3.13.0
     * 
     * @param {object} data - An object containing a set of key-value pairs that should be persisted to cloud storage.
     * The object must contain only serializable values - any non-serializable values will cause the entire modification to be rejected.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */saveData:function(t){if(!this.checkAPI("playerSetDataAsync"))return this;var e=this;return FBInstant.player.setDataAsync(t).then(function(){e.emit("savedata",t)}).catch(function(t){e.emit("savedatafail",t)}),this},/**
     * Immediately flushes any changes to the player data to the designated cloud storage.
     * This function is expensive, and should primarily be used for critical changes where persistence needs to be immediate
     * and known by the game. Non-critical changes should rely on the platform to persist them in the background.
     * NOTE: Calls to player.setDataAsync will be rejected while this function's result is pending.
     * 
     * Data managed via this plugins Data Manager instance is automatically synced with Facebook. However, you can call this
     * method directly if you need to flush the data directly.
     * 
     * When the APIs `flushDataAsync` call resolves it will emit the `flushdata` event from this plugin. If the call fails for some
     * reason it will emit `flushdatafail` instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#flushData
     * @since 3.13.0
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */flushData:function(){if(!this.checkAPI("playerFlushDataAsync"))return this;var t=this;return FBInstant.player.flushDataAsync().then(function(){t.emit("flushdata")}).catch(function(e){t.emit("flushdatafail",e)}),this},/**
     * Retrieve stats from the designated cloud storage of the current player.
     * 
     * The data is requested in an async call, so the result isn't available immediately.
     * 
     * When the call completes the `getstats` event will be emitted along with the data object returned.
     * 
     * If the call fails, i.e. it's not in the list of supported APIs, or the request was rejected,
     * it will emit a `getstatsfail` event instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getStats
     * @since 3.13.0
     * 
     * @param {string[]} [keys] - An optional array of unique keys to retrieve stats for. If the function is called without it, it will fetch all stats.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */getStats:function(t){if(!this.checkAPI("playerGetStatsAsync"))return this;var e=this;return FBInstant.player.getStatsAsync(t).then(function(t){e.emit("getstats",t)}).catch(function(t){e.emit("getstatsfail",t)}),this},/**
     * Save the stats of the current player to the designated cloud storage.
     * 
     * Stats in the Facebook Instant Games API are purely numerical values paired with a string-based key. Only numbers can be saved as stats,
     * all other data types will be ignored.
     * 
     * The data is requested in an async call, so the result isn't available immediately.
     * 
     * When the call completes the `savestats` event will be emitted along with the data object returned.
     * 
     * If the call fails, i.e. it's not in the list of supported APIs, or the request was rejected,
     * it will emit a `savestatsfail` event instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#saveStats
     * @since 3.13.0
     * 
     * @param {object} data - An object containing a set of key-value pairs that should be persisted to cloud storage as stats. Note that only numerical values are stored.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */saveStats:function(t){if(!this.checkAPI("playerSetStatsAsync"))return this;var e={};for(var i in t)"number"==typeof t[i]&&(e[i]=t[i]);var n=this;return FBInstant.player.setStatsAsync(e).then(function(){n.emit("savestats",e)}).catch(function(t){n.emit("savestatsfail",t)}),this},/**
     * Increment the stats of the current player and save them to the designated cloud storage.
     * 
     * Stats in the Facebook Instant Games API are purely numerical values paired with a string-based key. Only numbers can be saved as stats,
     * all other data types will be ignored.
     * 
     * The data object provided for this call should contain offsets for how much to modify the stats by:
     * 
     * ```javascript
     * this.facebook.incStats({
     *     level: 1,
     *     zombiesSlain: 17,
     *     rank: -1
     * });
     * ```
     * 
     * The data is requested in an async call, so the result isn't available immediately.
     * 
     * When the call completes the `incstats` event will be emitted along with the data object returned.
     * 
     * If the call fails, i.e. it's not in the list of supported APIs, or the request was rejected,
     * it will emit a `incstatsfail` event instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#incStats
     * @since 3.13.0
     * 
     * @param {object} data - An object containing a set of key-value pairs indicating how much to increment each stat in cloud storage. Note that only numerical values are processed.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */incStats:function(t){if(!this.checkAPI("playerIncrementStatsAsync"))return this;var e={};for(var i in t)"number"==typeof t[i]&&(e[i]=t[i]);var n=this;return FBInstant.player.incrementStatsAsync(e).then(function(t){n.emit("incstats",t)}).catch(function(t){n.emit("incstatsfail",t)}),this},/**
     * Sets the data associated with the individual gameplay session for the current context.
     * 
     * This function should be called whenever the game would like to update the current session data.
     * 
     * This session data may be used to populate a variety of payloads, such as game play webhooks.
     *
     * @method Phaser.FacebookInstantGamesPlugin#saveSession
     * @since 3.13.0
     * 
     * @param {object} data - An arbitrary data object, which must be less than or equal to 1000 characters when stringified.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */saveSession:function(t){return this.checkAPI("setSessionData")&&(JSON.stringify(t).length<=1e3?FBInstant.setSessionData(t):console.warn("Session data too long. Max 1000 chars.")),this},/**
     * This invokes a dialog to let the user share specified content, either as a message in Messenger or as a post on the user's timeline.
     * 
     * A blob of data can be attached to the share which every game session launched from the share will be able to access via the `this.entryPointData` property.
     * 
     * This data must be less than or equal to 1000 characters when stringified.
     * 
     * When this method is called you should consider your game paused. Listen out for the `resume` event from this plugin to know when the dialog has been closed.
     * 
     * The user may choose to cancel the share action and close the dialog. The resulting `resume` event will be dispatched regardless if the user actually shared the content or not.
     *
     * @method Phaser.FacebookInstantGamesPlugin#openShare
     * @since 3.13.0
     * 
     * @param {string} text - A text message to be shared.
     * @param {string} key - The key of the texture to use as the share image.
     * @param {string} [frame] - The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
     * @param {object} [sessionData] - A blob of data to attach to the share.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */openShare:function(t,e,i,n){return this._share("SHARE",t,e,i,n)},/**
     * This invokes a dialog to let the user invite a friend to play this game, either as a message in Messenger or as a post on the user's timeline.
     * 
     * A blob of data can be attached to the share which every game session launched from the share will be able to access via the `this.entryPointData` property.
     * 
     * This data must be less than or equal to 1000 characters when stringified.
     * 
     * When this method is called you should consider your game paused. Listen out for the `resume` event from this plugin to know when the dialog has been closed.
     * 
     * The user may choose to cancel the share action and close the dialog. The resulting `resume` event will be dispatched regardless if the user actually shared the content or not.
     *
     * @method Phaser.FacebookInstantGamesPlugin#openInvite
     * @since 3.13.0
     * 
     * @param {string} text - A text message to be shared.
     * @param {string} key - The key of the texture to use as the share image.
     * @param {string} [frame] - The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
     * @param {object} [sessionData] - A blob of data to attach to the share.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */openInvite:function(t,e,i,n){return this._share("INVITE",t,e,i,n)},/**
     * This invokes a dialog to let the user share specified content, either as a message in Messenger or as a post on the user's timeline.
     * 
     * A blob of data can be attached to the share which every game session launched from the share will be able to access via the `this.entryPointData` property.
     * 
     * This data must be less than or equal to 1000 characters when stringified.
     * 
     * When this method is called you should consider your game paused. Listen out for the `resume` event from this plugin to know when the dialog has been closed.
     * 
     * The user may choose to cancel the share action and close the dialog. The resulting `resume` event will be dispatched regardless if the user actually shared the content or not.
     *
     * @method Phaser.FacebookInstantGamesPlugin#openRequest
     * @since 3.13.0
     * 
     * @param {string} text - A text message to be shared.
     * @param {string} key - The key of the texture to use as the share image.
     * @param {string} [frame] - The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
     * @param {object} [sessionData] - A blob of data to attach to the share.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */openRequest:function(t,e,i,n){return this._share("REQUEST",t,e,i,n)},/**
     * This invokes a dialog to let the user share specified content, either as a message in Messenger or as a post on the user's timeline.
     * 
     * A blob of data can be attached to the share which every game session launched from the share will be able to access via the `this.entryPointData` property.
     * 
     * This data must be less than or equal to 1000 characters when stringified.
     * 
     * When this method is called you should consider your game paused. Listen out for the `resume` event from this plugin to know when the dialog has been closed.
     * 
     * The user may choose to cancel the share action and close the dialog. The resulting `resume` event will be dispatched regardless if the user actually shared the content or not.
     *
     * @method Phaser.FacebookInstantGamesPlugin#openChallenge
     * @since 3.13.0
     * 
     * @param {string} text - A text message to be shared.
     * @param {string} key - The key of the texture to use as the share image.
     * @param {string} [frame] - The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
     * @param {object} [sessionData] - A blob of data to attach to the share.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */openChallenge:function(t,e,i,n){return this._share("CHALLENGE",t,e,i,n)},/**
     * Internal share handler.
     *
     * @method Phaser.FacebookInstantGamesPlugin#_share
     * @private
     * @since 3.13.0
     * 
     * @param {string} intent - ("INVITE" | "REQUEST" | "CHALLENGE" | "SHARE") Indicates the intent of the share.
     * @param {string} text - A text message to be shared.
     * @param {string} key - The key of the texture to use as the share image.
     * @param {string} [frame] - The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
     * @param {object} [sessionData] - A blob of data to attach to the share.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */_share:function(t,e,i,n,s){if(!this.checkAPI("shareAsync"))return this;if(void 0===s&&(s={}),i)var r=this.game.textures.getBase64(i,n);// intent ("INVITE" | "REQUEST" | "CHALLENGE" | "SHARE") Indicates the intent of the share.
// image string A base64 encoded image to be shared.
// text string A text message to be shared.
// data Object? A blob of data to attach to the share. All game sessions launched from the share will be able to access this blob through FBInstant.getEntryPointData().
var o={intent:t,image:r,text:e,data:s},a=this;return FBInstant.shareAsync(o).then(function(){a.emit("resume")}),this},/**
     * This function determines whether the number of participants in the current game context is between a given minimum and maximum, inclusive.
     * If one of the bounds is null only the other bound will be checked against.
     * It will always return the original result for the first call made in a context in a given game play session.
     * Subsequent calls, regardless of arguments, will return the answer to the original query until a context change occurs and the query result is reset.
     *
     * @method Phaser.FacebookInstantGamesPlugin#isSizeBetween
     * @since 3.13.0
     * 
     * @param {integer} [min] - The minimum bound of the context size query.
     * @param {integer} [max] - The maximum bound of the context size query.
     * 
     * @return {object} The Context Size Response object in the format: `{answer: boolean, minSize: number?, maxSize: number?}`.
     */isSizeBetween:function(t,e){return this.checkAPI("contextIsSizeBetween")?FBInstant.context.isSizeBetween(t,e):this},/**
     * Request a switch into a specific context. If the player does not have permission to enter that context,
     * or if the player does not provide permission for the game to enter that context, this will emit a `switchfail` event.
     * 
     * Otherwise, the plugin will emit the `switch` event when the game has switched into the specified context.
     *
     * @method Phaser.FacebookInstantGamesPlugin#switchContext
     * @since 3.13.0
     * 
     * @param {string} contextID - The ID of the desired context.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */switchContext:function(t){if(!this.checkAPI("contextSwitchAsync"))return this;if(t!==this.contextID){var e=this;FBInstant.context.switchAsync(t).then(function(){e.contextID=FBInstant.context.getID(),e.emit("switch",e.contextID)}).catch(function(t){e.emit("switchfail",t)})}return this},/**
     * A filter that may be applied to a Context Choose operation.
     * 
     * 'NEW_CONTEXT_ONLY' - Prefer to only surface contexts the game has not been played in before.
     * 'INCLUDE_EXISTING_CHALLENGES' - Include the "Existing Challenges" section, which surfaces actively played-in contexts that the player is a part of.
     * 'NEW_PLAYERS_ONLY' - In sections containing individuals, prefer people who have not played the game.
     * 
     * @typedef {string} ContextFilter
     *//**
     * A configuration object that may be applied to a Context Choose operation.
     * 
     * @typedef {object} ChooseContextConfig
     * @property {ContextFilter[]} [filters] - The set of filters to apply to the context suggestions: 'NEW_CONTEXT_ONLY', 'INCLUDE_EXISTING_CHALLENGES' or 'NEW_PLAYERS_ONLY'.
     * @property {number} [maxSize] - The maximum number of participants that a suggested context should ideally have.
     * @property {number} [minSize] - The minimum number of participants that a suggested context should ideally have.
     *//**
     * Opens a context selection dialog for the player. If the player selects an available context,
     * the client will attempt to switch into that context, and emit the `choose` event if successful.
     * Otherwise, if the player exits the menu or the client fails to switch into the new context, the `choosefail` event will be emitted.
     * 
     * @method Phaser.FacebookInstantGamesPlugin#chooseContext
     * @since 3.13.0
     * 
     * @param {ChooseContextConfig} [options] - An object specifying conditions on the contexts that should be offered.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */chooseContext:function(t){if(!this.checkAPI("contextChooseAsync"))return this;var e=this;return FBInstant.context.chooseAsync(t).then(function(){e.contextID=FBInstant.context.getID(),e.emit("choose",e.contextID)}).catch(function(t){e.emit("choosefail",t)}),this},/**
     * Attempts to create or switch into a context between a specified player and the current player.
     * This plugin will emit the `create` event once the context switch is completed.
     * If the API call fails, such as if the player listed is not a Connected Player of the current player or if the
     * player does not provide permission to enter the new context, then the plugin will emit a 'createfail' event.
     *
     * @method Phaser.FacebookInstantGamesPlugin#createContext
     * @since 3.13.0
     * 
     * @param {string} playerID - ID of the player.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */createContext:function(t){if(!this.checkAPI("contextCreateAsync"))return this;var e=this;return FBInstant.context.createAsync(t).then(function(){e.contextID=FBInstant.context.getID(),e.emit("create",e.contextID)}).catch(function(t){e.emit("createfail",t)}),this},/**
     * Fetches an array of ConnectedPlayer objects containing information about active players
     * (people who played the game in the last 90 days) that are connected to the current player.
     * 
     * It makes an async call to the API, so the result isn't available immediately.
     * 
     * If they are successfully subscribed this plugin will emit the `players` event along
     * with the player data.
     * 
     * If they cannot, i.e. it's not in the list of supported APIs, or the request
     * was rejected, it will emit a `playersfail` event instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getPlayers
     * @since 3.13.0
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */getPlayers:function(){if(!this.checkAPI("playerGetConnectedPlayersAsync"))return this;var t=this;return FBInstant.player.getConnectedPlayersAsync().then(function(e){t.emit("players",e)}).catch(function(e){t.emit("playersfail",e)}),this},/**
     * Fetches the game's product catalog.
     * 
     * It makes an async call to the API, so the result isn't available immediately.
     * 
     * If they are successfully subscribed this plugin will emit the `getcatalog` event along
     * with the catalog data.
     * 
     * If they cannot, i.e. it's not in the list of supported APIs, or the request
     * was rejected, it will emit a `getcatalogfail` event instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getCatalog
     * @since 3.13.0
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */getCatalog:function(){if(!this.paymentsReady)return this;var t=this,e=this.catalog;return FBInstant.payments.getCatalogAsync().then(function(i){e=[],i.forEach(function(t){e.push(h(t))}),t.emit("getcatalog",e)}).catch(function(e){t.emit("getcatalogfail",e)}),this},/**
     * Fetches a single Product from the game's product catalog.
     * 
     * The product catalog must have been populated using `getCatalog` prior to calling this method.
     * 
     * Use this to look-up product details based on a purchase list.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getProduct
     * @since 3.17.0
     * 
     * @param {string} productID - The Product ID of the item to get from the catalog.
     * 
     * @return {?Product} The Product from the catalog, or `null` if it couldn't be found or the catalog isn't populated.
     */getProduct:function(t){for(var e=0;e<this.catalog.length;e++)if(this.catalog[e].productID===t)return this.catalog[e];return null},/**
     * Begins the purchase flow for a specific product.
     * 
     * It makes an async call to the API, so the result isn't available immediately.
     * 
     * If they are successfully subscribed this plugin will emit the `purchase` event along
     * with the purchase data.
     * 
     * If they cannot, i.e. it's not in the list of supported APIs, or the request
     * was rejected, it will emit a `purchasefail` event instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#purchase
     * @since 3.13.0
     * 
     * @param {string} productID - The identifier of the product to purchase.
     * @param {string} [developerPayload] - An optional developer-specified payload, to be included in the returned purchase's signed request.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */purchase:function(t,e){if(!this.paymentsReady)return this;var i={productID:t};e&&(i.developerPayload=e);var n=this;return FBInstant.payments.purchaseAsync(i).then(function(t){var e=l(t);n.emit("purchase",e)}).catch(function(t){n.emit("purchasefail",t)}),this},/**
     * Fetches all of the player's unconsumed purchases. The game must fetch the current player's purchases
     * as soon as the client indicates that it is ready to perform payments-related operations,
     * i.e. at game start. The game can then process and consume any purchases that are waiting to be consumed.
     * 
     * It makes an async call to the API, so the result isn't available immediately.
     * 
     * If they are successfully subscribed this plugin will emit the `getpurchases` event along
     * with the purchase data.
     * 
     * If they cannot, i.e. it's not in the list of supported APIs, or the request
     * was rejected, it will emit a `getpurchasesfail` event instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getPurchases
     * @since 3.13.0
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */getPurchases:function(){if(!this.paymentsReady)return this;var t=this,e=this.purchases;return FBInstant.payments.getPurchasesAsync().then(function(i){e=[],i.forEach(function(t){e.push(l(t))}),t.emit("getpurchases",e)}).catch(function(e){t.emit("getpurchasesfail",e)}),this},/**
     * Consumes a specific purchase belonging to the current player. Before provisioning a product's effects to the player,
     * the game should request the consumption of the purchased product. Once the purchase is successfully consumed,
     * the game should immediately provide the player with the effects of their purchase.
     * 
     * It makes an async call to the API, so the result isn't available immediately.
     * 
     * If they are successfully subscribed this plugin will emit the `consumepurchase` event along
     * with the purchase data.
     * 
     * If they cannot, i.e. it's not in the list of supported APIs, or the request
     * was rejected, it will emit a `consumepurchasefail` event instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#consumePurchase
     * @since 3.17.0
     * 
     * @param {string} purchaseToken - The purchase token of the purchase that should be consumed.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */consumePurchase:function(t){if(!this.paymentsReady)return this;var e=this;return FBInstant.payments.consumePurchaseAsync(t).then(function(){e.emit("consumepurchase",t)}).catch(function(t){e.emit("consumepurchasefail",t)}),this},/**
     * Informs Facebook of a custom update that occurred in the game.
     * This will temporarily yield control to Facebook and Facebook will decide what to do based on what the update is.
     * Once Facebook returns control to the game the plugin will emit an `update` or `updatefail` event.
     * 
     * It makes an async call to the API, so the result isn't available immediately.
     * 
     * The `text` parameter is an update payload with the following structure:
     * 
     * ```
     * text: {
     *     default: 'X just invaded Y\'s village!',
     *     localizations: {
     *         ar_AR: 'X \u0641\u0642\u0637 \u063A\u0632\u062A ' +
     *         '\u0642\u0631\u064A\u0629 Y!',
     *         en_US: 'X just invaded Y\'s village!',
     *         es_LA: '\u00A1X acaba de invadir el pueblo de Y!',
     *     }
     * }
     * ```
     *
     * @method Phaser.FacebookInstantGamesPlugin#update
     * @since 3.13.0
     * 
     * @param {string} cta - The call to action text.
     * @param {object} text - The text object.
     * @param {string} key - The key of the texture to use as the share image.
     * @param {?(string|integer)} frame - The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
     * @param {string} template - The update template key.
     * @param {object} updateData - The update data object payload.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */update:function(t,e,i,n,s,r){return this._update("CUSTOM",t,e,i,n,s,r)},/**
     * Informs Facebook of a leaderboard update that occurred in the game.
     * This will temporarily yield control to Facebook and Facebook will decide what to do based on what the update is.
     * Once Facebook returns control to the game the plugin will emit an `update` or `updatefail` event.
     * 
     * It makes an async call to the API, so the result isn't available immediately.
     * 
     * The `text` parameter is an update payload with the following structure:
     * 
     * ```
     * text: {
     *     default: 'X just invaded Y\'s village!',
     *     localizations: {
     *         ar_AR: 'X \u0641\u0642\u0637 \u063A\u0632\u062A ' +
     *         '\u0642\u0631\u064A\u0629 Y!',
     *         en_US: 'X just invaded Y\'s village!',
     *         es_LA: '\u00A1X acaba de invadir el pueblo de Y!',
     *     }
     * }
     * ```
     *
     * @method Phaser.FacebookInstantGamesPlugin#updateLeaderboard
     * @since 3.13.0
     * 
     * @param {string} cta - The call to action text.
     * @param {object} text - The text object.
     * @param {string} key - The key of the texture to use as the share image.
     * @param {?(string|integer)} frame - The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
     * @param {string} template - The update template key.
     * @param {object} updateData - The update data object payload.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */updateLeaderboard:function(t,e,i,n,s,r){return this._update("LEADERBOARD",t,e,i,n,s,r)},/**
     * Internal update handler.
     *
     * @method Phaser.FacebookInstantGamesPlugin#_update
     * @private
     * @since 3.13.0
     * 
     * @param {string} action - The update action.
     * @param {string} cta - The call to action text.
     * @param {object} text - The text object.
     * @param {string} key - The key of the texture to use as the share image.
     * @param {?(string|integer)} frame - The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
     * @param {string} template - The update template key.
     * @param {object} updateData - The update data object payload.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */_update:function(t,e,i,n,s,r,o){if(!this.checkAPI("shareAsync"))return this;if(void 0===e&&(e=""),"string"==typeof i&&(i={default:i}),void 0===o&&(o={}),n)var a=this.game.textures.getBase64(n,s);var h={action:t,cta:e,image:a,text:i,template:r,data:o,strategy:"IMMEDIATE",notification:"NO_PUSH"},l=this;return FBInstant.updateAsync(h).then(function(){l.emit("update")}).catch(function(t){l.emit("updatefail",t)}),this},/**
     * Request that the client switch to a different Instant Game.
     * 
     * It makes an async call to the API, so the result isn't available immediately.
     * 
     * If the game switches successfully this plugin will emit the `switchgame` event and the client will load the new game.
     * 
     * If they cannot, i.e. it's not in the list of supported APIs, or the request
     * was rejected, it will emit a `switchgamefail` event instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#switchGame
     * @since 3.13.0
     * 
     * @param {string} appID - The Application ID of the Instant Game to switch to. The application must be an Instant Game, and must belong to the same business as the current game.
     * @param {object} [data] - An optional data payload. This will be set as the entrypoint data for the game being switched to. Must be less than or equal to 1000 characters when stringified.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */switchGame:function(t,e){if(!this.checkAPI("switchGameAsync"))return this;if(e&&JSON.stringify(e).length>1e3)return console.warn("Switch Game data too long. Max 1000 chars."),this;var i=this;return FBInstant.switchGameAsync(t,e).then(function(){i.emit("switchgame",t)}).catch(function(t){i.emit("switchgamefail",t)}),this},/**
     * Prompts the user to create a shortcut to the game if they are eligible to.
     * Can only be called once per session.
     * 
     * It makes an async call to the API, so the result isn't available immediately.
     * 
     * If the user choose to create a shortcut this plugin will emit the `shortcutcreated` event.
     * 
     * If they cannot, i.e. it's not in the list of supported APIs, or the request
     * was rejected, it will emit a `shortcutcreatedfail` event instead.
     *
     * @method Phaser.FacebookInstantGamesPlugin#createShortcut
     * @since 3.13.0
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */createShortcut:function(){var t=this;return FBInstant.canCreateShortcutAsync().then(function(e){e&&FBInstant.createShortcutAsync().then(function(){t.emit("shortcutcreated")}).catch(function(e){t.emit("shortcutfailed",e)})}),this},/**
     * Quits the game.
     *
     * @method Phaser.FacebookInstantGamesPlugin#quit
     * @since 3.13.0
     */quit:function(){FBInstant.quit()},/**
     * Log an app event with FB Analytics.
     * 
     * See https://developers.facebook.com/docs/javascript/reference/v2.8#app_events for more details about FB Analytics.
     *
     * @method Phaser.FacebookInstantGamesPlugin#log
     * @since 3.13.0
     * 
     * @param {string} name - Name of the event. Must be 2 to 40 characters, and can only contain '_', '-', ' ', and alphanumeric characters.
     * @param {number} [value] - An optional numeric value that FB Analytics can calculate a sum with.
     * @param {object} [params] - An optional object that can contain up to 25 key-value pairs to be logged with the event. Keys must be 2 to 40 characters, and can only contain '_', '-', ' ', and alphanumeric characters. Values must be less than 100 characters in length.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */log:function(t,e,i){return this.checkAPI("logEvent")&&(void 0===i&&(i={}),t.length>=2&&t.length<=40&&FBInstant.logEvent(t,parseFloat(e),i)),this},/**
     * Attempt to create an instance of an interstitial ad.
     * 
     * If the instance is created successfully then the ad is preloaded ready for display in-game via the method `showAd()`.
     * 
     * If the ad loads it will emit the `adloaded` event, passing the AdInstance as the only parameter.
     * 
     * If the ad cannot be displayed because there was no inventory to fill it, it will emit the `adsnofill` event.
     *
     * @method Phaser.FacebookInstantGamesPlugin#preloadAds
     * @since 3.13.0
     * 
     * @param {(string|string[])} placementID - The ad placement ID, or an array of IDs, as created in your Audience Network settings within Facebook.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */preloadAds:function(t){if(!this.checkAPI("getInterstitialAdAsync"))return this;Array.isArray(t)||(t=[t]);var e=this,n=0;for(s=0;s<this.ads.length;s++)!this.ads[s].shown&&n++;if(n+t.length>=3)return console.warn("Too many AdInstances. Show an ad before loading more"),this;for(s=0;s<t.length;s++){var s,r,o=t[s];FBInstant.getInterstitialAdAsync(o).then(function(t){return r=t,t.loadAsync()}).then(function(){var t=i(o,r,!1);e.ads.push(t),e.emit("adloaded",t)}).catch(function(t){"ADS_NO_FILL"===t.code?e.emit("adsnofill",o):"ADS_FREQUENT_LOAD"===t.code?e.emit("adsfrequentload",o):console.warn(t)})}return this},/**
     * Attempt to create an instance of an rewarded video ad.
     * 
     * If the instance is created successfully then the ad is preloaded ready for display in-game via the method `showVideo()`.
     * 
     * If the ad loads it will emit the `adloaded` event, passing the AdInstance as the only parameter.
     * 
     * If the ad cannot be displayed because there was no inventory to fill it, it will emit the `adsnofill` event.
     *
     * @method Phaser.FacebookInstantGamesPlugin#preloadVideoAds
     * @since 3.13.0
     * 
     * @param {(string|string[])} placementID - The ad placement ID, or an array of IDs, as created in your Audience Network settings within Facebook.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */preloadVideoAds:function(t){if(!this.checkAPI("getRewardedVideoAsync"))return this;Array.isArray(t)||(t=[t]);var e=this,n=0;for(s=0;s<this.ads.length;s++)!this.ads[s].shown&&n++;if(n+t.length>=3)return console.warn("Too many AdInstances. Show an ad before loading more"),this;for(s=0;s<t.length;s++){var s,r,o=t[s];FBInstant.getRewardedVideoAsync(o).then(function(t){return r=t,t.loadAsync()}).then(function(){var t=i(o,r,!0);e.ads.push(t),e.emit("adloaded",t)}).catch(function(t){"ADS_NO_FILL"===t.code?e.emit("adsnofill",o):"ADS_FREQUENT_LOAD"===t.code?e.emit("adsfrequentload",o):console.warn(t)})}return this},/**
     * Displays a previously loaded interstitial ad.
     * 
     * If the ad is successfully displayed this plugin will emit the `adfinished` event, with the AdInstance object as its parameter.
     * 
     * If the ad cannot be displayed, it will emit the `adsnotloaded` event.
     *
     * @method Phaser.FacebookInstantGamesPlugin#showAd
     * @since 3.13.0
     * 
     * @param {string} placementID - The ad placement ID to display.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */showAd:function(t){for(var e=this,i=0;i<this.ads.length;i++){var n=this.ads[i];if(n.placementID===t&&!n.shown){n.instance.showAsync().then(function(){n.shown=!0,e.emit("adfinished",n)}).catch(function(t){"ADS_NOT_LOADED"===t.code?e.emit("adsnotloaded",n):"RATE_LIMITED"===t.code&&e.emit("adratelimited",n),e.emit("adshowerror",t,n)});break}}return this},/**
     * Displays a previously loaded interstitial video ad.
     * 
     * If the ad is successfully displayed this plugin will emit the `adfinished` event, with the AdInstance object as its parameter.
     * 
     * If the ad cannot be displayed, it will emit the `adsnotloaded` event.
     *
     * @method Phaser.FacebookInstantGamesPlugin#showVideo
     * @since 3.13.0
     * 
     * @param {string} placementID - The ad placement ID to display.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */showVideo:function(t){for(var e=this,i=0;i<this.ads.length;i++){var n=this.ads[i];if(n.placementID===t&&n.video&&!n.shown){n.instance.showAsync().then(function(){n.shown=!0,e.emit("adfinished",n)}).catch(function(t){"ADS_NOT_LOADED"===t.code?e.emit("adsnotloaded",n):"RATE_LIMITED"===t.code&&e.emit("adratelimited",n),e.emit("adshowerror",t,n)});break}}return this},/**
     * Attempts to match the current player with other users looking for people to play with.
     * If successful, a new Messenger group thread will be created containing the matched players and the player will
     * be context switched to that thread. This plugin will also dispatch the `matchplayer` event, containing the new context ID and Type.
     * 
     * The default minimum and maximum number of players in one matched thread are 2 and 20 respectively,
     * depending on how many players are trying to get matched around the same time.
     * 
     * The values can be changed in `fbapp-config.json`. See the Bundle Config documentation for documentation about `fbapp-config.json`.
     *
     * @method Phaser.FacebookInstantGamesPlugin#matchPlayer
     * @since 3.13.0
     * 
     * @param {string} [matchTag] - Optional extra information about the player used to group them with similar players. Players will only be grouped with other players with exactly the same tag. The tag must only include letters, numbers, and underscores and be 100 characters or less in length.
     * @param {boolean} [switchImmediately=false] - Optional extra parameter that specifies whether the player should be immediately switched to the new context when a match is found. By default this will be false which will mean the player needs explicitly press play after being matched to switch to the new context.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */matchPlayer:function(t,e){if(void 0===t&&(t=null),void 0===e&&(e=!1),!this.checkAPI("matchPlayerAsync"))return this;var i=this;return FBInstant.matchPlayerAsync(t,e).then(function(){i.getID(),i.getType(),i.emit("matchplayer",i.contextID,i.contextType)}),this},/**
     * Fetch a specific leaderboard belonging to this Instant Game.
     * 
     * The data is requested in an async call, so the result isn't available immediately.
     * 
     * When the call completes the `getleaderboard` event will be emitted along with a Leaderboard object instance.
     *
     * @method Phaser.FacebookInstantGamesPlugin#getLeaderboard
     * @since 3.13.0
     * 
     * @param {string} name - The name of the leaderboard. Each leaderboard for an Instant Game must have its own distinct name.
     * 
     * @return {this} This Facebook Instant Games Plugin instance.
     */getLeaderboard:function(t){if(!this.checkAPI("getLeaderboardAsync"))return this;var e=this;return FBInstant.getLeaderboardAsync(t).then(function(i){var n=new a(e,i);e.leaderboards[t]=n,e.emit("getleaderboard",n)}).catch(function(t){console.warn(t)}),this},/**
     * Quits the Facebook API and then destroys this plugin.
     *
     * @method Phaser.FacebookInstantGamesPlugin#destroy
     * @since 3.13.0
     */destroy:function(){FBInstant.quit(),this.data.destroy(),this.removeAllListeners(),this.catalog=[],this.purchases=[],this.leaderboards=[],this.ads=[],this.game=null}});t.exports=u}),r("6QMQ2",function(t,e){t.exports=function(t,e,i){return{instance:e,placementID:t,shown:!1,video:i}}}),r("c0SEE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */var i=s("jwj1g"),n=s("3vRz3"),r=s("aNzkO"),o=new i({Extends:n,initialize:function(t,e){n.call(this),/**
         * A reference to the Facebook Instant Games Plugin.
         *
         * @name Phaser.FacebookInstantGamesLeaderboard#plugin
         * @type {Phaser.FacebookInstantGamesPlugin}
         * @since 3.13.0
         */this.plugin=t,/**
         * An Instant Game leaderboard instance.
         *
         * @name Phaser.FacebookInstantGamesLeaderboard#ref
         * @type {any}
         * @since 3.13.0
         */this.ref=e,/**
         * The name of the leaderboard.
         *
         * @name Phaser.FacebookInstantGamesLeaderboard#name
         * @type {string}
         * @since 3.13.0
         */this.name=e.getName(),/**
         * The ID of the context that the leaderboard is associated with, or null if the leaderboard is not tied to a particular context.
         *
         * @name Phaser.FacebookInstantGamesLeaderboard#contextID
         * @type {string}
         * @since 3.13.0
         */this.contextID=e.getContextID(),/**
         * The total number of player entries in the leaderboard.
         * This value defaults to zero. Populate it via the `getEntryCount()` method.
         *
         * @name Phaser.FacebookInstantGamesLeaderboard#entryCount
         * @type {integer}
         * @since 3.13.0
         */this.entryCount=0,/**
         * The players score object.
         * This value defaults to `null`. Populate it via the `getPlayerScore()` method.
         *
         * @name Phaser.FacebookInstantGamesLeaderboard#playerScore
         * @type {LeaderboardScore}
         * @since 3.13.0
         */this.playerScore=null,/**
         * The scores in the Leaderboard from the currently requested range.
         * This value defaults to an empty array. Populate it via the `getScores()` method.
         * The contents of this array are reset each time `getScores()` is called.
         *
         * @name Phaser.FacebookInstantGamesLeaderboard#scores
         * @type {LeaderboardScore[]}
         * @since 3.13.0
         */this.scores=[],this.getEntryCount()},/**
     * Fetches the total number of player entries in the leaderboard.
     * 
     * The data is requested in an async call, so the result isn't available immediately.
     * 
     * When the call completes this Leaderboard will emit the `getentrycount` event along with the count and name of the Leaderboard.
     *
     * @method Phaser.FacebookInstantGamesLeaderboard#getEntryCount
     * @since 3.13.0
     * 
     * @return {this} This Leaderboard instance.
     */getEntryCount:function(){var t=this;return this.ref.getEntryCountAsync().then(function(e){t.entryCount=e,t.emit("getentrycount",e,t.name)}).catch(function(t){console.warn(t)}),this},/**
     * Updates the player's score. If the player has an existing score, the old score will only be replaced if the new score is better than it.
     * NOTE: If the leaderboard is associated with a specific context, the game must be in that context to set a score for the player.
     * 
     * The data is requested in an async call, so the result isn't available immediately.
     * 
     * When the call completes this Leaderboard will emit the `setscore` event along with the LeaderboardScore object and the name of the Leaderboard.
     * 
     * If the save fails the event will send `null` as the score value.
     *
     * @method Phaser.FacebookInstantGamesLeaderboard#setScore
     * @since 3.13.0
     * 
     * @param {integer} score - The new score for the player. Must be a 64-bit integer number.
     * @param {(string|any)} [data] - Metadata to associate with the stored score. Must be less than 2KB in size. If an object is given it will be passed to `JSON.stringify`.
     * 
     * @return {this} This Leaderboard instance.
     */setScore:function(t,e){void 0===e&&(e=""),"object"==typeof e&&(e=JSON.stringify(e));var i=this;return this.ref.setScoreAsync(t,e).then(function(t){if(t){var e=r(t);i.playerScore=e,i.emit("setscore",e,i.name)}else i.emit("setscore",null,i.name)}).catch(function(t){console.warn(t)}),this},/**
     * Gets the players leaderboard entry and stores it in the `playerScore` property.
     * 
     * The data is requested in an async call, so the result isn't available immediately.
     * 
     * When the call completes this Leaderboard will emit the `getplayerscore` event along with the score and the name of the Leaderboard.
     * 
     * If the player has not yet saved a score, the event will send `null` as the score value, and `playerScore` will be set to `null` as well.
     *
     * @method Phaser.FacebookInstantGamesLeaderboard#getPlayerScore
     * @since 3.13.0
     * 
     * @return {this} This Leaderboard instance.
     */getPlayerScore:function(){var t=this;return this.ref.getPlayerEntryAsync().then(function(e){if(e){var i=r(e);t.playerScore=i,t.emit("getplayerscore",i,t.name)}else t.emit("getplayerscore",null,t.name)}).catch(function(t){console.warn(t)}),this},/**
     * Retrieves a set of leaderboard entries, ordered by score ranking in the leaderboard.
     * 
     * The data is requested in an async call, so the result isn't available immediately.
     * 
     * When the call completes this Leaderboard will emit the `getscores` event along with an array of LeaderboardScore entries and the name of the Leaderboard.
     *
     * @method Phaser.FacebookInstantGamesLeaderboard#getScores
     * @since 3.13.0
     * 
     * @param {integer} [count=10] - The number of entries to attempt to fetch from the leaderboard. Currently, up to a maximum of 100 entries may be fetched per query.
     * @param {integer} [offset=0] - The offset from the top of the leaderboard that entries will be fetched from.
     * 
     * @return {this} This Leaderboard instance.
     */getScores:function(t,e){void 0===t&&(t=10),void 0===e&&(e=0);var i=this;return this.ref.getEntriesAsync(t,e).then(function(t){i.scores=[],t.forEach(function(t){i.scores.push(r(t))}),i.emit("getscores",i.scores,i.name)}).catch(function(t){console.warn(t)}),this},/**
     * Retrieves a set of leaderboard entries, based on the current player's connected players (including the current player), ordered by local rank within the set of connected players.
     * 
     * The data is requested in an async call, so the result isn't available immediately.
     * 
     * When the call completes this Leaderboard will emit the `getconnectedscores` event along with an array of LeaderboardScore entries and the name of the Leaderboard.
     *
     * @method Phaser.FacebookInstantGamesLeaderboard#getConnectedScores
     * @since 3.16.0
     * 
     * @return {this} This Leaderboard instance.
     */getConnectedScores:function(){var t=this;return this.ref.getConnectedPlayerEntriesAsync().then(function(e){t.scores=[],e.forEach(function(e){t.scores.push(r(e))}),t.emit("getconnectedscores",t.scores,t.name)}).catch(function(t){console.warn(t)}),this}});t.exports=o}),r("aNzkO",function(t,e){t.exports=function(t){return{score:t.getScore(),scoreFormatted:t.getFormattedScore(),timestamp:t.getTimestamp(),rank:t.getRank(),data:t.getExtraData(),playerName:t.getPlayer().getName(),playerPhotoURL:t.getPlayer().getPhoto(),playerID:t.getPlayer().getID()}}}),r("czVpT",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */var i=s("7BSWl");t.exports=function(t){return{title:i(t,"title",""),productID:i(t,"productID",""),description:i(t,"description",""),imageURI:i(t,"imageURI",""),price:i(t,"price",""),priceCurrencyCode:i(t,"priceCurrencyCode","")}}}),r("2kdfq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */var i=s("7BSWl");t.exports=function(t){return{developerPayload:i(t,"developerPayload",""),paymentID:i(t,"paymentID",""),productID:i(t,"productID",""),purchaseTime:i(t,"purchaseTime",""),purchaseToken:i(t,"purchaseToken",""),signedRequest:i(t,"signedRequest","")}}}),r("kNR1J",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.GameObjects
 */var i={Events:s("jIv3O"),DisplayList:s("l2vY8"),GameObjectCreator:s("ebQQp"),GameObjectFactory:s("kge7H"),UpdateList:s("2WeDD"),Components:s("4FF1v"),BuildGameObject:s("i9cSP"),BuildGameObjectAnimation:s("cDuAM"),GameObject:s("1zqlR"),BitmapText:s("gvPR8"),Blitter:s("2cD2D"),Container:s("ixgBh"),DOMElement:s("gZAGH"),DynamicBitmapText:s("5soSO"),Extern:s("9I9TZ"),Graphics:s("2Irqj"),Group:s("hDBsd"),Image:s("8qGvv"),Particles:s("jyMeR"),PathFollower:s("75mFg"),RenderTexture:s("iCX4n"),RetroFont:s("eCKky"),Rope:s("4dBPv"),Sprite:s("gXuc8"),Text:s("1jO0s"),TileSprite:s("kwyUq"),Zone:s("dZGDG"),Video:s("Cfqdl"),//  Shapes
Shape:s("6cKpG"),Arc:s("ab6uD"),Curve:s("20vs1"),Ellipse:s("i1Pn1"),Grid:s("3qA3v"),IsoBox:s("ibqbn"),IsoTriangle:s("e1XH0"),Line:s("cW0dL"),Polygon:s("4HMPS"),Rectangle:s("gGVmO"),Star:s("lemMU"),Triangle:s("b6DRH"),//  Game Object Factories
Factories:{Blitter:s("i3l6S"),Container:s("gE6ET"),DOMElement:s("ghXwl"),DynamicBitmapText:s("pLPkQ"),Extern:s("3f2P6"),Graphics:s("5tfzZ"),Group:s("knm1M"),Image:s("dI5N4"),Particles:s("fgDAM"),PathFollower:s("iE8dp"),RenderTexture:s("60zoM"),Rope:s("43Yb1"),Sprite:s("5SbTm"),StaticBitmapText:s("iv8Vm"),Text:s("8BYGq"),TileSprite:s("ivPvd"),Zone:s("6HUvG"),Video:s("aFn2V"),//  Shapes
Arc:s("kh6qR"),Curve:s("kVr0M"),Ellipse:s("1f8NL"),Grid:s("kJGm5"),IsoBox:s("4MiAm"),IsoTriangle:s("5wABL"),Line:s("jyuVH"),Polygon:s("1dcev"),Rectangle:s("9pPj8"),Star:s("7gJso"),Triangle:s("dhc8H")},Creators:{Blitter:s("hS4bP"),Container:s("azfIw"),DynamicBitmapText:s("aQ5a3"),Graphics:s("aSOvl"),Group:s("kteFs"),Image:s("978g9"),Particles:s("k6UHi"),RenderTexture:s("fc299"),Rope:s("6pbqo"),Sprite:s("jEuMc"),StaticBitmapText:s("k8onx"),Text:s("ejLtj"),TileSprite:s("4wQ0d"),Zone:s("1Uncu"),Video:s("3HD58")}};//  WebGL only Game Objects
i.Mesh=s("3JO7H"),i.Quad=s("frkgB"),i.Shader=s("iwnS9"),i.Factories.Mesh=s("ek47i"),i.Factories.Quad=s("5sQTt"),i.Factories.Shader=s("imx1M"),i.Creators.Mesh=s("3VQSR"),i.Creators.Quad=s("aW7lj"),i.Creators.Shader=s("7bRuL"),i.Light=s("hDwlH"),s("5eZQq"),s("hsf2U"),t.exports=i}),r("l2vY8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("aqhsx"),r=s("7AzQW"),o=s("4rtgc"),a=s("7D0e6"),h=new i({Extends:n,initialize:function(t){n.call(this,t),/**
         * The flag the determines whether Game Objects should be sorted when `depthSort()` is called.
         *
         * @name Phaser.GameObjects.DisplayList#sortChildrenFlag
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.sortChildrenFlag=!1,/**
         * The Scene that this Display List belongs to.
         *
         * @name Phaser.GameObjects.DisplayList#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * The Scene's Systems.
         *
         * @name Phaser.GameObjects.DisplayList#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,t.sys.events.once(o.BOOT,this.boot,this),t.sys.events.on(o.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.GameObjects.DisplayList#boot
     * @private
     * @since 3.5.1
     */boot:function(){this.systems.events.once(o.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.GameObjects.DisplayList#start
     * @private
     * @since 3.5.0
     */start:function(){this.systems.events.once(o.SHUTDOWN,this.shutdown,this)},/**
     * Force a sort of the display list on the next call to depthSort.
     *
     * @method Phaser.GameObjects.DisplayList#queueDepthSort
     * @since 3.0.0
     */queueDepthSort:function(){this.sortChildrenFlag=!0},/**
     * Immediately sorts the display list if the flag is set.
     *
     * @method Phaser.GameObjects.DisplayList#depthSort
     * @since 3.0.0
     */depthSort:function(){this.sortChildrenFlag&&(a.inplace(this.list,this.sortByDepth),this.sortChildrenFlag=!1)},/**
     * Compare the depth of two Game Objects.
     *
     * @method Phaser.GameObjects.DisplayList#sortByDepth
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} childA - The first Game Object.
     * @param {Phaser.GameObjects.GameObject} childB - The second Game Object.
     *
     * @return {integer} The difference between the depths of each Game Object.
     */sortByDepth:function(t,e){return t._depth-e._depth},/**
     * Returns an array which contains all objects currently on the Display List.
     * This is a reference to the main list array, not a copy of it, so be careful not to modify it.
     *
     * @method Phaser.GameObjects.DisplayList#getChildren
     * @since 3.12.0
     *
     * @return {Phaser.GameObjects.GameObject[]} The group members.
     */getChildren:function(){return this.list},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.GameObjects.DisplayList#shutdown
     * @private
     * @since 3.0.0
     */shutdown:function(){for(var t=this.list.length;t--;)this.list[t].destroy(!0);this.list.length=0,this.systems.events.off(o.SHUTDOWN,this.shutdown,this)},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.GameObjects.DisplayList#destroy
     * @private
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.scene.sys.events.off(o.START,this.start,this),this.scene=null,this.systems=null}});r.register("DisplayList",h,"displayList"),t.exports=h}),r("aqhsx",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("3Mp2n"),n=s("jwj1g"),r=s("13GYA"),o=s("7D0e6"),a=new n({initialize:function(t){/**
         * The parent of this list.
         *
         * @name Phaser.Structs.List#parent
         * @type {*}
         * @since 3.0.0
         */this.parent=t,/**
         * The objects that belong to this collection.
         *
         * @genericUse {T[]} - [$type]
         *
         * @name Phaser.Structs.List#list
         * @type {Array.<*>}
         * @default []
         * @since 3.0.0
         */this.list=[],/**
         * The index of the current element.
         * 
         * This is used internally when iterating through the list with the {@link #first}, {@link #last}, {@link #get}, and {@link #previous} properties.
         *
         * @name Phaser.Structs.List#position
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.position=0,/**
         * A callback that is invoked every time a child is added to this list.
         *
         * @name Phaser.Structs.List#addCallback
         * @type {function}
         * @since 3.4.0
         */this.addCallback=r,/**
         * A callback that is invoked every time a child is removed from this list.
         *
         * @name Phaser.Structs.List#removeCallback
         * @type {function}
         * @since 3.4.0
         */this.removeCallback=r,/**
         * The property key to sort by.
         *
         * @name Phaser.Structs.List#_sortKey
         * @type {string}
         * @since 3.4.0
         */this._sortKey=""},/**
     * Adds the given item to the end of the list. Each item must be unique.
     *
     * @method Phaser.Structs.List#add
     * @since 3.0.0
     *
     * @genericUse {T} - [child,$return]
     *
     * @param {*|Array.<*>} child - The item, or array of items, to add to the list.
     * @param {boolean} [skipCallback=false] - Skip calling the List.addCallback if this child is added successfully.
     *
     * @return {*} The list's underlying array.
     */add:function(t,e){return e?i.Add(this.list,t):i.Add(this.list,t,0,this.addCallback,this)},/**
     * Adds an item to list, starting at a specified index. Each item must be unique within the list.
     *
     * @method Phaser.Structs.List#addAt
     * @since 3.0.0
     *
     * @genericUse {T} - [child,$return]
     *
     * @param {*} child - The item, or array of items, to add to the list.
     * @param {integer} [index=0] - The index in the list at which the element(s) will be inserted.
     * @param {boolean} [skipCallback=false] - Skip calling the List.addCallback if this child is added successfully.
     *
     * @return {*} The List's underlying array.
     */addAt:function(t,e,n){return n?i.AddAt(this.list,t,e):i.AddAt(this.list,t,e,0,this.addCallback,this)},/**
     * Retrieves the item at a given position inside the List.
     *
     * @method Phaser.Structs.List#getAt
     * @since 3.0.0
     *
     * @genericUse {T} - [$return]
     *
     * @param {integer} index - The index of the item.
     *
     * @return {*} The retrieved item, or `undefined` if it's outside the List's bounds.
     */getAt:function(t){return this.list[t]},/**
     * Locates an item within the List and returns its index.
     *
     * @method Phaser.Structs.List#getIndex
     * @since 3.0.0
     *
     * @genericUse {T} - [child]
     *
     * @param {*} child - The item to locate.
     *
     * @return {integer} The index of the item within the List, or -1 if it's not in the List.
     */getIndex:function(t){//  Return -1 if given child isn't a child of this display list
return this.list.indexOf(t)},/**
     * Sort the contents of this List so the items are in order based on the given property.
     * For example, `sort('alpha')` would sort the List contents based on the value of their `alpha` property.
     *
     * @method Phaser.Structs.List#sort
     * @since 3.0.0
     *
     * @genericUse {T[]} - [children,$return]
     *
     * @param {string} property - The property to lexically sort by.
     * @param {function} [handler] - Provide your own custom handler function. Will receive 2 children which it should compare and return a boolean.
     *
     * @return {Phaser.Structs.List} This List object.
     */sort:function(t,e){return t&&(void 0===e&&(e=function(e,i){return e[t]-i[t]}),o.inplace(this.list,e)),this},/**
     * Searches for the first instance of a child with its `name`
     * property matching the given argument. Should more than one child have
     * the same name only the first is returned.
     *
     * @method Phaser.Structs.List#getByName
     * @since 3.0.0
     *
     * @genericUse {T | null} - [$return]
     *
     * @param {string} name - The name to search for.
     *
     * @return {?*} The first child with a matching name, or null if none were found.
     */getByName:function(t){return i.GetFirst(this.list,"name",t)},/**
     * Returns a random child from the group.
     *
     * @method Phaser.Structs.List#getRandom
     * @since 3.0.0
     *
     * @genericUse {T | null} - [$return]
     *
     * @param {integer} [startIndex=0] - Offset from the front of the group (lowest child).
     * @param {integer} [length=(to top)] - Restriction on the number of values you want to randomly select from.
     *
     * @return {?*} A random child of this Group.
     */getRandom:function(t,e){return i.GetRandom(this.list,t,e)},/**
     * Returns the first element in a given part of the List which matches a specific criterion.
     *
     * @method Phaser.Structs.List#getFirst
     * @since 3.0.0
     *
     * @genericUse {T | null} - [$return]
     *
     * @param {string} property - The name of the property to test or a falsey value to have no criterion.
     * @param {*} value - The value to test the `property` against, or `undefined` to allow any value and only check for existence.
     * @param {number} [startIndex=0] - The position in the List to start the search at.
     * @param {number} [endIndex] - The position in the List to optionally stop the search at. It won't be checked.
     *
     * @return {?*} The first item which matches the given criterion, or `null` if no such item exists.
     */getFirst:function(t,e,n,s){return i.GetFirst(this.list,t,e,n,s)},/**
     * Returns all children in this List.
     *
     * You can optionally specify a matching criteria using the `property` and `value` arguments.
     *
     * For example: `getAll('parent')` would return only children that have a property called `parent`.
     *
     * You can also specify a value to compare the property to:
     * 
     * `getAll('visible', true)` would return only children that have their visible property set to `true`.
     *
     * Optionally you can specify a start and end index. For example if this List had 100 children,
     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
     * the first 50 children in the List.
     *
     * @method Phaser.Structs.List#getAll
     * @since 3.0.0
     *
     * @genericUse {T} - [value]
     * @genericUse {T[]} - [$return]
     *
     * @param {string} [property] - An optional property to test against the value argument.
     * @param {*} [value] - If property is set then Child.property must strictly equal this value to be included in the results.
     * @param {integer} [startIndex] - The first child index to start the search from.
     * @param {integer} [endIndex] - The last child index to search up until.
     *
     * @return {Array.<*>} All items of the List which match the given criterion, if any.
     */getAll:function(t,e,n,s){return i.GetAll(this.list,t,e,n,s)},/**
     * Returns the total number of items in the List which have a property matching the given value.
     *
     * @method Phaser.Structs.List#count
     * @since 3.0.0
     *
     * @genericUse {T} - [value]
     *
     * @param {string} property - The property to test on each item.
     * @param {*} value - The value to test the property against.
     *
     * @return {integer} The total number of matching elements.
     */count:function(t,e){return i.CountAllMatching(this.list,t,e)},/**
     * Swaps the positions of two items in the list.
     *
     * @method Phaser.Structs.List#swap
     * @since 3.0.0
     *
     * @genericUse {T} - [child1,child2]
     *
     * @param {*} child1 - The first item to swap.
     * @param {*} child2 - The second item to swap.
     */swap:function(t,e){i.Swap(this.list,t,e)},/**
     * Moves an item in the List to a new position.
     *
     * @method Phaser.Structs.List#moveTo
     * @since 3.0.0
     *
     * @genericUse {T} - [child,$return]
     *
     * @param {*} child - The item to move.
     * @param {integer} index - Moves an item in the List to a new position.
     *
     * @return {*} The item that was moved.
     */moveTo:function(t,e){return i.MoveTo(this.list,t,e)},/**
     * Removes one or many items from the List.
     *
     * @method Phaser.Structs.List#remove
     * @since 3.0.0
     *
     * @genericUse {T} - [child,$return]
     *
     * @param {*} child - The item, or array of items, to remove.
     * @param {boolean} [skipCallback=false] - Skip calling the List.removeCallback.
     *
     * @return {*} The item, or array of items, which were successfully removed from the List.
     */remove:function(t,e){return e?i.Remove(this.list,t):i.Remove(this.list,t,this.removeCallback,this)},/**
     * Removes the item at the given position in the List.
     *
     * @method Phaser.Structs.List#removeAt
     * @since 3.0.0
     *
     * @genericUse {T} - [$return]
     *
     * @param {integer} index - The position to remove the item from.
     * @param {boolean} [skipCallback=false] - Skip calling the List.removeCallback.
     *
     * @return {*} The item that was removed.
     */removeAt:function(t,e){return e?i.RemoveAt(this.list,t):i.RemoveAt(this.list,t,this.removeCallback,this)},/**
     * Removes the items within the given range in the List.
     *
     * @method Phaser.Structs.List#removeBetween
     * @since 3.0.0
     *
     * @genericUse {T[]} - [$return]
     *
     * @param {integer} [startIndex=0] - The index to start removing from.
     * @param {integer} [endIndex] - The position to stop removing at. The item at this position won't be removed.
     * @param {boolean} [skipCallback=false] - Skip calling the List.removeCallback.
     *
     * @return {Array.<*>} An array of the items which were removed.
     */removeBetween:function(t,e,n){return n?i.RemoveBetween(this.list,t,e):i.RemoveBetween(this.list,t,e,this.removeCallback,this)},/**
     * Removes all the items.
     *
     * @method Phaser.Structs.List#removeAll
     * @since 3.0.0
     *
     * @genericUse {Phaser.Structs.List.<T>} - [$return]
     * 
     * @param {boolean} [skipCallback=false] - Skip calling the List.removeCallback.
     *
     * @return {Phaser.Structs.List} This List object.
     */removeAll:function(t){for(var e=this.list.length;e--;)this.remove(this.list[e],t);return this},/**
     * Brings the given child to the top of this List.
     *
     * @method Phaser.Structs.List#bringToTop
     * @since 3.0.0
     *
     * @genericUse {T} - [child,$return]
     *
     * @param {*} child - The item to bring to the top of the List.
     *
     * @return {*} The item which was moved.
     */bringToTop:function(t){return i.BringToTop(this.list,t)},/**
     * Sends the given child to the bottom of this List.
     *
     * @method Phaser.Structs.List#sendToBack
     * @since 3.0.0
     *
     * @genericUse {T} - [child,$return]
     *
     * @param {*} child - The item to send to the back of the list.
     *
     * @return {*} The item which was moved.
     */sendToBack:function(t){return i.SendToBack(this.list,t)},/**
     * Moves the given child up one place in this group unless it's already at the top.
     *
     * @method Phaser.Structs.List#moveUp
     * @since 3.0.0
     *
     * @genericUse {T} - [child,$return]
     *
     * @param {*} child - The item to move up.
     *
     * @return {*} The item which was moved.
     */moveUp:function(t){return i.MoveUp(this.list,t),t},/**
     * Moves the given child down one place in this group unless it's already at the bottom.
     *
     * @method Phaser.Structs.List#moveDown
     * @since 3.0.0
     *
     * @genericUse {T} - [child,$return]
     *
     * @param {*} child - The item to move down.
     *
     * @return {*} The item which was moved.
     */moveDown:function(t){return i.MoveDown(this.list,t),t},/**
     * Reverses the order of all children in this List.
     *
     * @method Phaser.Structs.List#reverse
     * @since 3.0.0
     *
     * @genericUse {Phaser.Structs.List.<T>} - [$return]
     *
     * @return {Phaser.Structs.List} This List object.
     */reverse:function(){return this.list.reverse(),this},/**
     * Shuffles the items in the list.
     *
     * @method Phaser.Structs.List#shuffle
     * @since 3.0.0
     *
     * @genericUse {Phaser.Structs.List.<T>} - [$return]
     *
     * @return {Phaser.Structs.List} This List object.
     */shuffle:function(){return i.Shuffle(this.list),this},/**
     * Replaces a child of this List with the given newChild. The newChild cannot be a member of this List.
     *
     * @method Phaser.Structs.List#replace
     * @since 3.0.0
     *
     * @genericUse {T} - [oldChild,newChild,$return]
     *
     * @param {*} oldChild - The child in this List that will be replaced.
     * @param {*} newChild - The child to be inserted into this List.
     *
     * @return {*} Returns the oldChild that was replaced within this group.
     */replace:function(t,e){return i.Replace(this.list,t,e)},/**
     * Checks if an item exists within the List.
     *
     * @method Phaser.Structs.List#exists
     * @since 3.0.0
     *
     * @genericUse {T} - [child]
     *
     * @param {*} child - The item to check for the existence of.
     *
     * @return {boolean} `true` if the item is found in the list, otherwise `false`.
     */exists:function(t){return this.list.indexOf(t)>-1},/**
     * Sets the property `key` to the given value on all members of this List.
     *
     * @method Phaser.Structs.List#setAll
     * @since 3.0.0
     *
     * @genericUse {T} - [value]
     *
     * @param {string} property - The name of the property to set.
     * @param {*} value - The value to set the property to.
     * @param {integer} [startIndex] - The first child index to start the search from.
     * @param {integer} [endIndex] - The last child index to search up until.
     */setAll:function(t,e,n,s){return i.SetAll(this.list,t,e,n,s),this},/**
     * Passes all children to the given callback.
     *
     * @method Phaser.Structs.List#each
     * @since 3.0.0
     *
     * @genericUse {EachListCallback.<T>} - [callback]
     *
     * @param {EachListCallback} callback - The function to call.
     * @param {*} [context] - Value to use as `this` when executing callback.
     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.
     */each:function(t,e){for(var i=[null],n=2;n<arguments.length;n++)i.push(arguments[n]);for(n=0;n<this.list.length;n++)i[0]=this.list[n],t.apply(e,i)},/**
     * Clears the List and recreates its internal array.
     *
     * @method Phaser.Structs.List#shutdown
     * @since 3.0.0
     */shutdown:function(){this.removeAll(),this.list=[]},/**
     * Destroys this List.
     *
     * @method Phaser.Structs.List#destroy
     * @since 3.0.0
     */destroy:function(){this.removeAll(),this.parent=null,this.addCallback=null,this.removeCallback=null},/**
     * The number of items inside the List.
     *
     * @name Phaser.Structs.List#length
     * @type {integer}
     * @readonly
     * @since 3.0.0
     */length:{get:function(){return this.list.length}},/**
     * The first item in the List or `null` for an empty List.
     *
     * @name Phaser.Structs.List#first
     * @genericUse {T} - [$type]
     * @type {*}
     * @readonly
     * @since 3.0.0
     */first:{get:function(){return(this.position=0,this.list.length>0)?this.list[0]:null}},/**
     * The last item in the List, or `null` for an empty List.
     *
     * @name Phaser.Structs.List#last
     * @genericUse {T} - [$type]
     * @type {*}
     * @readonly
     * @since 3.0.0
     */last:{get:function(){return this.list.length>0?(this.position=this.list.length-1,this.list[this.position]):null}},/**
     * The next item in the List, or `null` if the entire List has been traversed.
     * 
     * This property can be read successively after reading {@link #first} or manually setting the {@link #position} to iterate the List.
     *
     * @name Phaser.Structs.List#next
     * @genericUse {T} - [$type]
     * @type {*}
     * @readonly
     * @since 3.0.0
     */next:{get:function(){return this.position<this.list.length?(this.position++,this.list[this.position]):null}},/**
     * The previous item in the List, or `null` if the entire List has been traversed.
     * 
     * This property can be read successively after reading {@link #last} or manually setting the {@link #position} to iterate the List backwards.
     *
     * @name Phaser.Structs.List#previous
     * @genericUse {T} - [$type]
     * @type {*}
     * @readonly
     * @since 3.0.0
     */previous:{get:function(){return this.position>0?(this.position--,this.list[this.position]):null}}});t.exports=a}),r("3Mp2n",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Utils.Array
 */t.exports={Matrix:s("6Yg0C"),Add:s("eN80y"),AddAt:s("57oIl"),BringToTop:s("eqPcv"),CountAllMatching:s("3Tziy"),Each:s("6Gqgp"),EachInRange:s("aUDwM"),FindClosestInSorted:s("3tt0c"),GetAll:s("9CZay"),GetFirst:s("at5Hg"),GetRandom:s("5H1qm"),MoveDown:s("3opXF"),MoveTo:s("lqyO8"),MoveUp:s("6Pd3W"),NumberArray:s("3L6N7"),NumberArrayStep:s("e6GZn"),QuickSelect:s("1ohUM"),Range:s("3OeE3"),Remove:s("2SW6f"),RemoveAt:s("dT2eW"),RemoveBetween:s("b32kD"),RemoveRandomElement:s("3dAOl"),Replace:s("1sHs4"),RotateLeft:s("jq6lX"),RotateRight:s("7ZIew"),SafeRange:s("9GGLm"),SendToBack:s("1KJmp"),SetAll:s("4x0c3"),Shuffle:s("Na5BX"),SpliceOne:s("eOqX8"),StableSort:s("7D0e6"),Swap:s("g1DUE")}}),r("6Yg0C",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Utils.Array.Matrix
 */t.exports={CheckMatrix:s("60a3X"),MatrixToString:s("fLsp3"),ReverseColumns:s("6IAYj"),ReverseRows:s("790OL"),Rotate180:s("it2Do"),RotateLeft:s("d7unX"),RotateMatrix:s("it2gi"),RotateRight:s("iqk2I"),TransposeMatrix:s("aGT6U")}}),r("60a3X",function(t,e){t.exports=function(t){if(!Array.isArray(t)||t.length<2||!Array.isArray(t[0]))return!1;//  Validate the rest of the rows are the same length
for(var e=t[0].length,i=1;i<t.length;i++)if(t[i].length!==e)return!1;return!0}}),r("fLsp3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7y2Q8"),n=s("60a3X");t.exports=function(t){var e="";if(!n(t))return e;for(var s=0;s<t.length;s++){for(var r=0;r<t[s].length;r++){var o=t[s][r].toString();"undefined"!==o?e+=i(o,2):e+="?",r<t[s].length-1&&(e+=" |")}if(s<t.length-1){e+="\n";for(var a=0;a<t[s].length;a++)e+="---",a<t[s].length-1&&(e+="+");e+="\n"}}return e}}),r("6IAYj",function(t,e){t.exports=function(t){return t.reverse()}}),r("790OL",function(t,e){t.exports=function(t){for(var e=0;e<t.length;e++)t[e].reverse();return t}}),r("it2Do",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("it2gi");t.exports=function(t){return i(t,180)}}),r("it2gi",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("60a3X"),n=s("aGT6U");t.exports=function(t,e){if(void 0===e&&(e=90),!i(t))return null;if("string"!=typeof e&&(e=(e%360+360)%360),90===e||-270===e||"rotateLeft"===e)(t=n(t)).reverse();else if(-90===e||270===e||"rotateRight"===e)t.reverse(),t=n(t);else if(180===Math.abs(e)||"rotate180"===e){for(var s=0;s<t.length;s++)t[s].reverse();t.reverse()}return t}}),r("aGT6U",function(t,e){t.exports=function(t){for(var e=t.length,i=t[0].length,n=Array(i),s=0;s<i;s++){n[s]=Array(e);for(var r=e-1;r>-1;r--)n[s][r]=t[r][s]}return n}}),r("d7unX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("it2gi");t.exports=function(t){return i(t,90)}}),r("iqk2I",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("it2gi");t.exports=function(t){return i(t,-90)}}),r("eN80y",function(t,e){t.exports=function(t,e,i,n,s){if(void 0===s&&(s=t),i>0){var r=i-t.length;//  There's nothing more we can do here, the array is full
if(r<=0)return null}//  Fast path to avoid array mutation and iteration
if(!Array.isArray(e))return -1===t.indexOf(e)?(t.push(e),n&&n.call(s,e),e):null;for(//  If we got this far, we have an array of items to insert
//  Ensure all the items are unique
var o=e.length-1;o>=0;)-1!==t.indexOf(e[o])&&e.splice(o,1),o--;if(0===//  Anything left?
(o=e.length))return null;i>0&&o>r&&(e.splice(r),o=r);for(var a=0;a<o;a++){var h=e[a];t.push(h),n&&n.call(s,h)}return e}}),r("57oIl",function(t,e){t.exports=function(t,e,i,n,s,r){if(void 0===i&&(i=0),void 0===r&&(r=t),n>0){var o=n-t.length;//  There's nothing more we can do here, the array is full
if(o<=0)return null}//  Fast path to avoid array mutation and iteration
if(!Array.isArray(e))return -1===t.indexOf(e)?(t.splice(i,0,e),s&&s.call(r,e),e):null;for(//  If we got this far, we have an array of items to insert
//  Ensure all the items are unique
var a=e.length-1;a>=0;)-1!==t.indexOf(e[a])&&e.pop(),a--;if(0===//  Anything left?
(a=e.length))return null;n>0&&a>o&&(e.splice(o),a=o);for(var h=a-1;h>=0;h--){var l=e[h];t.splice(i,0,l),s&&s.call(r,l)}return e}}),r("eqPcv",function(t,e){t.exports=function(t,e){var i=t.indexOf(e);return -1!==i&&i<t.length&&(t.splice(i,1),t.push(e)),e}}),r("3Tziy",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("9GGLm");t.exports=function(t,e,n,s,r){void 0===s&&(s=0),void 0===r&&(r=t.length);var o=0;if(i(t,s,r))for(var a=s;a<r;a++)t[a][e]===n&&o++;return o}}),r("6Gqgp",function(t,e){t.exports=function(t,e,i){var n,s=[null];for(n=3;n<arguments.length;n++)s.push(arguments[n]);for(n=0;n<t.length;n++)s[0]=t[n],e.apply(i,s);return t}}),r("aUDwM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("9GGLm");t.exports=function(t,e,n,s,r){if(void 0===s&&(s=0),void 0===r&&(r=t.length),i(t,s,r)){var o,a=[null];for(o=5;o<arguments.length;o++)a.push(arguments[o]);for(o=s;o<r;o++)a[0]=t[o],e.apply(n,a)}return t}}),r("5H1qm",function(t,e){t.exports=function(t,e,i){void 0===e&&(e=0),void 0===i&&(i=t.length);var n=e+Math.floor(Math.random()*i);return void 0===t[n]?null:t[n]}}),r("3opXF",function(t,e){t.exports=function(t,e){var i=t.indexOf(e);if(i>0){var n=t[i-1],s=t.indexOf(n);t[i]=n,t[s]=e}return t}}),r("lqyO8",function(t,e){t.exports=function(t,e,i){var n=t.indexOf(e);if(-1===n||i<0||i>=t.length)throw Error("Supplied index out of bounds");return n!==i&&(//  Remove
t.splice(n,1),//  Add in new location
t.splice(i,0,e)),e}}),r("6Pd3W",function(t,e){t.exports=function(t,e){var i=t.indexOf(e);if(-1!==i&&i<t.length-1){//  The element one above `item` in the array
var n=t[i+1],s=t.indexOf(n);t[i]=n,t[s]=e}return t}}),r("3L6N7",function(t,e){t.exports=function(t,e,i,n){for(var s=[],r=t;r<=e;r++)if(i||n){var o=i?i+r.toString():r.toString();n&&(o=o.concat(n)),s.push(o)}else s.push(r);return s}}),r("e6GZn",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("dzVSZ");t.exports=function(t,e,n){void 0===t&&(t=0),void 0===e&&(e=null),void 0===n&&(n=1),null===e&&(e=t,t=0);for(var s=[],r=Math.max(i((e-t)/(n||1)),0),o=0;o<r;o++)s.push(t),t+=n;return s}}),r("1ohUM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @ignore
 */function i(t,e,i){var n=t[e];t[e]=t[i],t[i]=n}/**
 * @ignore
 */function n(t,e){return t<e?-1:t>e?1:0}/**
 * A [Floyd-Rivest](https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm) quick selection algorithm.
 *
 * Rearranges the array items so that all items in the [left, k] range are smaller than all items in [k, right];
 * The k-th element will have the (k - left + 1)th smallest value in [left, right].
 *
 * The array is modified in-place.
 *
 * Based on code by [Vladimir Agafonkin](https://www.npmjs.com/~mourner)
 *
 * @function Phaser.Utils.Array.QuickSelect
 * @since 3.0.0
 *
 * @param {array} arr - The array to sort.
 * @param {integer} k - The k-th element index.
 * @param {integer} [left=0] - The index of the left part of the range.
 * @param {integer} [right] - The index of the right part of the range.
 * @param {function} [compare] - An optional comparison function. Is passed two elements and should return 0, 1 or -1.
 */var s=function(t,e,r,o,a){for(void 0===r&&(r=0),void 0===o&&(o=t.length-1),void 0===a&&(a=n);o>r;){if(o-r>600){var h=o-r+1,l=e-r+1,u=Math.log(h),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(h-c)/h)*(l-h/2<0?-1:1),f=Math.max(r,Math.floor(e-l*c/h+d)),p=Math.min(o,Math.floor(e+(h-l)*c/h+d));s(t,e,f,p,a)}var g=t[e],v=r,m=o;for(i(t,r,e),a(t[o],g)>0&&i(t,r,o);v<m;){for(i(t,v,m),v++,m--;0>a(t[v],g);)v++;for(;a(t[m],g)>0;)m--}0===a(t[r],g)?i(t,r,m):i(t,++m,o),m<=e&&(r=m+1),e<=m&&(o=m-1)}};t.exports=s}),r("3OeE3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5pMDk"),n=s("Na5BX"),r=function(t,e,i){for(var n=[],s=0;s<t.length;s++)for(var r=0;r<e.length;r++)for(var o=0;o<i;o++)n.push({a:t[s],b:e[r]});return n};t.exports=function(t,e,s){var o=i(s,"max",0),a=i(s,"qty",1),h=i(s,"random",!1),l=i(s,"randomB",!1),u=i(s,"repeat",0),c=i(s,"yoyo",!1),d=[];//  Endless repeat, so limit by max
if(l&&n(e),-1===u){if(0===o)u=0;else{//  Work out how many repeats we need
var f=t.length*e.length*a;c&&(f*=2),u=Math.ceil(o/f)}}for(var p=0;p<=u;p++){var g=r(t,e,a);h&&n(g),d=d.concat(g),c&&(g.reverse(),d=d.concat(g))}return o&&d.splice(o),d}}),r("dT2eW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eOqX8");t.exports=function(t,e,n,s){if(void 0===s&&(s=t),e<0||e>t.length-1)throw Error("Index out of bounds");var r=i(t,e);return n&&n.call(s,r),r}}),r("b32kD",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("9GGLm");t.exports=function(t,e,n,s,r){if(void 0===e&&(e=0),void 0===n&&(n=t.length),void 0===r&&(r=t),!i(t,e,n))return[];var o=n-e,a=t.splice(e,o);if(s)for(var h=0;h<a.length;h++){var l=a[h];s.call(r,l)}return a}}),r("3dAOl",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eOqX8");t.exports=function(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=t.length),i(t,e+Math.floor(Math.random()*n))}}),r("1sHs4",function(t,e){t.exports=function(t,e,i){var n=t.indexOf(e),s=t.indexOf(i);return -1!==n&&-1===s&&(t[n]=i,!0)}}),r("1KJmp",function(t,e){t.exports=function(t,e){var i=t.indexOf(e);return -1!==i&&i>0&&(t.splice(i,1),t.unshift(e)),e}}),r("4x0c3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("9GGLm");t.exports=function(t,e,n,s,r){if(void 0===s&&(s=0),void 0===r&&(r=t.length),i(t,s,r))for(var o=s;o<r;o++){var a=t[o];a.hasOwnProperty(e)&&(a[e]=n)}return t}}),r("7D0e6",function(t,e){!/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///! stable.js 0.1.6, https://github.com/Two-Screen/stable
//!  2017 Angry Bytes and contributors. MIT licensed.
/**
 * @namespace Phaser.Utils.Array.StableSortFunctions
 */function(){/**
 * A stable array sort, because `Array#sort()` is not guaranteed stable.
 * This is an implementation of merge sort, without recursion.
 *
 * @function Phaser.Utils.Array.StableSort
 * @since 3.0.0
 *
 * @param {array} arr - The input array to be sorted.
 * @param {function} comp - The comparison handler.
 *
 * @return {array} The sorted result.
 */var e=function(t,e){return i(t.slice(),e)};// Execute the sort using the input array and a second buffer as work space.
// Returns one of those two, containing the final result.
function i(t,e){"function"!=typeof e&&(e=function(t,e){return String(t).localeCompare(e)});// Short-circuit when there's nothing to sort.
var i=t.length;if(i<=1)return t;for(var s=Array(i),r=1;r<i;r*=2){n(t,e,r,s);var o=t;t=s,s=o}return t}/**
 * Sort the input array and simply copy it back if the result isn't in the original array, which happens on an odd number of passes.
 *
 * @function Phaser.Utils.Array.StableSortFunctions.inplace
 * @memberof Phaser.Utils.Array.StableSortFunctions
 * @since 3.0.0
 *
 * @param {array} arr - The input array.
 * @param {function} comp - The comparison handler.
 *
 * @return {array} The sorted array.
 */e.inplace=function(t,e){var s=i(t,e);return s!==t&&n(s,null,t.length,t),t};// Run a single pass with the given chunk size.
var n=function(t,e,i,n){var s,r,o,a,h,l=t.length,u=0,c=2*i;// Iterate over pairs of chunks.
for(s=0;s<l;s+=c)for(o=(r=s+i)+i,r>l&&(r=l),o>l&&(o=l),// Iterate both chunks in parallel.
a=s,h=r;;)// Compare the chunks.
if(a<r&&h<o)// This works for a regular `sort()` compatible comparator,
// but also for a simple comparator like: `a > b`
0>=e(t[a],t[h])?n[u++]=t[a++]:n[u++]=t[h++];else if(a<r)n[u++]=t[a++];else if(h<o)n[u++]=t[h++];else break};void 0!==t?t.exports=e:window.stable=e}()}),r("g1DUE",function(t,e){t.exports=function(t,e,i){if(e!==i){var n=t.indexOf(e),s=t.indexOf(i);if(n<0||s<0)throw Error("Supplied items must be elements of the same array");return t[n]=i,t[s]=e,t}}}),r("2WeDD",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("gz3ML"),r=s("7AzQW"),o=s("4rtgc"),a=new i({Extends:n,initialize:function(t){n.call(this),/**
         * The Scene that the Update List belongs to.
         *
         * @name Phaser.GameObjects.UpdateList#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * The Scene's Systems.
         *
         * @name Phaser.GameObjects.UpdateList#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,/**
         * The `pending` list is a selection of items which are due to be made 'active' in the next update.
         *
         * @name Phaser.GameObjects.UpdateList#_pending
         * @type {Array.<*>}
         * @private
         * @default []
         * @since 3.20.0
         *//**
         * The `active` list is a selection of items which are considered active and should be updated.
         *
         * @name Phaser.GameObjects.UpdateList#_active
         * @type {Array.<*>}
         * @private
         * @default []
         * @since 3.20.0
         *//**
         * The `destroy` list is a selection of items that were active and are awaiting being destroyed in the next update.
         *
         * @name Phaser.GameObjects.UpdateList#_destroy
         * @type {Array.<*>}
         * @private
         * @default []
         * @since 3.20.0
         *//**
         * The total number of items awaiting processing.
         *
         * @name Phaser.GameObjects.UpdateList#_toProcess
         * @type {integer}
         * @private
         * @default 0
         * @since 3.0.0
         */t.sys.events.once(o.BOOT,this.boot,this),t.sys.events.on(o.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.GameObjects.UpdateList#boot
     * @private
     * @since 3.5.1
     */boot:function(){this.systems.events.once(o.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.GameObjects.UpdateList#start
     * @private
     * @since 3.5.0
     */start:function(){var t=this.systems.events;t.on(o.PRE_UPDATE,this.update,this),t.on(o.UPDATE,this.sceneUpdate,this),t.once(o.SHUTDOWN,this.shutdown,this)},/**
     * The update step.
     *
     * Pre-updates every active Game Object in the list.
     *
     * @method Phaser.GameObjects.UpdateList#sceneUpdate
     * @since 3.20.0
     *
     * @param {number} time - The current timestamp.
     * @param {number} delta - The delta time elapsed since the last frame.
     */sceneUpdate:function(t,e){for(var i=this._active,n=i.length,s=0;s<n;s++){var r=i[s];r.active&&r.preUpdate.call(r,t,e)}},/**
     * The Scene that owns this plugin is shutting down.
     * 
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.GameObjects.UpdateList#shutdown
     * @since 3.0.0
     */shutdown:function(){for(var t=this._active.length;t--;)this._active[t].destroy(!0);for(t=this._pending.length;t--;)this._pending[t].destroy(!0);for(t=this._destroy.length;t--;)this._destroy[t].destroy(!0);this._toProcess=0,this._pending=[],this._active=[],this._destroy=[],this.removeAllListeners();var e=this.systems.events;e.off(o.PRE_UPDATE,this.preUpdate,this),e.off(o.UPDATE,this.sceneUpdate,this),e.off(o.SHUTDOWN,this.shutdown,this)},/**
     * The Scene that owns this plugin is being destroyed.
     * 
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.GameObjects.UpdateList#destroy
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.systems.events.off(o.START,this.start,this),this.scene=null,this.systems=null}});r.register("UpdateList",a,"updateList"),t.exports=a}),r("gz3ML",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("3vRz3"),r=s("ffLtS"),o=new i({Extends:n,initialize:function(){n.call(this),/**
         * The `pending` list is a selection of items which are due to be made 'active' in the next update.
         *
         * @genericUse {T[]} - [$type]
         *
         * @name Phaser.Structs.ProcessQueue#_pending
         * @type {Array.<*>}
         * @private
         * @default []
         * @since 3.0.0
         */this._pending=[],/**
         * The `active` list is a selection of items which are considered active and should be updated.
         *
         * @genericUse {T[]} - [$type]
         *
         * @name Phaser.Structs.ProcessQueue#_active
         * @type {Array.<*>}
         * @private
         * @default []
         * @since 3.0.0
         */this._active=[],/**
         * The `destroy` list is a selection of items that were active and are awaiting being destroyed in the next update.
         *
         * @genericUse {T[]} - [$type]
         *
         * @name Phaser.Structs.ProcessQueue#_destroy
         * @type {Array.<*>}
         * @private
         * @default []
         * @since 3.0.0
         */this._destroy=[],/**
         * The total number of items awaiting processing.
         *
         * @name Phaser.Structs.ProcessQueue#_toProcess
         * @type {integer}
         * @private
         * @default 0
         * @since 3.0.0
         */this._toProcess=0},/**
     * Adds a new item to the Process Queue.
     * 
     * The item is added to the pending list and made active in the next update.
     *
     * @method Phaser.Structs.ProcessQueue#add
     * @since 3.0.0
     *
     * @genericUse {T} - [item]
     * @genericUse {Phaser.Structs.ProcessQueue.<T>} - [$return]
     *
     * @param {*} item - The item to add to the queue.
     *
     * @return {*} The item that was added.
     */add:function(t){return this._pending.push(t),this._toProcess++,t},/**
     * Removes an item from the Process Queue.
     * 
     * The item is added to the pending destroy and fully removed in the next update.
     *
     * @method Phaser.Structs.ProcessQueue#remove
     * @since 3.0.0
     *
     * @genericUse {T} - [item]
     * @genericUse {Phaser.Structs.ProcessQueue.<T>} - [$return]
     *
     * @param {*} item - The item to be removed from the queue.
     *
     * @return {*} The item that was removed.
     */remove:function(t){return this._destroy.push(t),this._toProcess++,t},/**
     * Removes all active items from this Process Queue.
     * 
     * All the items are marked as 'pending destroy' and fully removed in the next update.
     *
     * @method Phaser.Structs.ProcessQueue#removeAll
     * @since 3.20.0
     *
     * @return {this} This Process Queue object.
     */removeAll:function(){for(var t=this._active,e=this._destroy,i=t.length;i--;)e.push(t[i]),this._toProcess++;return this},/**
     * Update this queue. First it will process any items awaiting destruction, and remove them.
     * 
     * Then it will check to see if there are any items pending insertion, and move them to an
     * active state. Finally, it will return a list of active items for further processing.
     *
     * @method Phaser.Structs.ProcessQueue#update
     * @since 3.0.0
     *
     * @genericUse {T[]} - [$return]
     *
     * @return {Array.<*>} A list of active items.
     */update:function(){if(0===this._toProcess)return this._active;var t,e,i=this._destroy,n=this._active;//  Clear the 'destroy' list
for(t=0;t<i.length;t++){e=i[t];//  Remove from the 'active' array
var s=n.indexOf(e);-1!==s&&(n.splice(s,1),this.emit(r.REMOVE,e))}for(t=0,i.length=0,//  Process the pending addition list
//  This stops callbacks and out of sync events from populating the active array mid-way during an update
i=this._pending;t<i.length;t++)e=i[t],this._active.push(e),this.emit(r.ADD,e);//  The owner of this queue can now safely do whatever it needs to with the active list
return i.length=0,this._toProcess=0,this._active},/**
     * Returns the current list of active items.
     * 
     * This method returns a reference to the active list array, not a copy of it.
     * Therefore, be careful to not modify this array outside of the ProcessQueue.
     *
     * @method Phaser.Structs.ProcessQueue#getActive
     * @since 3.0.0
     *
     * @genericUse {T[]} - [$return]
     *
     * @return {Array.<*>} A list of active items.
     */getActive:function(){return this._active},/**
     * The number of entries in the active list.
     *
     * @name Phaser.Structs.ProcessQueue#length
     * @type {integer}
     * @readonly
     * @since 3.20.0
     */length:{get:function(){return this._active.length}},/**
     * Immediately destroys this process queue, clearing all of its internal arrays and resetting the process totals.
     *
     * @method Phaser.Structs.ProcessQueue#destroy
     * @since 3.0.0
     */destroy:function(){this._toProcess=0,this._pending=[],this._active=[],this._destroy=[]}});t.exports=o}),r("ffLtS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Structs.Events
 */t.exports={PROCESS_QUEUE_ADD:s("lGpvP"),PROCESS_QUEUE_REMOVE:s("2LjZD")}}),r("lGpvP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Process Queue Add Event.
 * 
 * This event is dispatched by a Process Queue when a new item is successfully moved to its active list.
 * 
 * You will most commonly see this used by a Scene's Update List when a new Game Object has been added.
 * 
 * In that instance, listen to this event from within a Scene using: `this.sys.updateList.on('add', listener)`.
 *
 * @event Phaser.Structs.Events#PROCESS_QUEUE_ADD
 * @since 3.20.0
 * 
 * @param {*} item - The item that was added to the Process Queue.
 */t.exports="add"}),r("2LjZD",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Process Queue Remove Event.
 * 
 * This event is dispatched by a Process Queue when a new item is successfully removed from its active list.
 * 
 * You will most commonly see this used by a Scene's Update List when a Game Object has been removed.
 * 
 * In that instance, listen to this event from within a Scene using: `this.sys.updateList.on('remove', listener)`.
 *
 * @event Phaser.Structs.Events#PROCESS_QUEUE_REMOVE
 * @since 3.20.0
 * 
 * @param {*} item - The item that was removed from the Process Queue.
 */t.exports="remove"}),r("i9cSP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("3qUcC"),n=s("cSaNN");t.exports=function(t,e,s){//  Position
e.x=n(s,"x",0),e.y=n(s,"y",0),e.depth=n(s,"depth",0),//  Flip
e.flipX=n(s,"flipX",!1),e.flipY=n(s,"flipY",!1);//  Scale
//  Either: { scale: 2 } or { scale: { x: 2, y: 2 }}
var r=n(s,"scale",null);"number"==typeof r?e.setScale(r):null!==r&&(e.scaleX=n(r,"x",1),e.scaleY=n(r,"y",1));//  ScrollFactor
//  Either: { scrollFactor: 2 } or { scrollFactor: { x: 2, y: 2 }}
var o=n(s,"scrollFactor",null);"number"==typeof o?e.setScrollFactor(o):null!==o&&(e.scrollFactorX=n(o,"x",1),e.scrollFactorY=n(o,"y",1)),//  Rotation
e.rotation=n(s,"rotation",0);var a=n(s,"angle",null);null!==a&&(e.angle=a),//  Alpha
e.alpha=n(s,"alpha",1);//  Origin
//  Either: { origin: 0.5 } or { origin: { x: 0.5, y: 0.5 }}
var h=n(s,"origin",null);if("number"==typeof h)e.setOrigin(h);else if(null!==h){var l=n(h,"x",.5),u=n(h,"y",.5);e.setOrigin(l,u)}return(//  BlendMode
e.blendMode=n(s,"blendMode",i.NORMAL),//  Visible
e.visible=n(s,"visible",!0),n(s,"add",!0)&&t.sys.displayList.add(e),e.preUpdate&&t.sys.updateList.add(e),e)}}),r("cSaNN",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5OyGi"),n=s("5pMDk");t.exports=function(t,e,s){var r=n(t,e,null);if(null===r)return s;if(Array.isArray(r))return i.RND.pick(r);if("object"==typeof r){if(r.hasOwnProperty("randInt"))return i.RND.integerInRange(r.randInt[0],r.randInt[1]);if(r.hasOwnProperty("randFloat"))return i.RND.realInRange(r.randFloat[0],r.randFloat[1])}else if("function"==typeof r)return r(e);return r}}),r("cDuAM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSaNN");t.exports=function(t,e){var n=i(e,"anims",null);if(null===n)return t;if("string"==typeof n)t.anims.play(n);else if("object"==typeof n){//  { anims: {
//              key: string
//              startFrame: [string|integer]
//              delay: [float]
//              repeat: [integer]
//              repeatDelay: [float]
//              yoyo: [boolean]
//              play: [boolean]
//              delayedPlay: [boolean]
//           }
//  }
var s=t.anims,r=i(n,"key",void 0),o=i(n,"startFrame",void 0),a=i(n,"delay",0),h=i(n,"repeat",0),l=i(n,"repeatDelay",0),u=i(n,"yoyo",!1),c=i(n,"play",!1),d=i(n,"delayedPlay",0);s.setDelay(a),s.setRepeat(h),s.setRepeatDelay(l),s.setYoyo(u),c?s.play(r,o):d>0?s.delayedPlay(d,r,o):s.load(r)}return t}}),r("gvPR8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("1zqlR"),o=s("bzJWV"),a=s("dz3Xz"),h=s("5t9GW"),l=s("8fXrz"),u=new i({Extends:r,Mixins:[n.Alpha,n.BlendMode,n.Depth,n.Mask,n.Origin,n.Pipeline,n.ScrollFactor,n.Texture,n.Tint,n.Transform,n.Visible,l],initialize:function(t,e,i,n,s,a,h){void 0===s&&(s=""),void 0===h&&(h=0),r.call(this,t,"BitmapText"),/**
         * The key of the Bitmap Font used by this Bitmap Text.
         * To change the font after creation please use `setFont`.
         *
         * @name Phaser.GameObjects.BitmapText#font
         * @type {string}
         * @readonly
         * @since 3.0.0
         */this.font=n;var l=this.scene.sys.cache.bitmapFont.get(n);/**
         * The data of the Bitmap Font used by this Bitmap Text.
         *
         * @name Phaser.GameObjects.BitmapText#fontData
         * @type {Phaser.Types.GameObjects.BitmapText.BitmapFontData}
         * @readonly
         * @since 3.0.0
         */this.fontData=l.data,/**
         * The text that this Bitmap Text object displays.
         *
         * @name Phaser.GameObjects.BitmapText#_text
         * @type {string}
         * @private
         * @since 3.0.0
         */this._text="",/**
         * The font size of this Bitmap Text.
         *
         * @name Phaser.GameObjects.BitmapText#_fontSize
         * @type {number}
         * @private
         * @since 3.0.0
         */this._fontSize=a||this.fontData.size,/**
         * Adds / Removes spacing between characters.
         *
         * Can be a negative or positive number.
         *
         * @name Phaser.GameObjects.BitmapText#_letterSpacing
         * @type {number}
         * @private
         * @since 3.4.0
         */this._letterSpacing=0,/**
         * Controls the alignment of each line of text in this BitmapText object.
         * Only has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.
         * Has no effect with single-lines of text.
         *
         * See the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.
         *
         * 0 = Left aligned (default)
         * 1 = Middle aligned
         * 2 = Right aligned
         *
         * The alignment position is based on the longest line of text.
         *
         * @name Phaser.GameObjects.BitmapText#_align
         * @type {integer}
         * @private
         * @since 3.11.0
         */this._align=h,/**
         * An object that describes the size of this Bitmap Text.
         *
         * @name Phaser.GameObjects.BitmapText#_bounds
         * @type {Phaser.Types.GameObjects.BitmapText.BitmapTextSize}
         * @private
         * @since 3.0.0
         */this._bounds=o(),/**
         * An internal dirty flag for bounds calculation.
         *
         * @name Phaser.GameObjects.BitmapText#_dirty
         * @type {boolean}
         * @private
         * @since 3.11.0
         */this._dirty=!0,/**
         * Internal cache var holding the maxWidth.
         *
         * @name Phaser.GameObjects.BitmapText#_maxWidth
         * @type {number}
         * @private
         * @since 3.21.0
         */this._maxWidth=0,/**
         * The character code used to detect for word wrapping.
         * Defaults to 32 (a space character).
         *
         * @name Phaser.GameObjects.BitmapText#wordWrapCharCode
         * @type {number}
         * @since 3.21.0
         */this.wordWrapCharCode=32,this.setTexture(l.texture,l.frame),this.setPosition(e,i),this.setOrigin(0,0),this.initPipeline(),this.setText(s)},/**
     * Set the lines of text in this BitmapText to be left-aligned.
     * This only has any effect if this BitmapText contains more than one line of text.
     *
     * @method Phaser.GameObjects.BitmapText#setLeftAlign
     * @since 3.11.0
     *
     * @return {this} This BitmapText Object.
     */setLeftAlign:function(){return this._align=u.ALIGN_LEFT,this._dirty=!0,this},/**
     * Set the lines of text in this BitmapText to be center-aligned.
     * This only has any effect if this BitmapText contains more than one line of text.
     *
     * @method Phaser.GameObjects.BitmapText#setCenterAlign
     * @since 3.11.0
     *
     * @return {this} This BitmapText Object.
     */setCenterAlign:function(){return this._align=u.ALIGN_CENTER,this._dirty=!0,this},/**
     * Set the lines of text in this BitmapText to be right-aligned.
     * This only has any effect if this BitmapText contains more than one line of text.
     *
     * @method Phaser.GameObjects.BitmapText#setRightAlign
     * @since 3.11.0
     *
     * @return {this} This BitmapText Object.
     */setRightAlign:function(){return this._align=u.ALIGN_RIGHT,this._dirty=!0,this},/**
     * Set the font size of this Bitmap Text.
     *
     * @method Phaser.GameObjects.BitmapText#setFontSize
     * @since 3.0.0
     *
     * @param {number} size - The font size to set.
     *
     * @return {this} This BitmapText Object.
     */setFontSize:function(t){return this._fontSize=t,this._dirty=!0,this},/**
     * Sets the letter spacing between each character of this Bitmap Text.
     * Can be a positive value to increase the space, or negative to reduce it.
     * Spacing is applied after the kerning values have been set.
     *
     * @method Phaser.GameObjects.BitmapText#setLetterSpacing
     * @since 3.4.0
     *
     * @param {number} [spacing=0] - The amount of horizontal space to add between each character.
     *
     * @return {this} This BitmapText Object.
     */setLetterSpacing:function(t){return void 0===t&&(t=0),this._letterSpacing=t,this._dirty=!0,this},/**
     * Set the textual content of this BitmapText.
     *
     * An array of strings will be converted into multi-line text. Use the align methods to change multi-line alignment.
     *
     * @method Phaser.GameObjects.BitmapText#setText
     * @since 3.0.0
     *
     * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this BitmapText.
     *
     * @return {this} This BitmapText Object.
     */setText:function(t){return t||0===t||(t=""),Array.isArray(t)&&(t=t.join("\n")),t!==this.text&&(this._text=t.toString(),this._dirty=!0,this.updateDisplayOrigin()),this},/**
     * Calculate the bounds of this Bitmap Text.
     *
     * An object is returned that contains the position, width and height of the Bitmap Text in local and global
     * contexts.
     *
     * Local size is based on just the font size and a [0, 0] position.
     *
     * Global size takes into account the Game Object's scale, world position and display origin.
     *
     * Also in the object is data regarding the length of each line, should this be a multi-line BitmapText.
     *
     * @method Phaser.GameObjects.BitmapText#getTextBounds
     * @since 3.0.0
     *
     * @param {boolean} [round] - Whether to round the results to the nearest integer.
     *
     * @return {Phaser.Types.GameObjects.BitmapText.BitmapTextSize} An object that describes the size of this Bitmap Text.
     */getTextBounds:function(t){//  local = The BitmapText based on fontSize and 0x0 coords
//  global = The BitmapText, taking into account scale and world position
//  lines = The BitmapText line data
var e=this._bounds;return(this._dirty||this.scaleX!==e.scaleX||this.scaleY!==e.scaleY)&&(o(this,t,e),this._dirty=!1,this.updateDisplayOrigin()),e},/**
     * Changes the font this BitmapText is using to render.
     *
     * The new texture is loaded and applied to the BitmapText. The existing test, size and alignment are preserved,
     * unless overridden via the arguments.
     *
     * @method Phaser.GameObjects.BitmapText#setFont
     * @since 3.11.0
     *
     * @param {string} font - The key of the font to use from the Bitmap Font cache.
     * @param {number} [size] - The font size of this Bitmap Text. If not specified the current size will be used.
     * @param {integer} [align=0] - The alignment of the text in a multi-line BitmapText object. If not specified the current alignment will be used.
     *
     * @return {this} This BitmapText Object.
     */setFont:function(t,e,i){if(void 0===e&&(e=this._fontSize),void 0===i&&(i=this._align),t!==this.font){var n=this.scene.sys.cache.bitmapFont.get(t);n&&(this.font=t,this.fontData=n.data,this._fontSize=e,this._align=i,this.setTexture(n.texture,n.frame),o(this,!1,this._bounds))}return this},/**
     * Sets the maximum display width of this BitmapText in pixels.
     *
     * If `BitmapText.text` is longer than `maxWidth` then the lines will be automatically wrapped
     * based on the previous whitespace character found in the line.
     *
     * If no whitespace was found then no wrapping will take place and consequently the `maxWidth` value will not be honored.
     *
     * Disable maxWidth by setting the value to 0.
     *
     * You can set the whitespace character to be searched for by setting the `wordWrapCharCode` parameter or property.
     *
     * @method Phaser.GameObjects.BitmapText#setMaxWidth
     * @since 3.21.0
     *
     * @param {number} value - The maximum display width of this BitmapText in pixels. Set to zero to disable.
     * @param {number} [wordWrapCharCode] - The character code to check for when word wrapping. Defaults to 32 (the space character).
     *
     * @return {this} This BitmapText Object.
     */setMaxWidth:function(t,e){return this._maxWidth=t,this._dirty=!0,void 0!==e&&(this.wordWrapCharCode=e),this},/**
     * Controls the alignment of each line of text in this BitmapText object.
     *
     * Only has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.
     * Has no effect with single-lines of text.
     *
     * See the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.
     *
     * 0 = Left aligned (default)
     * 1 = Middle aligned
     * 2 = Right aligned
     *
     * The alignment position is based on the longest line of text.
     *
     * @name Phaser.GameObjects.BitmapText#align
     * @type {integer}
     * @since 3.11.0
     */align:{set:function(t){this._align=t,this._dirty=!0},get:function(){return this._align}},/**
     * The text that this Bitmap Text object displays.
     *
     * You can also use the method `setText` if you want a chainable way to change the text content.
     *
     * @name Phaser.GameObjects.BitmapText#text
     * @type {string}
     * @since 3.0.0
     */text:{set:function(t){this.setText(t)},get:function(){return this._text}},/**
     * The font size of this Bitmap Text.
     *
     * You can also use the method `setFontSize` if you want a chainable way to change the font size.
     *
     * @name Phaser.GameObjects.BitmapText#fontSize
     * @type {number}
     * @since 3.0.0
     */fontSize:{set:function(t){this._fontSize=t,this._dirty=!0},get:function(){return this._fontSize}},/**
     * Adds / Removes spacing between characters.
     *
     * Can be a negative or positive number.
     *
     * You can also use the method `setLetterSpacing` if you want a chainable way to change the letter spacing.
     *
     * @name Phaser.GameObjects.BitmapText#letterSpacing
     * @type {number}
     * @since 3.0.0
     */letterSpacing:{set:function(t){this._letterSpacing=t,this._dirty=!0},get:function(){return this._letterSpacing}},/**
     * The maximum display width of this BitmapText in pixels.
     *
     * If BitmapText.text is longer than maxWidth then the lines will be automatically wrapped
     * based on the last whitespace character found in the line.
     *
     * If no whitespace was found then no wrapping will take place and consequently the maxWidth value will not be honored.
     *
     * Disable maxWidth by setting the value to 0.
     *
     * @name Phaser.GameObjects.BitmapText#maxWidth
     * @type {number}
     * @since 3.21.0
     */maxWidth:{set:function(t){this._maxWidth=t,this._dirty=!0},get:function(){return this._maxWidth}},/**
     * The width of this Bitmap Text.
     *
     * @name Phaser.GameObjects.BitmapText#width
     * @type {number}
     * @readonly
     * @since 3.0.0
     */width:{get:function(){return this.getTextBounds(!1),this._bounds.global.width}},/**
     * The height of this bitmap text.
     *
     * @name Phaser.GameObjects.BitmapText#height
     * @type {number}
     * @readonly
     * @since 3.0.0
     */height:{get:function(){return this.getTextBounds(!1),this._bounds.global.height}},/**
     * Build a JSON representation of this Bitmap Text.
     *
     * @method Phaser.GameObjects.BitmapText#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.GameObjects.BitmapText.JSONBitmapText} A JSON representation of this Bitmap Text.
     */toJSON:function(){var t=n.ToJSON(this),e={font:this.font,text:this.text,fontSize:this.fontSize,letterSpacing:this.letterSpacing,align:this.align};return t.data=e,t}});/**
 * Left align the text characters in a multi-line BitmapText object.
 *
 * @name Phaser.GameObjects.BitmapText.ALIGN_LEFT
 * @type {integer}
 * @since 3.11.0
 */u.ALIGN_LEFT=0,/**
 * Center align the text characters in a multi-line BitmapText object.
 *
 * @name Phaser.GameObjects.BitmapText.ALIGN_CENTER
 * @type {integer}
 * @since 3.11.0
 */u.ALIGN_CENTER=1,/**
 * Right align the text characters in a multi-line BitmapText object.
 *
 * @name Phaser.GameObjects.BitmapText.ALIGN_RIGHT
 * @type {integer}
 * @since 3.11.0
 */u.ALIGN_RIGHT=2,/**
 * Parse an XML Bitmap Font from an Atlas.
 *
 * Adds the parsed Bitmap Font data to the cache with the `fontName` key.
 *
 * @method Phaser.GameObjects.BitmapText.ParseFromAtlas
 * @since 3.0.0
 *
 * @param {Phaser.Scene} scene - The Scene to parse the Bitmap Font for.
 * @param {string} fontName - The key of the font to add to the Bitmap Font cache.
 * @param {string} textureKey - The key of the BitmapFont's texture.
 * @param {string} frameKey - The key of the BitmapFont texture's frame.
 * @param {string} xmlKey - The key of the XML data of the font to parse.
 * @param {integer} [xSpacing] - The x-axis spacing to add between each letter.
 * @param {integer} [ySpacing] - The y-axis spacing to add to the line height.
 *
 * @return {boolean} Whether the parsing was successful or not.
 */u.ParseFromAtlas=a,/**
 * Parse an XML font to Bitmap Font data for the Bitmap Font cache.
 *
 * @method Phaser.GameObjects.BitmapText.ParseXMLBitmapFont
 * @since 3.17.0
 *
 * @param {XMLDocument} xml - The XML Document to parse the font from.
 * @param {integer} [xSpacing=0] - The x-axis spacing to add between each letter.
 * @param {integer} [ySpacing=0] - The y-axis spacing to add to the line height.
 * @param {Phaser.Textures.Frame} [frame] - The texture frame to take into account while parsing.
 *
 * @return {Phaser.Types.GameObjects.BitmapText.BitmapFontData} The parsed Bitmap Font data.
 */u.ParseXMLBitmapFont=h,t.exports=u}),r("bzJWV",function(t,e){t.exports=function(t,e,i){if(void 0===i)return i={local:{x:0,y:0,width:0,height:0},global:{x:0,y:0,width:0,height:0},lines:{shortest:0,longest:0,lengths:null,height:0},wrappedText:"",words:[],scaleX:0,scaleY:0};var n=t.text,s=n.length,r=t.maxWidth,o=t.wordWrapCharCode,a=Number.MAX_VALUE,h=Number.MAX_VALUE,l=0,u=0,c=t.fontData.chars,d=t.fontData.lineHeight,f=t.letterSpacing,p=0,g=0,v=0,m=null,y=0,x=0,w=t.fontSize/t.fontData.size,T=w*t.scaleX,b=w*t.scaleY,S=null,A=0,E=[],_=Number.MAX_VALUE,C=0,M=0,P=0,O=[],R=null;//  Scan for breach of maxWidth and insert carriage-returns
if(r>0){for(D=0;D<s;D++){if(10===(v=n.charCodeAt(D))){null!==R&&(O.push({word:R.word,i:R.i,x:R.x*T,y:R.y*b,w:R.w*T,h:R.h*b,cr:!0}),R=null),p=0,g+=d,S=null;continue}if(m=c[v]){if(null!==S)var L,k,D,F,I=m.kerning[A];v===o?null!==R&&(O.push({word:R.word,i:R.i,x:R.x*T,y:R.y*b,w:R.w*T,h:R.h*b,cr:!1}),R=null):(null===R&&(R={word:"",i:D,x:p,y:g,w:0,h:d,cr:!1}),R.word=R.word.concat(n[D]),R.w+=m.xOffset+m.xAdvance+(void 0!==I?I:0)),p+=m.xAdvance+f,S=m,A=v}}null!==R&&O.push({word:R.word,i:R.i,x:R.x*T,y:R.y*b,w:R.w*T,h:R.h*b,cr:!1}),//  Reset for the next loop
p=0,g=0,S=null,A=0;var B=0,N=[];for(D=0;D<O.length;D++){var Y=O[D],z=Y.x,j=Y.x+Y.w;if(F){var X=z-(F.x+F.w);B=z-(X+F.w),F=null}var U=z-B,G=j-B;U>r||G>r?(N.push(Y.i-1),Y.cr?(N.push(Y.i+Y.word.length),B=0,F=null):F=Y):Y.cr&&(N.push(Y.i+Y.word.length),B=0,F=null)}for(D=N.length-1;D>=0;D--)L=n,k=N[D],n=L.substr(0,k)+"\n"+L.substr(k+1);i.wrappedText=n,s=n.length,//  Recalculated in the next loop
O=[],R=null}for(D=0;D<s;D++){if(10===(v=n.charCodeAt(D))){null!==R&&(O.push({word:R.word,i:R.i,x:R.x*T,y:R.y*b,w:R.w*T,h:R.h*b}),R=null),p=0,g+=d,S=null,E[M]=P,P>C&&(C=P),P<_&&(_=P),M++,P=0;continue}if(m=c[v]){if(y=p,x=g,null!==S){var W=m.kerning[A];y+=void 0!==W?W:0}a>y&&(a=y),h>x&&(h=x);var V=y+m.xAdvance,H=x+d;l<V&&(l=V),u<H&&(u=H),v===o?null!==R&&(O.push({word:R.word,i:R.i,x:R.x*T,y:R.y*b,w:R.w*T,h:R.h*b}),R=null):(null===R&&(R={word:"",i:D,x:p,y:g,w:0,h:d}),R.word=R.word.concat(n[D]),R.w+=m.xOffset+m.xAdvance+(void 0!==W?W:0)),p+=m.xAdvance+f,S=m,A=v,P=V*w}}null!==R&&O.push({word:R.word,i:R.i,x:R.x*T,y:R.y*b,w:R.w*T,h:R.h*b}),E[M]=P,P>C&&(C=P),P<_&&(_=P);var q=i.local,K=i.global,Z=i.lines;return q.x=a*w,q.y=h*w,q.width=l*w,q.height=u*w,K.x=t.x-t.displayOriginX+a*T,K.y=t.y-t.displayOriginY+h*b,K.width=l*T,K.height=u*b,Z.shortest=_,Z.longest=C,Z.lengths=E,e&&(q.x=Math.round(q.x),q.y=Math.round(q.y),q.width=Math.round(q.width),q.height=Math.round(q.height),K.x=Math.round(K.x),K.y=Math.round(K.y),K.width=Math.round(K.width),K.height=Math.round(K.height),Z.shortest=Math.round(_),Z.longest=Math.round(C)),i.words=O,i.lines.height=d,i.scaleX=t.scaleX,i.scaleY=t.scaleY,i}}),r("dz3Xz",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5t9GW");t.exports=function(t,e,n,s,r,o,a){var h=t.sys.textures.getFrame(n,s),l=t.sys.cache.xml.get(r);if(!h||!l)return!1;var u=i(l,o,a,h);return t.sys.cache.bitmapFont.add(e,{data:u,texture:n,frame:s}),!0}}),r("5t9GW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * Read an integer value from an XML Node.
 *
 * @function getValue
 * @since 3.0.0
 * @private
 *
 * @param {Node} node - The XML Node.
 * @param {string} attribute - The attribute to read.
 *
 * @return {integer} The parsed value.
 */function i(t,e){return parseInt(t.getAttribute(e),10)}t.exports=function(t,e,n,s){void 0===e&&(e=0),void 0===n&&(n=0);var r={},o=t.getElementsByTagName("info")[0],a=t.getElementsByTagName("common")[0];r.font=o.getAttribute("face"),r.size=i(o,"size"),r.lineHeight=i(a,"lineHeight")+n,r.chars={};var h=t.getElementsByTagName("char"),l=void 0!==s&&s.trimmed;if(l)var u=s.height,c=s.width;for(var d=0;d<h.length;d++){var f=h[d],p=i(f,"id"),g=i(f,"x"),v=i(f,"y"),m=i(f,"width"),y=i(f,"height");l&&(g<c&&(c=g),v<u&&(u=v)),r.chars[p]={x:g,y:v,width:m,height:y,centerX:Math.floor(m/2),centerY:Math.floor(y/2),xOffset:i(f,"xoffset"),yOffset:i(f,"yoffset"),xAdvance:i(f,"xadvance")+e,data:{},kerning:{}}}if(l&&0!==u&&0!==c)//  so we can work out how much to adjust the glyphs by
for(var x in r.chars){var w=r.chars[x];w.x-=s.x,w.y-=s.y}var T=t.getElementsByTagName("kerning");for(d=0;d<T.length;d++){var b=T[d],S=i(b,"first"),A=i(b,"second"),E=i(b,"amount");r.chars[A].kerning[S]=E}return r}}),r("8fXrz",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("d8Hj8"),r=s("9nXSE"),t.exports={renderWebGL:n,renderCanvas:r}}),r("d8Hj8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){var o,a,h=e._text,l=h.length;if(0!==l){var u=this.pipeline;t.setPipeline(u,e);var c=u._tempMatrix1,d=u._tempMatrix2,f=u._tempMatrix3;d.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),c.copyFrom(s.matrix),r?(//  Multiply the camera by the parent matrix
c.multiplyWithOffset(r,-s.scrollX*e.scrollFactorX,-s.scrollY*e.scrollFactorY),//  Undo the camera scroll
d.e=e.x,d.f=e.y):(d.e-=s.scrollX*e.scrollFactorX,d.f-=s.scrollY*e.scrollFactorY),//  Multiply by the Sprite matrix, store result in calcMatrix
c.multiply(d,f);var p=e.frame,g=p.glTexture,v=p.cutX,m=p.cutY,y=g.width,x=g.height,w=e._isTinted&&e.tintFill,T=i.getTintAppendFloatAlpha(e._tintTL,s.alpha*e._alphaTL),b=i.getTintAppendFloatAlpha(e._tintTR,s.alpha*e._alphaTR),S=i.getTintAppendFloatAlpha(e._tintBL,s.alpha*e._alphaBL),A=i.getTintAppendFloatAlpha(e._tintBR,s.alpha*e._alphaBR);u.setTexture2D(g,0);var E=0,_=0,C=0,M=0,P=e._letterSpacing,O=0,R=0,L=0,k=0,D=e.fontData,F=D.chars,I=D.lineHeight,B=e._fontSize/D.size,N=e._align,Y=0,z=0,j=e.getTextBounds(!1);e.maxWidth>0&&(l=(h=j.wrappedText).length);var X=e._bounds.lines;1===N?z=(X.longest-X.lengths[0])/2:2===N&&(z=X.longest-X.lengths[0]);for(var U=s.roundPixels,G=0;G<l;G++){//  Carriage-return
if(10===(C=h.charCodeAt(G))){Y++,1===N?z=(X.longest-X.lengths[Y])/2:2===N&&(z=X.longest-X.lengths[Y]),E=0,_+=I,a=null;continue}if(o=F[C]){O=v+o.x,R=m+o.y,L=o.width,k=o.height;var W=o.xOffset+E,V=o.yOffset+_;if(null!==a){var H=o.kerning[M];W+=void 0!==H?H:0}//  Nothing to render or a space? Then skip to the next glyph
if(E+=o.xAdvance+P,a=o,M=C,0!==L&&0!==k&&32!==C){W*=B,V*=B,W-=e.displayOriginX,V-=e.displayOriginY;var q=O/y,K=R/x,Z=(O+L)/y,Q=(R+k)/x,J=(W+=z)+L*B,$=V+k*B,tt=f.getX(W,V),te=f.getY(W,V),ti=f.getX(W,$),tn=f.getY(W,$),ts=f.getX(J,$),tr=f.getY(J,$),to=f.getX(J,V),ta=f.getY(J,V);U&&(tt=Math.round(tt),te=Math.round(te),ti=Math.round(ti),tn=Math.round(tn),ts=Math.round(ts),tr=Math.round(tr),to=Math.round(to),ta=Math.round(ta)),u.batchQuad(tt,te,ti,tn,ts,tr,to,ta,q,K,Z,Q,T,b,S,A,w,g,0)}}}}}}),r("9nXSE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("csLaZ");t.exports=function(t,e,n,s,r){var o=e._text,a=o.length,h=t.currentContext;if(0!==a&&i(t,h,e,s,r)){var l=e.frame,u=e.fontData.chars,c=e.fontData.lineHeight,d=e._letterSpacing,f=0,p=0,g=0,v=null,m=0,y=0,x=0,w=0,T=0,b=0,S=null,A=0,E=e.frame.source.image,_=l.cutX,C=l.cutY,M=e._fontSize/e.fontData.size,P=e._align,O=0,R=0,L=e.getTextBounds(!1);e.maxWidth>0&&(a=(o=L.wrappedText).length);var k=e._bounds.lines;1===P?R=(k.longest-k.lengths[0])/2:2===P&&(R=k.longest-k.lengths[0]),h.translate(-e.displayOriginX,-e.displayOriginY);for(var D=s.roundPixels,F=0;F<a;F++){if(10===(g=o.charCodeAt(F))){O++,1===P?R=(k.longest-k.lengths[O])/2:2===P&&(R=k.longest-k.lengths[O]),f=0,p+=c,S=null;continue}if(v=u[g]){if(m=_+v.x,y=C+v.y,x=v.width,w=v.height,T=v.xOffset+f,b=v.yOffset+p,null!==S){var I=v.kerning[A];T+=void 0!==I?I:0}T*=M,b*=M,T+=R,f+=v.xAdvance+d,S=v,A=g,0!==x&&0!==w&&32!==g&&(D&&(T=Math.round(T),b=Math.round(b)),h.save(),h.translate(T,b),h.scale(M,M),h.drawImage(E,m,y,x,w,0,0,x,w),h.restore())}}h.restore()}}}),r("csLaZ",function(t,e){t.exports=function(t,e,i,n,s){var r=n.alpha*i.alpha;if(r<=0)return!1;var o=t._tempMatrix1.copyFromArray(n.matrix.matrix),a=t._tempMatrix2.applyITRS(i.x,i.y,i.rotation,i.scaleX,i.scaleY),h=t._tempMatrix3;return s?(//  Multiply the camera by the parent matrix
o.multiplyWithOffset(s,-n.scrollX*i.scrollFactorX,-n.scrollY*i.scrollFactorY),//  Undo the camera scroll
a.e=i.x,a.f=i.y):(a.e-=n.scrollX*i.scrollFactorX,a.f-=n.scrollY*i.scrollFactorY),//  Multiply by the Sprite matrix, store result in calcMatrix
o.multiply(a,h),//  Blend Mode
e.globalCompositeOperation=t.blendModes[i.blendMode],//  Alpha
e.globalAlpha=r,e.save(),h.setToContext(e),e.imageSmoothingEnabled=!(!t.antialias||i.frame&&i.frame.source.scaleMode),!0}}),r("2cD2D",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("4vYTx"),n=s("kjfuT"),r=s("jwj1g"),o=s("4FF1v"),a=s("7O4PF"),h=s("1zqlR"),l=s("aqhsx"),u=new r({Extends:h,Mixins:[o.Alpha,o.BlendMode,o.Depth,o.Mask,o.Pipeline,o.ScrollFactor,o.Size,o.Texture,o.Transform,o.Visible,i],initialize:function(t,e,i,n,s){h.call(this,t,"Blitter"),this.setTexture(n,s),this.setPosition(e,i),this.initPipeline(),/**
         * The children of this Blitter.
         * This List contains all of the Bob objects created by the Blitter.
         *
         * @name Phaser.GameObjects.Blitter#children
         * @type {Phaser.Structs.List.<Phaser.GameObjects.Bob>}
         * @since 3.0.0
         */this.children=new l,/**
         * A transient array that holds all of the Bobs that will be rendered this frame.
         * The array is re-populated whenever the dirty flag is set.
         *
         * @name Phaser.GameObjects.Blitter#renderList
         * @type {Phaser.GameObjects.Bob[]}
         * @default []
         * @private
         * @since 3.0.0
         */this.renderList=[],/**
         * Is the Blitter considered dirty?
         * A 'dirty' Blitter has had its child count changed since the last frame.
         *
         * @name Phaser.GameObjects.Blitter#dirty
         * @type {boolean}
         * @since 3.0.0
         */this.dirty=!1},/**
     * Creates a new Bob in this Blitter.
     *
     * The Bob is created at the given coordinates, relative to the Blitter and uses the given frame.
     * A Bob can use any frame belonging to the texture bound to the Blitter.
     *
     * @method Phaser.GameObjects.Blitter#create
     * @since 3.0.0
     *
     * @param {number} x - The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.
     * @param {number} y - The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.
     * @param {(string|integer|Phaser.Textures.Frame)} [frame] - The Frame the Bob will use. It _must_ be part of the Texture the parent Blitter object is using.
     * @param {boolean} [visible=true] - Should the created Bob render or not?
     * @param {integer} [index] - The position in the Blitters Display List to add the new Bob at. Defaults to the top of the list.
     *
     * @return {Phaser.GameObjects.Bob} The newly created Bob object.
     */create:function(t,e,i,s,r){void 0===s&&(s=!0),void 0===r&&(r=this.children.length),void 0===i?i=this.frame:i instanceof a||(i=this.texture.get(i));var o=new n(this,t,e,i,s);return this.children.addAt(o,r,!1),this.dirty=!0,o},/**
     * Creates multiple Bob objects within this Blitter and then passes each of them to the specified callback.
     *
     * @method Phaser.GameObjects.Blitter#createFromCallback
     * @since 3.0.0
     *
     * @param {CreateCallback} callback - The callback to invoke after creating a bob. It will be sent two arguments: The Bob and the index of the Bob.
     * @param {integer} quantity - The quantity of Bob objects to create.
     * @param {(string|integer|Phaser.Textures.Frame|string[]|integer[]|Phaser.Textures.Frame[])} [frame] - The Frame the Bobs will use. It must be part of the Blitter Texture.
     * @param {boolean} [visible=true] - Should the created Bob render or not?
     *
     * @return {Phaser.GameObjects.Bob[]} An array of Bob objects that were created.
     */createFromCallback:function(t,e,i,n){for(var s=this.createMultiple(e,i,n),r=0;r<s.length;r++){var o=s[r];t.call(this,o,r)}return s},/**
     * Creates multiple Bobs in one call.
     *
     * The amount created is controlled by a combination of the `quantity` argument and the number of frames provided.
     *
     * If the quantity is set to 10 and you provide 2 frames, then 20 Bobs will be created. 10 with the first
     * frame and 10 with the second.
     *
     * @method Phaser.GameObjects.Blitter#createMultiple
     * @since 3.0.0
     *
     * @param {integer} quantity - The quantity of Bob objects to create.
     * @param {(string|integer|Phaser.Textures.Frame|string[]|integer[]|Phaser.Textures.Frame[])} [frame] - The Frame the Bobs will use. It must be part of the Blitter Texture.
     * @param {boolean} [visible=true] - Should the created Bob render or not?
     *
     * @return {Phaser.GameObjects.Bob[]} An array of Bob objects that were created.
     */createMultiple:function(t,e,i){void 0===e&&(e=this.frame.name),void 0===i&&(i=!0),Array.isArray(e)||(e=[e]);var n=[],s=this;return e.forEach(function(e){for(var r=0;r<t;r++)n.push(s.create(0,0,e,i))}),n},/**
     * Checks if the given child can render or not, by checking its `visible` and `alpha` values.
     *
     * @method Phaser.GameObjects.Blitter#childCanRender
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Bob} child - The Bob to check for rendering.
     *
     * @return {boolean} Returns `true` if the given child can render, otherwise `false`.
     */childCanRender:function(t){return t.visible&&t.alpha>0},/**
     * Returns an array of Bobs to be rendered.
     * If the Blitter is dirty then a new list is generated and stored in `renderList`.
     *
     * @method Phaser.GameObjects.Blitter#getRenderList
     * @since 3.0.0
     *
     * @return {Phaser.GameObjects.Bob[]} An array of Bob objects that will be rendered this frame.
     */getRenderList:function(){return this.dirty&&(this.renderList=this.children.list.filter(this.childCanRender,this),this.dirty=!1),this.renderList},/**
     * Removes all Bobs from the children List and clears the dirty flag.
     *
     * @method Phaser.GameObjects.Blitter#clear
     * @since 3.0.0
     */clear:function(){this.children.removeAll(),this.dirty=!0},/**
     * Internal destroy handler, called as part of the destroy process.
     *
     * @method Phaser.GameObjects.Blitter#preDestroy
     * @protected
     * @since 3.9.0
     */preDestroy:function(){this.children.destroy(),this.renderList=[]}});t.exports=u}),r("4vYTx",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("bmag1"),r=s("91wlN"),t.exports={renderWebGL:n,renderCanvas:r}}),r("bmag1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){var o=e.getRenderList();if(0!==o.length){var a=this.pipeline;t.setPipeline(a,e);var h=s.scrollX*e.scrollFactorX,l=s.scrollY*e.scrollFactorY,u=a._tempMatrix1;u.copyFrom(s.matrix),r&&(u.multiplyWithOffset(r,-h,-l),h=0,l=0);for(var c=e.x-h,d=e.y-l,f=-1,p=s.alpha*e.alpha,g=s.roundPixels,v=0;v<o.length;v++){var m=o[v],y=m.frame,x=m.alpha*p;if(0!==x){var w=y.width,T=y.height,b=c+m.x+y.x,S=d+m.y+y.y;m.flipX&&(w*=-1,b+=y.width),m.flipY&&(T*=-1,S+=y.height);var A=b+w,E=S+T,_=u.getX(b,S),C=u.getY(b,S),M=u.getX(A,E),P=u.getY(A,E),O=i.getTintAppendFloatAlpha(m.tint,x);y.sourceIndex!==f&&(a.setTexture2D(y.glTexture,0),f=y.sourceIndex),g&&(_=Math.round(_),C=Math.round(C),M=Math.round(M),P=Math.round(P)),a.batchQuad(_,C,_,P,M,P,M,C,y.u0,y.v0,y.u1,y.v1,O,O,O,O,!1,y.glTexture,0)&&(f=-1)}}}}}),r("91wlN",function(t,e){t.exports=function(t,e,i,n,s){var r=e.getRenderList();if(0!==r.length){var o=t.currentContext,a=n.alpha*e.alpha;if(0!==a){//  Blend Mode + Scale Mode
o.globalCompositeOperation=t.blendModes[e.blendMode],o.imageSmoothingEnabled=!(!t.antialias||e.frame.source.scaleMode);var h=e.x-n.scrollX*e.scrollFactorX,l=e.y-n.scrollY*e.scrollFactorY;o.save(),s&&s.copyToContext(o);//  Render bobs
for(var u=n.roundPixels,c=0;c<r.length;c++){var d=r[c],f=d.flipX||d.flipY,p=d.frame,g=p.canvasData,v=p.x,m=p.y,y=1,x=1,w=d.alpha*a;0!==w&&(o.globalAlpha=w,f?(d.flipX&&(y=-1,v-=g.width),d.flipY&&(x=-1,m-=g.height),o.save(),o.translate(d.x+h,d.y+l),o.scale(y,x),o.drawImage(p.source.image,g.x,g.y,g.width,g.height,v,m,g.width,g.height),o.restore()):(u&&(v=Math.round(v),m=Math.round(m)),o.drawImage(p.source.image,g.x,g.y,g.width,g.height,v+d.x+h,m+d.y+l,g.width,g.height)))}o.restore()}}}}),r("kjfuT",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7O4PF"),r=new i({initialize:function(t,e,i,n,s){/**
         * The Blitter object that this Bob belongs to.
         *
         * @name Phaser.GameObjects.Bob#parent
         * @type {Phaser.GameObjects.Blitter}
         * @since 3.0.0
         */this.parent=t,/**
         * The x position of this Bob, relative to the x position of the Blitter.
         *
         * @name Phaser.GameObjects.Bob#x
         * @type {number}
         * @since 3.0.0
         */this.x=e,/**
         * The y position of this Bob, relative to the y position of the Blitter.
         *
         * @name Phaser.GameObjects.Bob#y
         * @type {number}
         * @since 3.0.0
         */this.y=i,/**
         * The frame that the Bob uses to render with.
         * To change the frame use the `Bob.setFrame` method.
         *
         * @name Phaser.GameObjects.Bob#frame
         * @type {Phaser.Textures.Frame}
         * @protected
         * @since 3.0.0
         */this.frame=n,/**
         * A blank object which can be used to store data related to this Bob in.
         *
         * @name Phaser.GameObjects.Bob#data
         * @type {object}
         * @default {}
         * @since 3.0.0
         */this.data={},/**
         * The tint value of this Bob.
         *
         * @name Phaser.GameObjects.Bob#tint
         * @type {number}
         * @default 0xffffff
         * @since 3.20.0
         */this.tint=16777215,/**
         * The visible state of this Bob.
         *
         * @name Phaser.GameObjects.Bob#_visible
         * @type {boolean}
         * @private
         * @since 3.0.0
         */this._visible=s,/**
         * The alpha value of this Bob.
         *
         * @name Phaser.GameObjects.Bob#_alpha
         * @type {number}
         * @private
         * @default 1
         * @since 3.0.0
         */this._alpha=1,/**
         * The horizontally flipped state of the Bob.
         * A Bob that is flipped horizontally will render inversed on the horizontal axis.
         * Flipping always takes place from the middle of the texture.
         *
         * @name Phaser.GameObjects.Bob#flipX
         * @type {boolean}
         * @since 3.0.0
         */this.flipX=!1,/**
         * The vertically flipped state of the Bob.
         * A Bob that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
         * Flipping always takes place from the middle of the texture.
         *
         * @name Phaser.GameObjects.Bob#flipY
         * @type {boolean}
         * @since 3.0.0
         */this.flipY=!1},/**
     * Changes the Texture Frame being used by this Bob.
     * The frame must be part of the Texture the parent Blitter is using.
     * If no value is given it will use the default frame of the Blitter parent.
     *
     * @method Phaser.GameObjects.Bob#setFrame
     * @since 3.0.0
     *
     * @param {(string|integer|Phaser.Textures.Frame)} [frame] - The frame to be used during rendering.
     *
     * @return {this} This Bob Game Object.
     */setFrame:function(t){return void 0===t?this.frame=this.parent.frame:t instanceof n&&t.texture===this.parent.texture?this.frame=t:this.frame=this.parent.texture.get(t),this},/**
     * Resets the horizontal and vertical flipped state of this Bob back to their default un-flipped state.
     *
     * @method Phaser.GameObjects.Bob#resetFlip
     * @since 3.0.0
     *
     * @return {this} This Bob Game Object.
     */resetFlip:function(){return this.flipX=!1,this.flipY=!1,this},/**
     * Resets this Bob.
     *
     * Changes the position to the values given, and optionally changes the frame.
     *
     * Also resets the flipX and flipY values, sets alpha back to 1 and visible to true.
     *
     * @method Phaser.GameObjects.Bob#reset
     * @since 3.0.0
     *
     * @param {number} x - The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.
     * @param {number} y - The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.
     * @param {(string|integer|Phaser.Textures.Frame)} [frame] - The Frame the Bob will use. It _must_ be part of the Texture the parent Blitter object is using.
     *
     * @return {this} This Bob Game Object.
     */reset:function(t,e,i){return this.x=t,this.y=e,this.flipX=!1,this.flipY=!1,this._alpha=1,this._visible=!0,this.parent.dirty=!0,i&&this.setFrame(i),this},/**
     * Changes the position of this Bob to the values given.
     *
     * @method Phaser.GameObjects.Bob#setPosition
     * @since 3.20.0
     *
     * @param {number} x - The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.
     * @param {number} y - The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.
     *
     * @return {this} This Bob Game Object.
     */setPosition:function(t,e){return this.x=t,this.y=e,this},/**
     * Sets the horizontal flipped state of this Bob.
     *
     * @method Phaser.GameObjects.Bob#setFlipX
     * @since 3.0.0
     *
     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.
     *
     * @return {this} This Bob Game Object.
     */setFlipX:function(t){return this.flipX=t,this},/**
     * Sets the vertical flipped state of this Bob.
     *
     * @method Phaser.GameObjects.Bob#setFlipY
     * @since 3.0.0
     *
     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.
     *
     * @return {this} This Bob Game Object.
     */setFlipY:function(t){return this.flipY=t,this},/**
     * Sets the horizontal and vertical flipped state of this Bob.
     *
     * @method Phaser.GameObjects.Bob#setFlip
     * @since 3.0.0
     *
     * @param {boolean} x - The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     * @param {boolean} y - The horizontal flipped state. `false` for no flip, or `true` to be flipped.
     *
     * @return {this} This Bob Game Object.
     */setFlip:function(t,e){return this.flipX=t,this.flipY=e,this},/**
     * Sets the visibility of this Bob.
     * 
     * An invisible Bob will skip rendering.
     *
     * @method Phaser.GameObjects.Bob#setVisible
     * @since 3.0.0
     *
     * @param {boolean} value - The visible state of the Game Object.
     *
     * @return {this} This Bob Game Object.
     */setVisible:function(t){return this.visible=t,this},/**
     * Set the Alpha level of this Bob. The alpha controls the opacity of the Game Object as it renders.
     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
     * 
     * A Bob with alpha 0 will skip rendering.
     *
     * @method Phaser.GameObjects.Bob#setAlpha
     * @since 3.0.0
     *
     * @param {number} value - The alpha value used for this Bob. Between 0 and 1.
     *
     * @return {this} This Bob Game Object.
     */setAlpha:function(t){return this.alpha=t,this},/**
     * Sets the tint of this Bob.
     *
     * @method Phaser.GameObjects.Bob#setTint
     * @since 3.20.0
     *
     * @param {number} value - The tint value used for this Bob. Between 0 and 0xffffff.
     *
     * @return {this} This Bob Game Object.
     */setTint:function(t){return this.tint=t,this},/**
     * Destroys this Bob instance.
     * Removes itself from the Blitter and clears the parent, frame and data properties.
     *
     * @method Phaser.GameObjects.Bob#destroy
     * @since 3.0.0
     */destroy:function(){this.parent.dirty=!0,this.parent.children.remove(this),this.parent=void 0,this.frame=void 0,this.data=void 0},/**
     * The visible state of the Bob.
     * 
     * An invisible Bob will skip rendering.
     *
     * @name Phaser.GameObjects.Bob#visible
     * @type {boolean}
     * @since 3.0.0
     */visible:{get:function(){return this._visible},set:function(t){this.parent.dirty|=this._visible!==t,this._visible=t}},/**
     * The alpha value of the Bob, between 0 and 1.
     * 
     * A Bob with alpha 0 will skip rendering.
     *
     * @name Phaser.GameObjects.Bob#alpha
     * @type {number}
     * @since 3.0.0
     */alpha:{get:function(){return this._alpha},set:function(t){this.parent.dirty|=this._alpha>0!=t>0,this._alpha=t}}});t.exports=r}),r("ixgBh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("3Mp2n"),n=s("3qUcC"),r=s("jwj1g"),o=s("4FF1v"),a=s("jIv3O"),h=s("1zqlR"),l=s("cwr8X"),u=s("5toVX"),c=s("dDbeb"),d=s("7SBSk"),f=new r({Extends:h,Mixins:[o.AlphaSingle,o.BlendMode,o.ComputedSize,o.Depth,o.Mask,o.Transform,o.Visible,u],initialize:function(t,e,i,s){h.call(this,t,"Container"),/**
         * An array holding the children of this Container.
         *
         * @name Phaser.GameObjects.Container#list
         * @type {Phaser.GameObjects.GameObject[]}
         * @since 3.4.0
         */this.list=[],/**
         * Does this Container exclusively manage its children?
         *
         * The default is `true` which means a child added to this Container cannot
         * belong in another Container, which includes the Scene display list.
         *
         * If you disable this then this Container will no longer exclusively manage its children.
         * This allows you to create all kinds of interesting graphical effects, such as replicating
         * Game Objects without reparenting them all over the Scene.
         * However, doing so will prevent children from receiving any kind of input event or have
         * their physics bodies work by default, as they're no longer a single entity on the
         * display list, but are being replicated where-ever this Container is.
         *
         * @name Phaser.GameObjects.Container#exclusive
         * @type {boolean}
         * @default true
         * @since 3.4.0
         */this.exclusive=!0,/**
         * Containers can have an optional maximum size. If set to anything above 0 it
         * will constrict the addition of new Game Objects into the Container, capping off
         * the maximum limit the Container can grow in size to.
         *
         * @name Phaser.GameObjects.Container#maxSize
         * @type {integer}
         * @default -1
         * @since 3.4.0
         */this.maxSize=-1,/**
         * The cursor position.
         *
         * @name Phaser.GameObjects.Container#position
         * @type {integer}
         * @since 3.4.0
         */this.position=0,/**
         * Internal Transform Matrix used for local space conversion.
         *
         * @name Phaser.GameObjects.Container#localTransform
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.4.0
         */this.localTransform=new o.TransformMatrix,/**
         * Internal temporary Transform Matrix used to avoid object creation.
         *
         * @name Phaser.GameObjects.Container#tempTransformMatrix
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @private
         * @since 3.4.0
         */this.tempTransformMatrix=new o.TransformMatrix,/**
         * A reference to the Scene Display List.
         *
         * @name Phaser.GameObjects.Container#_displayList
         * @type {Phaser.GameObjects.DisplayList}
         * @private
         * @since 3.4.0
         */this._displayList=t.sys.displayList,/**
         * The property key to sort by.
         *
         * @name Phaser.GameObjects.Container#_sortKey
         * @type {string}
         * @private
         * @since 3.4.0
         */this._sortKey="",/**
         * A reference to the Scene Systems Event Emitter.
         *
         * @name Phaser.GameObjects.Container#_sysEvents
         * @type {Phaser.Events.EventEmitter}
         * @private
         * @since 3.9.0
         */this._sysEvents=t.sys.events,/**
         * The horizontal scroll factor of this Container.
         *
         * The scroll factor controls the influence of the movement of a Camera upon this Container.
         *
         * When a camera scrolls it will change the location at which this Container is rendered on-screen.
         * It does not change the Containers actual position values.
         * 
         * For a Container, setting this value will only update the Container itself, not its children.
         * If you wish to change the scrollFactor of the children as well, use the `setScrollFactor` method.
         *
         * A value of 1 means it will move exactly in sync with a camera.
         * A value of 0 means it will not move at all, even if the camera moves.
         * Other values control the degree to which the camera movement is mapped to this Container.
         * 
         * Please be aware that scroll factor values other than 1 are not taken in to consideration when
         * calculating physics collisions. Bodies always collide based on their world position, but changing
         * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
         * them from physics bodies if not accounted for in your code.
         *
         * @name Phaser.GameObjects.Container#scrollFactorX
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.scrollFactorX=1,/**
         * The vertical scroll factor of this Container.
         *
         * The scroll factor controls the influence of the movement of a Camera upon this Container.
         *
         * When a camera scrolls it will change the location at which this Container is rendered on-screen.
         * It does not change the Containers actual position values.
         * 
         * For a Container, setting this value will only update the Container itself, not its children.
         * If you wish to change the scrollFactor of the children as well, use the `setScrollFactor` method.
         *
         * A value of 1 means it will move exactly in sync with a camera.
         * A value of 0 means it will not move at all, even if the camera moves.
         * Other values control the degree to which the camera movement is mapped to this Container.
         * 
         * Please be aware that scroll factor values other than 1 are not taken in to consideration when
         * calculating physics collisions. Bodies always collide based on their world position, but changing
         * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
         * them from physics bodies if not accounted for in your code.
         *
         * @name Phaser.GameObjects.Container#scrollFactorY
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.scrollFactorY=1,this.setPosition(e,i),this.clearAlpha(),this.setBlendMode(n.SKIP_CHECK),s&&this.add(s)},/**
     * Internal value to allow Containers to be used for input and physics.
     * Do not change this value. It has no effect other than to break things.
     *
     * @name Phaser.GameObjects.Container#originX
     * @type {number}
     * @readonly
     * @since 3.4.0
     */originX:{get:function(){return .5}},/**
     * Internal value to allow Containers to be used for input and physics.
     * Do not change this value. It has no effect other than to break things.
     *
     * @name Phaser.GameObjects.Container#originY
     * @type {number}
     * @readonly
     * @since 3.4.0
     */originY:{get:function(){return .5}},/**
     * Internal value to allow Containers to be used for input and physics.
     * Do not change this value. It has no effect other than to break things.
     *
     * @name Phaser.GameObjects.Container#displayOriginX
     * @type {number}
     * @readonly
     * @since 3.4.0
     */displayOriginX:{get:function(){return .5*this.width}},/**
     * Internal value to allow Containers to be used for input and physics.
     * Do not change this value. It has no effect other than to break things.
     *
     * @name Phaser.GameObjects.Container#displayOriginY
     * @type {number}
     * @readonly
     * @since 3.4.0
     */displayOriginY:{get:function(){return .5*this.height}},/**
     * Does this Container exclusively manage its children?
     *
     * The default is `true` which means a child added to this Container cannot
     * belong in another Container, which includes the Scene display list.
     *
     * If you disable this then this Container will no longer exclusively manage its children.
     * This allows you to create all kinds of interesting graphical effects, such as replicating
     * Game Objects without reparenting them all over the Scene.
     * However, doing so will prevent children from receiving any kind of input event or have
     * their physics bodies work by default, as they're no longer a single entity on the
     * display list, but are being replicated where-ever this Container is.
     *
     * @method Phaser.GameObjects.Container#setExclusive
     * @since 3.4.0
     *
     * @param {boolean} [value=true] - The exclusive state of this Container.
     *
     * @return {this} This Container.
     */setExclusive:function(t){return void 0===t&&(t=!0),this.exclusive=t,this},/**
     * Gets the bounds of this Container. It works by iterating all children of the Container,
     * getting their respective bounds, and then working out a min-max rectangle from that.
     * It does not factor in if the children render or not, all are included.
     *
     * Some children are unable to return their bounds, such as Graphics objects, in which case
     * they are skipped.
     *
     * Depending on the quantity of children in this Container it could be a really expensive call,
     * so cache it and only poll it as needed.
     *
     * The values are stored and returned in a Rectangle object.
     *
     * @method Phaser.GameObjects.Container#getBounds
     * @since 3.4.0
     *
     * @param {Phaser.Geom.Rectangle} [output] - A Geom.Rectangle object to store the values in. If not provided a new Rectangle will be created.
     *
     * @return {Phaser.Geom.Rectangle} The values stored in the output object.
     */getBounds:function(t){if(void 0===t&&(t=new l),t.setTo(this.x,this.y,0,0),this.parentContainer){var e=this.parentContainer.getBoundsTransformMatrix().transformPoint(this.x,this.y);t.setTo(e.x,e.y,0,0)}if(this.list.length>0){var i=this.list,n=new l,s=i[0].getBounds();t.setTo(s.x,s.y,s.width,s.height);for(var r=1;r<i.length;r++){var o=i[r];o.getBounds&&(o.getBounds(n),c(n,t,t))}}return t},/**
     * Internal add handler.
     *
     * @method Phaser.GameObjects.Container#addHandler
     * @private
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just added to this Container.
     */addHandler:function(t){t.once(a.DESTROY,this.remove,this),this.exclusive&&(this._displayList.remove(t),t.parentContainer&&t.parentContainer.remove(t),t.parentContainer=this)},/**
     * Internal remove handler.
     *
     * @method Phaser.GameObjects.Container#removeHandler
     * @private
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just removed from this Container.
     */removeHandler:function(t){t.off(a.DESTROY,this.remove),this.exclusive&&(t.parentContainer=null)},/**
     * Takes a Point-like object, such as a Vector2, Geom.Point or object with public x and y properties,
     * and transforms it into the space of this Container, then returns it in the output object.
     *
     * @method Phaser.GameObjects.Container#pointToContainer
     * @since 3.4.0
     *
     * @param {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} source - The Source Point to be transformed.
     * @param {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} [output] - A destination object to store the transformed point in. If none given a Vector2 will be created and returned.
     *
     * @return {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} The transformed point.
     */pointToContainer:function(t,e){void 0===e&&(e=new d),this.parentContainer?this.parentContainer.pointToContainer(t,e):e=new d(t.x,t.y);var i=this.tempTransformMatrix;return(//  No need to loadIdentity because applyITRS overwrites every value anyway
i.applyITRS(this.x,this.y,this.rotation,this.scaleX,this.scaleY),i.invert(),i.transformPoint(t.x,t.y,e),e)},/**
     * Returns the world transform matrix as used for Bounds checks.
     * 
     * The returned matrix is temporal and shouldn't be stored.
     *
     * @method Phaser.GameObjects.Container#getBoundsTransformMatrix
     * @since 3.4.0
     *
     * @return {Phaser.GameObjects.Components.TransformMatrix} The world transform matrix.
     */getBoundsTransformMatrix:function(){return this.getWorldTransformMatrix(this.tempTransformMatrix,this.localTransform)},/**
     * Adds the given Game Object, or array of Game Objects, to this Container.
     *
     * Each Game Object must be unique within the Container.
     *
     * @method Phaser.GameObjects.Container#add
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to add to the Container.
     *
     * @return {this} This Container instance.
     */add:function(t){return i.Add(this.list,t,this.maxSize,this.addHandler,this),this},/**
     * Adds the given Game Object, or array of Game Objects, to this Container at the specified position.
     *
     * Existing Game Objects in the Container are shifted up.
     *
     * Each Game Object must be unique within the Container.
     *
     * @method Phaser.GameObjects.Container#addAt
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to add to the Container.
     * @param {integer} [index=0] - The position to insert the Game Object/s at.
     *
     * @return {this} This Container instance.
     */addAt:function(t,e){return i.AddAt(this.list,t,e,this.maxSize,this.addHandler,this),this},/**
     * Returns the Game Object at the given position in this Container.
     *
     * @method Phaser.GameObjects.Container#getAt
     * @since 3.4.0
     *
     * @param {integer} index - The position to get the Game Object from.
     *
     * @return {?Phaser.GameObjects.GameObject} The Game Object at the specified index, or `null` if none found.
     */getAt:function(t){return this.list[t]},/**
     * Returns the index of the given Game Object in this Container.
     *
     * @method Phaser.GameObjects.Container#getIndex
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object to search for in this Container.
     *
     * @return {integer} The index of the Game Object in this Container, or -1 if not found.
     */getIndex:function(t){return this.list.indexOf(t)},/**
     * Sort the contents of this Container so the items are in order based on the given property.
     * For example: `sort('alpha')` would sort the elements based on the value of their `alpha` property.
     *
     * @method Phaser.GameObjects.Container#sort
     * @since 3.4.0
     *
     * @param {string} property - The property to lexically sort by.
     * @param {function} [handler] - Provide your own custom handler function. Will receive 2 children which it should compare and return a boolean.
     *
     * @return {this} This Container instance.
     */sort:function(t,e){return t&&(void 0===e&&(e=function(e,i){return e[t]-i[t]}),i.StableSort.inplace(this.list,e)),this},/**
     * Searches for the first instance of a child with its `name` property matching the given argument.
     * Should more than one child have the same name only the first is returned.
     *
     * @method Phaser.GameObjects.Container#getByName
     * @since 3.4.0
     *
     * @param {string} name - The name to search for.
     *
     * @return {?Phaser.GameObjects.GameObject} The first child with a matching name, or `null` if none were found.
     */getByName:function(t){return i.GetFirst(this.list,"name",t)},/**
     * Returns a random Game Object from this Container.
     *
     * @method Phaser.GameObjects.Container#getRandom
     * @since 3.4.0
     *
     * @param {integer} [startIndex=0] - An optional start index.
     * @param {integer} [length] - An optional length, the total number of elements (from the startIndex) to choose from.
     *
     * @return {?Phaser.GameObjects.GameObject} A random child from the Container, or `null` if the Container is empty.
     */getRandom:function(t,e){return i.GetRandom(this.list,t,e)},/**
     * Gets the first Game Object in this Container.
     *
     * You can also specify a property and value to search for, in which case it will return the first
     * Game Object in this Container with a matching property and / or value.
     *
     * For example: `getFirst('visible', true)` would return the first Game Object that had its `visible` property set.
     *
     * You can limit the search to the `startIndex` - `endIndex` range.
     *
     * @method Phaser.GameObjects.Container#getFirst
     * @since 3.4.0
     *
     * @param {string} property - The property to test on each Game Object in the Container.
     * @param {*} value - The value to test the property against. Must pass a strict (`===`) comparison check.
     * @param {integer} [startIndex=0] - An optional start index to search from.
     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)
     *
     * @return {?Phaser.GameObjects.GameObject} The first matching Game Object, or `null` if none was found.
     */getFirst:function(t,e,n,s){return i.GetFirst(this.list,t,e,n,s)},/**
     * Returns all Game Objects in this Container.
     *
     * You can optionally specify a matching criteria using the `property` and `value` arguments.
     *
     * For example: `getAll('body')` would return only Game Objects that have a body property.
     *
     * You can also specify a value to compare the property to:
     *
     * `getAll('visible', true)` would return only Game Objects that have their visible property set to `true`.
     *
     * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,
     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
     * the first 50 Game Objects.
     *
     * @method Phaser.GameObjects.Container#getAll
     * @since 3.4.0
     *
     * @param {string} [property] - The property to test on each Game Object in the Container.
     * @param {any} [value] - If property is set then the `property` must strictly equal this value to be included in the results.
     * @param {integer} [startIndex=0] - An optional start index to search from.
     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)
     *
     * @return {Phaser.GameObjects.GameObject[]} An array of matching Game Objects from this Container.
     */getAll:function(t,e,n,s){return i.GetAll(this.list,t,e,n,s)},/**
     * Returns the total number of Game Objects in this Container that have a property
     * matching the given value.
     *
     * For example: `count('visible', true)` would count all the elements that have their visible property set.
     *
     * You can optionally limit the operation to the `startIndex` - `endIndex` range.
     *
     * @method Phaser.GameObjects.Container#count
     * @since 3.4.0
     *
     * @param {string} property - The property to check.
     * @param {any} value - The value to check.
     * @param {integer} [startIndex=0] - An optional start index to search from.
     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)
     *
     * @return {integer} The total number of Game Objects in this Container with a property matching the given value.
     */count:function(t,e,n,s){return i.CountAllMatching(this.list,t,e,n,s)},/**
     * Swaps the position of two Game Objects in this Container.
     * Both Game Objects must belong to this Container.
     *
     * @method Phaser.GameObjects.Container#swap
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject} child1 - The first Game Object to swap.
     * @param {Phaser.GameObjects.GameObject} child2 - The second Game Object to swap.
     *
     * @return {this} This Container instance.
     */swap:function(t,e){return i.Swap(this.list,t,e),this},/**
     * Moves a Game Object to a new position within this Container.
     *
     * The Game Object must already be a child of this Container.
     *
     * The Game Object is removed from its old position and inserted into the new one.
     * Therefore the Container size does not change. Other children will change position accordingly.
     *
     * @method Phaser.GameObjects.Container#moveTo
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object to move.
     * @param {integer} index - The new position of the Game Object in this Container.
     *
     * @return {this} This Container instance.
     */moveTo:function(t,e){return i.MoveTo(this.list,t,e),this},/**
     * Removes the given Game Object, or array of Game Objects, from this Container.
     *
     * The Game Objects must already be children of this Container.
     *
     * You can also optionally call `destroy` on each Game Object that is removed from the Container.
     *
     * @method Phaser.GameObjects.Container#remove
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to be removed from the Container.
     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each child successfully removed from this Container.
     *
     * @return {this} This Container instance.
     */remove:function(t,e){var n=i.Remove(this.list,t,this.removeHandler,this);if(e&&n){Array.isArray(n)||(n=[n]);for(var s=0;s<n.length;s++)n[s].destroy()}return this},/**
     * Removes the Game Object at the given position in this Container.
     *
     * You can also optionally call `destroy` on the Game Object, if one is found.
     *
     * @method Phaser.GameObjects.Container#removeAt
     * @since 3.4.0
     *
     * @param {integer} index - The index of the Game Object to be removed.
     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on the Game Object if successfully removed from this Container.
     *
     * @return {this} This Container instance.
     */removeAt:function(t,e){var n=i.RemoveAt(this.list,t,this.removeHandler,this);return e&&n&&n.destroy(),this},/**
     * Removes the Game Objects between the given positions in this Container.
     *
     * You can also optionally call `destroy` on each Game Object that is removed from the Container.
     *
     * @method Phaser.GameObjects.Container#removeBetween
     * @since 3.4.0
     *
     * @param {integer} [startIndex=0] - An optional start index to search from.
     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)
     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each Game Object successfully removed from this Container.
     *
     * @return {this} This Container instance.
     */removeBetween:function(t,e,n){var s=i.RemoveBetween(this.list,t,e,this.removeHandler,this);if(n)for(var r=0;r<s.length;r++)s[r].destroy();return this},/**
     * Removes all Game Objects from this Container.
     *
     * You can also optionally call `destroy` on each Game Object that is removed from the Container.
     *
     * @method Phaser.GameObjects.Container#removeAll
     * @since 3.4.0
     *
     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each Game Object successfully removed from this Container.
     *
     * @return {this} This Container instance.
     */removeAll:function(t){var e=i.RemoveBetween(this.list,0,this.list.length,this.removeHandler,this);if(t)for(var n=0;n<e.length;n++)e[n].destroy();return this},/**
     * Brings the given Game Object to the top of this Container.
     * This will cause it to render on-top of any other objects in the Container.
     *
     * @method Phaser.GameObjects.Container#bringToTop
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object to bring to the top of the Container.
     *
     * @return {this} This Container instance.
     */bringToTop:function(t){return i.BringToTop(this.list,t),this},/**
     * Sends the given Game Object to the bottom of this Container.
     * This will cause it to render below any other objects in the Container.
     *
     * @method Phaser.GameObjects.Container#sendToBack
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object to send to the bottom of the Container.
     *
     * @return {this} This Container instance.
     */sendToBack:function(t){return i.SendToBack(this.list,t),this},/**
     * Moves the given Game Object up one place in this Container, unless it's already at the top.
     *
     * @method Phaser.GameObjects.Container#moveUp
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object to be moved in the Container.
     *
     * @return {this} This Container instance.
     */moveUp:function(t){return i.MoveUp(this.list,t),this},/**
     * Moves the given Game Object down one place in this Container, unless it's already at the bottom.
     *
     * @method Phaser.GameObjects.Container#moveDown
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object to be moved in the Container.
     *
     * @return {this} This Container instance.
     */moveDown:function(t){return i.MoveDown(this.list,t),this},/**
     * Reverses the order of all Game Objects in this Container.
     *
     * @method Phaser.GameObjects.Container#reverse
     * @since 3.4.0
     *
     * @return {this} This Container instance.
     */reverse:function(){return this.list.reverse(),this},/**
     * Shuffles the all Game Objects in this Container using the Fisher-Yates implementation.
     *
     * @method Phaser.GameObjects.Container#shuffle
     * @since 3.4.0
     *
     * @return {this} This Container instance.
     */shuffle:function(){return i.Shuffle(this.list),this},/**
     * Replaces a Game Object in this Container with the new Game Object.
     * The new Game Object cannot already be a child of this Container.
     *
     * @method Phaser.GameObjects.Container#replace
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject} oldChild - The Game Object in this Container that will be replaced.
     * @param {Phaser.GameObjects.GameObject} newChild - The Game Object to be added to this Container.
     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on the Game Object if successfully removed from this Container.
     *
     * @return {this} This Container instance.
     */replace:function(t,e,n){return i.Replace(this.list,t,e)&&(this.addHandler(e),this.removeHandler(t),n&&t.destroy()),this},/**
     * Returns `true` if the given Game Object is a direct child of this Container.
     *
     * This check does not scan nested Containers.
     *
     * @method Phaser.GameObjects.Container#exists
     * @since 3.4.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object to check for within this Container.
     *
     * @return {boolean} True if the Game Object is an immediate child of this Container, otherwise false.
     */exists:function(t){return this.list.indexOf(t)>-1},/**
     * Sets the property to the given value on all Game Objects in this Container.
     *
     * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,
     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
     * the first 50 Game Objects.
     *
     * @method Phaser.GameObjects.Container#setAll
     * @since 3.4.0
     *
     * @param {string} property - The property that must exist on the Game Object.
     * @param {any} value - The value to get the property to.
     * @param {integer} [startIndex=0] - An optional start index to search from.
     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)
     *
     * @return {this} This Container instance.
     */setAll:function(t,e,n,s){return i.SetAll(this.list,t,e,n,s),this},/**
     * @callback EachContainerCallback
     * @generic I - [item]
     *
     * @param {*} item - The child Game Object of the Container.
     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.
     *//**
     * Passes all Game Objects in this Container to the given callback.
     *
     * A copy of the Container is made before passing each entry to your callback.
     * This protects against the callback itself modifying the Container.
     *
     * If you know for sure that the callback will not change the size of this Container
     * then you can use the more performant `Container.iterate` method instead.
     *
     * @method Phaser.GameObjects.Container#each
     * @since 3.4.0
     *
     * @param {function} callback - The function to call.
     * @param {object} [context] - Value to use as `this` when executing callback.
     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.
     *
     * @return {this} This Container instance.
     */each:function(t,e){var i,n=[null],s=this.list.slice(),r=s.length;for(i=2;i<arguments.length;i++)n.push(arguments[i]);for(i=0;i<r;i++)n[0]=s[i],t.apply(e,n);return this},/**
     * Passes all Game Objects in this Container to the given callback.
     *
     * Only use this method when you absolutely know that the Container will not be modified during
     * the iteration, i.e. by removing or adding to its contents.
     *
     * @method Phaser.GameObjects.Container#iterate
     * @since 3.4.0
     *
     * @param {function} callback - The function to call.
     * @param {object} [context] - Value to use as `this` when executing callback.
     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.
     *
     * @return {this} This Container instance.
     */iterate:function(t,e){var i,n=[null];for(i=2;i<arguments.length;i++)n.push(arguments[i]);for(i=0;i<this.list.length;i++)n[0]=this.list[i],t.apply(e,n);return this},/**
     * Sets the scroll factor of this Container and optionally all of its children.
     *
     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
     *
     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
     * It does not change the Game Objects actual position values.
     *
     * A value of 1 means it will move exactly in sync with a camera.
     * A value of 0 means it will not move at all, even if the camera moves.
     * Other values control the degree to which the camera movement is mapped to this Game Object.
     * 
     * Please be aware that scroll factor values other than 1 are not taken in to consideration when
     * calculating physics collisions. Bodies always collide based on their world position, but changing
     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
     * them from physics bodies if not accounted for in your code.
     *
     * @method Phaser.GameObjects.Container#setScrollFactor
     * @since 3.0.0
     *
     * @param {number} x - The horizontal scroll factor of this Game Object.
     * @param {number} [y=x] - The vertical scroll factor of this Game Object. If not set it will use the `x` value.
     * @param {boolean} [updateChildren=false] - Apply this scrollFactor to all Container children as well?
     *
     * @return {this} This Game Object instance.
     */setScrollFactor:function(t,e,n){return void 0===e&&(e=t),void 0===n&&(n=!1),this.scrollFactorX=t,this.scrollFactorY=e,n&&(i.SetAll(this.list,"scrollFactorX",t),i.SetAll(this.list,"scrollFactorY",e)),this},/**
     * The number of Game Objects inside this Container.
     *
     * @name Phaser.GameObjects.Container#length
     * @type {integer}
     * @readonly
     * @since 3.4.0
     */length:{get:function(){return this.list.length}},/**
     * Returns the first Game Object within the Container, or `null` if it is empty.
     *
     * You can move the cursor by calling `Container.next` and `Container.previous`.
     *
     * @name Phaser.GameObjects.Container#first
     * @type {?Phaser.GameObjects.GameObject}
     * @readonly
     * @since 3.4.0
     */first:{get:function(){return(this.position=0,this.list.length>0)?this.list[0]:null}},/**
     * Returns the last Game Object within the Container, or `null` if it is empty.
     *
     * You can move the cursor by calling `Container.next` and `Container.previous`.
     *
     * @name Phaser.GameObjects.Container#last
     * @type {?Phaser.GameObjects.GameObject}
     * @readonly
     * @since 3.4.0
     */last:{get:function(){return this.list.length>0?(this.position=this.list.length-1,this.list[this.position]):null}},/**
     * Returns the next Game Object within the Container, or `null` if it is empty.
     *
     * You can move the cursor by calling `Container.next` and `Container.previous`.
     *
     * @name Phaser.GameObjects.Container#next
     * @type {?Phaser.GameObjects.GameObject}
     * @readonly
     * @since 3.4.0
     */next:{get:function(){return this.position<this.list.length?(this.position++,this.list[this.position]):null}},/**
     * Returns the previous Game Object within the Container, or `null` if it is empty.
     *
     * You can move the cursor by calling `Container.next` and `Container.previous`.
     *
     * @name Phaser.GameObjects.Container#previous
     * @type {?Phaser.GameObjects.GameObject}
     * @readonly
     * @since 3.4.0
     */previous:{get:function(){return this.position>0?(this.position--,this.list[this.position]):null}},/**
     * Internal destroy handler, called as part of the destroy process.
     *
     * @method Phaser.GameObjects.Container#preDestroy
     * @protected
     * @since 3.9.0
     */preDestroy:function(){this.removeAll(!!this.exclusive),this.localTransform.destroy(),this.tempTransformMatrix.destroy(),this.list=[],this._displayList=null}});t.exports=f}),r("5toVX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("ihMdm"),r=s("b7Qte"),t.exports={renderWebGL:n,renderCanvas:r}}),r("ihMdm",function(t,e){t.exports=function(t,e,i,n,s){var r=e.list;if(0!==r.length){var o=e.localTransform;s?(o.loadIdentity(),o.multiply(s),o.translate(e.x,e.y),o.rotate(e.rotation),o.scale(e.scaleX,e.scaleY)):o.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY);var a=-1!==e.blendMode;a||t.setBlendMode(0);for(var h=e.alpha,l=e.scrollFactorX,u=e.scrollFactorY,c=r.length,d=0;d<c;d++){var f,p,g,v,m=r[d];if(m.willRender(n)){if(void 0!==m.alphaTopLeft)f=m.alphaTopLeft,p=m.alphaTopRight,g=m.alphaBottomLeft,v=m.alphaBottomRight;else{var y=m.alpha;f=y,p=y,g=y,v=y}var x=m.scrollFactorX,w=m.scrollFactorY;a||m.blendMode===t.currentBlendMode||t.setBlendMode(m.blendMode);var T=m.mask;T&&T.preRenderWebGL(t,m,n);var b=m.type;b!==t.currentType&&(t.newType=!0,t.currentType=b),t.nextTypeMatch=d<c-1&&r[d+1].type===t.currentType,//  Set parent values
m.setScrollFactor(x*l,w*u),m.setAlpha(f*h,p*h,g*h,v*h),//  Render
m.renderWebGL(t,m,i,n,o),//  Restore original values
m.setAlpha(f,p,g,v),m.setScrollFactor(x,w),T&&T.postRenderWebGL(t,n),t.newType=!1}}}}}),r("b7Qte",function(t,e){t.exports=function(t,e,i,n,s){var r=e.list;if(0!==r.length){var o=e.localTransform;s?(o.loadIdentity(),o.multiply(s),o.translate(e.x,e.y),o.rotate(e.rotation),o.scale(e.scaleX,e.scaleY)):o.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY);var a=-1!==e.blendMode;a||t.setBlendMode(0);for(var h=e._alpha,l=e.scrollFactorX,u=e.scrollFactorY,c=0;c<r.length;c++){var d=r[c];if(d.willRender(n)){var f=d.alpha,p=d.scrollFactorX,g=d.scrollFactorY;a||d.blendMode===t.currentBlendMode||t.setBlendMode(d.blendMode),//  Set parent values
d.setScrollFactor(p*l,g*u),d.setAlpha(f*h),//  Render
d.renderCanvas(t,d,i,n,o),//  Restore original values
d.setAlpha(f),d.setScrollFactor(p,g)}}}}}),r("dDbeb",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cwr8X");t.exports=function(t,e,n){void 0===n&&(n=new i);//  Cache vars so we can use one of the input rects as the output rect
var s=Math.min(t.x,e.x),r=Math.min(t.y,e.y),o=Math.max(t.right,e.right)-s,a=Math.max(t.bottom,e.bottom)-r;return n.setTo(s,r,o,a)}}),r("gZAGH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("fDeAE"),o=s("1zqlR"),a=s("jC9MQ"),h=s("kJrIV"),l=s("4rtgc"),u=s("27QVG"),c=new i({Extends:o,Mixins:[n.AlphaSingle,n.BlendMode,n.Depth,n.Origin,n.ScrollFactor,n.Transform,n.Visible,r],initialize:function(t,e,i,n,s,r){o.call(this,t,"DOMElement"),/**
         * A reference to the parent DOM Container that the Game instance created when it started.
         * 
         * @name Phaser.GameObjects.DOMElement#parent
         * @type {Element}
         * @since 3.17.0
         */this.parent=t.sys.game.domContainer,/**
         * A reference to the HTML Cache.
         * 
         * @name Phaser.GameObjects.DOMElement#cache
         * @type {Phaser.Cache.BaseCache}
         * @since 3.17.0
         */this.cache=t.sys.cache.html,/**
         * The actual DOM Element that this Game Object is bound to. For example, if you've created a `<div>`
         * then this property is a direct reference to that element within the dom.
         * 
         * @name Phaser.GameObjects.DOMElement#node
         * @type {Element}
         * @since 3.17.0
         */this.node,/**
         * By default a DOM Element will have its transform, display, opacity, zIndex and blend mode properties
         * updated when its rendered. If, for some reason, you don't want any of these changed other than the
         * CSS transform, then set this flag to `true`. When `true` only the CSS Transform is applied and it's
         * up to you to keep track of and set the other properties as required.
         * 
         * This can be handy if, for example, you've a nested DOM Element and you don't want the opacity to be
         * picked-up by any of its children.
         * 
         * @name Phaser.GameObjects.DOMElement#transformOnly
         * @type {boolean}
         * @since 3.17.0
         */this.transformOnly=!1,/**
         * The angle, in radians, by which to skew the DOM Element on the horizontal axis.
         * 
         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform
         * 
         * @name Phaser.GameObjects.DOMElement#skewX
         * @type {number}
         * @since 3.17.0
         */this.skewX=0,/**
         * The angle, in radians, by which to skew the DOM Element on the vertical axis.
         * 
         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform
         * 
         * @name Phaser.GameObjects.DOMElement#skewY
         * @type {number}
         * @since 3.17.0
         */this.skewY=0,/**
         * A Vector4 that contains the 3D rotation of this DOM Element around a fixed axis in 3D space.
         * 
         * All values in the Vector4 are treated as degrees, unless the `rotate3dAngle` property is changed.
         * 
         * For more details see the following MDN page:
         * 
         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d
         * 
         * @name Phaser.GameObjects.DOMElement#rotate3d
         * @type {Phaser.Math.Vector4}
         * @since 3.17.0
         */this.rotate3d=new u,/**
         * The unit that represents the 3D rotation values. By default this is `deg` for degrees, but can
         * be changed to any supported unit. See this page for further details:
         * 
         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d
         * 
         * @name Phaser.GameObjects.DOMElement#rotate3dAngle
         * @type {string}
         * @since 3.17.0
         */this.rotate3dAngle="deg",/**
         * The native (un-scaled) width of this Game Object.
         * 
         * For a DOM Element this property is read-only.
         * 
         * The property `displayWidth` holds the computed bounds of this DOM Element, factoring in scaling.
         * 
         * @name Phaser.GameObjects.DOMElement#width
         * @type {number}
         * @readonly
         * @since 3.17.0
         */this.width=0,/**
         * The native (un-scaled) height of this Game Object.
         * 
         * For a DOM Element this property is read-only.
         * 
         * The property `displayHeight` holds the computed bounds of this DOM Element, factoring in scaling.
         * 
         * @name Phaser.GameObjects.DOMElement#height
         * @type {number}
         * @readonly
         * @since 3.17.0
         */this.height=0,/**
         * The computed display width of this Game Object, based on the `getBoundingClientRect` DOM call.
         * 
         * The property `width` holds the un-scaled width of this DOM Element.
         * 
         * @name Phaser.GameObjects.DOMElement#displayWidth
         * @type {number}
         * @readonly
         * @since 3.17.0
         */this.displayWidth=0,/**
         * The computed display height of this Game Object, based on the `getBoundingClientRect` DOM call.
         * 
         * The property `height` holds the un-scaled height of this DOM Element.
         * 
         * @name Phaser.GameObjects.DOMElement#displayHeight
         * @type {number}
         * @readonly
         * @since 3.17.0
         */this.displayHeight=0,/**
         * Internal native event handler.
         * 
         * @name Phaser.GameObjects.DOMElement#handler
         * @type {number}
         * @private
         * @since 3.17.0
         */this.handler=this.dispatchNativeEvent.bind(this),this.setPosition(e,i),"string"==typeof n?"#"===n[0]?this.setElement(n.substr(1),s,r):this.createElement(n,s,r):n&&this.setElement(n,s,r),t.sys.events.on(l.SLEEP,this.handleSceneEvent,this),t.sys.events.on(l.WAKE,this.handleSceneEvent,this)},/**
     * Handles a Scene Sleep and Wake event.
     *
     * @method Phaser.GameObjects.DOMElement#handleSceneEvent
     * @private
     * @since 3.22.0
     *
     * @param {Phaser.Scenes.Systems} sys - The Scene Systems.
     */handleSceneEvent:function(t){var e=this.node,i=e.style;e&&(i.display=t.settings.visible?"block":"none")},/**
     * Sets the horizontal and vertical skew values of this DOM Element.
     * 
     * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/transform
     *
     * @method Phaser.GameObjects.DOMElement#setSkew
     * @since 3.17.0
     *
     * @param {number} [x=0] - The angle, in radians, by which to skew the DOM Element on the horizontal axis.
     * @param {number} [y=x] - The angle, in radians, by which to skew the DOM Element on the vertical axis.
     * 
     * @return {this} This DOM Element instance.
     */setSkew:function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),this.skewX=t,this.skewY=e,this},/**
     * Sets the perspective CSS property of the _parent DOM Container_. This determines the distance between the z=0
     * plane and the user in order to give a 3D-positioned element some perspective. Each 3D element with
     * z > 0 becomes larger; each 3D-element with z < 0 becomes smaller. The strength of the effect is determined
     * by the value of this property.
     * 
     * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/perspective
     * 
     * **Changing this value changes it globally for all DOM Elements, as they all share the same parent container.**
     *
     * @method Phaser.GameObjects.DOMElement#setPerspective
     * @since 3.17.0
     *
     * @param {number} value - The perspective value, in pixels, that determines the distance between the z plane and the user.
     * 
     * @return {this} This DOM Element instance.
     */setPerspective:function(t){return this.parent.style.perspective=t+"px",this},/**
     * The perspective CSS property value of the _parent DOM Container_. This determines the distance between the z=0
     * plane and the user in order to give a 3D-positioned element some perspective. Each 3D element with
     * z > 0 becomes larger; each 3D-element with z < 0 becomes smaller. The strength of the effect is determined
     * by the value of this property.
     * 
     * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/perspective
     * 
     * **Changing this value changes it globally for all DOM Elements, as they all share the same parent container.**
     * 
     * @name Phaser.GameObjects.DOMElement#perspective
     * @type {number}
     * @since 3.17.0
     */perspective:{get:function(){return parseFloat(this.parent.style.perspective)},set:function(t){this.parent.style.perspective=t+"px"}},/**
     * Adds one or more native DOM event listeners onto the underlying Element of this Game Object.
     * The event is then dispatched via this Game Objects standard event emitter.
     * 
     * For example:
     * 
     * ```javascript
     * var div = this.add.dom(x, y, element);
     * 
     * div.addListener('click');
     * 
     * div.on('click', handler);
     * ```
     *
     * @method Phaser.GameObjects.DOMElement#addListener
     * @since 3.17.0
     *
     * @param {string} events - The DOM event/s to listen for. You can specify multiple events by separating them with spaces.
     * 
     * @return {this} This DOM Element instance.
     */addListener:function(t){if(this.node){t=t.split(" ");for(var e=0;e<t.length;e++)this.node.addEventListener(t[e],this.handler,!1)}return this},/**
     * Removes one or more native DOM event listeners from the underlying Element of this Game Object.
     *
     * @method Phaser.GameObjects.DOMElement#removeListener
     * @since 3.17.0
     *
     * @param {string} events - The DOM event/s to stop listening for. You can specify multiple events by separating them with spaces.
     * 
     * @return {this} This DOM Element instance.
     */removeListener:function(t){if(this.node){t=t.split(" ");for(var e=0;e<t.length;e++)this.node.removeEventListener(t[e],this.handler)}return this},/**
     * Internal event proxy to dispatch native DOM Events via this Game Object.
     *
     * @method Phaser.GameObjects.DOMElement#dispatchNativeEvent
     * @private
     * @since 3.17.0
     *
     * @param {any} event - The native DOM event.
     */dispatchNativeEvent:function(t){this.emit(t.type,t)},/**
     * Creates a native DOM Element, adds it to the parent DOM Container and then binds it to this Game Object,
     * so you can control it. The `tagName` should be a string and is passed to `document.createElement`:
     * 
     * ```javascript
     * this.add.dom().createElement('div');
     * ```
     * 
     * For more details on acceptable tag names see: https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
     * 
     * You can also pass in a DOMString or style object to set the CSS on the created element, and an optional `innerText`
     * value as well. Here is an example of a DOMString:
     * 
     * ```javascript
     * this.add.dom().createElement('div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');
     * ```
     * 
     * And using a style object:
     * 
     * ```javascript
     * var style = {
     *   'background-color': 'lime';
     *   'width': '200px';
     *   'height': '100px';
     *   'font': '48px Arial';
     * };
     * 
     * this.add.dom().createElement('div', style, 'Phaser');
     * ```
     * 
     * If this Game Object already has an Element, it is removed from the DOM entirely first.
     * Any event listeners you may have previously created will need to be re-created after this call.
     *
     * @method Phaser.GameObjects.DOMElement#createElement
     * @since 3.17.0
     *
     * @param {string} tagName - A string that specifies the type of element to be created. The nodeName of the created element is initialized with the value of tagName. Don't use qualified names (like "html:a") with this method.
     * @param {(string|any)} [style] - Either a DOMString that holds the CSS styles to be applied to the created element, or an object the styles will be ready from.
     * @param {string} [innerText] - A DOMString that holds the text that will be set as the innerText of the created element.
     * 
     * @return {this} This DOM Element instance.
     */createElement:function(t,e,i){return this.setElement(document.createElement(t),e,i)},/**
     * Binds a new DOM Element to this Game Object. If this Game Object already has an Element it is removed from the DOM
     * entirely first. Any event listeners you may have previously created will need to be re-created on the new element.
     * 
     * The `element` argument you pass to this method can be either a string tagName:
     * 
     * ```javascript
     * <h1 id="heading">Phaser</h1>
     *
     * this.add.dom().setElement('heading');
     * ```
     * 
     * Or a reference to an Element instance:
     * 
     * ```javascript
     * <h1 id="heading">Phaser</h1>
     *
     * var h1 = document.getElementById('heading');
     * 
     * this.add.dom().setElement(h1);
     * ```
     * 
     * You can also pass in a DOMString or style object to set the CSS on the created element, and an optional `innerText`
     * value as well. Here is an example of a DOMString:
     * 
     * ```javascript
     * this.add.dom().setElement(h1, 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');
     * ```
     * 
     * And using a style object:
     * 
     * ```javascript
     * var style = {
     *   'background-color': 'lime';
     *   'width': '200px';
     *   'height': '100px';
     *   'font': '48px Arial';
     * };
     * 
     * this.add.dom().setElement(h1, style, 'Phaser');
     * ```
     *
     * @method Phaser.GameObjects.DOMElement#setElement
     * @since 3.17.0
     *
     * @param {(string|Element)} element - If a string it is passed to `getElementById()`, or it should be a reference to an existing Element.
     * @param {(string|any)} [style] - Either a DOMString that holds the CSS styles to be applied to the created element, or an object the styles will be ready from.
     * @param {string} [innerText] - A DOMString that holds the text that will be set as the innerText of the created element.
     * 
     * @return {this} This DOM Element instance.
     */setElement:function(t,e,i){var n;if(//  Already got an element? Remove it first
this.removeElement(),"string"==typeof t?("#"===t[0]&&(t=t.substr(1)),n=document.getElementById(t)):"object"==typeof t&&1===t.nodeType&&(n=t),!n)return this;//  style can be empty, a string or a plain object
if(this.node=n,e&&a(e))for(var s in e)n.style[s]=e[s];else"string"==typeof e&&(n.style=e);return(//  Add / Override the values we need
n.style.zIndex="0",n.style.display="inline",n.style.position="absolute",//  Node handler
n.phaser=this,this.parent&&this.parent.appendChild(n),i&&(n.innerText=i),this.updateSize())},/**
     * Takes a block of html from the HTML Cache, that has previously been preloaded into the game, and then
     * creates a DOM Element from it. The loaded HTML is set as the `innerHTML` property of the created
     * element.
     * 
     * Assume the following html is stored in a file called `loginform.html`:
     * 
     * ```html
     * <input type="text" name="nameField" placeholder="Enter your name" style="font-size: 32px">
     * <input type="button" name="playButton" value="Let's Play" style="font-size: 32px">
     * ```
     * 
     * Which is loaded into your game using the cache key 'login':
     * 
     * ```javascript
     * this.load.html('login', 'assets/loginform.html');
     * ```
     * 
     * You can create a DOM Element from it using the cache key:
     * 
     * ```javascript
     * this.add.dom().createFromCache('login');
     * ```
     * 
     * The optional `elementType` argument controls the container that is created, into which the loaded html is inserted.
     * The default is a plain `div` object, but any valid tagName can be given.
     * 
     * If this Game Object already has an Element, it is removed from the DOM entirely first.
     * Any event listeners you may have previously created will need to be re-created after this call.
     *
     * @method Phaser.GameObjects.DOMElement#createFromCache
     * @since 3.17.0
     * 
     * @param {string} The key of the html cache entry to use for this DOM Element.
     * @param {string} [tagName='div'] - The tag name of the element into which all of the loaded html will be inserted. Defaults to a plain div tag.
     * 
     * @return {this} This DOM Element instance.
     */createFromCache:function(t,e){var i=this.cache.get(t);return i&&this.createFromHTML(i,e),this},/**
     * Takes a string of html and then creates a DOM Element from it. The HTML is set as the `innerHTML`
     * property of the created element.
     * 
     * ```javascript
     * let form = `
     * <input type="text" name="nameField" placeholder="Enter your name" style="font-size: 32px">
     * <input type="button" name="playButton" value="Let's Play" style="font-size: 32px">
     * `;
     * ```
     * 
     * You can create a DOM Element from it using the string:
     * 
     * ```javascript
     * this.add.dom().createFromHTML(form);
     * ```
     * 
     * The optional `elementType` argument controls the type of container that is created, into which the html is inserted.
     * The default is a plain `div` object, but any valid tagName can be given.
     * 
     * If this Game Object already has an Element, it is removed from the DOM entirely first.
     * Any event listeners you may have previously created will need to be re-created after this call.
     *
     * @method Phaser.GameObjects.DOMElement#createFromHTML
     * @since 3.17.0
     * 
     * @param {string} A string of html to be set as the `innerHTML` property of the created element.
     * @param {string} [tagName='div'] - The tag name of the element into which all of the html will be inserted. Defaults to a plain div tag.
     * 
     * @return {this} This DOM Element instance.
     */createFromHTML:function(t,e){void 0===e&&(e="div"),//  Already got an element? Remove it first
this.removeElement();var i=document.createElement(e);return this.node=i,i.style.zIndex="0",i.style.display="inline",i.style.position="absolute",//  Node handler
i.phaser=this,this.parent&&this.parent.appendChild(i),i.innerHTML=t,this.updateSize()},/**
     * Removes the current DOM Element bound to this Game Object from the DOM entirely and resets the
     * `node` property of this Game Object to be `null`.
     *
     * @method Phaser.GameObjects.DOMElement#removeElement
     * @since 3.17.0
     * 
     * @return {this} This DOM Element instance.
     */removeElement:function(){return this.node&&(h(this.node),this.node=null),this},/**
     * Internal method that calls `getBoundingClientRect` on the `node` and then sets the bounds width
     * and height into the `displayWidth` and `displayHeight` properties, and the `clientWidth` and `clientHeight`
     * values into the `width` and `height` properties respectively.
     * 
     * This is called automatically whenever a new element is created or set.
     *
     * @method Phaser.GameObjects.DOMElement#updateSize
     * @since 3.17.0
     * 
     * @return {this} This DOM Element instance.
     */updateSize:function(){var t=this.node,e=t.getBoundingClientRect();return this.width=t.clientWidth,this.height=t.clientHeight,this.displayWidth=e.width||0,this.displayHeight=e.height||0,this},/**
     * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through
     * them, looking for the first one that has a property matching the given key and value. It then returns this child
     * if found, or `null` if not.
     *
     * @method Phaser.GameObjects.DOMElement#getChildByProperty
     * @since 3.17.0
     * 
     * @param {string} property - The property to search the children for.
     * @param {string} value - The value the property must strictly equal.
     * 
     * @return {?Element} The first matching child DOM Element, or `null` if not found.
     */getChildByProperty:function(t,e){if(this.node){for(var i=this.node.querySelectorAll("*"),n=0;n<i.length;n++)if(i[n][t]===e)return i[n]}return null},/**
     * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through
     * them, looking for the first one that has a matching id. It then returns this child if found, or `null` if not.
     * 
     * Be aware that class and id names are case-sensitive.
     *
     * @method Phaser.GameObjects.DOMElement#getChildByID
     * @since 3.17.0
     * 
     * @param {string} id - The id to search the children for.
     * 
     * @return {?Element} The first matching child DOM Element, or `null` if not found.
     */getChildByID:function(t){return this.getChildByProperty("id",t)},/**
     * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through
     * them, looking for the first one that has a matching name. It then returns this child if found, or `null` if not.
     * 
     * Be aware that class and id names are case-sensitive.
     *
     * @method Phaser.GameObjects.DOMElement#getChildByName
     * @since 3.17.0
     * 
     * @param {string} name - The name to search the children for.
     * 
     * @return {?Element} The first matching child DOM Element, or `null` if not found.
     */getChildByName:function(t){return this.getChildByProperty("name",t)},/**
     * Sets the `className` property of the DOM Element node and updates the internal sizes.
     *
     * @method Phaser.GameObjects.DOMElement#setClassName
     * @since 3.17.0
     * 
     * @param {string} className - A string representing the class or space-separated classes of the element.
     * 
     * @return {this} This DOM Element instance.
     */setClassName:function(t){return this.node&&(this.node.className=t,this.updateSize()),this},/**
     * Sets the `innerText` property of the DOM Element node and updates the internal sizes.
     * 
     * Note that only certain types of Elements can have `innerText` set on them.
     *
     * @method Phaser.GameObjects.DOMElement#setText
     * @since 3.17.0
     * 
     * @param {string} text - A DOMString representing the rendered text content of the element.
     * 
     * @return {this} This DOM Element instance.
     */setText:function(t){return this.node&&(this.node.innerText=t,this.updateSize()),this},/**
     * Sets the `innerHTML` property of the DOM Element node and updates the internal sizes.
     *
     * @method Phaser.GameObjects.DOMElement#setHTML
     * @since 3.17.0
     * 
     * @param {string} html - A DOMString of html to be set as the `innerHTML` property of the element.
     * 
     * @return {this} This DOM Element instance.
     */setHTML:function(t){return this.node&&(this.node.innerHTML=t,this.updateSize()),this},/**
     * Runs internal update tasks.
     *
     * @method Phaser.GameObjects.DOMElement#preUpdate
     * @private
     * @since 3.17.0
     */preUpdate:function(){var t=this.parentContainer,e=this.node;e&&t&&!t.willRender()&&(e.style.display="none")},/**
     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.
     * 
     * DOMElements always return `true` as they need to still set values during the render pass, even if not visible.
     *
     * @method Phaser.GameObjects.DOMElement#willRender
     * @since 3.17.0
     *
     * @return {boolean} `true` if the Game Object should be rendered, otherwise `false`.
     */willRender:function(){return!0},/**
     * Handles the pre-destroy step for the DOM Element, which removes the underlying node from the DOM.
     *
     * @method Phaser.GameObjects.DOMElement#preDestroy
     * @private
     * @since 3.17.0
     */preDestroy:function(){this.removeElement(),this.scene.sys.events.off(l.SLEEP,this.handleSceneEvent,this),this.scene.sys.events.off(l.WAKE,this.handleSceneEvent,this)}});t.exports=c}),r("fDeAE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("eSiH4"),r=s("eSiH4"),t.exports={renderWebGL:n,renderCanvas:r}}),r("eSiH4",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jDJM3"),n=s("1zqlR");t.exports=function(t,e,s,r,o){var a=e.node,h=a.style,l=e.scene.sys.settings;if(!a||!h||!l.visible||n.RENDER_MASK!==e.renderFlags||0!==e.cameraFilter&&e.cameraFilter&r.id||e.parentContainer&&!e.parentContainer.willRender()){a&&(h.display="none");return}var u=e.parentContainer,c=r.alpha*e.alpha;u&&(c*=u.alpha);var d=t._tempMatrix1,f=t._tempMatrix2,p=t._tempMatrix3,g=0,v=0,m="0%",y="0%";o?(g=e.width*e.scaleX*e.originX,v=e.height*e.scaleY*e.originY,f.applyITRS(e.x-g,e.y-v,e.rotation,e.scaleX,e.scaleY),d.copyFrom(r.matrix),//  Multiply the camera by the parent matrix
d.multiplyWithOffset(o,-r.scrollX*e.scrollFactorX,-r.scrollY*e.scrollFactorY),//  Undo the camera scroll
f.e=e.x-g,f.f=e.y-v):(g=e.width*e.originX,v=e.height*e.originY,f.applyITRS(e.x-g,e.y-v,e.rotation,e.scaleX,e.scaleY),d.copyFrom(r.matrix),m=100*e.originX+"%",y=100*e.originY+"%",f.e-=r.scrollX*e.scrollFactorX,f.f-=r.scrollY*e.scrollFactorY),//  Multiply by the src matrix, store result in calcMatrix
d.multiply(f,p),e.transformOnly||(h.display="block",h.opacity=c,h.zIndex=e._depth,h.pointerEvents="auto",h.mixBlendMode=i[e._blendMode]),// https://developer.mozilla.org/en-US/docs/Web/CSS/transform
h.transform=p.getCSSMatrix()+" skew("+e.skewX+"rad, "+e.skewY+"rad) rotate3d("+e.rotate3d.x+","+e.rotate3d.y+","+e.rotate3d.z+","+e.rotate3d.w+e.rotate3dAngle+")",h.transformOrigin=m+" "+y}}),r("jDJM3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * Phaser Blend Modes to CSS Blend Modes Map.
 * 
 * @name Phaser.CSSBlendModes
 * @enum {string}
 * @memberof Phaser
 * @readonly
 * @since 3.12.0
 */t.exports=["normal","multiply","multiply","screen","overlay","darken","lighten","color-dodge","color-burn","hard-light","soft-light","difference","exclusion","hue","saturation","color","luminosity"]}),r("5soSO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gvPR8"),n=s("jwj1g"),r=s("hGpk3"),o=new n({Extends:i,Mixins:[r],initialize:function(t,e,n,s,r,o,a){i.call(this,t,e,n,s,r,o,a),this.type="DynamicBitmapText",/**
         * The horizontal scroll position of the Bitmap Text.
         *
         * @name Phaser.GameObjects.DynamicBitmapText#scrollX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.scrollX=0,/**
         * The vertical scroll position of the Bitmap Text.
         *
         * @name Phaser.GameObjects.DynamicBitmapText#scrollY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.scrollY=0,/**
         * The crop width of the Bitmap Text.
         *
         * @name Phaser.GameObjects.DynamicBitmapText#cropWidth
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.cropWidth=0,/**
         * The crop height of the Bitmap Text.
         *
         * @name Phaser.GameObjects.DynamicBitmapText#cropHeight
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.cropHeight=0,/**
         * A callback that alters how each character of the Bitmap Text is rendered.
         *
         * @name Phaser.GameObjects.DynamicBitmapText#displayCallback
         * @type {Phaser.Types.GameObjects.BitmapText.DisplayCallback}
         * @since 3.0.0
         */this.displayCallback,/**
         * The data object that is populated during rendering, then passed to the displayCallback.
         * You should modify this object then return it back from the callback. It's updated values
         * will be used to render the specific glyph.
         * 
         * Please note that if you need a reference to this object locally in your game code then you
         * should shallow copy it, as it's updated and re-used for every glyph in the text.
         *
         * @name Phaser.GameObjects.DynamicBitmapText#callbackData
         * @type {Phaser.Types.GameObjects.BitmapText.DisplayCallbackConfig}
         * @since 3.11.0
         */this.callbackData={parent:this,color:0,tint:{topLeft:0,topRight:0,bottomLeft:0,bottomRight:0},index:0,charCode:0,x:0,y:0,scale:0,rotation:0,data:0}},/**
     * Set the crop size of this Bitmap Text.
     *
     * @method Phaser.GameObjects.DynamicBitmapText#setSize
     * @since 3.0.0
     *
     * @param {number} width - The width of the crop.
     * @param {number} height - The height of the crop.
     *
     * @return {this} This Game Object.
     */setSize:function(t,e){return this.cropWidth=t,this.cropHeight=e,this},/**
     * Set a callback that alters how each character of the Bitmap Text is rendered.
     *
     * The callback receives a {@link Phaser.Types.GameObjects.BitmapText.DisplayCallbackConfig} object that contains information about the character that's
     * about to be rendered.
     *
     * It should return an object with `x`, `y`, `scale` and `rotation` properties that will be used instead of the
     * usual values when rendering.
     *
     * @method Phaser.GameObjects.DynamicBitmapText#setDisplayCallback
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.BitmapText.DisplayCallback} callback - The display callback to set.
     *
     * @return {this} This Game Object.
     */setDisplayCallback:function(t){return this.displayCallback=t,this},/**
     * Set the horizontal scroll position of this Bitmap Text.
     *
     * @method Phaser.GameObjects.DynamicBitmapText#setScrollX
     * @since 3.0.0
     *
     * @param {number} value - The horizontal scroll position to set.
     *
     * @return {this} This Game Object.
     */setScrollX:function(t){return this.scrollX=t,this},/**
     * Set the vertical scroll position of this Bitmap Text.
     *
     * @method Phaser.GameObjects.DynamicBitmapText#setScrollY
     * @since 3.0.0
     *
     * @param {number} value - The vertical scroll position to set.
     *
     * @return {this} This Game Object.
     */setScrollY:function(t){return this.scrollY=t,this}});t.exports=o}),r("hGpk3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("1lJvn"),r=s("bkoGq"),t.exports={renderWebGL:n,renderCanvas:r}}),r("1lJvn",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){var o,a,h=e.text,l=h.length;if(0!==l){var u=this.pipeline;t.setPipeline(u,e);var c=e.cropWidth>0||e.cropHeight>0;c&&(u.flush(),t.pushScissor(e.x,e.y,e.cropWidth*e.scaleX,e.cropHeight*e.scaleY));var d=u._tempMatrix1,f=u._tempMatrix2,p=u._tempMatrix3,g=u._tempMatrix4;f.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),d.copyFrom(s.matrix),r?(//  Multiply the camera by the parent matrix
d.multiplyWithOffset(r,-s.scrollX*e.scrollFactorX,-s.scrollY*e.scrollFactorY),//  Undo the camera scroll
f.e=e.x,f.f=e.y):(f.e-=s.scrollX*e.scrollFactorX,f.f-=s.scrollY*e.scrollFactorY),//  Multiply by the Sprite matrix, store result in calcMatrix
d.multiply(f,p);var v=e.frame,m=v.glTexture,y=v.cutX,x=v.cutY,w=m.width,T=m.height,b=e._isTinted&&e.tintFill,S=i.getTintAppendFloatAlpha(e._tintTL,s.alpha*e._alphaTL),A=i.getTintAppendFloatAlpha(e._tintTR,s.alpha*e._alphaTR),E=i.getTintAppendFloatAlpha(e._tintBL,s.alpha*e._alphaBL),_=i.getTintAppendFloatAlpha(e._tintBR,s.alpha*e._alphaBR);u.setTexture2D(m,0);var C=0,M=0,P=0,O=0,R=e.letterSpacing,L=0,k=0,D=0,F=0,I=e.scrollX,B=e.scrollY,N=e.fontData,Y=N.chars,z=N.lineHeight,j=e.fontSize/N.size,X=0,U=e._align,G=0,W=0;//  Update the bounds - skipped internally if not dirty
e.getTextBounds(!1);var V=e._bounds.lines;1===U?W=(V.longest-V.lengths[0])/2:2===U&&(W=V.longest-V.lengths[0]);for(var H=s.roundPixels,q=e.displayCallback,K=e.callbackData,Z=0;Z<l;Z++){//  Carriage-return
if(10===(P=h.charCodeAt(Z))){G++,1===U?W=(V.longest-V.lengths[G])/2:2===U&&(W=V.longest-V.lengths[G]),C=0,M+=z,a=null;continue}if(o=Y[P]){L=y+o.x,k=x+o.y,D=o.width,F=o.height;var Q=o.xOffset+C-I,J=o.yOffset+M-B;if(null!==a){var $=o.kerning[O];Q+=void 0!==$?$:0}//  Nothing to render or a space? Then skip to the next glyph
if(C+=o.xAdvance+R,a=o,O=P,0!==D&&0!==F&&32!==P){if(j=e.fontSize/e.fontData.size,X=0,q){K.color=0,K.tint.topLeft=S,K.tint.topRight=A,K.tint.bottomLeft=E,K.tint.bottomRight=_,K.index=Z,K.charCode=P,K.x=Q,K.y=J,K.scale=j,K.rotation=X,K.data=o.data;var tt=q(K);Q=tt.x,J=tt.y,j=tt.scale,X=tt.rotation,tt.color?(S=tt.color,A=tt.color,E=tt.color,_=tt.color):(S=tt.tint.topLeft,A=tt.tint.topRight,E=tt.tint.bottomLeft,_=tt.tint.bottomRight),S=i.getTintAppendFloatAlpha(S,s.alpha*e._alphaTL),A=i.getTintAppendFloatAlpha(A,s.alpha*e._alphaTR),E=i.getTintAppendFloatAlpha(E,s.alpha*e._alphaBL),_=i.getTintAppendFloatAlpha(_,s.alpha*e._alphaBR)}Q*=j,J*=j,Q-=e.displayOriginX,J-=e.displayOriginY,Q+=W,g.applyITRS(Q,J,X,j,j),p.multiply(g,f);var te=L/w,ti=k/T,tn=(L+D)/w,ts=(k+F)/T,tr=D,to=F,ta=f.e,th=f.f,tl=to*f.c+f.e,tu=to*f.d+f.f,tc=tr*f.a+to*f.c+f.e,td=tr*f.b+to*f.d+f.f,tf=tr*f.a+f.e,tp=tr*f.b+f.f;H&&(ta=Math.round(ta),th=Math.round(th),tl=Math.round(tl),tu=Math.round(tu),tc=Math.round(tc),td=Math.round(td),tf=Math.round(tf),tp=Math.round(tp)),u.batchQuad(ta,th,tl,tu,tc,td,tf,tp,te,ti,tn,ts,S,A,E,_,b,m,0)}}}c&&(u.flush(),t.popScissor())}}}),r("bkoGq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("csLaZ");t.exports=function(t,e,n,s,r){var o=e._text,a=o.length,h=t.currentContext;if(0!==a&&i(t,h,e,s,r)){var l=e.frame,u=e.displayCallback,c=e.callbackData,d=e.fontData.chars,f=e.fontData.lineHeight,p=e._letterSpacing,g=0,v=0,m=0,y=null,x=0,w=0,T=0,b=0,S=0,A=0,E=null,_=0,C=e.frame.source.image,M=l.cutX,P=l.cutY,O=0,R=0,L=e._fontSize/e.fontData.size,k=e._align,D=0,F=0;//  Update the bounds - skipped internally if not dirty
e.getTextBounds(!1);var I=e._bounds.lines;1===k?F=(I.longest-I.lengths[0])/2:2===k&&(F=I.longest-I.lengths[0]),h.translate(-e.displayOriginX,-e.displayOriginY);var B=s.roundPixels;e.cropWidth>0&&e.cropHeight>0&&(h.beginPath(),h.rect(0,0,e.cropWidth,e.cropHeight),h.clip());for(var N=0;N<a;N++){if(//  Reset the scale (in case the callback changed it)
R=L,O=0,10===(m=o.charCodeAt(N))){D++,1===k?F=(I.longest-I.lengths[D])/2:2===k&&(F=I.longest-I.lengths[D]),g=0,v+=f,E=null;continue}if(y=d[m]){if(x=M+y.x,w=P+y.y,T=y.width,b=y.height,S=y.xOffset+g-e.scrollX,A=y.yOffset+v-e.scrollY,null!==E){var Y=y.kerning[_];S+=void 0!==Y?Y:0}if(u){c.index=N,c.charCode=m,c.x=S,c.y=A,c.scale=R,c.rotation=O,c.data=y.data;var z=u(c);S=z.x,A=z.y,R=z.scale,O=z.rotation}S*=R,A*=R,S+=F,g+=y.xAdvance+p,E=y,_=m,0!==T&&0!==b&&32!==m&&(B&&(S=Math.round(S),A=Math.round(A)),h.save(),h.translate(S,A),h.rotate(O),h.scale(R,R),h.drawImage(C,x,w,T,b,0,0,T,b),h.restore())}}h.restore()}}}),r("9I9TZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("1zqlR"),o=s("iTi06"),a=new i({Extends:r,Mixins:[n.Alpha,n.BlendMode,n.Depth,n.Flip,n.Origin,n.ScrollFactor,n.Size,n.Texture,n.Tint,n.Transform,n.Visible,o],initialize:function(t){r.call(this,t,"Extern")},preUpdate:function(){//  override this!
//  Arguments: time, delta
},render:function(){//  override this!
//  Arguments: renderer, camera, calcMatrix
}});t.exports=a}),r("iTi06",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("jW8sW"),r=s("bf19D"),t.exports={renderWebGL:n,renderCanvas:r}}),r("jW8sW",function(t,e){t.exports=function(t,e,i,n,s){var r=t.currentPipeline;t.clearPipeline();var o=t._tempMatrix1,a=t._tempMatrix2,h=t._tempMatrix3;a.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),o.copyFrom(n.matrix),s?(//  Multiply the camera by the parent matrix
o.multiplyWithOffset(s,-n.scrollX*e.scrollFactorX,-n.scrollY*e.scrollFactorY),//  Undo the camera scroll
a.e=e.x,a.f=e.y):(a.e-=n.scrollX*e.scrollFactorX,a.f-=n.scrollY*e.scrollFactorY),//  Multiply by the Sprite matrix, store result in calcMatrix
o.multiply(a,h),//  Callback
e.render.call(e,t,n,h),t.rebindPipeline(r)}}),r("bf19D",function(t,e){}),r("2Irqj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2LSzx"),n=s("jwj1g"),r=s("dRykN"),o=s("gRRWm"),a=s("2UeGA"),h=s("1CJAb"),l=s("42G5m"),u=s("DznIZ"),c=s("i5mxL"),d=s("fVg1f"),f=s("hKiq1"),p=s("azs1m"),g=s("eaZcG"),v=s("1zqlR"),m=s("7BSWl"),y=s("5pMDk"),x=s("bNtDi"),w=s("fdwDj"),T=new n({Extends:v,Mixins:[o,a,h,l,u,c,d,f,w],initialize:function(t,e){var i=y(e,"x",0),n=y(e,"y",0);v.call(this,t,"Graphics"),this.setPosition(i,n),this.initPipeline(),/**
         * The horizontal display origin of the Graphics.
         *
         * @name Phaser.GameObjects.Graphics#displayOriginX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.displayOriginX=0,/**
         * The vertical display origin of the Graphics.
         *
         * @name Phaser.GameObjects.Graphics#displayOriginY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.displayOriginY=0,/**
         * The array of commands used to render the Graphics.
         *
         * @name Phaser.GameObjects.Graphics#commandBuffer
         * @type {array}
         * @default []
         * @since 3.0.0
         */this.commandBuffer=[],/**
         * The default fill color for shapes rendered by this Graphics object.
         *
         * @name Phaser.GameObjects.Graphics#defaultFillColor
         * @type {number}
         * @default -1
         * @since 3.0.0
         */this.defaultFillColor=-1,/**
         * The default fill alpha for shapes rendered by this Graphics object.
         *
         * @name Phaser.GameObjects.Graphics#defaultFillAlpha
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.defaultFillAlpha=1,/**
         * The default stroke width for shapes rendered by this Graphics object.
         *
         * @name Phaser.GameObjects.Graphics#defaultStrokeWidth
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.defaultStrokeWidth=1,/**
         * The default stroke color for shapes rendered by this Graphics object.
         *
         * @name Phaser.GameObjects.Graphics#defaultStrokeColor
         * @type {number}
         * @default -1
         * @since 3.0.0
         */this.defaultStrokeColor=-1,/**
         * The default stroke alpha for shapes rendered by this Graphics object.
         *
         * @name Phaser.GameObjects.Graphics#defaultStrokeAlpha
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.defaultStrokeAlpha=1,/**
         * Internal property that keeps track of the line width style setting.
         *
         * @name Phaser.GameObjects.Graphics#_lineWidth
         * @type {number}
         * @private
         * @since 3.0.0
         */this._lineWidth=1,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.GameObjects.Graphics#_tempMatrix1
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.17.0
         */this._tempMatrix1=new p,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.GameObjects.Graphics#_tempMatrix2
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.17.0
         */this._tempMatrix2=new p,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.GameObjects.Graphics#_tempMatrix3
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.17.0
         */this._tempMatrix3=new p,this.setDefaultStyles(e)},/**
     * Set the default style settings for this Graphics object.
     *
     * @method Phaser.GameObjects.Graphics#setDefaultStyles
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Graphics.Styles} options - The styles to set as defaults.
     *
     * @return {this} This Game Object.
     */setDefaultStyles:function(t){return y(t,"lineStyle",null)&&(this.defaultStrokeWidth=y(t,"lineStyle.width",1),this.defaultStrokeColor=y(t,"lineStyle.color",16777215),this.defaultStrokeAlpha=y(t,"lineStyle.alpha",1),this.lineStyle(this.defaultStrokeWidth,this.defaultStrokeColor,this.defaultStrokeAlpha)),y(t,"fillStyle",null)&&(this.defaultFillColor=y(t,"fillStyle.color",16777215),this.defaultFillAlpha=y(t,"fillStyle.alpha",1),this.fillStyle(this.defaultFillColor,this.defaultFillAlpha)),this},/**
     * Set the current line style.
     *
     * @method Phaser.GameObjects.Graphics#lineStyle
     * @since 3.0.0
     *
     * @param {number} lineWidth - The stroke width.
     * @param {number} color - The stroke color.
     * @param {number} [alpha=1] - The stroke alpha.
     *
     * @return {this} This Game Object.
     */lineStyle:function(t,e,i){return void 0===i&&(i=1),this.commandBuffer.push(r.LINE_STYLE,t,e,i),this._lineWidth=t,this},/**
     * Set the current fill style.
     *
     * @method Phaser.GameObjects.Graphics#fillStyle
     * @since 3.0.0
     *
     * @param {number} color - The fill color.
     * @param {number} [alpha=1] - The fill alpha.
     *
     * @return {this} This Game Object.
     */fillStyle:function(t,e){return void 0===e&&(e=1),this.commandBuffer.push(r.FILL_STYLE,t,e),this},/**
     * Sets a gradient fill style. This is a WebGL only feature.
     *
     * The gradient color values represent the 4 corners of an untransformed rectangle.
     * The gradient is used to color all filled shapes and paths drawn after calling this method.
     * If you wish to turn a gradient off, call `fillStyle` and provide a new single fill color.
     *
     * When filling a triangle only the first 3 color values provided are used for the 3 points of a triangle.
     *
     * This feature is best used only on rectangles and triangles. All other shapes will give strange results.
     *
     * Note that for objects such as arcs or ellipses, or anything which is made out of triangles, each triangle used
     * will be filled with a gradient on its own. There is no ability to gradient fill a shape or path as a single
     * entity at this time.
     *
     * @method Phaser.GameObjects.Graphics#fillGradientStyle
     * @webglOnly
     * @since 3.12.0
     *
     * @param {integer} topLeft - The tint being applied to the top-left of the Game Object.
     * @param {integer} topRight - The tint being applied to the top-right of the Game Object.
     * @param {integer} bottomLeft - The tint being applied to the bottom-left of the Game Object.
     * @param {integer} bottomRight - The tint being applied to the bottom-right of the Game Object.
     * @param {number} [alpha=1] - The fill alpha.
     *
     * @return {this} This Game Object.
     */fillGradientStyle:function(t,e,i,n,s){return void 0===s&&(s=1),this.commandBuffer.push(r.GRADIENT_FILL_STYLE,s,t,e,i,n),this},/**
     * Sets a gradient line style. This is a WebGL only feature.
     *
     * The gradient color values represent the 4 corners of an untransformed rectangle.
     * The gradient is used to color all stroked shapes and paths drawn after calling this method.
     * If you wish to turn a gradient off, call `lineStyle` and provide a new single line color.
     *
     * This feature is best used only on single lines. All other shapes will give strange results.
     *
     * Note that for objects such as arcs or ellipses, or anything which is made out of triangles, each triangle used
     * will be filled with a gradient on its own. There is no ability to gradient stroke a shape or path as a single
     * entity at this time.
     *
     * @method Phaser.GameObjects.Graphics#lineGradientStyle
     * @webglOnly
     * @since 3.12.0
     *
     * @param {number} lineWidth - The stroke width.
     * @param {integer} topLeft - The tint being applied to the top-left of the Game Object.
     * @param {integer} topRight - The tint being applied to the top-right of the Game Object.
     * @param {integer} bottomLeft - The tint being applied to the bottom-left of the Game Object.
     * @param {integer} bottomRight - The tint being applied to the bottom-right of the Game Object.
     * @param {number} [alpha=1] - The fill alpha.
     *
     * @return {this} This Game Object.
     */lineGradientStyle:function(t,e,i,n,s,o){return void 0===o&&(o=1),this.commandBuffer.push(r.GRADIENT_LINE_STYLE,t,o,e,i,n,s),this},/**
     * Sets the texture frame this Graphics Object will use when drawing all shapes defined after calling this.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     *
     * Once set, all shapes will use this texture. Call this method with no arguments to clear it.
     *
     * The textures are not tiled. They are stretched to the dimensions of the shapes being rendered. For this reason,
     * it works best with seamless / tileable textures.
     *
     * The mode argument controls how the textures are combined with the fill colors. The default value (0) will
     * multiply the texture by the fill color. A value of 1 will use just the fill color, but the alpha data from the texture,
     * and a value of 2 will use just the texture and no fill color at all.
     *
     * @method Phaser.GameObjects.Graphics#setTexture
     * @since 3.12.0
     * @webglOnly
     *
     * @param {string} [key] - The key of the texture to be used, as stored in the Texture Manager. Leave blank to clear a previously set texture.
     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.
     * @param {number} [mode=0] - The texture tint mode. 0 is multiply, 1 is alpha only and 2 is texture only.
     *
     * @return {this} This Game Object.
     */setTexture:function(t,e,i){if(void 0===i&&(i=0),void 0===t)this.commandBuffer.push(r.CLEAR_TEXTURE);else{var n=this.scene.sys.textures.getFrame(t,e);n&&(2===i&&(i=3),this.commandBuffer.push(r.SET_TEXTURE,n,i))}return this},/**
     * Start a new shape path.
     *
     * @method Phaser.GameObjects.Graphics#beginPath
     * @since 3.0.0
     *
     * @return {this} This Game Object.
     */beginPath:function(){return this.commandBuffer.push(r.BEGIN_PATH),this},/**
     * Close the current path.
     *
     * @method Phaser.GameObjects.Graphics#closePath
     * @since 3.0.0
     *
     * @return {this} This Game Object.
     */closePath:function(){return this.commandBuffer.push(r.CLOSE_PATH),this},/**
     * Fill the current path.
     *
     * @method Phaser.GameObjects.Graphics#fillPath
     * @since 3.0.0
     *
     * @return {this} This Game Object.
     */fillPath:function(){return this.commandBuffer.push(r.FILL_PATH),this},/**
     * Fill the current path.
     * 
     * This is an alias for `Graphics.fillPath` and does the same thing.
     * It was added to match the CanvasRenderingContext 2D API.
     *
     * @method Phaser.GameObjects.Graphics#fill
     * @since 3.16.0
     *
     * @return {this} This Game Object.
     */fill:function(){return this.commandBuffer.push(r.FILL_PATH),this},/**
     * Stroke the current path.
     *
     * @method Phaser.GameObjects.Graphics#strokePath
     * @since 3.0.0
     *
     * @return {this} This Game Object.
     */strokePath:function(){return this.commandBuffer.push(r.STROKE_PATH),this},/**
     * Stroke the current path.
     * 
     * This is an alias for `Graphics.strokePath` and does the same thing.
     * It was added to match the CanvasRenderingContext 2D API.
     *
     * @method Phaser.GameObjects.Graphics#stroke
     * @since 3.16.0
     *
     * @return {this} This Game Object.
     */stroke:function(){return this.commandBuffer.push(r.STROKE_PATH),this},/**
     * Fill the given circle.
     *
     * @method Phaser.GameObjects.Graphics#fillCircleShape
     * @since 3.0.0
     *
     * @param {Phaser.Geom.Circle} circle - The circle to fill.
     *
     * @return {this} This Game Object.
     */fillCircleShape:function(t){return this.fillCircle(t.x,t.y,t.radius)},/**
     * Stroke the given circle.
     *
     * @method Phaser.GameObjects.Graphics#strokeCircleShape
     * @since 3.0.0
     *
     * @param {Phaser.Geom.Circle} circle - The circle to stroke.
     *
     * @return {this} This Game Object.
     */strokeCircleShape:function(t){return this.strokeCircle(t.x,t.y,t.radius)},/**
     * Fill a circle with the given position and radius.
     *
     * @method Phaser.GameObjects.Graphics#fillCircle
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate of the center of the circle.
     * @param {number} y - The y coordinate of the center of the circle.
     * @param {number} radius - The radius of the circle.
     *
     * @return {this} This Game Object.
     */fillCircle:function(t,e,i){return this.beginPath(),this.arc(t,e,i,0,x.PI2),this.fillPath(),this},/**
     * Stroke a circle with the given position and radius.
     *
     * @method Phaser.GameObjects.Graphics#strokeCircle
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate of the center of the circle.
     * @param {number} y - The y coordinate of the center of the circle.
     * @param {number} radius - The radius of the circle.
     *
     * @return {this} This Game Object.
     */strokeCircle:function(t,e,i){return this.beginPath(),this.arc(t,e,i,0,x.PI2),this.strokePath(),this},/**
     * Fill the given rectangle.
     *
     * @method Phaser.GameObjects.Graphics#fillRectShape
     * @since 3.0.0
     *
     * @param {Phaser.Geom.Rectangle} rect - The rectangle to fill.
     *
     * @return {this} This Game Object.
     */fillRectShape:function(t){return this.fillRect(t.x,t.y,t.width,t.height)},/**
     * Stroke the given rectangle.
     *
     * @method Phaser.GameObjects.Graphics#strokeRectShape
     * @since 3.0.0
     *
     * @param {Phaser.Geom.Rectangle} rect - The rectangle to stroke.
     *
     * @return {this} This Game Object.
     */strokeRectShape:function(t){return this.strokeRect(t.x,t.y,t.width,t.height)},/**
     * Fill a rectangle with the given position and size.
     *
     * @method Phaser.GameObjects.Graphics#fillRect
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate of the top-left of the rectangle.
     * @param {number} y - The y coordinate of the top-left of the rectangle.
     * @param {number} width - The width of the rectangle.
     * @param {number} height - The height of the rectangle.
     *
     * @return {this} This Game Object.
     */fillRect:function(t,e,i,n){return this.commandBuffer.push(r.FILL_RECT,t,e,i,n),this},/**
     * Stroke a rectangle with the given position and size.
     *
     * @method Phaser.GameObjects.Graphics#strokeRect
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate of the top-left of the rectangle.
     * @param {number} y - The y coordinate of the top-left of the rectangle.
     * @param {number} width - The width of the rectangle.
     * @param {number} height - The height of the rectangle.
     *
     * @return {this} This Game Object.
     */strokeRect:function(t,e,i,n){var s=this._lineWidth/2,r=t-s,o=t+s;return this.beginPath(),this.moveTo(t,e),this.lineTo(t,e+n),this.strokePath(),this.beginPath(),this.moveTo(t+i,e),this.lineTo(t+i,e+n),this.strokePath(),this.beginPath(),this.moveTo(r,e),this.lineTo(o+i,e),this.strokePath(),this.beginPath(),this.moveTo(r,e+n),this.lineTo(o+i,e+n),this.strokePath(),this},/**
     * Fill a rounded rectangle with the given position, size and radius.
     *
     * @method Phaser.GameObjects.Graphics#fillRoundedRect
     * @since 3.11.0
     *
     * @param {number} x - The x coordinate of the top-left of the rectangle.
     * @param {number} y - The y coordinate of the top-left of the rectangle.
     * @param {number} width - The width of the rectangle.
     * @param {number} height - The height of the rectangle.
     * @param {(Phaser.Types.GameObjects.Graphics.RoundedRectRadius|number)} [radius=20] - The corner radius; It can also be an object to specify different radii for corners.
     *
     * @return {this} This Game Object.
     */fillRoundedRect:function(t,e,i,n,s){void 0===s&&(s=20);var r=s,o=s,a=s,h=s;return"number"!=typeof s&&(r=m(s,"tl",20),o=m(s,"tr",20),a=m(s,"bl",20),h=m(s,"br",20)),this.beginPath(),this.moveTo(t+r,e),this.lineTo(t+i-o,e),this.arc(t+i-o,e+o,o,-x.TAU,0),this.lineTo(t+i,e+n-h),this.arc(t+i-h,e+n-h,h,0,x.TAU),this.lineTo(t+a,e+n),this.arc(t+a,e+n-a,a,x.TAU,Math.PI),this.lineTo(t,e+r),this.arc(t+r,e+r,r,-Math.PI,-x.TAU),this.fillPath(),this},/**
     * Stroke a rounded rectangle with the given position, size and radius.
     *
     * @method Phaser.GameObjects.Graphics#strokeRoundedRect
     * @since 3.11.0
     *
     * @param {number} x - The x coordinate of the top-left of the rectangle.
     * @param {number} y - The y coordinate of the top-left of the rectangle.
     * @param {number} width - The width of the rectangle.
     * @param {number} height - The height of the rectangle.
     * @param {(Phaser.Types.GameObjects.Graphics.RoundedRectRadius|number)} [radius=20] - The corner radius; It can also be an object to specify different radii for corners.
     *
     * @return {this} This Game Object.
     */strokeRoundedRect:function(t,e,i,n,s){void 0===s&&(s=20);var r=s,o=s,a=s,h=s;return"number"!=typeof s&&(r=m(s,"tl",20),o=m(s,"tr",20),a=m(s,"bl",20),h=m(s,"br",20)),this.beginPath(),this.moveTo(t+r,e),this.lineTo(t+i-o,e),this.arc(t+i-o,e+o,o,-x.TAU,0),this.lineTo(t+i,e+n-h),this.arc(t+i-h,e+n-h,h,0,x.TAU),this.lineTo(t+a,e+n),this.arc(t+a,e+n-a,a,x.TAU,Math.PI),this.lineTo(t,e+r),this.arc(t+r,e+r,r,-Math.PI,-x.TAU),this.strokePath(),this},/**
     * Fill the given point.
     *
     * Draws a square at the given position, 1 pixel in size by default.
     *
     * @method Phaser.GameObjects.Graphics#fillPointShape
     * @since 3.0.0
     *
     * @param {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} point - The point to fill.
     * @param {number} [size=1] - The size of the square to draw.
     *
     * @return {this} This Game Object.
     */fillPointShape:function(t,e){return this.fillPoint(t.x,t.y,e)},/**
     * Fill a point at the given position.
     *
     * Draws a square at the given position, 1 pixel in size by default.
     *
     * @method Phaser.GameObjects.Graphics#fillPoint
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate of the point.
     * @param {number} y - The y coordinate of the point.
     * @param {number} [size=1] - The size of the square to draw.
     *
     * @return {this} This Game Object.
     */fillPoint:function(t,e,i){return!i||i<1?i=1:(t-=i/2,e-=i/2),this.commandBuffer.push(r.FILL_RECT,t,e,i,i),this},/**
     * Fill the given triangle.
     *
     * @method Phaser.GameObjects.Graphics#fillTriangleShape
     * @since 3.0.0
     *
     * @param {Phaser.Geom.Triangle} triangle - The triangle to fill.
     *
     * @return {this} This Game Object.
     */fillTriangleShape:function(t){return this.fillTriangle(t.x1,t.y1,t.x2,t.y2,t.x3,t.y3)},/**
     * Stroke the given triangle.
     *
     * @method Phaser.GameObjects.Graphics#strokeTriangleShape
     * @since 3.0.0
     *
     * @param {Phaser.Geom.Triangle} triangle - The triangle to stroke.
     *
     * @return {this} This Game Object.
     */strokeTriangleShape:function(t){return this.strokeTriangle(t.x1,t.y1,t.x2,t.y2,t.x3,t.y3)},/**
     * Fill a triangle with the given points.
     *
     * @method Phaser.GameObjects.Graphics#fillTriangle
     * @since 3.0.0
     *
     * @param {number} x0 - The x coordinate of the first point.
     * @param {number} y0 - The y coordinate of the first point.
     * @param {number} x1 - The x coordinate of the second point.
     * @param {number} y1 - The y coordinate of the second point.
     * @param {number} x2 - The x coordinate of the third point.
     * @param {number} y2 - The y coordinate of the third point.
     *
     * @return {this} This Game Object.
     */fillTriangle:function(t,e,i,n,s,o){return this.commandBuffer.push(r.FILL_TRIANGLE,t,e,i,n,s,o),this},/**
     * Stroke a triangle with the given points.
     *
     * @method Phaser.GameObjects.Graphics#strokeTriangle
     * @since 3.0.0
     *
     * @param {number} x0 - The x coordinate of the first point.
     * @param {number} y0 - The y coordinate of the first point.
     * @param {number} x1 - The x coordinate of the second point.
     * @param {number} y1 - The y coordinate of the second point.
     * @param {number} x2 - The x coordinate of the third point.
     * @param {number} y2 - The y coordinate of the third point.
     *
     * @return {this} This Game Object.
     */strokeTriangle:function(t,e,i,n,s,o){return this.commandBuffer.push(r.STROKE_TRIANGLE,t,e,i,n,s,o),this},/**
     * Draw the given line.
     *
     * @method Phaser.GameObjects.Graphics#strokeLineShape
     * @since 3.0.0
     *
     * @param {Phaser.Geom.Line} line - The line to stroke.
     *
     * @return {this} This Game Object.
     */strokeLineShape:function(t){return this.lineBetween(t.x1,t.y1,t.x2,t.y2)},/**
     * Draw a line between the given points.
     *
     * @method Phaser.GameObjects.Graphics#lineBetween
     * @since 3.0.0
     *
     * @param {number} x1 - The x coordinate of the start point of the line.
     * @param {number} y1 - The y coordinate of the start point of the line.
     * @param {number} x2 - The x coordinate of the end point of the line.
     * @param {number} y2 - The y coordinate of the end point of the line.
     *
     * @return {this} This Game Object.
     */lineBetween:function(t,e,i,n){return this.beginPath(),this.moveTo(t,e),this.lineTo(i,n),this.strokePath(),this},/**
     * Draw a line from the current drawing position to the given position.
     *
     * Moves the current drawing position to the given position.
     *
     * @method Phaser.GameObjects.Graphics#lineTo
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate to draw the line to.
     * @param {number} y - The y coordinate to draw the line to.
     *
     * @return {this} This Game Object.
     */lineTo:function(t,e){return this.commandBuffer.push(r.LINE_TO,t,e),this},/**
     * Move the current drawing position to the given position.
     *
     * @method Phaser.GameObjects.Graphics#moveTo
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate to move to.
     * @param {number} y - The y coordinate to move to.
     *
     * @return {this} This Game Object.
     */moveTo:function(t,e){return this.commandBuffer.push(r.MOVE_TO,t,e),this},/**
     * Stroke the shape represented by the given array of points.
     *
     * Pass `closeShape` to automatically close the shape by joining the last to the first point.
     * 
     * Pass `closePath` to automatically close the path before it is stroked.
     *
     * @method Phaser.GameObjects.Graphics#strokePoints
     * @since 3.0.0
     *
     * @param {(array|Phaser.Geom.Point[])} points - The points to stroke.
     * @param {boolean} [closeShape=false] - When `true`, the shape is closed by joining the last point to the first point.
     * @param {boolean} [closePath=false] - When `true`, the path is closed before being stroked.
     * @param {integer} [endIndex] - The index of `points` to stop drawing at. Defaults to `points.length`.
     *
     * @return {this} This Game Object.
     */strokePoints:function(t,e,i,n){void 0===e&&(e=!1),void 0===i&&(i=!1),void 0===n&&(n=t.length),this.beginPath(),this.moveTo(t[0].x,t[0].y);for(var s=1;s<n;s++)this.lineTo(t[s].x,t[s].y);return e&&this.lineTo(t[0].x,t[0].y),i&&this.closePath(),this.strokePath(),this},/**
     * Fill the shape represented by the given array of points.
     *
     * Pass `closeShape` to automatically close the shape by joining the last to the first point.
     * 
     * Pass `closePath` to automatically close the path before it is filled.
     *
     * @method Phaser.GameObjects.Graphics#fillPoints
     * @since 3.0.0
     *
     * @param {(array|Phaser.Geom.Point[])} points - The points to fill.
     * @param {boolean} [closeShape=false] - When `true`, the shape is closed by joining the last point to the first point.
     * @param {boolean} [closePath=false] - When `true`, the path is closed before being stroked.
     * @param {integer} [endIndex] - The index of `points` to stop at. Defaults to `points.length`.
     *
     * @return {this} This Game Object.
     */fillPoints:function(t,e,i,n){void 0===e&&(e=!1),void 0===i&&(i=!1),void 0===n&&(n=t.length),this.beginPath(),this.moveTo(t[0].x,t[0].y);for(var s=1;s<n;s++)this.lineTo(t[s].x,t[s].y);return e&&this.lineTo(t[0].x,t[0].y),i&&this.closePath(),this.fillPath(),this},/**
     * Stroke the given ellipse.
     *
     * @method Phaser.GameObjects.Graphics#strokeEllipseShape
     * @since 3.0.0
     *
     * @param {Phaser.Geom.Ellipse} ellipse - The ellipse to stroke.
     * @param {integer} [smoothness=32] - The number of points to draw the ellipse with.
     *
     * @return {this} This Game Object.
     */strokeEllipseShape:function(t,e){void 0===e&&(e=32);var i=t.getPoints(e);return this.strokePoints(i,!0)},/**
     * Stroke an ellipse with the given position and size.
     *
     * @method Phaser.GameObjects.Graphics#strokeEllipse
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate of the center of the ellipse.
     * @param {number} y - The y coordinate of the center of the ellipse.
     * @param {number} width - The width of the ellipse.
     * @param {number} height - The height of the ellipse.
     * @param {integer} [smoothness=32] - The number of points to draw the ellipse with.
     *
     * @return {this} This Game Object.
     */strokeEllipse:function(t,e,i,n,s){void 0===s&&(s=32);var r=new g(t,e,i,n).getPoints(s);return this.strokePoints(r,!0)},/**
     * Fill the given ellipse.
     *
     * @method Phaser.GameObjects.Graphics#fillEllipseShape
     * @since 3.0.0
     *
     * @param {Phaser.Geom.Ellipse} ellipse - The ellipse to fill.
     * @param {integer} [smoothness=32] - The number of points to draw the ellipse with.
     *
     * @return {this} This Game Object.
     */fillEllipseShape:function(t,e){void 0===e&&(e=32);var i=t.getPoints(e);return this.fillPoints(i,!0)},/**
     * Fill an ellipse with the given position and size.
     *
     * @method Phaser.GameObjects.Graphics#fillEllipse
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate of the center of the ellipse.
     * @param {number} y - The y coordinate of the center of the ellipse.
     * @param {number} width - The width of the ellipse.
     * @param {number} height - The height of the ellipse.
     * @param {integer} [smoothness=32] - The number of points to draw the ellipse with.
     *
     * @return {this} This Game Object.
     */fillEllipse:function(t,e,i,n,s){void 0===s&&(s=32);var r=new g(t,e,i,n).getPoints(s);return this.fillPoints(r,!0)},/**
     * Draw an arc.
     *
     * This method can be used to create circles, or parts of circles.
     * 
     * Make sure you call `beginPath` before starting the arc unless you wish for the arc to automatically
     * close when filled or stroked.
     *
     * Use the optional `overshoot` argument increase the number of iterations that take place when
     * the arc is rendered in WebGL. This is useful if you're drawing an arc with an especially thick line,
     * as it will allow the arc to fully join-up. Try small values at first, i.e. 0.01.
     *
     * Call {@link Phaser.GameObjects.Graphics#fillPath} or {@link Phaser.GameObjects.Graphics#strokePath} after calling
     * this method to draw the arc.
     *
     * @method Phaser.GameObjects.Graphics#arc
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate of the center of the circle.
     * @param {number} y - The y coordinate of the center of the circle.
     * @param {number} radius - The radius of the circle.
     * @param {number} startAngle - The starting angle, in radians.
     * @param {number} endAngle - The ending angle, in radians.
     * @param {boolean} [anticlockwise=false] - Whether the drawing should be anticlockwise or clockwise.
     * @param {number} [overshoot=0] - This value allows you to increase the segment iterations in WebGL rendering. Useful if the arc has a thick stroke and needs to overshoot to join-up cleanly. Use small numbers such as 0.01 to start with and increase as needed.
     *
     * @return {this} This Game Object.
     */arc:function(t,e,i,n,s,o,a){return void 0===o&&(o=!1),void 0===a&&(a=0),this.commandBuffer.push(r.ARC,t,e,i,n,s,o,a),this},/**
     * Creates a pie-chart slice shape centered at `x`, `y` with the given radius.
     * You must define the start and end angle of the slice.
     *
     * Setting the `anticlockwise` argument to `true` creates a shape similar to Pacman.
     * Setting it to `false` creates a shape like a slice of pie.
     *
     * This method will begin a new path and close the path at the end of it.
     * To display the actual slice you need to call either `strokePath` or `fillPath` after it.
     *
     * @method Phaser.GameObjects.Graphics#slice
     * @since 3.4.0
     *
     * @param {number} x - The horizontal center of the slice.
     * @param {number} y - The vertical center of the slice.
     * @param {number} radius - The radius of the slice.
     * @param {number} startAngle - The start angle of the slice, given in radians.
     * @param {number} endAngle - The end angle of the slice, given in radians.
     * @param {boolean} [anticlockwise=false] - Whether the drawing should be anticlockwise or clockwise.
     * @param {number} [overshoot=0] - This value allows you to overshoot the endAngle by this amount. Useful if the arc has a thick stroke and needs to overshoot to join-up cleanly.
     *
     * @return {this} This Game Object.
     */slice:function(t,e,i,n,s,o,a){return void 0===o&&(o=!1),void 0===a&&(a=0),this.commandBuffer.push(r.BEGIN_PATH),this.commandBuffer.push(r.MOVE_TO,t,e),this.commandBuffer.push(r.ARC,t,e,i,n,s,o,a),this.commandBuffer.push(r.CLOSE_PATH),this},/**
     * Saves the state of the Graphics by pushing the current state onto a stack.
     *
     * The most recently saved state can then be restored with {@link Phaser.GameObjects.Graphics#restore}.
     *
     * @method Phaser.GameObjects.Graphics#save
     * @since 3.0.0
     *
     * @return {this} This Game Object.
     */save:function(){return this.commandBuffer.push(r.SAVE),this},/**
     * Restores the most recently saved state of the Graphics by popping from the state stack.
     *
     * Use {@link Phaser.GameObjects.Graphics#save} to save the current state, and call this afterwards to restore that state.
     *
     * If there is no saved state, this command does nothing.
     *
     * @method Phaser.GameObjects.Graphics#restore
     * @since 3.0.0
     *
     * @return {this} This Game Object.
     */restore:function(){return this.commandBuffer.push(r.RESTORE),this},/**
     * Inserts a translation command into this Graphics objects command buffer.
     * 
     * All objects drawn _after_ calling this method will be translated
     * by the given amount.
     * 
     * This does not change the position of the Graphics object itself,
     * only of the objects drawn by it after calling this method.
     *
     * @method Phaser.GameObjects.Graphics#translateCanvas
     * @since 3.0.0
     *
     * @param {number} x - The horizontal translation to apply.
     * @param {number} y - The vertical translation to apply.
     *
     * @return {this} This Game Object.
     */translateCanvas:function(t,e){return this.commandBuffer.push(r.TRANSLATE,t,e),this},/**
     * Inserts a scale command into this Graphics objects command buffer.
     * 
     * All objects drawn _after_ calling this method will be scaled
     * by the given amount.
     * 
     * This does not change the scale of the Graphics object itself,
     * only of the objects drawn by it after calling this method.
     *
     * @method Phaser.GameObjects.Graphics#scaleCanvas
     * @since 3.0.0
     *
     * @param {number} x - The horizontal scale to apply.
     * @param {number} y - The vertical scale to apply.
     *
     * @return {this} This Game Object.
     */scaleCanvas:function(t,e){return this.commandBuffer.push(r.SCALE,t,e),this},/**
     * Inserts a rotation command into this Graphics objects command buffer.
     * 
     * All objects drawn _after_ calling this method will be rotated
     * by the given amount.
     * 
     * This does not change the rotation of the Graphics object itself,
     * only of the objects drawn by it after calling this method.
     *
     * @method Phaser.GameObjects.Graphics#rotateCanvas
     * @since 3.0.0
     *
     * @param {number} radians - The rotation angle, in radians.
     *
     * @return {this} This Game Object.
     */rotateCanvas:function(t){return this.commandBuffer.push(r.ROTATE,t),this},/**
     * Clear the command buffer and reset the fill style and line style to their defaults.
     *
     * @method Phaser.GameObjects.Graphics#clear
     * @since 3.0.0
     *
     * @return {this} This Game Object.
     */clear:function(){return this.commandBuffer.length=0,this.defaultFillColor>-1&&this.fillStyle(this.defaultFillColor,this.defaultFillAlpha),this.defaultStrokeColor>-1&&this.lineStyle(this.defaultStrokeWidth,this.defaultStrokeColor,this.defaultStrokeAlpha),this},/**
     * Generate a texture from this Graphics object.
     *
     * If `key` is a string it'll generate a new texture using it and add it into the
     * Texture Manager (assuming no key conflict happens).
     *
     * If `key` is a Canvas it will draw the texture to that canvas context. Note that it will NOT
     * automatically upload it to the GPU in WebGL mode.
     *
     * @method Phaser.GameObjects.Graphics#generateTexture
     * @since 3.0.0
     *
     * @param {(string|HTMLCanvasElement)} key - The key to store the texture with in the Texture Manager, or a Canvas to draw to.
     * @param {integer} [width] - The width of the graphics to generate.
     * @param {integer} [height] - The height of the graphics to generate.
     *
     * @return {this} This Game Object.
     */generateTexture:function(t,e,i){var n,s,r=this.scene.sys,o=r.game.renderer;if(void 0===e&&(e=r.scale.width),void 0===i&&(i=r.scale.height),T.TargetCamera.setScene(this.scene),T.TargetCamera.setViewport(0,0,e,i),T.TargetCamera.scrollX=this.x,T.TargetCamera.scrollY=this.y,"string"==typeof t){if(r.textures.exists(t)){var a=//  Key is a string, it DOES exist in the Texture Manager AND is a canvas, so draw to it
(n=r.textures.get(t)).getSourceImage();a instanceof HTMLCanvasElement&&(s=a.getContext("2d"))}else s=//  Key is a string and doesn't exist in the Texture Manager, so generate and save it
(n=r.textures.createCanvas(t,e,i)).getSourceImage().getContext("2d")}else t instanceof HTMLCanvasElement&&(s=t.getContext("2d"));return s&&(// var GraphicsCanvasRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix, renderTargetCtx, allowClip)
this.renderCanvas(o,this,0,T.TargetCamera,null,s,!1),n&&n.refresh()),this},/**
     * Internal destroy handler, called as part of the destroy process.
     *
     * @method Phaser.GameObjects.Graphics#preDestroy
     * @protected
     * @since 3.9.0
     */preDestroy:function(){this.commandBuffer=[]}});/**
 * A Camera used specifically by the Graphics system for rendering to textures.
 *
 * @name Phaser.GameObjects.Graphics.TargetCamera
 * @type {Phaser.Cameras.Scene2D.Camera}
 * @since 3.1.0
 */T.TargetCamera=new i,t.exports=T}),r("dRykN",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */t.exports={ARC:0,BEGIN_PATH:1,CLOSE_PATH:2,FILL_RECT:3,LINE_TO:4,MOVE_TO:5,LINE_STYLE:6,FILL_STYLE:7,FILL_PATH:8,STROKE_PATH:9,FILL_TRIANGLE:10,STROKE_TRIANGLE:11,SAVE:14,RESTORE:15,TRANSLATE:16,SCALE:17,ROTATE:18,SET_TEXTURE:19,CLEAR_TEXTURE:20,GRADIENT_FILL_STYLE:21,GRADIENT_LINE_STYLE:22}}),r("eaZcG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("dsAkp"),r=s("1vBT7"),o=s("61Yre"),a=s("gZ2BZ"),h=s("fH1i1"),l=new i({initialize:function(t,e,i,n){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=0),/**
         * The geometry constant type of this object: `GEOM_CONST.ELLIPSE`.
         * Used for fast type comparisons.
         *
         * @name Phaser.Geom.Ellipse#type
         * @type {integer}
         * @readonly
         * @since 3.19.0
         */this.type=a.ELLIPSE,/**
         * The x position of the center of the ellipse.
         *
         * @name Phaser.Geom.Ellipse#x
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.x=t,/**
         * The y position of the center of the ellipse.
         *
         * @name Phaser.Geom.Ellipse#y
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.y=e,/**
         * The width of the ellipse.
         *
         * @name Phaser.Geom.Ellipse#width
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.width=i,/**
         * The height of the ellipse.
         *
         * @name Phaser.Geom.Ellipse#height
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.height=n},/**
     * Check to see if the Ellipse contains the given x / y coordinates.
     *
     * @method Phaser.Geom.Ellipse#contains
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate to check within the ellipse.
     * @param {number} y - The y coordinate to check within the ellipse.
     *
     * @return {boolean} True if the coordinates are within the ellipse, otherwise false.
     */contains:function(t,e){return n(this,t,e)},/**
     * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse
     * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point
     * at 180 degrees around the circle.
     *
     * @method Phaser.Geom.Ellipse#getPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point} O - [out,$return]
     *
     * @param {number} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the ellipse.
     * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.
     *
     * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the ellipse.
     */getPoint:function(t,e){return r(this,t,e)},/**
     * Returns an array of Point objects containing the coordinates of the points around the circumference of the Ellipse,
     * based on the given quantity or stepRate values.
     *
     * @method Phaser.Geom.Ellipse#getPoints
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point[]} O - [output,$return]
     *
     * @param {integer} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
     * @param {number} [stepRate] - Sets the quantity by getting the circumference of the ellipse and dividing it by the stepRate.
     * @param {(array|Phaser.Geom.Point[])} [output] - An array to insert the points in to. If not provided a new array will be created.
     *
     * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the circumference of the ellipse.
     */getPoints:function(t,e,i){return o(this,t,e,i)},/**
     * Returns a uniformly distributed random point from anywhere within the given Ellipse.
     *
     * @method Phaser.Geom.Ellipse#getRandomPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point} O - [point,$return]
     *
     * @param {(Phaser.Geom.Point|object)} [point] - A Point or point-like object to set the random `x` and `y` values in.
     *
     * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.
     */getRandomPoint:function(t){return h(this,t)},/**
     * Sets the x, y, width and height of this ellipse.
     *
     * @method Phaser.Geom.Ellipse#setTo
     * @since 3.0.0
     *
     * @param {number} x - The x position of the center of the ellipse.
     * @param {number} y - The y position of the center of the ellipse.
     * @param {number} width - The width of the ellipse.
     * @param {number} height - The height of the ellipse.
     *
     * @return {this} This Ellipse object.
     */setTo:function(t,e,i,n){return this.x=t,this.y=e,this.width=i,this.height=n,this},/**
     * Sets this Ellipse to be empty with a width and height of zero.
     * Does not change its position.
     *
     * @method Phaser.Geom.Ellipse#setEmpty
     * @since 3.0.0
     *
     * @return {this} This Ellipse object.
     */setEmpty:function(){return this.width=0,this.height=0,this},/**
     * Sets the position of this Ellipse.
     *
     * @method Phaser.Geom.Ellipse#setPosition
     * @since 3.0.0
     *
     * @param {number} x - The x position of the center of the ellipse.
     * @param {number} y - The y position of the center of the ellipse.
     *
     * @return {this} This Ellipse object.
     */setPosition:function(t,e){return void 0===e&&(e=t),this.x=t,this.y=e,this},/**
     * Sets the size of this Ellipse.
     * Does not change its position.
     *
     * @method Phaser.Geom.Ellipse#setSize
     * @since 3.0.0
     *
     * @param {number} width - The width of the ellipse.
     * @param {number} [height=width] - The height of the ellipse.
     *
     * @return {this} This Ellipse object.
     */setSize:function(t,e){return void 0===e&&(e=t),this.width=t,this.height=e,this},/**
     * Checks to see if the Ellipse is empty: has a width or height equal to zero.
     *
     * @method Phaser.Geom.Ellipse#isEmpty
     * @since 3.0.0
     *
     * @return {boolean} True if the Ellipse is empty, otherwise false.
     */isEmpty:function(){return this.width<=0||this.height<=0},/**
     * Returns the minor radius of the ellipse. Also known as the Semi Minor Axis.
     *
     * @method Phaser.Geom.Ellipse#getMinorRadius
     * @since 3.0.0
     *
     * @return {number} The minor radius.
     */getMinorRadius:function(){return Math.min(this.width,this.height)/2},/**
     * Returns the major radius of the ellipse. Also known as the Semi Major Axis.
     *
     * @method Phaser.Geom.Ellipse#getMajorRadius
     * @since 3.0.0
     *
     * @return {number} The major radius.
     */getMajorRadius:function(){return Math.max(this.width,this.height)/2},/**
     * The left position of the Ellipse.
     *
     * @name Phaser.Geom.Ellipse#left
     * @type {number}
     * @since 3.0.0
     */left:{get:function(){return this.x-this.width/2},set:function(t){this.x=t+this.width/2}},/**
     * The right position of the Ellipse.
     *
     * @name Phaser.Geom.Ellipse#right
     * @type {number}
     * @since 3.0.0
     */right:{get:function(){return this.x+this.width/2},set:function(t){this.x=t-this.width/2}},/**
     * The top position of the Ellipse.
     *
     * @name Phaser.Geom.Ellipse#top
     * @type {number}
     * @since 3.0.0
     */top:{get:function(){return this.y-this.height/2},set:function(t){this.y=t+this.height/2}},/**
     * The bottom position of the Ellipse.
     *
     * @name Phaser.Geom.Ellipse#bottom
     * @type {number}
     * @since 3.0.0
     */bottom:{get:function(){return this.y+this.height/2},set:function(t){this.y=t-this.height/2}}});t.exports=l}),r("dsAkp",function(t,e){t.exports=function(t,e,i){if(t.width<=0||t.height<=0)return!1;//  Normalize the coords to an ellipse with center 0,0 and a radius of 0.5
var n=(e-t.x)/t.width,s=(i-t.y)/t.height;return n*=n,s*=s,n+s<.25}}),r("1vBT7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jKWrM"),n=s("hqfaz"),r=s("bNtDi"),o=s("cSEB9");t.exports=function(t,e,s){return void 0===s&&(s=new o),i(t,n(e,0,r.PI2),s)}}),r("jKWrM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e,n){void 0===n&&(n=new i);var s=t.width/2,r=t.height/2;return n.x=t.x+s*Math.cos(e),n.y=t.y+r*Math.sin(e),n}}),r("61Yre",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("dmO0a"),n=s("jKWrM"),r=s("hqfaz"),o=s("bNtDi");t.exports=function(t,e,s,a){void 0===a&&(a=[]),!e&&s>0&&(e=i(t)/s);for(var h=0;h<e;h++){var l=r(h/e,0,o.PI2);a.push(n(t,l))}return a}}),r("dmO0a",function(t,e){t.exports=function(t){var e=t.width/2,i=t.height/2,n=Math.pow(e-i,2)/Math.pow(e+i,2);return Math.PI*(e+i)*(1+3*n/(10+Math.sqrt(4-3*n)))}}),r("fdwDj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("3KdB7"),//  Needed for Graphics.generateTexture
r=s("cYp0N"),r=s("cYp0N"),t.exports={renderWebGL:n,renderCanvas:r}}),r("3KdB7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("dRykN"),n=s("gaO4e"),r=function(t,e,i){this.x=t,this.y=e,this.width=i},o=function(t,e,i){this.points=[],this.pointsLength=1,this.points[0]=new r(t,e,i)},a=[];t.exports=function(t,e,s,h,l){if(0!==e.commandBuffer.length){var u=this.pipeline;t.setPipeline(u,e);var c=e._tempMatrix1,d=e._tempMatrix2,f=e._tempMatrix3;f.loadIdentity(),d.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),c.copyFrom(h.matrix),l?(//  Multiply the camera by the parent matrix
c.multiplyWithOffset(l,-h.scrollX*e.scrollFactorX,-h.scrollY*e.scrollFactorY),//  Undo the camera scroll
d.e=e.x,d.f=e.y):(d.e-=h.scrollX*e.scrollFactorX,d.f-=h.scrollY*e.scrollFactorY),//  Multiply by the Sprite matrix, store result in calcMatrix
c.multiply(d);for(var p=e.commandBuffer,g=h.alpha*e.alpha,v=1,m=u.fillTint,y=u.strokeTint,x=0,w=0,T=0,b=2*Math.PI,S=[],A=0,E=!1,_=null,C=n.getTintAppendFloatAlphaAndSwap,M=t.blankTexture.glTexture,P=0;P<p.length;P++)switch(p[P]){case i.BEGIN_PATH:S.length=0,_=null,E=!0;break;case i.CLOSE_PATH:E=!1,_&&_.points.length&&_.points.push(_.points[0]);break;case i.FILL_PATH:for(A=0;A<S.length;A++)u.setTexture2D(M),u.batchFillPath(S[A].points,f,c);break;case i.STROKE_PATH:for(A=0;A<S.length;A++)u.setTexture2D(M),u.batchStrokePath(S[A].points,v,E,f,c);break;case i.LINE_STYLE:v=p[++P];var O=C(p[++P],p[++P]*g);y.TL=O,y.TR=O,y.BL=O,y.BR=O;break;case i.FILL_STYLE:var R=C(p[++P],p[++P]*g);m.TL=R,m.TR=R,m.BL=R,m.BR=R;break;case i.GRADIENT_FILL_STYLE:var L=p[++P]*g;m.TL=C(p[++P],L),m.TR=C(p[++P],L),m.BL=C(p[++P],L),m.BR=C(p[++P],L);break;case i.GRADIENT_LINE_STYLE:v=p[++P];var k=p[++P]*g;y.TL=C(p[++P],k),y.TR=C(p[++P],k),y.BL=C(p[++P],k),y.BR=C(p[++P],k);break;case i.ARC:var D=0,F=p[++P],I=p[++P],B=p[++P],N=p[++P],Y=p[++P],z=p[++P],j=p[++P];for(Y-=N,z?Y<-b?Y=-b:Y>0&&(Y=-b+Y%b):Y>b?Y=b:Y<0&&(Y=b+Y%b),null===_&&(_=new o(F+Math.cos(N)*B,I+Math.sin(N)*B,v),S.push(_),D+=.01);D<1+j;)x=F+Math.cos(T=Y*D+N)*B,w=I+Math.sin(T)*B,_.points.push(new r(x,w,v)),D+=.01;x=F+Math.cos(T=Y+N)*B,w=I+Math.sin(T)*B,_.points.push(new r(x,w,v));break;case i.FILL_RECT:u.setTexture2D(M),u.batchFillRect(p[++P],p[++P],p[++P],p[++P],f,c);break;case i.FILL_TRIANGLE:u.setTexture2D(M),u.batchFillTriangle(p[++P],p[++P],p[++P],p[++P],p[++P],p[++P],f,c);break;case i.STROKE_TRIANGLE:u.setTexture2D(M),u.batchStrokeTriangle(p[++P],p[++P],p[++P],p[++P],p[++P],p[++P],v,f,c);break;case i.LINE_TO:null!==_?_.points.push(new r(p[++P],p[++P],v)):(_=new o(p[++P],p[++P],v),S.push(_));break;case i.MOVE_TO:_=new o(p[++P],p[++P],v),S.push(_);break;case i.SAVE:a.push(f.copyToArray());break;case i.RESTORE:f.copyFromArray(a.pop());break;case i.TRANSLATE:F=p[++P],I=p[++P],f.translate(F,I);break;case i.SCALE:F=p[++P],I=p[++P],f.scale(F,I);break;case i.ROTATE:f.rotate(p[++P]);break;case i.SET_TEXTURE:var X=p[++P],U=p[++P];u.currentFrame=X,u.setTexture2D(X.glTexture,0),u.tintEffect=U,M=X.glTexture;break;case i.CLEAR_TEXTURE:u.currentFrame=t.blankTexture,u.tintEffect=2,M=t.blankTexture.glTexture}}}}),r("cYp0N",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("dRykN"),n=s("csLaZ");t.exports=function(t,e,s,r,o,a,h){var l=e.commandBuffer,u=l.length,c=a||t.currentContext;if(0!==u&&n(t,c,e,r,o)){var d=1,f=1,p=0,g=0,v=1,m=0,y=0,x=0;//  Reset any currently active paths
c.beginPath();for(var w=0;w<u;++w)switch(l[w]){case i.ARC:c.arc(l[w+1],l[w+2],l[w+3],l[w+4],l[w+5],l[w+6]),//  +7 because overshoot is the 7th value, not used in Canvas
w+=7;break;case i.LINE_STYLE:v=l[w+1],p=l[w+2],d=l[w+3],m=(16711680&p)>>>16,y=(65280&p)>>>8,x=255&p,c.strokeStyle="rgba("+m+","+y+","+x+","+d+")",c.lineWidth=v,w+=3;break;case i.FILL_STYLE:g=l[w+1],f=l[w+2],m=(16711680&g)>>>16,y=(65280&g)>>>8,x=255&g,c.fillStyle="rgba("+m+","+y+","+x+","+f+")",w+=2;break;case i.BEGIN_PATH:c.beginPath();break;case i.CLOSE_PATH:c.closePath();break;case i.FILL_PATH:h||c.fill();break;case i.STROKE_PATH:h||c.stroke();break;case i.FILL_RECT:h?c.rect(l[w+1],l[w+2],l[w+3],l[w+4]):c.fillRect(l[w+1],l[w+2],l[w+3],l[w+4]),w+=4;break;case i.FILL_TRIANGLE:c.beginPath(),c.moveTo(l[w+1],l[w+2]),c.lineTo(l[w+3],l[w+4]),c.lineTo(l[w+5],l[w+6]),c.closePath(),h||c.fill(),w+=6;break;case i.STROKE_TRIANGLE:c.beginPath(),c.moveTo(l[w+1],l[w+2]),c.lineTo(l[w+3],l[w+4]),c.lineTo(l[w+5],l[w+6]),c.closePath(),h||c.stroke(),w+=6;break;case i.LINE_TO:c.lineTo(l[w+1],l[w+2]),w+=2;break;case i.MOVE_TO:c.moveTo(l[w+1],l[w+2]),w+=2;break;case i.LINE_FX_TO:c.lineTo(l[w+1],l[w+2]),w+=5;break;case i.MOVE_FX_TO:c.moveTo(l[w+1],l[w+2]),w+=5;break;case i.SAVE:c.save();break;case i.RESTORE:c.restore();break;case i.TRANSLATE:c.translate(l[w+1],l[w+2]),w+=2;break;case i.SCALE:c.scale(l[w+1],l[w+2]),w+=2;break;case i.ROTATE:c.rotate(l[w+1]),w+=1;break;case i.GRADIENT_FILL_STYLE:w+=5;break;case i.GRADIENT_LINE_STYLE:w+=6;break;case i.SET_TEXTURE:w+=2}//  Restore the context saved in SetTransform
c.restore()}}}),r("hDBsd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("fs3fn"),n=s("jwj1g"),r=s("jIv3O"),o=s("7BSWl"),a=s("5pMDk"),h=s("jC9MQ"),l=s("3OeE3"),u=s("lxxnL"),c=s("gXuc8"),d=new n({initialize:function(t,e,i){i?e&&!Array.isArray(e)&&(e=[e]):Array.isArray(e)?h(e[0])&&(//  It's an array of plain config objects
i=e,e=null):h(e)&&(//  Children isn't an array. Is it a config object though?
i=e,e=null),/**
         * This scene this group belongs to.
         *
         * @name Phaser.GameObjects.Group#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * Members of this group.
         *
         * @name Phaser.GameObjects.Group#children
         * @type {Phaser.Structs.Set.<Phaser.GameObjects.GameObject>}
         * @since 3.0.0
         */this.children=new u(e),/**
         * A flag identifying this object as a group.
         *
         * @name Phaser.GameObjects.Group#isParent
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.isParent=!0,/**
         * A textual representation of this Game Object.
         * Used internally by Phaser but is available for your own custom classes to populate.
         *
         * @name Phaser.GameObjects.Group#type
         * @type {string}
         * @default 'Group'
         * @since 3.21.0
         */this.type="Group",/**
         * The class to create new group members from.
         *
         * @name Phaser.GameObjects.Group#classType
         * @type {Function}
         * @since 3.0.0
         * @default Phaser.GameObjects.Sprite
         */this.classType=o(i,"classType",c),/**
         * The name of this group.
         * Empty by default and never populated by Phaser, this is left for developers to use.
         *
         * @name Phaser.GameObjects.Group#name
         * @type {string}
         * @default ''
         * @since 3.18.0
         */this.name=o(i,"name",""),/**
         * Whether this group runs its {@link Phaser.GameObjects.Group#preUpdate} method
         * (which may update any members).
         *
         * @name Phaser.GameObjects.Group#active
         * @type {boolean}
         * @since 3.0.0
         */this.active=o(i,"active",!0),/**
         * The maximum size of this group, if used as a pool. -1 is no limit.
         *
         * @name Phaser.GameObjects.Group#maxSize
         * @type {integer}
         * @since 3.0.0
         * @default -1
         */this.maxSize=o(i,"maxSize",-1),/**
         * A default texture key to use when creating new group members.
         *
         * This is used in {@link Phaser.GameObjects.Group#create}
         * but not in {@link Phaser.GameObjects.Group#createMultiple}.
         *
         * @name Phaser.GameObjects.Group#defaultKey
         * @type {string}
         * @since 3.0.0
         */this.defaultKey=o(i,"defaultKey",null),/**
         * A default texture frame to use when creating new group members.
         *
         * @name Phaser.GameObjects.Group#defaultFrame
         * @type {(string|integer)}
         * @since 3.0.0
         */this.defaultFrame=o(i,"defaultFrame",null),/**
         * Whether to call the update method of any members.
         *
         * @name Phaser.GameObjects.Group#runChildUpdate
         * @type {boolean}
         * @default false
         * @since 3.0.0
         * @see Phaser.GameObjects.Group#preUpdate
         */this.runChildUpdate=o(i,"runChildUpdate",!1),/**
         * A function to be called when adding or creating group members.
         *
         * @name Phaser.GameObjects.Group#createCallback
         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}
         * @since 3.0.0
         */this.createCallback=o(i,"createCallback",null),/**
         * A function to be called when removing group members.
         *
         * @name Phaser.GameObjects.Group#removeCallback
         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}
         * @since 3.0.0
         */this.removeCallback=o(i,"removeCallback",null),/**
         * A function to be called when creating several group members at once.
         *
         * @name Phaser.GameObjects.Group#createMultipleCallback
         * @type {?Phaser.Types.GameObjects.Group.GroupMultipleCreateCallback}
         * @since 3.0.0
         */this.createMultipleCallback=o(i,"createMultipleCallback",null),/**
         * A function to be called when adding or creating group members.
         * For internal use only by a Group, or any class that extends it.
         *
         * @name Phaser.GameObjects.Group#internalCreateCallback
         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}
         * @private
         * @since 3.22.0
         */this.internalCreateCallback=o(i,"internalCreateCallback",null),/**
         * A function to be called when removing group members.
         * For internal use only by a Group, or any class that extends it.
         *
         * @name Phaser.GameObjects.Group#internalRemoveCallback
         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}
         * @private
         * @since 3.22.0
         */this.internalRemoveCallback=o(i,"internalRemoveCallback",null),i&&this.createMultiple(i)},/**
     * Creates a new Game Object and adds it to this group, unless the group {@link Phaser.GameObjects.Group#isFull is full}.
     *
     * Calls {@link Phaser.GameObjects.Group#createCallback}.
     *
     * @method Phaser.GameObjects.Group#create
     * @since 3.0.0
     *
     * @param {number} [x=0] - The horizontal position of the new Game Object in the world.
     * @param {number} [y=0] - The vertical position of the new Game Object in the world.
     * @param {string} [key=defaultKey] - The texture key of the new Game Object.
     * @param {(string|integer)} [frame=defaultFrame] - The texture frame of the new Game Object.
     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of the new Game Object.
     * @param {boolean} [active=true] - The {@link Phaser.GameObjects.GameObject#active} state of the new Game Object.
     *
     * @return {any} The new Game Object (usually a Sprite, etc.).
     */create:function(t,e,i,n,s,r){//  Pool?
if(void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=this.defaultKey),void 0===n&&(n=this.defaultFrame),void 0===s&&(s=!0),void 0===r&&(r=!0),this.isFull())return null;var o=new this.classType(this.scene,t,e,i,n);return this.scene.sys.displayList.add(o),o.preUpdate&&this.scene.sys.updateList.add(o),o.visible=s,o.setActive(r),this.add(o),o},/**
     * Creates several Game Objects and adds them to this group.
     *
     * If the group becomes {@link Phaser.GameObjects.Group#isFull}, no further Game Objects are created.
     *
     * Calls {@link Phaser.GameObjects.Group#createMultipleCallback} and {@link Phaser.GameObjects.Group#createCallback}.
     *
     * @method Phaser.GameObjects.Group#createMultiple
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Group.GroupCreateConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig[]} config - Creation settings. This can be a single configuration object or an array of such objects, which will be applied in turn.
     *
     * @return {any[]} The newly created Game Objects.
     */createMultiple:function(t){if(this.isFull())return[];Array.isArray(t)||(t=[t]);var e=[];if(t[0].key)for(var i=0;i<t.length;i++){var n=this.createFromConfig(t[i]);e=e.concat(n)}return e},/**
     * A helper for {@link Phaser.GameObjects.Group#createMultiple}.
     *
     * @method Phaser.GameObjects.Group#createFromConfig
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Group.GroupCreateConfig} options - Creation settings.
     *
     * @return {any[]} The newly created Game Objects.
     */createFromConfig:function(t){if(this.isFull())return[];this.classType=o(t,"classType",this.classType);var e=o(t,"key",void 0),n=o(t,"frame",null),s=o(t,"visible",!0),r=o(t,"active",!0),h=[];//  Can't do anything without at least a key
if(void 0===e)return h;Array.isArray(e)||(e=[e]),Array.isArray(n)||(n=[n]);//  Build an array of key frame pairs to loop through
var u=o(t,"repeat",0),c=o(t,"randomKey",!1),d=o(t,"randomFrame",!1),f=o(t,"yoyo",!1),p=o(t,"quantity",!1),g=o(t,"frameQuantity",1),v=l(e,n,{max:o(t,"max",0),qty:p||g,random:c,randomB:d,repeat:u,yoyo:f});t.createCallback&&(this.createCallback=t.createCallback),t.removeCallback&&(this.removeCallback=t.removeCallback);for(var m=0;m<v.length;m++){var y=this.create(0,0,v[m].a,v[m].b,s,r);if(!y)break;h.push(y)}//  Post-creation options (applied only to those items created in this call):
var x=a(t,"setXY.x",0),w=a(t,"setXY.y",0),T=a(t,"setXY.stepX",0),b=a(t,"setXY.stepY",0);i.SetXY(h,x,w,T,b);var S=a(t,"setRotation.value",0),A=a(t,"setRotation.step",0);i.SetRotation(h,S,A);var E=a(t,"setScale.x",1),_=a(t,"setScale.y",E),C=a(t,"setScale.stepX",0),M=a(t,"setScale.stepY",0);i.SetScale(h,E,_,C,M);var P=a(t,"setAlpha.value",1),O=a(t,"setAlpha.step",0);i.SetAlpha(h,P,O);var R=a(t,"setDepth.value",0),L=a(t,"setDepth.step",0);i.SetDepth(h,R,L);var k=a(t,"setScrollFactor.x",1),D=a(t,"setScrollFactor.y",k),F=a(t,"setScrollFactor.stepX",0),I=a(t,"setScrollFactor.stepY",0);i.SetScrollFactor(h,k,D,F,I);var B=o(t,"hitArea",null),N=o(t,"hitAreaCallback",null);B&&i.SetHitArea(h,B,N);var Y=o(t,"gridAlign",!1);return Y&&i.GridAlign(h,Y),this.createMultipleCallback&&this.createMultipleCallback.call(this,h),h},/**
     * Updates any group members, if {@link Phaser.GameObjects.Group#runChildUpdate} is enabled.
     *
     * @method Phaser.GameObjects.Group#preUpdate
     * @since 3.0.0
     *
     * @param {number} time - The current timestamp.
     * @param {number} delta - The delta time elapsed since the last frame.
     */preUpdate:function(t,e){if(this.runChildUpdate&&0!==this.children.size)for(var i=this.children.entries.slice(),n=0;n<i.length;n++){var s=i[n];s.active&&s.update(t,e)}},/**
     * Adds a Game Object to this group.
     *
     * Calls {@link Phaser.GameObjects.Group#createCallback}.
     *
     * @method Phaser.GameObjects.Group#add
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.
     * @param {boolean} [addToScene=false] - Also add the Game Object to the scene.
     *
     * @return {this} This Group object.
     */add:function(t,e){return void 0===e&&(e=!1),this.isFull()||(this.children.set(t),this.internalCreateCallback&&this.internalCreateCallback.call(this,t),this.createCallback&&this.createCallback.call(this,t),e&&(this.scene.sys.displayList.add(t),t.preUpdate&&this.scene.sys.updateList.add(t)),t.on(r.DESTROY,this.remove,this)),this},/**
     * Adds several Game Objects to this group.
     *
     * Calls {@link Phaser.GameObjects.Group#createCallback}.
     *
     * @method Phaser.GameObjects.Group#addMultiple
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject[]} children - The Game Objects to add.
     * @param {boolean} [addToScene=false] - Also add the Game Objects to the scene.
     *
     * @return {this} This group.
     */addMultiple:function(t,e){if(void 0===e&&(e=!1),Array.isArray(t))for(var i=0;i<t.length;i++)this.add(t[i],e);return this},/**
     * Removes a member of this Group and optionally removes it from the Scene and / or destroys it.
     *
     * Calls {@link Phaser.GameObjects.Group#removeCallback}.
     *
     * @method Phaser.GameObjects.Group#remove
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.
     * @param {boolean} [removeFromScene=false] - Optionally remove the Group member from the Scene it belongs to.
     * @param {boolean} [destroyChild=false] - Optionally call destroy on the removed Group member.
     *
     * @return {this} This Group object.
     */remove:function(t,e,i){return void 0===e&&(e=!1),void 0===i&&(i=!1),this.children.contains(t)&&(this.children.delete(t),this.internalRemoveCallback&&this.internalRemoveCallback.call(this,t),this.removeCallback&&this.removeCallback.call(this,t),t.off(r.DESTROY,this.remove,this),i?t.destroy():e&&(t.scene.sys.displayList.remove(t),t.preUpdate&&t.scene.sys.updateList.remove(t))),this},/**
     * Removes all members of this Group and optionally removes them from the Scene and / or destroys them.
     *
     * Does not call {@link Phaser.GameObjects.Group#removeCallback}.
     *
     * @method Phaser.GameObjects.Group#clear
     * @since 3.0.0
     *
     * @param {boolean} [removeFromScene=false] - Optionally remove each Group member from the Scene.
     * @param {boolean} [destroyChild=false] - Optionally call destroy on the removed Group members.
     *
     * @return {this} This group.
     */clear:function(t,e){void 0===t&&(t=!1),void 0===e&&(e=!1);for(var i=this.children,n=0;n<i.size;n++){var s=i.entries[n];s.off(r.DESTROY,this.remove,this),e?s.destroy():t&&(s.scene.sys.displayList.remove(s),s.preUpdate&&s.scene.sys.updateList.remove(s))}return this.children.clear(),this},/**
     * Tests if a Game Object is a member of this group.
     *
     * @method Phaser.GameObjects.Group#contains
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} child - A Game Object.
     *
     * @return {boolean} True if the Game Object is a member of this group.
     */contains:function(t){return this.children.contains(t)},/**
     * All members of the group.
     *
     * @method Phaser.GameObjects.Group#getChildren
     * @since 3.0.0
     *
     * @return {Phaser.GameObjects.GameObject[]} The group members.
     */getChildren:function(){return this.children.entries},/**
     * The number of members of the group.
     *
     * @method Phaser.GameObjects.Group#getLength
     * @since 3.0.0
     *
     * @return {integer}
     */getLength:function(){return this.children.size},/**
     * Scans the Group, from top to bottom, for the first member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
     * assigns `x` and `y`, and returns the member.
     *
     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     *
     * @method Phaser.GameObjects.Group#getFirst
     * @since 3.0.0
     *
     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.
     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.
     * @param {number} [x] - The horizontal position of the Game Object in the world.
     * @param {number} [y] - The vertical position of the Game Object in the world.
     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).
     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).
     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).
     *
     * @return {?any} The first matching group member, or a newly created member, or null.
     */getFirst:function(t,e,i,n,s,r,o){return this.getHandler(!0,1,t,e,i,n,s,r,o)},/**
     * Scans the Group, from top to bottom, for the nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
     * assigns `x` and `y`, and returns the member.
     *
     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     *
     * @method Phaser.GameObjects.Group#getFirstNth
     * @since 3.6.0
     *
     * @param {integer} nth - The nth matching Group member to search for.
     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.
     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.
     * @param {number} [x] - The horizontal position of the Game Object in the world.
     * @param {number} [y] - The vertical position of the Game Object in the world.
     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).
     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).
     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).
     *
     * @return {?any} The first matching group member, or a newly created member, or null.
     */getFirstNth:function(t,e,i,n,s,r,o,a){return this.getHandler(!0,t,e,i,n,s,r,o,a)},/**
     * Scans the Group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
     * assigns `x` and `y`, and returns the member.
     *
     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     *
     * @method Phaser.GameObjects.Group#getLast
     * @since 3.6.0
     *
     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.
     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.
     * @param {number} [x] - The horizontal position of the Game Object in the world.
     * @param {number} [y] - The vertical position of the Game Object in the world.
     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).
     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).
     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).
     *
     * @return {?any} The first matching group member, or a newly created member, or null.
     */getLast:function(t,e,i,n,s,r,o){return this.getHandler(!1,1,t,e,i,n,s,r,o)},/**
     * Scans the Group for the last nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
     * assigns `x` and `y`, and returns the member.
     *
     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     *
     * @method Phaser.GameObjects.Group#getLastNth
     * @since 3.6.0
     *
     * @param {integer} nth - The nth matching Group member to search for.
     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.
     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.
     * @param {number} [x] - The horizontal position of the Game Object in the world.
     * @param {number} [y] - The vertical position of the Game Object in the world.
     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).
     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).
     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).
     *
     * @return {?any} The first matching group member, or a newly created member, or null.
     */getLastNth:function(t,e,i,n,s,r,o,a){return this.getHandler(!1,t,e,i,n,s,r,o,a)},/**
     * Scans the group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
     * assigns `x` and `y`, and returns the member.
     *
     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     *
     * @method Phaser.GameObjects.Group#getHandler
     * @private
     * @since 3.6.0
     *
     * @param {boolean} forwards - Search front to back or back to front?
     * @param {integer} nth - Stop matching after nth successful matches.
     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.
     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.
     * @param {number} [x] - The horizontal position of the Game Object in the world.
     * @param {number} [y] - The vertical position of the Game Object in the world.
     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).
     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).
     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).
     *
     * @return {?any} The first matching group member, or a newly created member, or null.
     */getHandler:function(t,e,i,n,s,r,o,a,h){void 0===i&&(i=!1),void 0===n&&(n=!1);var l,u,c=0,d=this.children.entries;if(t)for(u=0;u<d.length;u++)if((l=d[u]).active===i){if(++c===e)break}else l=null;else for(u=d.length-1;u>=0;u--)if((l=d[u]).active===i){if(++c===e)break}else l=null;return l?("number"==typeof s&&(l.x=s),"number"==typeof r&&(l.y=r),l):n?this.create(s,r,o,a,h):null},/**
     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,
     * assigns `x` and `y`, and returns the member.
     *
     * If no inactive member is found and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
     * The new Game Object will have its active state set to `true`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     *
     * @method Phaser.GameObjects.Group#get
     * @since 3.0.0
     *
     * @param {number} [x] - The horizontal position of the Game Object in the world.
     * @param {number} [y] - The vertical position of the Game Object in the world.
     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).
     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).
     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).
     *
     * @return {?any} The first inactive group member, or a newly created member, or null.
     */get:function(t,e,i,n,s){return this.getFirst(!1,!0,t,e,i,n,s)},/**
     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `true`,
     * assigns `x` and `y`, and returns the member.
     *
     * If no active member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     *
     * @method Phaser.GameObjects.Group#getFirstAlive
     * @since 3.0.0
     *
     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.
     * @param {number} [x] - The horizontal position of the Game Object in the world.
     * @param {number} [y] - The vertical position of the Game Object in the world.
     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).
     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).
     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).
     *
     * @return {any} The first active group member, or a newly created member, or null.
     */getFirstAlive:function(t,e,i,n,s,r){return this.getFirst(!0,t,e,i,n,s,r)},/**
     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,
     * assigns `x` and `y`, and returns the member.
     *
     * If no inactive member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.
     * The new Game Object will have an active state set to `true`.
     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
     *
     * @method Phaser.GameObjects.Group#getFirstDead
     * @since 3.0.0
     *
     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.
     * @param {number} [x] - The horizontal position of the Game Object in the world.
     * @param {number} [y] - The vertical position of the Game Object in the world.
     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).
     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).
     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).
     *
     * @return {any} The first inactive group member, or a newly created member, or null.
     */getFirstDead:function(t,e,i,n,s,r){return this.getFirst(!1,t,e,i,n,s,r)},/**
     * {@link Phaser.GameObjects.Components.Animation#play Plays} an animation for all members of this group.
     *
     * @method Phaser.GameObjects.Group#playAnimation
     * @since 3.0.0
     *
     * @param {string} key - The string-based key of the animation to play.
     * @param {string} [startFrame=0] - Optionally start the animation playing from this frame index.
     *
     * @return {this} This Group object.
     */playAnimation:function(t,e){return i.PlayAnimation(this.children.entries,t,e),this},/**
     * Whether this group's size at its {@link Phaser.GameObjects.Group#maxSize maximum}.
     *
     * @method Phaser.GameObjects.Group#isFull
     * @since 3.0.0
     *
     * @return {boolean} True if the number of members equals {@link Phaser.GameObjects.Group#maxSize}.
     */isFull:function(){return -1!==this.maxSize&&this.children.size>=this.maxSize},/**
     * Counts the number of active (or inactive) group members.
     *
     * @method Phaser.GameObjects.Group#countActive
     * @since 3.0.0
     *
     * @param {boolean} [value=true] - Count active (true) or inactive (false) group members.
     *
     * @return {integer} The number of group members with an active state matching the `active` argument.
     */countActive:function(t){void 0===t&&(t=!0);for(var e=0,i=0;i<this.children.size;i++)this.children.entries[i].active===t&&e++;return e},/**
     * Counts the number of in-use (active) group members.
     *
     * @method Phaser.GameObjects.Group#getTotalUsed
     * @since 3.0.0
     *
     * @return {integer} The number of group members with an active state of true.
     */getTotalUsed:function(){return this.countActive()},/**
     * The difference of {@link Phaser.GameObjects.Group#maxSize} and the number of active group members.
     *
     * This represents the number of group members that could be created or reactivated before reaching the size limit.
     *
     * @method Phaser.GameObjects.Group#getTotalFree
     * @since 3.0.0
     *
     * @return {integer} maxSize minus the number of active group numbers; or a large number (if maxSize is -1).
     */getTotalFree:function(){var t=this.getTotalUsed();return(-1===this.maxSize?999999999999:this.maxSize)-t},/**
     * Sets the property as defined in `key` of each group member to the given value.
     *
     * @method Phaser.GameObjects.Group#propertyValueSet
     * @since 3.21.0
     *
     * @param {string} key - The property to be updated.
     * @param {number} value - The amount to set the property to.
     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.
     * @param {integer} [index=0] - An optional offset to start searching from within the items array.
     * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.
     *
     * @return {this} This Group object.
     */propertyValueSet:function(t,e,n,s,r){return i.PropertyValueSet(this.children.entries,t,e,n,s,r),this},/**
     * Adds the given value to the property as defined in `key` of each group member.
     *
     * @method Phaser.GameObjects.Group#propertyValueInc
     * @since 3.21.0
     *
     * @param {string} key - The property to be updated.
     * @param {number} value - The amount to set the property to.
     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.
     * @param {integer} [index=0] - An optional offset to start searching from within the items array.
     * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.
     *
     * @return {this} This Group object.
     */propertyValueInc:function(t,e,n,s,r){return i.PropertyValueInc(this.children.entries,t,e,n,s,r),this},/**
     * Sets the x of each group member.
     *
     * @method Phaser.GameObjects.Group#setX
     * @since 3.21.0
     *
     * @param {number} value - The amount to set the property to.
     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */setX:function(t,e){return i.SetX(this.children.entries,t,e),this},/**
     * Sets the y of each group member.
     *
     * @method Phaser.GameObjects.Group#setY
     * @since 3.21.0
     *
     * @param {number} value - The amount to set the property to.
     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */setY:function(t,e){return i.SetY(this.children.entries,t,e),this},/**
     * Sets the x, y of each group member.
     *
     * @method Phaser.GameObjects.Group#setXY
     * @since 3.21.0
     *
     * @param {number} x - The amount to set the `x` property to.
     * @param {number} [y=x] - The amount to set the `y` property to. If `undefined` or `null` it uses the `x` value.
     * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.
     * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */setXY:function(t,e,n,s){return i.SetXY(this.children.entries,t,e,n,s),this},/**
     * Adds the given value to the x of each group member.
     *
     * @method Phaser.GameObjects.Group#incX
     * @since 3.21.0
     *
     * @param {number} value - The amount to be added to the `x` property.
     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */incX:function(t,e){return i.IncX(this.children.entries,t,e),this},/**
     * Adds the given value to the y of each group member.
     *
     * @method Phaser.GameObjects.Group#incY
     * @since 3.21.0
     *
     * @param {number} value - The amount to be added to the `y` property.
     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */incY:function(t,e){return i.IncY(this.children.entries,t,e),this},/**
     * Adds the given value to the x, y of each group member.
     *
     * @method Phaser.GameObjects.Group#incXY
     * @since 3.21.0
     *
     * @param {number} x - The amount to be added to the `x` property.
     * @param {number} [y=x] - The amount to be added to the `y` property. If `undefined` or `null` it uses the `x` value.
     * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.
     * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */incXY:function(t,e,n,s){return i.IncXY(this.children.entries,t,e,n,s),this},/**
     * Iterate through the group members changing the position of each element to be that of the element that came before
     * it in the array (or after it if direction = 1)
     * 
     * The first group member position is set to x/y.
     *
     * @method Phaser.GameObjects.Group#shiftPosition
     * @since 3.21.0
     *
     * @param {number} x - The x coordinate to place the first item in the array at.
     * @param {number} y - The y coordinate to place the first item in the array at.
     * @param {integer} [direction=0] - The iteration direction. 0 = first to last and 1 = last to first.
     *
     * @return {this} This Group object.
     */shiftPosition:function(t,e,n){return i.ShiftPosition(this.children.entries,t,e,n),this},/**
     * Sets the angle of each group member.
     *
     * @method Phaser.GameObjects.Group#angle
     * @since 3.21.0
     *
     * @param {number} value - The amount to set the angle to, in degrees.
     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */angle:function(t,e){return i.Angle(this.children.entries,t,e),this},/**
     * Sets the rotation of each group member.
     *
     * @method Phaser.GameObjects.Group#rotate
     * @since 3.21.0
     *
     * @param {number} value - The amount to set the rotation to, in radians.
     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */rotate:function(t,e){return i.Rotate(this.children.entries,t,e),this},/**
     * Rotates each group member around the given point by the given angle.
     *
     * @method Phaser.GameObjects.Group#rotateAround
     * @since 3.21.0
     *
     * @param {Phaser.Types.Math.Vector2Like} point - Any object with public `x` and `y` properties.
     * @param {number} angle - The angle to rotate by, in radians.
     *
     * @return {this} This Group object.
     */rotateAround:function(t,e){return i.RotateAround(this.children.entries,t,e),this},/**
     * Rotates each group member around the given point by the given angle and distance.
     *
     * @method Phaser.GameObjects.Group#rotateAroundDistance
     * @since 3.21.0
     *
     * @param {Phaser.Types.Math.Vector2Like} point - Any object with public `x` and `y` properties.
     * @param {number} angle - The angle to rotate by, in radians.
     * @param {number} distance - The distance from the point of rotation in pixels.
     *
     * @return {this} This Group object.
     */rotateAroundDistance:function(t,e,n){return i.RotateAroundDistance(this.children.entries,t,e,n),this},/**
     * Sets the alpha of each group member.
     *
     * @method Phaser.GameObjects.Group#setAlpha
     * @since 3.21.0
     *
     * @param {number} value - The amount to set the alpha to.
     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */setAlpha:function(t,e){return i.SetAlpha(this.children.entries,t,e),this},/**
     * Sets the tint of each group member.
     *
     * @method Phaser.GameObjects.Group#setTint
     * @since 3.21.0
     *
     * @param {number} topLeft - The tint being applied to top-left corner of item. If other parameters are given no value, this tint will be applied to whole item.
     * @param {number} [topRight] - The tint to be applied to top-right corner of item.
     * @param {number} [bottomLeft] - The tint to be applied to the bottom-left corner of item.
     * @param {number} [bottomRight] - The tint to be applied to the bottom-right corner of item.
     *
     * @return {this} This Group object.
     */setTint:function(t,e,n,s){return i.SetTint(this.children.entries,t,e,n,s),this},/**
     * Sets the originX, originY of each group member.
     *
     * @method Phaser.GameObjects.Group#setOrigin
     * @since 3.21.0
     *
     * @param {number} originX - The amount to set the `originX` property to.
     * @param {number} [originY] - The amount to set the `originY` property to. If `undefined` or `null` it uses the `originX` value.
     * @param {number} [stepX=0] - This is added to the `originX` amount, multiplied by the iteration counter.
     * @param {number} [stepY=0] - This is added to the `originY` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */setOrigin:function(t,e,n,s){return i.SetOrigin(this.children.entries,t,e,n,s),this},/**
     * Sets the scaleX of each group member.
     *
     * @method Phaser.GameObjects.Group#scaleX
     * @since 3.21.0
     *
     * @param {number} value - The amount to set the property to.
     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */scaleX:function(t,e){return i.ScaleX(this.children.entries,t,e),this},/**
     * Sets the scaleY of each group member.
     *
     * @method Phaser.GameObjects.Group#scaleY
     * @since 3.21.0
     *
     * @param {number} value - The amount to set the property to.
     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */scaleY:function(t,e){return i.ScaleY(this.children.entries,t,e),this},/**
     * Sets the scaleX, scaleY of each group member.
     *
     * @method Phaser.GameObjects.Group#scaleXY
     * @since 3.21.0
     *
     * @param {number} scaleX - The amount to be added to the `scaleX` property.
     * @param {number} [scaleY] - The amount to be added to the `scaleY` property. If `undefined` or `null` it uses the `scaleX` value.
     * @param {number} [stepX=0] - This is added to the `scaleX` amount, multiplied by the iteration counter.
     * @param {number} [stepY=0] - This is added to the `scaleY` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */scaleXY:function(t,e,n,s){return i.ScaleXY(this.children.entries,t,e,n,s),this},/**
     * Sets the depth of each group member.
     *
     * @method Phaser.GameObjects.Group#setDepth
     * @since 3.0.0
     *
     * @param {number} value - The amount to set the property to.
     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.
     *
     * @return {this} This Group object.
     */setDepth:function(t,e){return i.SetDepth(this.children.entries,t,e),this},/**
     * Sets the blendMode of each group member.
     *
     * @method Phaser.GameObjects.Group#setBlendMode
     * @since 3.21.0
     *
     * @param {number} value - The amount to set the property to.
     *
     * @return {this} This Group object.
     */setBlendMode:function(t){return i.SetBlendMode(this.children.entries,t),this},/**
     * Passes all group members to the Input Manager to enable them for input with identical areas and callbacks.
     *
     * @method Phaser.GameObjects.Group#setHitArea
     * @since 3.21.0
     *
     * @param {*} hitArea - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.
     * @param {Phaser.Types.Input.HitAreaCallback} hitAreaCallback - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.
     *
     * @return {this} This Group object.
     */setHitArea:function(t,e){return i.SetHitArea(this.children.entries,t,e),this},/**
     * Shuffles the group members in place.
     *
     * @method Phaser.GameObjects.Group#shuffle
     * @since 3.21.0
     *
     * @return {this} This Group object.
     */shuffle:function(){return i.Shuffle(this.children.entries),this},/**
     * Deactivates a member of this group.
     *
     * @method Phaser.GameObjects.Group#kill
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - A member of this group.
     */kill:function(t){this.children.contains(t)&&t.setActive(!1)},/**
     * Deactivates and hides a member of this group.
     *
     * @method Phaser.GameObjects.Group#killAndHide
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - A member of this group.
     */killAndHide:function(t){this.children.contains(t)&&(t.setActive(!1),t.setVisible(!1))},/**
     * Sets the visible of each group member.
     *
     * @method Phaser.GameObjects.Group#setVisible
     * @since 3.21.0
     *
     * @param {boolean} value - The value to set the property to.
     * @param {integer} [index=0] - An optional offset to start searching from within the items array.
     * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.
     *
     * @return {this} This Group object.
     */setVisible:function(t,e,n){return i.SetVisible(this.children.entries,t,e,n),this},/**
     * Toggles (flips) the visible state of each member of this group.
     *
     * @method Phaser.GameObjects.Group#toggleVisible
     * @since 3.0.0
     *
     * @return {this} This Group object.
     */toggleVisible:function(){return i.ToggleVisible(this.children.entries),this},/**
     * Empties this group and removes it from the Scene.
     *
     * Does not call {@link Phaser.GameObjects.Group#removeCallback}.
     *
     * @method Phaser.GameObjects.Group#destroy
     * @since 3.0.0
     *
     * @param {boolean} [destroyChildren=false] - Also {@link Phaser.GameObjects.GameObject#destroy} each group member.
     */destroy:function(t){void 0===t&&(t=!1),this.scene&&!this.ignoreDestroy&&(this.clear(!1,t),this.scene=void 0,this.children=void 0)}});t.exports=d}),r("lxxnL",function(t,e){/**
 * @callback EachSetCallback<E>
 *
 * @param {E} entry - The Set entry.
 * @param {number} index - The index of the entry within the Set.
 *
 * @return {?boolean} The callback result.
 *//**
 * @classdesc
 * A Set is a collection of unique elements.
 *
 * @class Set
 * @memberof Phaser.Structs
 * @constructor
 * @since 3.0.0
 *
 * @generic T
 * @genericUse {T[]} - [elements]
 *
 * @param {Array.<*>} [elements] - An optional array of elements to insert into this Set.
 */var i=new(s("jwj1g"))({initialize:function(t){if(/**
         * The entries of this Set. Stored internally as an array.
         *
         * @genericUse {T[]} - [$type]
         *
         * @name Phaser.Structs.Set#entries
         * @type {Array.<*>}
         * @default []
         * @since 3.0.0
         */this.entries=[],Array.isArray(t))for(var e=0;e<t.length;e++)this.set(t[e])},/**
     * Inserts the provided value into this Set. If the value is already contained in this Set this method will have no effect.
     *
     * @method Phaser.Structs.Set#set
     * @since 3.0.0
     *
     * @genericUse {T} - [value]
     * @genericUse {Phaser.Structs.Set.<T>} - [$return]
     *
     * @param {*} value - The value to insert into this Set.
     *
     * @return {Phaser.Structs.Set} This Set object.
     */set:function(t){return -1===this.entries.indexOf(t)&&this.entries.push(t),this},/**
     * Get an element of this Set which has a property of the specified name, if that property is equal to the specified value.
     * If no elements of this Set satisfy the condition then this method will return `null`.
     *
     * @method Phaser.Structs.Set#get
     * @since 3.0.0
     *
     * @genericUse {T} - [value,$return]
     *
     * @param {string} property - The property name to check on the elements of this Set.
     * @param {*} value - The value to check for.
     *
     * @return {*} The first element of this Set that meets the required condition, or `null` if this Set contains no elements that meet the condition.
     */get:function(t,e){for(var i=0;i<this.entries.length;i++){var n=this.entries[i];if(n[t]===e)return n}},/**
     * Returns an array containing all the values in this Set.
     *
     * @method Phaser.Structs.Set#getArray
     * @since 3.0.0
     *
     * @genericUse {T[]} - [$return]
     *
     * @return {Array.<*>} An array containing all the values in this Set.
     */getArray:function(){return this.entries.slice(0)},/**
     * Removes the given value from this Set if this Set contains that value.
     *
     * @method Phaser.Structs.Set#delete
     * @since 3.0.0
     *
     * @genericUse {T} - [value]
     * @genericUse {Phaser.Structs.Set.<T>} - [$return]
     *
     * @param {*} value - The value to remove from the Set.
     *
     * @return {Phaser.Structs.Set} This Set object.
     */delete:function(t){var e=this.entries.indexOf(t);return e>-1&&this.entries.splice(e,1),this},/**
     * Dumps the contents of this Set to the console via `console.group`.
     *
     * @method Phaser.Structs.Set#dump
     * @since 3.0.0
     */dump:function(){// eslint-disable-next-line no-console
console.group("Set");for(var t=0;t<this.entries.length;t++)console.log(this.entries[t]);// eslint-disable-next-line no-console
console.groupEnd()},/**
     * Passes each value in this Set to the given callback.
     * Use this function when you know this Set will be modified during the iteration, otherwise use `iterate`.
     *
     * @method Phaser.Structs.Set#each
     * @since 3.0.0
     *
     * @genericUse {EachSetCallback.<T>} - [callback]
     * @genericUse {Phaser.Structs.Set.<T>} - [$return]
     *
     * @param {EachSetCallback} callback - The callback to be invoked and passed each value this Set contains.
     * @param {*} [callbackScope] - The scope of the callback.
     *
     * @return {Phaser.Structs.Set} This Set object.
     */each:function(t,e){var i,n=this.entries.slice(),s=n.length;if(e)for(i=0;i<s&&!1!==t.call(e,n[i],i);i++);else for(i=0;i<s&&!1!==t(n[i],i);i++);return this},/**
     * Passes each value in this Set to the given callback.
     * For when you absolutely know this Set won't be modified during the iteration.
     *
     * @method Phaser.Structs.Set#iterate
     * @since 3.0.0
     *
     * @genericUse {EachSetCallback.<T>} - [callback]
     * @genericUse {Phaser.Structs.Set.<T>} - [$return]
     *
     * @param {EachSetCallback} callback - The callback to be invoked and passed each value this Set contains.
     * @param {*} [callbackScope] - The scope of the callback.
     *
     * @return {Phaser.Structs.Set} This Set object.
     */iterate:function(t,e){var i,n=this.entries.length;if(e)for(i=0;i<n&&!1!==t.call(e,this.entries[i],i);i++);else for(i=0;i<n&&!1!==t(this.entries[i],i);i++);return this},/**
     * Goes through each entry in this Set and invokes the given function on them, passing in the arguments.
     *
     * @method Phaser.Structs.Set#iterateLocal
     * @since 3.0.0
     *
     * @genericUse {Phaser.Structs.Set.<T>} - [$return]
     *
     * @param {string} callbackKey - The key of the function to be invoked on each Set entry.
     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.
     *
     * @return {Phaser.Structs.Set} This Set object.
     */iterateLocal:function(t){var e,i=[];for(e=1;e<arguments.length;e++)i.push(arguments[e]);var n=this.entries.length;for(e=0;e<n;e++){var s=this.entries[e];s[t].apply(s,i)}return this},/**
     * Clears this Set so that it no longer contains any values.
     *
     * @method Phaser.Structs.Set#clear
     * @since 3.0.0
     *
     * @genericUse {Phaser.Structs.Set.<T>} - [$return]
     *
     * @return {Phaser.Structs.Set} This Set object.
     */clear:function(){return this.entries.length=0,this},/**
     * Returns `true` if this Set contains the given value, otherwise returns `false`.
     *
     * @method Phaser.Structs.Set#contains
     * @since 3.0.0
     *
     * @genericUse {T} - [value]
     *
     * @param {*} value - The value to check for in this Set.
     *
     * @return {boolean} `true` if the given value was found in this Set, otherwise `false`.
     */contains:function(t){return this.entries.indexOf(t)>-1},/**
     * Returns a new Set containing all values that are either in this Set or in the Set provided as an argument.
     *
     * @method Phaser.Structs.Set#union
     * @since 3.0.0
     *
     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]
     *
     * @param {Phaser.Structs.Set} set - The Set to perform the union with.
     *
     * @return {Phaser.Structs.Set} A new Set containing all the values in this Set and the Set provided as an argument.
     */union:function(t){var e=new i;return t.entries.forEach(function(t){e.set(t)}),this.entries.forEach(function(t){e.set(t)}),e},/**
     * Returns a new Set that contains only the values which are in this Set and that are also in the given Set.
     *
     * @method Phaser.Structs.Set#intersect
     * @since 3.0.0
     *
     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]
     *
     * @param {Phaser.Structs.Set} set - The Set to intersect this set with.
     *
     * @return {Phaser.Structs.Set} The result of the intersection, as a new Set.
     */intersect:function(t){var e=new i;return this.entries.forEach(function(i){t.contains(i)&&e.set(i)}),e},/**
     * Returns a new Set containing all the values in this Set which are *not* also in the given Set.
     *
     * @method Phaser.Structs.Set#difference
     * @since 3.0.0
     *
     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]
     *
     * @param {Phaser.Structs.Set} set - The Set to perform the difference with.
     *
     * @return {Phaser.Structs.Set} A new Set containing all the values in this Set that are not also in the Set provided as an argument to this method.
     */difference:function(t){var e=new i;return this.entries.forEach(function(i){t.contains(i)||e.set(i)}),e},/**
     * The size of this Set. This is the number of entries within it.
     * Changing the size will truncate the Set if the given value is smaller than the current size.
     * Increasing the size larger than the current size has no effect.
     *
     * @name Phaser.Structs.Set#size
     * @type {integer}
     * @since 3.0.0
     */size:{get:function(){return this.entries.length},set:function(t){return t<this.entries.length?this.entries.length=t:this.entries.length}}});t.exports=i}),r("gXuc8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("1zqlR"),o=s("7xBzH"),a=new i({Extends:r,Mixins:[n.Alpha,n.BlendMode,n.Depth,n.Flip,n.GetBounds,n.Mask,n.Origin,n.Pipeline,n.ScrollFactor,n.Size,n.TextureCrop,n.Tint,n.Transform,n.Visible,o],initialize:function(t,e,i,s,o){r.call(this,t,"Sprite"),/**
         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.
         *
         * @name Phaser.GameObjects.Sprite#_crop
         * @type {object}
         * @private
         * @since 3.11.0
         */this._crop=this.resetCropObject(),/**
         * The Animation Controller of this Sprite.
         *
         * @name Phaser.GameObjects.Sprite#anims
         * @type {Phaser.GameObjects.Components.Animation}
         * @since 3.0.0
         */this.anims=new n.Animation(this),this.setTexture(s,o),this.setPosition(e,i),this.setSizeToFrame(),this.setOriginFromFrame(),this.initPipeline()},/**
     * Update this Sprite's animations.
     *
     * @method Phaser.GameObjects.Sprite#preUpdate
     * @protected
     * @since 3.0.0
     *
     * @param {number} time - The current timestamp.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */preUpdate:function(t,e){this.anims.update(t,e)},/**
     * Start playing the given animation.
     *
     * @method Phaser.GameObjects.Sprite#play
     * @since 3.0.0
     *
     * @param {string} key - The string-based key of the animation to play.
     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.
     * @param {integer} [startFrame=0] - Optionally start the animation playing from this frame index.
     *
     * @return {this} This Game Object.
     */play:function(t,e,i){return this.anims.play(t,e,i),this},/**
     * Build a JSON representation of this Sprite.
     *
     * @method Phaser.GameObjects.Sprite#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.
     */toJSON:function(){//  Extra Sprite data is added here
return n.ToJSON(this)},/**
     * Handles the pre-destroy step for the Sprite, which removes the Animation component.
     *
     * @method Phaser.GameObjects.Sprite#preDestroy
     * @private
     * @since 3.14.0
     */preDestroy:function(){this.anims.destroy(),this.anims=void 0}});t.exports=a}),r("7xBzH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("asWCp"),r=s("fX7xt"),t.exports={renderWebGL:n,renderCanvas:r}}),r("asWCp",function(t,e){t.exports=function(t,e,i,n,s){this.pipeline.batchSprite(e,n,s)}}),r("fX7xt",function(t,e){t.exports=function(t,e,i,n,s){t.batchSprite(e,e.frame,n,s)}}),r("8qGvv",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("1zqlR"),o=s("lov8M"),a=new i({Extends:r,Mixins:[n.Alpha,n.BlendMode,n.Depth,n.Flip,n.GetBounds,n.Mask,n.Origin,n.Pipeline,n.ScrollFactor,n.Size,n.TextureCrop,n.Tint,n.Transform,n.Visible,o],initialize:function(t,e,i,n,s){r.call(this,t,"Image"),/**
         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.
         *
         * @name Phaser.GameObjects.Image#_crop
         * @type {object}
         * @private
         * @since 3.11.0
         */this._crop=this.resetCropObject(),this.setTexture(n,s),this.setPosition(e,i),this.setSizeToFrame(),this.setOriginFromFrame(),this.initPipeline()}});t.exports=a}),r("lov8M",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("lvyFt"),r=s("37n2d"),t.exports={renderWebGL:n,renderCanvas:r}}),r("lvyFt",function(t,e){t.exports=function(t,e,i,n,s){this.pipeline.batchSprite(e,n,s)}}),r("37n2d",function(t,e){t.exports=function(t,e,i,n,s){t.batchSprite(e,e.frame,n,s)}}),r("jyMeR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.GameObjects.Particles
 */t.exports={GravityWell:s("WUmMp"),Particle:s("b1bWN"),ParticleEmitter:s("hlq7f"),ParticleEmitterManager:s("fnOwf"),Zones:s("3zceK")}}),r("WUmMp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7BSWl"),r=new i({initialize:function(t,e,i,s,r){if("object"==typeof t){var o=t;t=n(o,"x",0),e=n(o,"y",0),i=n(o,"power",0),s=n(o,"epsilon",100),r=n(o,"gravity",50)}else void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===s&&(s=100),void 0===r&&(r=50);/**
         * The x coordinate of the Gravity Well, in world space.
         *
         * @name Phaser.GameObjects.Particles.GravityWell#x
         * @type {number}
         * @since 3.0.0
         */this.x=t,/**
         * The y coordinate of the Gravity Well, in world space.
         *
         * @name Phaser.GameObjects.Particles.GravityWell#y
         * @type {number}
         * @since 3.0.0
         */this.y=e,/**
         * The active state of the Gravity Well. An inactive Gravity Well will not influence any particles.
         *
         * @name Phaser.GameObjects.Particles.GravityWell#active
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.active=!0,/**
         * Internal gravity value.
         *
         * @name Phaser.GameObjects.Particles.GravityWell#_gravity
         * @type {number}
         * @private
         * @since 3.0.0
         */this._gravity=r,/**
         * Internal power value.
         *
         * @name Phaser.GameObjects.Particles.GravityWell#_power
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._power=0,/**
         * Internal epsilon value.
         *
         * @name Phaser.GameObjects.Particles.GravityWell#_epsilon
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._epsilon=0,/**
         * The strength of the gravity force - larger numbers produce a stronger force.
         *
         * @name Phaser.GameObjects.Particles.GravityWell#power
         * @type {number}
         * @since 3.0.0
         */this.power=i,/**
         * The minimum distance for which the gravity force is calculated.
         *
         * @name Phaser.GameObjects.Particles.GravityWell#epsilon
         * @type {number}
         * @since 3.0.0
         */this.epsilon=s},/**
     * Takes a Particle and updates it based on the properties of this Gravity Well.
     *
     * @method Phaser.GameObjects.Particles.GravityWell#update
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle to update.
     * @param {number} delta - The delta time in ms.
     * @param {number} step - The delta value divided by 1000.
     */update:function(t,e){var i=this.x-t.x,n=this.y-t.y,s=i*i+n*n;if(0!==s){var r=Math.sqrt(s);s<this._epsilon&&(s=this._epsilon);var o=this._power*e/(s*r)*100;t.velocityX+=i*o,t.velocityY+=n*o}},epsilon:{get:function(){return Math.sqrt(this._epsilon)},set:function(t){this._epsilon=t*t}},power:{get:function(){return this._power/this._gravity},set:function(t){this._power=t*this._gravity}},gravity:{get:function(){return this._gravity},set:function(t){var e=this.power;this._gravity=t,this.power=e}}});t.exports=r}),r("b1bWN",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("2zqSA"),r=s("bwLQh"),o=new i({initialize:function(t){/**
         * The Emitter to which this Particle belongs.
         *
         * A Particle can only belong to a single Emitter and is created, updated and destroyed via it.
         *
         * @name Phaser.GameObjects.Particles.Particle#emitter
         * @type {Phaser.GameObjects.Particles.ParticleEmitter}
         * @since 3.0.0
         */this.emitter=t,/**
         * The texture frame used to render this Particle.
         *
         * @name Phaser.GameObjects.Particles.Particle#frame
         * @type {Phaser.Textures.Frame}
         * @default null
         * @since 3.0.0
         */this.frame=null,/**
         * The x coordinate of this Particle.
         *
         * @name Phaser.GameObjects.Particles.Particle#x
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.x=0,/**
         * The y coordinate of this Particle.
         *
         * @name Phaser.GameObjects.Particles.Particle#y
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.y=0,/**
         * The x velocity of this Particle.
         *
         * @name Phaser.GameObjects.Particles.Particle#velocityX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.velocityX=0,/**
         * The y velocity of this Particle.
         *
         * @name Phaser.GameObjects.Particles.Particle#velocityY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.velocityY=0,/**
         * The x acceleration of this Particle.
         *
         * @name Phaser.GameObjects.Particles.Particle#accelerationX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.accelerationX=0,/**
         * The y acceleration of this Particle.
         *
         * @name Phaser.GameObjects.Particles.Particle#accelerationY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.accelerationY=0,/**
         * The maximum horizontal velocity this Particle can travel at.
         *
         * @name Phaser.GameObjects.Particles.Particle#maxVelocityX
         * @type {number}
         * @default 10000
         * @since 3.0.0
         */this.maxVelocityX=1e4,/**
         * The maximum vertical velocity this Particle can travel at.
         *
         * @name Phaser.GameObjects.Particles.Particle#maxVelocityY
         * @type {number}
         * @default 10000
         * @since 3.0.0
         */this.maxVelocityY=1e4,/**
         * The bounciness, or restitution, of this Particle.
         *
         * @name Phaser.GameObjects.Particles.Particle#bounce
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.bounce=0,/**
         * The horizontal scale of this Particle.
         *
         * @name Phaser.GameObjects.Particles.Particle#scaleX
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.scaleX=1,/**
         * The vertical scale of this Particle.
         *
         * @name Phaser.GameObjects.Particles.Particle#scaleY
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.scaleY=1,/**
         * The alpha value of this Particle.
         *
         * @name Phaser.GameObjects.Particles.Particle#alpha
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.alpha=1,/**
         * The angle of this Particle in degrees.
         *
         * @name Phaser.GameObjects.Particles.Particle#angle
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.angle=0,/**
         * The angle of this Particle in radians.
         *
         * @name Phaser.GameObjects.Particles.Particle#rotation
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.rotation=0,/**
         * The tint applied to this Particle.
         *
         * @name Phaser.GameObjects.Particles.Particle#tint
         * @type {integer}
         * @webglOnly
         * @since 3.0.0
         */this.tint=16777215,/**
         * The lifespan of this Particle in ms.
         *
         * @name Phaser.GameObjects.Particles.Particle#life
         * @type {number}
         * @default 1000
         * @since 3.0.0
         */this.life=1e3,/**
         * The current life of this Particle in ms.
         *
         * @name Phaser.GameObjects.Particles.Particle#lifeCurrent
         * @type {number}
         * @default 1000
         * @since 3.0.0
         */this.lifeCurrent=1e3,/**
         * The delay applied to this Particle upon emission, in ms.
         *
         * @name Phaser.GameObjects.Particles.Particle#delayCurrent
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.delayCurrent=0,/**
         * The normalized lifespan T value, where 0 is the start and 1 is the end.
         *
         * @name Phaser.GameObjects.Particles.Particle#lifeT
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.lifeT=0,/**
         * The data used by the ease equation.
         *
         * @name Phaser.GameObjects.Particles.Particle#data
         * @type {object}
         * @since 3.0.0
         */this.data={tint:{min:16777215,max:16777215,current:16777215},alpha:{min:1,max:1},rotate:{min:0,max:0},scaleX:{min:1,max:1},scaleY:{min:1,max:1}}},/**
     * Checks to see if this Particle is alive and updating.
     *
     * @method Phaser.GameObjects.Particles.Particle#isAlive
     * @since 3.0.0
     *
     * @return {boolean} `true` if this Particle is alive and updating, otherwise `false`.
     */isAlive:function(){return this.lifeCurrent>0},/**
     * Resets the position of this particle back to zero.
     *
     * @method Phaser.GameObjects.Particles.Particle#resetPosition
     * @since 3.16.0
     */resetPosition:function(){this.x=0,this.y=0},/**
     * Starts this Particle from the given coordinates.
     *
     * @method Phaser.GameObjects.Particles.Particle#fire
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate to launch this Particle from.
     * @param {number} y - The y coordinate to launch this Particle from.
     */fire:function(t,e){var i=this.emitter;this.frame=i.getFrame(),i.emitZone&&i.emitZone.getPoint(this),void 0===t?(i.follow&&(this.x+=i.follow.x+i.followOffset.x),this.x+=i.x.onEmit(this,"x")):this.x+=t,void 0===e?(i.follow&&(this.y+=i.follow.y+i.followOffset.y),this.y+=i.y.onEmit(this,"y")):this.y+=e,this.life=i.lifespan.onEmit(this,"lifespan"),this.lifeCurrent=this.life,this.lifeT=0;var s=i.speedX.onEmit(this,"speedX"),o=i.speedY?i.speedY.onEmit(this,"speedY"):s;if(i.radial){var a=n(i.angle.onEmit(this,"angle"));this.velocityX=Math.cos(a)*Math.abs(s),this.velocityY=Math.sin(a)*Math.abs(o)}else if(i.moveTo){var h=i.moveToX.onEmit(this,"moveToX"),l=i.moveToY?i.moveToY.onEmit(this,"moveToY"):h,u=Math.atan2(l-this.y,h-this.x),c=r(this.x,this.y,h,l)/(this.life/1e3);//  We know how many pixels we need to move, but how fast?
// var speed = this.distanceToXY(displayObject, x, y) / (maxTime / 1000);
this.velocityX=Math.cos(u)*c,this.velocityY=Math.sin(u)*c}else this.velocityX=s,this.velocityY=o;i.acceleration&&(this.accelerationX=i.accelerationX.onEmit(this,"accelerationX"),this.accelerationY=i.accelerationY.onEmit(this,"accelerationY")),this.maxVelocityX=i.maxVelocityX.onEmit(this,"maxVelocityX"),this.maxVelocityY=i.maxVelocityY.onEmit(this,"maxVelocityY"),this.delayCurrent=i.delay.onEmit(this,"delay"),this.scaleX=i.scaleX.onEmit(this,"scaleX"),this.scaleY=i.scaleY?i.scaleY.onEmit(this,"scaleY"):this.scaleX,this.angle=i.rotate.onEmit(this,"rotate"),this.rotation=n(this.angle),this.bounce=i.bounce.onEmit(this,"bounce"),this.alpha=i.alpha.onEmit(this,"alpha"),this.tint=i.tint.onEmit(this,"tint")},/**
     * An internal method that calculates the velocity of the Particle.
     *
     * @method Phaser.GameObjects.Particles.Particle#computeVelocity
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Emitter that is updating this Particle.
     * @param {number} delta - The delta time in ms.
     * @param {number} step - The delta value divided by 1000.
     * @param {array} processors - Particle processors (gravity wells).
     */computeVelocity:function(t,e,i,n){var s=this.velocityX,r=this.velocityY,o=this.accelerationX,a=this.accelerationY,h=this.maxVelocityX,l=this.maxVelocityY;s+=t.gravityX*i,r+=t.gravityY*i,o&&(s+=o*i),a&&(r+=a*i),s>h?s=h:s<-h&&(s=-h),r>l?r=l:r<-l&&(r=-l),this.velocityX=s,this.velocityY=r;//  Apply any additional processors
for(var u=0;u<n.length;u++)n[u].update(this,e,i)},/**
     * Checks if this Particle is still within the bounds defined by the given Emitter.
     *
     * If not, and depending on the Emitter collision flags, the Particle may either stop or rebound.
     *
     * @method Phaser.GameObjects.Particles.Particle#checkBounds
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Emitter to check the bounds against.
     */checkBounds:function(t){var e=t.bounds,i=-this.bounce;this.x<e.x&&t.collideLeft?(this.x=e.x,this.velocityX*=i):this.x>e.right&&t.collideRight&&(this.x=e.right,this.velocityX*=i),this.y<e.y&&t.collideTop?(this.y=e.y,this.velocityY*=i):this.y>e.bottom&&t.collideBottom&&(this.y=e.bottom,this.velocityY*=i)},/**
     * The main update method for this Particle.
     *
     * Updates its life values, computes the velocity and repositions the Particle.
     *
     * @method Phaser.GameObjects.Particles.Particle#update
     * @since 3.0.0
     *
     * @param {number} delta - The delta time in ms.
     * @param {number} step - The delta value divided by 1000.
     * @param {array} processors - An optional array of update processors.
     *
     * @return {boolean} Returns `true` if this Particle has now expired and should be removed, otherwise `false` if still active.
     */update:function(t,e,i){if(this.delayCurrent>0)return this.delayCurrent-=t,!1;var s=this.emitter,r=1-this.lifeCurrent/this.life;return(this.lifeT=r,this.computeVelocity(s,t,e,i),this.x+=this.velocityX*e,this.y+=this.velocityY*e,s.bounds&&this.checkBounds(s),s.deathZone&&s.deathZone.willKill(this))?(this.lifeCurrent=0,!0):(this.scaleX=s.scaleX.onUpdate(this,"scaleX",r,this.scaleX),s.scaleY?this.scaleY=s.scaleY.onUpdate(this,"scaleY",r,this.scaleY):this.scaleY=this.scaleX,this.angle=s.rotate.onUpdate(this,"rotate",r,this.angle),this.rotation=n(this.angle),this.alpha=s.alpha.onUpdate(this,"alpha",r,this.alpha),this.tint=s.tint.onUpdate(this,"tint",r,this.tint),this.lifeCurrent-=t,this.lifeCurrent<=0)}});t.exports=o}),r("hlq7f",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("3qUcC"),n=s("jwj1g"),r=s("4FF1v"),o=s("bSAIj"),a=s("g6KAN"),h=s("5j1iP"),l=s("7BSWl"),u=s("5H1qm"),c=s("88Y8i"),d=s("evjs6"),f=s("b1bWN"),p=s("8lICh"),g=s("cwr8X"),v=s("7D0e6"),m=s("7SBSk"),y=s("8qWuA"),x=new n({Mixins:[r.BlendMode,r.Mask,r.ScrollFactor,r.Visible],initialize:function(t,e){/**
         * The Emitter Manager this Emitter belongs to.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#manager
         * @type {Phaser.GameObjects.Particles.ParticleEmitterManager}
         * @since 3.0.0
         */this.manager=t,/**
         * The texture assigned to particles.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#texture
         * @type {Phaser.Textures.Texture}
         * @since 3.0.0
         */this.texture=t.texture,/**
         * The texture frames assigned to particles.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#frames
         * @type {Phaser.Textures.Frame[]}
         * @since 3.0.0
         */this.frames=[t.defaultFrame],/**
         * The default texture frame assigned to particles.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#defaultFrame
         * @type {Phaser.Textures.Frame}
         * @since 3.0.0
         */this.defaultFrame=t.defaultFrame,/**
         * Names of simple configuration properties.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#configFastMap
         * @type {object}
         * @since 3.0.0
         */this.configFastMap=["active","blendMode","collideBottom","collideLeft","collideRight","collideTop","deathCallback","deathCallbackScope","emitCallback","emitCallbackScope","follow","frequency","gravityX","gravityY","maxParticles","name","on","particleBringToTop","particleClass","radial","timeScale","trackVisible","visible"],/**
         * Names of complex configuration properties.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#configOpMap
         * @type {object}
         * @since 3.0.0
         */this.configOpMap=["accelerationX","accelerationY","angle","alpha","bounce","delay","lifespan","maxVelocityX","maxVelocityY","moveToX","moveToY","quantity","rotate","scaleX","scaleY","speedX","speedY","tint","x","y"],/**
         * The name of this Particle Emitter.
         *
         * Empty by default and never populated by Phaser, this is left for developers to use.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#name
         * @type {string}
         * @default ''
         * @since 3.0.0
         */this.name="",/**
         * The Particle Class which will be emitted by this Emitter.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#particleClass
         * @type {Phaser.GameObjects.Particles.Particle}
         * @default Phaser.GameObjects.Particles.Particle
         * @since 3.0.0
         */this.particleClass=f,/**
         * The x-coordinate of the particle origin (where particles will be emitted).
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#x
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 0
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setPosition
         */this.x=new h(e,"x",0,!0),/**
         * The y-coordinate of the particle origin (where particles will be emitted).
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#y
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 0
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setPosition
         */this.y=new h(e,"y",0,!0),/**
         * A radial emitter will emit particles in all directions between angle min and max,
         * using {@link Phaser.GameObjects.Particles.ParticleEmitter#speed} as the value. If set to false then this acts as a point Emitter.
         * A point emitter will emit particles only in the direction derived from the speedX and speedY values.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#radial
         * @type {boolean}
         * @default true
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setRadial
         */this.radial=!0,/**
         * Horizontal acceleration applied to emitted particles, in pixels per second squared.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#gravityX
         * @type {number}
         * @default 0
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setGravity
         */this.gravityX=0,/**
         * Vertical acceleration applied to emitted particles, in pixels per second squared.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#gravityY
         * @type {number}
         * @default 0
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setGravity
         */this.gravityY=0,/**
         * Whether accelerationX and accelerationY are non-zero. Set automatically during configuration.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#acceleration
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.acceleration=!1,/**
         * Horizontal acceleration applied to emitted particles, in pixels per second squared.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#accelerationX
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 0
         * @since 3.0.0
         */this.accelerationX=new h(e,"accelerationX",0,!0),/**
         * Vertical acceleration applied to emitted particles, in pixels per second squared.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#accelerationY
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 0
         * @since 3.0.0
         */this.accelerationY=new h(e,"accelerationY",0,!0),/**
         * The maximum horizontal velocity of emitted particles, in pixels per second squared.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#maxVelocityX
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 10000
         * @since 3.0.0
         */this.maxVelocityX=new h(e,"maxVelocityX",1e4,!0),/**
         * The maximum vertical velocity of emitted particles, in pixels per second squared.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#maxVelocityY
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 10000
         * @since 3.0.0
         */this.maxVelocityY=new h(e,"maxVelocityY",1e4,!0),/**
         * The initial horizontal speed of emitted particles, in pixels per second.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#speedX
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 0
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setSpeedX
         */this.speedX=new h(e,"speedX",0,!0),/**
         * The initial vertical speed of emitted particles, in pixels per second.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#speedY
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 0
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setSpeedY
         */this.speedY=new h(e,"speedY",0,!0),/**
         * Whether moveToX and moveToY are nonzero. Set automatically during configuration.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#moveTo
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.moveTo=!1,/**
         * The x-coordinate emitted particles move toward, when {@link Phaser.GameObjects.Particles.ParticleEmitter#moveTo} is true.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#moveToX
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 0
         * @since 3.0.0
         */this.moveToX=new h(e,"moveToX",0,!0),/**
         * The y-coordinate emitted particles move toward, when {@link Phaser.GameObjects.Particles.ParticleEmitter#moveTo} is true.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#moveToY
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 0
         * @since 3.0.0
         */this.moveToY=new h(e,"moveToY",0,!0),/**
         * Whether particles will rebound when they meet the emitter bounds.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#bounce
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 0
         * @since 3.0.0
         */this.bounce=new h(e,"bounce",0,!0),/**
         * The horizontal scale of emitted particles.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#scaleX
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 1
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setScale
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setScaleX
         */this.scaleX=new h(e,"scaleX",1),/**
         * The vertical scale of emitted particles.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#scaleY
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 1
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setScale
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setScaleY
         */this.scaleY=new h(e,"scaleY",1),/**
         * Color tint applied to emitted particles. Any alpha component (0xAA000000) is ignored.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#tint
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 0xffffffff
         * @since 3.0.0
         */this.tint=new h(e,"tint",4294967295),/**
         * The alpha (transparency) of emitted particles.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#alpha
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 1
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setAlpha
         */this.alpha=new h(e,"alpha",1),/**
         * The lifespan of emitted particles, in ms.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#lifespan
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 1000
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setLifespan
         */this.lifespan=new h(e,"lifespan",1e3,!0),/**
         * The angle of the initial velocity of emitted particles, in degrees.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#angle
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default { min: 0, max: 360 }
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setAngle
         */this.angle=new h(e,"angle",{min:0,max:360},!0),/**
         * The rotation of emitted particles, in degrees.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#rotate
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 0
         * @since 3.0.0
         */this.rotate=new h(e,"rotate",0),/**
         * A function to call when a particle is emitted.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#emitCallback
         * @type {?Phaser.Types.GameObjects.Particles.ParticleEmitterCallback}
         * @default null
         * @since 3.0.0
         */this.emitCallback=null,/**
         * The calling context for {@link Phaser.GameObjects.Particles.ParticleEmitter#emitCallback}.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#emitCallbackScope
         * @type {?*}
         * @default null
         * @since 3.0.0
         */this.emitCallbackScope=null,/**
         * A function to call when a particle dies.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#deathCallback
         * @type {?Phaser.Types.GameObjects.Particles.ParticleDeathCallback}
         * @default null
         * @since 3.0.0
         */this.deathCallback=null,/**
         * The calling context for {@link Phaser.GameObjects.Particles.ParticleEmitter#deathCallback}.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#deathCallbackScope
         * @type {?*}
         * @default null
         * @since 3.0.0
         */this.deathCallbackScope=null,/**
         * Set to hard limit the amount of particle objects this emitter is allowed to create.
         * 0 means unlimited.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#maxParticles
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.maxParticles=0,/**
         * How many particles are emitted each time particles are emitted (one explosion or one flow cycle).
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#quantity
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 1
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrequency
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setQuantity
         */this.quantity=new h(e,"quantity",1,!0),/**
         * How many ms to wait after emission before the particles start updating.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#delay
         * @type {Phaser.GameObjects.Particles.EmitterOp}
         * @default 0
         * @since 3.0.0
         */this.delay=new h(e,"delay",0,!0),/**
         * For a flow emitter, the time interval (>= 0) between particle flow cycles in ms.
         * A value of 0 means there is one particle flow cycle for each logic update (the maximum flow frequency). This is the default setting.
         * For an exploding emitter, this value will be -1.
         * Calling {@link Phaser.GameObjects.Particles.ParticleEmitter#flow} also puts the emitter in flow mode (frequency >= 0).
         * Calling {@link Phaser.GameObjects.Particles.ParticleEmitter#explode} also puts the emitter in explode mode (frequency = -1).
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#frequency
         * @type {number}
         * @default 0
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrequency
         */this.frequency=0,/**
         * Controls if the emitter is currently emitting a particle flow (when frequency >= 0).
         * Already alive particles will continue to update until they expire.
         * Controlled by {@link Phaser.GameObjects.Particles.ParticleEmitter#start} and {@link Phaser.GameObjects.Particles.ParticleEmitter#stop}.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#on
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.on=!0,/**
         * Newly emitted particles are added to the top of the particle list, i.e. rendered above those already alive.
         * Set to false to send them to the back.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#particleBringToTop
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.particleBringToTop=!0,/**
         * The time rate applied to active particles, affecting lifespan, movement, and tweens. Values larger than 1 are faster than normal.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#timeScale
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.timeScale=1,/**
         * An object describing a shape to emit particles from.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#emitZone
         * @type {?Phaser.GameObjects.Particles.Zones.EdgeZone|Phaser.GameObjects.Particles.Zones.RandomZone}
         * @default null
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setEmitZone
         */this.emitZone=null,/**
         * An object describing a shape that deactivates particles when they interact with it.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#deathZone
         * @type {?Phaser.GameObjects.Particles.Zones.DeathZone}
         * @default null
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setDeathZone
         */this.deathZone=null,/**
         * A rectangular boundary constraining particle movement.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#bounds
         * @type {?Phaser.Geom.Rectangle}
         * @default null
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setBounds
         */this.bounds=null,/**
         * Whether particles interact with the left edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideLeft
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.collideLeft=!0,/**
         * Whether particles interact with the right edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideRight
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.collideRight=!0,/**
         * Whether particles interact with the top edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideTop
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.collideTop=!0,/**
         * Whether particles interact with the bottom edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideBottom
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.collideBottom=!0,/**
         * Whether this emitter updates itself and its particles.
         *
         * Controlled by {@link Phaser.GameObjects.Particles.ParticleEmitter#pause}
         * and {@link Phaser.GameObjects.Particles.ParticleEmitter#resume}.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#active
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.active=!0,/**
         * Set this to false to hide any active particles.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#visible
         * @type {boolean}
         * @default true
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setVisible
         */this.visible=!0,/**
         * The blend mode of this emitter's particles.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#blendMode
         * @type {integer}
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setBlendMode
         */this.blendMode=i.NORMAL,/**
         * A Game Object whose position is used as the particle origin.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#follow
         * @type {?Phaser.GameObjects.GameObject}
         * @default null
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#startFollow
         * @see Phaser.GameObjects.Particles.ParticleEmitter#stopFollow
         */this.follow=null,/**
         * The offset of the particle origin from the {@link Phaser.GameObjects.Particles.ParticleEmitter#follow} target.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#followOffset
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#startFollow
         */this.followOffset=new m,/**
         * Whether the emitter's {@link Phaser.GameObjects.Particles.ParticleEmitter#visible} state will track
         * the {@link Phaser.GameObjects.Particles.ParticleEmitter#follow} target's visibility state.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#trackVisible
         * @type {boolean}
         * @default false
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#startFollow
         */this.trackVisible=!1,/**
         * The current texture frame, as an index of {@link Phaser.GameObjects.Particles.ParticleEmitter#frames}.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#currentFrame
         * @type {integer}
         * @default 0
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrame
         */this.currentFrame=0,/**
         * Whether texture {@link Phaser.GameObjects.Particles.ParticleEmitter#frames} are selected at random.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#randomFrame
         * @type {boolean}
         * @default true
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrame
         */this.randomFrame=!0,/**
         * The number of consecutive particles that receive a single texture frame (per frame cycle).
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#frameQuantity
         * @type {integer}
         * @default 1
         * @since 3.0.0
         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrame
         */this.frameQuantity=1,/**
         * Inactive particles.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#dead
         * @type {Phaser.GameObjects.Particles.Particle[]}
         * @private
         * @since 3.0.0
         */this.dead=[],/**
         * Active particles
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#alive
         * @type {Phaser.GameObjects.Particles.Particle[]}
         * @private
         * @since 3.0.0
         */this.alive=[],/**
         * The time until the next flow cycle.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#_counter
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._counter=0,/**
         * Counts up to {@link Phaser.GameObjects.Particles.ParticleEmitter#frameQuantity}.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitter#_frameCounter
         * @type {integer}
         * @private
         * @default 0
         * @since 3.0.0
         */this._frameCounter=0,e&&this.fromJSON(e)},/**
     * Merges configuration settings into the emitter's current settings.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#fromJSON
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} config - Settings for this emitter.
     *
     * @return {this} This Particle Emitter.
     */fromJSON:function(t){if(!t)return this;//  Only update properties from their current state if they exist in the given config
var e=0,i="";for(e=0;e<this.configFastMap.length;e++)d(t,i=this.configFastMap[e])&&(this[i]=l(t,i));for(e=0;e<this.configOpMap.length;e++)d(t,i=this.configOpMap[e])&&this[i].loadConfig(t);if(this.acceleration=0!==this.accelerationX.propertyValue||0!==this.accelerationY.propertyValue,this.moveTo=0!==this.moveToX.propertyValue||0!==this.moveToY.propertyValue,d(t,"speed")&&(this.speedX.loadConfig(t,"speed"),this.speedY=null),(c(t,["speedX","speedY"])||this.moveTo)&&(this.radial=!1),d(t,"scale")&&(this.scaleX.loadConfig(t,"scale"),this.scaleY=null),d(t,"callbackScope")){var n=l(t,"callbackScope",null);this.emitCallbackScope=n,this.deathCallbackScope=n}return d(t,"emitZone")&&this.setEmitZone(t.emitZone),d(t,"deathZone")&&this.setDeathZone(t.deathZone),d(t,"bounds")&&this.setBounds(t.bounds),d(t,"followOffset")&&this.followOffset.setFromObject(l(t,"followOffset",0)),d(t,"frame")&&this.setFrame(t.frame),this},/**
     * Creates a description of this emitter suitable for JSON serialization.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#toJSON
     * @since 3.0.0
     *
     * @param {object} [output] - An object to copy output into.
     *
     * @return {object} - The output object.
     */toJSON:function(t){void 0===t&&(t={});var e=0,i="";for(e=0;e<this.configFastMap.length;e++)t[i=this.configFastMap[e]]=this[i];for(e=0;e<this.configOpMap.length;e++)this[i=this.configOpMap[e]]&&(t[i]=this[i].toJSON());return this.speedY||(delete t.speedX,t.speed=this.speedX.toJSON()),this.scaleY||(delete t.scaleX,t.scale=this.scaleX.toJSON()),t},/**
     * Continuously moves the particle origin to follow a Game Object's position.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#startFollow
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} target - The Game Object to follow.
     * @param {number} [offsetX=0] - Horizontal offset of the particle origin from the Game Object.
     * @param {number} [offsetY=0] - Vertical offset of the particle origin from the Game Object.
     * @param {boolean} [trackVisible=false] - Whether the emitter's visible state will track the target's visible state.
     *
     * @return {this} This Particle Emitter.
     */startFollow:function(t,e,i,n){return void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=!1),this.follow=t,this.followOffset.set(e,i),this.trackVisible=n,this},/**
     * Stops following a Game Object.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#stopFollow
     * @since 3.0.0
     *
     * @return {this} This Particle Emitter.
     */stopFollow:function(){return this.follow=null,this.followOffset.set(0,0),this.trackVisible=!1,this},/**
     * Chooses a texture frame from {@link Phaser.GameObjects.Particles.ParticleEmitter#frames}.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#getFrame
     * @since 3.0.0
     *
     * @return {Phaser.Textures.Frame} The texture frame.
     */getFrame:function(){if(1===this.frames.length)return this.defaultFrame;if(this.randomFrame)return u(this.frames);var t=this.frames[this.currentFrame];return this._frameCounter++,this._frameCounter===this.frameQuantity&&(this._frameCounter=0,this.currentFrame=y(this.currentFrame+1,0,this._frameLength)),t},// frame: 0
// frame: 'red'
// frame: [ 0, 1, 2, 3 ]
// frame: [ 'red', 'green', 'blue', 'pink', 'white' ]
// frame: { frames: [ 'red', 'green', 'blue', 'pink', 'white' ], [cycle: bool], [quantity: int] }
/**
     * Sets a pattern for assigning texture frames to emitted particles.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setFrame
     * @since 3.0.0
     *
     * @param {(array|string|integer|Phaser.Types.GameObjects.Particles.ParticleEmitterFrameConfig)} frames - One or more texture frames, or a configuration object.
     * @param {boolean} [pickRandom=true] - Whether frames should be assigned at random from `frames`.
     * @param {integer} [quantity=1] - The number of consecutive particles that will receive each frame.
     *
     * @return {this} This Particle Emitter.
     */setFrame:function(t,e,i){void 0===e&&(e=!0),void 0===i&&(i=1),this.randomFrame=e,this.frameQuantity=i,this.currentFrame=0,this._frameCounter=0;var n=typeof t;if(Array.isArray(t)||"string"===n||"number"===n)this.manager.setEmitterFrames(t,this);else if("object"===n){var s=t;(t=l(s,"frames",null))&&this.manager.setEmitterFrames(t,this);var r=l(s,"cycle",!1);this.randomFrame=!r,this.frameQuantity=l(s,"quantity",i)}return this._frameLength=this.frames.length,1===this._frameLength&&(this.frameQuantity=1,this.randomFrame=!1),this},/**
     * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle movement on or off.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setRadial
     * @since 3.0.0
     *
     * @param {boolean} [value=true] - Radial mode (true) or point mode (true).
     *
     * @return {this} This Particle Emitter.
     */setRadial:function(t){return void 0===t&&(t=!0),this.radial=t,this},/**
     * Sets the position of the emitter's particle origin.
     * New particles will be emitted here.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setPosition
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} x - The x-coordinate of the particle origin.
     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} y - The y-coordinate of the particle origin.
     *
     * @return {this} This Particle Emitter.
     */setPosition:function(t,e){return this.x.onChange(t),this.y.onChange(e),this},/**
     * Sets or modifies a rectangular boundary constraining the particles.
     *
     * To remove the boundary, set {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds} to null.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setBounds
     * @since 3.0.0
     *
     * @param {(number|Phaser.Types.GameObjects.Particles.ParticleEmitterBounds|Phaser.Types.GameObjects.Particles.ParticleEmitterBoundsAlt)} x - The x-coordinate of the left edge of the boundary, or an object representing a rectangle.
     * @param {number} y - The y-coordinate of the top edge of the boundary.
     * @param {number} width - The width of the boundary.
     * @param {number} height - The height of the boundary.
     *
     * @return {this} This Particle Emitter.
     */setBounds:function(t,e,i,n){if("object"==typeof t){var s=t;t=s.x,e=s.y,i=d(s,"w")?s.w:s.width,n=d(s,"h")?s.h:s.height}return this.bounds?this.bounds.setTo(t,e,i,n):this.bounds=new g(t,e,i,n),this},/**
     * Sets the initial horizontal speed of emitted particles.
     * Changes the emitter to point mode.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setSpeedX
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The speed, in pixels per second.
     *
     * @return {this} This Particle Emitter.
     */setSpeedX:function(t){return this.speedX.onChange(t),//  If you specify speedX and Y then it changes the emitter from radial to a point emitter
this.radial=!1,this},/**
     * Sets the initial vertical speed of emitted particles.
     * Changes the emitter to point mode.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setSpeedY
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The speed, in pixels per second.
     *
     * @return {this} This Particle Emitter.
     */setSpeedY:function(t){return this.speedY&&(this.speedY.onChange(t),//  If you specify speedX and Y then it changes the emitter from radial to a point emitter
this.radial=!1),this},/**
     * Sets the initial radial speed of emitted particles.
     * Changes the emitter to radial mode.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setSpeed
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The speed, in pixels per second.
     *
     * @return {this} This Particle Emitter.
     */setSpeed:function(t){return this.speedX.onChange(t),this.speedY=null,//  If you specify speedX and Y then it changes the emitter from radial to a point emitter
this.radial=!0,this},/**
     * Sets the horizontal scale of emitted particles.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setScaleX
     * @since 3.0.0
     *
     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - The scale, relative to 1.
     *
     * @return {this} This Particle Emitter.
     */setScaleX:function(t){return this.scaleX.onChange(t),this},/**
     * Sets the vertical scale of emitted particles.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setScaleY
     * @since 3.0.0
     *
     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - The scale, relative to 1.
     *
     * @return {this} This Particle Emitter.
     */setScaleY:function(t){return this.scaleY.onChange(t),this},/**
     * Sets the scale of emitted particles.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setScale
     * @since 3.0.0
     *
     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - The scale, relative to 1.
     *
     * @return {this} This Particle Emitter.
     */setScale:function(t){return this.scaleX.onChange(t),this.scaleY=null,this},/**
     * Sets the horizontal gravity applied to emitted particles.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setGravityX
     * @since 3.0.0
     *
     * @param {number} value - Acceleration due to gravity, in pixels per second squared.
     *
     * @return {this} This Particle Emitter.
     */setGravityX:function(t){return this.gravityX=t,this},/**
     * Sets the vertical gravity applied to emitted particles.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setGravityY
     * @since 3.0.0
     *
     * @param {number} value - Acceleration due to gravity, in pixels per second squared.
     *
     * @return {this} This Particle Emitter.
     */setGravityY:function(t){return this.gravityY=t,this},/**
     * Sets the gravity applied to emitted particles.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setGravity
     * @since 3.0.0
     *
     * @param {number} x - Horizontal acceleration due to gravity, in pixels per second squared.
     * @param {number} y - Vertical acceleration due to gravity, in pixels per second squared.
     *
     * @return {this} This Particle Emitter.
     */setGravity:function(t,e){return this.gravityX=t,this.gravityY=e,this},/**
     * Sets the opacity of emitted particles.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setAlpha
     * @since 3.0.0
     *
     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - A value between 0 (transparent) and 1 (opaque).
     *
     * @return {this} This Particle Emitter.
     */setAlpha:function(t){return this.alpha.onChange(t),this},/**
     * Sets the color tint of emitted particles.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setTint
     * @since 3.22.0
     *
     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - A value between 0 and 0xffffff.
     *
     * @return {this} This Particle Emitter.
     */setTint:function(t){return this.tint.onChange(t),this},/**
     * Sets the angle of a {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle stream.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setEmitterAngle
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The angle of the initial velocity of emitted particles.
     *
     * @return {this} This Particle Emitter.
     */setEmitterAngle:function(t){return this.angle.onChange(t),this},/**
     * Sets the angle of a {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle stream.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setAngle
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The angle of the initial velocity of emitted particles.
     *
     * @return {this} This Particle Emitter.
     */setAngle:function(t){return this.angle.onChange(t),this},/**
     * Sets the lifespan of newly emitted particles.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setLifespan
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The particle lifespan, in ms.
     *
     * @return {this} This Particle Emitter.
     */setLifespan:function(t){return this.lifespan.onChange(t),this},/**
     * Sets the number of particles released at each flow cycle or explosion.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setQuantity
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} quantity - The number of particles to release at each flow cycle or explosion.
     *
     * @return {this} This Particle Emitter.
     */setQuantity:function(t){return this.quantity.onChange(t),this},/**
     * Sets the emitter's {@link Phaser.GameObjects.Particles.ParticleEmitter#frequency}
     * and {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setFrequency
     * @since 3.0.0
     *
     * @param {number} frequency - The time interval (>= 0) of each flow cycle, in ms; or -1 to put the emitter in explosion mode.
     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} [quantity] - The number of particles to release at each flow cycle or explosion.
     *
     * @return {this} This Particle Emitter.
     */setFrequency:function(t,e){return this.frequency=t,this._counter=0,e&&this.quantity.onChange(e),this},/**
     * Sets or removes the {@link Phaser.GameObjects.Particles.ParticleEmitter#emitZone}.
     *
     * An {@link Phaser.Types.GameObjects.Particles.ParticleEmitterEdgeZoneConfig EdgeZone} places particles on its edges. Its {@link Phaser.Types.GameObjects.Particles.EdgeZoneSource source} can be a Curve, Path, Circle, Ellipse, Line, Polygon, Rectangle, or Triangle; or any object with a suitable {@link Phaser.Types.GameObjects.Particles.EdgeZoneSourceCallback getPoints} method.
     *
     * A {@link Phaser.Types.GameObjects.Particles.ParticleEmitterRandomZoneConfig RandomZone} places randomly within its interior. Its {@link RandomZoneSource source} can be a Circle, Ellipse, Line, Polygon, Rectangle, or Triangle; or any object with a suitable {@link Phaser.Types.GameObjects.Particles.RandomZoneSourceCallback getRandomPoint} method.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setEmitZone
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterEdgeZoneConfig|Phaser.Types.GameObjects.Particles.ParticleEmitterRandomZoneConfig} [zoneConfig] - An object describing the zone, or `undefined` to remove any current emit zone.
     *
     * @return {this} This Particle Emitter.
     */setEmitZone:function(t){if(void 0===t)this.emitZone=null;else{//  Where source = Geom like Circle, or a Path or Curve
//  emitZone: { type: 'random', source: X }
//  emitZone: { type: 'edge', source: X, quantity: 32, [stepRate=0], [yoyo=false], [seamless=true] }
var e=l(t,"type","random"),i=l(t,"source",null);switch(e){case"random":this.emitZone=new p(i);break;case"edge":var n=l(t,"quantity",1),s=l(t,"stepRate",0),r=l(t,"yoyo",!1),o=l(t,"seamless",!0);this.emitZone=new a(i,n,s,r,o)}}return this},/**
     * Sets or removes the {@link Phaser.GameObjects.Particles.ParticleEmitter#deathZone}.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#setDeathZone
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterDeathZoneConfig} [zoneConfig] - An object describing the zone, or `undefined` to remove any current death zone.
     *
     * @return {this} This Particle Emitter.
     */setDeathZone:function(t){if(void 0===t)this.deathZone=null;else{//  Where source = Geom like Circle or Rect that supports a 'contains' function
//  deathZone: { type: 'onEnter', source: X }
//  deathZone: { type: 'onLeave', source: X }
var e=l(t,"type","onEnter"),i=l(t,"source",null);i&&"function"==typeof i.contains&&(this.deathZone=new o(i,"onEnter"===e))}return this},/**
     * Creates inactive particles and adds them to this emitter's pool.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#reserve
     * @since 3.0.0
     *
     * @param {integer} particleCount - The number of particles to create.
     *
     * @return {this} This Particle Emitter.
     */reserve:function(t){for(var e=this.dead,i=0;i<t;i++)e.push(new this.particleClass(this));return this},/**
     * Gets the number of active (in-use) particles in this emitter.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#getAliveParticleCount
     * @since 3.0.0
     *
     * @return {integer} The number of particles with `active=true`.
     */getAliveParticleCount:function(){return this.alive.length},/**
     * Gets the number of inactive (available) particles in this emitter.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#getDeadParticleCount
     * @since 3.0.0
     *
     * @return {integer} The number of particles with `active=false`.
     */getDeadParticleCount:function(){return this.dead.length},/**
     * Gets the total number of particles in this emitter.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#getParticleCount
     * @since 3.0.0
     *
     * @return {integer} The number of particles, including both alive and dead.
     */getParticleCount:function(){return this.getAliveParticleCount()+this.getDeadParticleCount()},/**
     * Whether this emitter is at its limit (if set).
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#atLimit
     * @since 3.0.0
     *
     * @return {boolean} Returns `true` if this Emitter is at its limit, or `false` if no limit, or below the `maxParticles` level.
     */atLimit:function(){return this.maxParticles>0&&this.getParticleCount()===this.maxParticles},/**
     * Sets a function to call for each newly emitted particle.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#onParticleEmit
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterCallback} callback - The function.
     * @param {*} [context] - The calling context.
     *
     * @return {this} This Particle Emitter.
     */onParticleEmit:function(t,e){return void 0===t?(//  Clear any previously set callback
this.emitCallback=null,this.emitCallbackScope=null):"function"==typeof t&&(this.emitCallback=t,e&&(this.emitCallbackScope=e)),this},/**
     * Sets a function to call for each particle death.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#onParticleDeath
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.ParticleDeathCallback} callback - The function.
     * @param {*} [context] - The function's calling context.
     *
     * @return {this} This Particle Emitter.
     */onParticleDeath:function(t,e){return void 0===t?(//  Clear any previously set callback
this.deathCallback=null,this.deathCallbackScope=null):"function"==typeof t&&(this.deathCallback=t,e&&(this.deathCallbackScope=e)),this},/**
     * Deactivates every particle in this emitter.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#killAll
     * @since 3.0.0
     *
     * @return {this} This Particle Emitter.
     */killAll:function(){for(var t=this.dead,e=this.alive;e.length>0;)t.push(e.pop());return this},/**
     * Calls a function for each active particle in this emitter.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#forEachAlive
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterCallback} callback - The function.
     * @param {*} context - The function's calling context.
     *
     * @return {this} This Particle Emitter.
     */forEachAlive:function(t,e){for(var i=this.alive,n=i.length,s=0;s<n;++s)t.call(e,i[s],this);return this},/**
     * Calls a function for each inactive particle in this emitter.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#forEachDead
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterCallback} callback - The function.
     * @param {*} context - The function's calling context.
     *
     * @return {this} This Particle Emitter.
     */forEachDead:function(t,e){for(var i=this.dead,n=i.length,s=0;s<n;++s)t.call(e,i[s],this);return this},/**
     * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#on} the emitter and resets the flow counter.
     *
     * If this emitter is in flow mode (frequency >= 0; the default), the particle flow will start (or restart).
     *
     * If this emitter is in explode mode (frequency = -1), nothing will happen.
     * Use {@link Phaser.GameObjects.Particles.ParticleEmitter#explode} or {@link Phaser.GameObjects.Particles.ParticleEmitter#flow} instead.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#start
     * @since 3.0.0
     *
     * @return {this} This Particle Emitter.
     */start:function(){return this.on=!0,this._counter=0,this},/**
     * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#on off} the emitter.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#stop
     * @since 3.11.0
     *
     * @return {this} This Particle Emitter.
     */stop:function(){return this.on=!1,this},/**
     * {@link Phaser.GameObjects.Particles.ParticleEmitter#active Deactivates} the emitter.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#pause
     * @since 3.0.0
     *
     * @return {this} This Particle Emitter.
     */pause:function(){return this.active=!1,this},/**
     * {@link Phaser.GameObjects.Particles.ParticleEmitter#active Activates} the emitter.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#resume
     * @since 3.0.0
     *
     * @return {this} This Particle Emitter.
     */resume:function(){return this.active=!0,this},/**
     * Removes the emitter from its manager and the scene.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#remove
     * @since 3.22.0
     *
     * @return {this} This Particle Emitter.
     */remove:function(){return this.manager.removeEmitter(this),this},/**
     * Sorts active particles with {@link Phaser.GameObjects.Particles.ParticleEmitter#depthSortCallback}.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#depthSort
     * @since 3.0.0
     *
     * @return {this} This Particle Emitter.
     */depthSort:function(){return v.inplace(this.alive,this.depthSortCallback),this},/**
     * Puts the emitter in flow mode (frequency >= 0) and starts (or restarts) a particle flow.
     *
     * To resume a flow at the current frequency and quantity, use {@link Phaser.GameObjects.Particles.ParticleEmitter#start} instead.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#flow
     * @since 3.0.0
     *
     * @param {number} frequency - The time interval (>= 0) of each flow cycle, in ms.
     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} [count=1] - The number of particles to emit at each flow cycle.
     *
     * @return {this} This Particle Emitter.
     */flow:function(t,e){return void 0===e&&(e=1),this.frequency=t,this.quantity.onChange(e),this.start()},/**
     * Puts the emitter in explode mode (frequency = -1), stopping any current particle flow, and emits several particles all at once.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#explode
     * @since 3.0.0
     *
     * @param {integer} count - The amount of Particles to emit.
     * @param {number} x - The x coordinate to emit the Particles from.
     * @param {number} y - The y coordinate to emit the Particles from.
     *
     * @return {Phaser.GameObjects.Particles.Particle} The most recently emitted Particle.
     */explode:function(t,e,i){return this.frequency=-1,this.emitParticle(t,e,i)},/**
     * Emits particles at a given position (or the emitter's current position).
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#emitParticleAt
     * @since 3.0.0
     *
     * @param {number} [x=this.x] - The x coordinate to emit the Particles from.
     * @param {number} [y=this.x] - The y coordinate to emit the Particles from.
     * @param {integer} [count=this.quantity] - The number of Particles to emit.
     *
     * @return {Phaser.GameObjects.Particles.Particle} The most recently emitted Particle.
     */emitParticleAt:function(t,e,i){return this.emitParticle(i,t,e)},/**
     * Emits particles at a given position (or the emitter's current position).
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#emitParticle
     * @since 3.0.0
     *
     * @param {integer} [count=this.quantity] - The number of Particles to emit.
     * @param {number} [x=this.x] - The x coordinate to emit the Particles from.
     * @param {number} [y=this.x] - The y coordinate to emit the Particles from.
     *
     * @return {Phaser.GameObjects.Particles.Particle} The most recently emitted Particle.
     *
     * @see Phaser.GameObjects.Particles.Particle#fire
     */emitParticle:function(t,e,i){if(!this.atLimit()){void 0===t&&(t=this.quantity.onEmit());for(var n=this.dead,s=0;s<t;s++){var r=n.pop();if(r||(r=new this.particleClass(this)),r.fire(e,i),this.particleBringToTop?this.alive.push(r):this.alive.unshift(r),this.emitCallback&&this.emitCallback.call(this.emitCallbackScope,r,this),this.atLimit())break}return r}},/**
     * Updates this emitter and its particles.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#preUpdate
     * @since 3.0.0
     *
     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */preUpdate:function(t,e){var i=//  Scale the delta
(e*=this.timeScale)/1e3;this.trackVisible&&(this.visible=this.follow.visible);//  Any particle processors?
var n=this.manager.getProcessors(),s=this.alive,r=this.dead,o=0,a=[],h=s.length;for(o=0;o<h;o++){var l=s[o];//  update returns `true` if the particle is now dead (lifeCurrent <= 0)
l.update(e,i,n)&&a.push({index:o,particle:l})}if(//  Move dead particles to the dead array
(h=a.length)>0){var u=this.deathCallback,c=this.deathCallbackScope;for(o=h-1;o>=0;o--){var d=a[o];//  Remove from particles array
s.splice(d.index,1),//  Add to dead array
r.push(d.particle),u&&u.call(c,d.particle),d.particle.resetPosition()}}this.on&&(0===this.frequency?this.emitParticle():this.frequency>0&&(this._counter-=e,this._counter<=0&&(this.emitParticle(),//  counter = frequency - remained from previous delta
this._counter=this.frequency-Math.abs(this._counter))))},/**
     * Calculates the difference of two particles, for sorting them by depth.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitter#depthSortCallback
     * @since 3.0.0
     *
     * @param {object} a - The first particle.
     * @param {object} b - The second particle.
     *
     * @return {integer} The difference of a and b's y coordinates.
     */depthSortCallback:function(t,e){return t.y-e.y}});t.exports=x}),r("bSAIj",function(t,e){/**
 * @classdesc
 * A Death Zone.
 *
 * A Death Zone is a special type of zone that will kill a Particle as soon as it either enters, or leaves, the zone.
 *
 * The zone consists of a `source` which could be a Geometric shape, such as a Rectangle or Ellipse, or your own
 * object as long as it includes a `contains` method for which the Particles can be tested against.
 *
 * @class DeathZone
 * @memberof Phaser.GameObjects.Particles.Zones
 * @constructor
 * @since 3.0.0
 *
 * @param {Phaser.Types.GameObjects.Particles.DeathZoneSource} source - An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.
 * @param {boolean} killOnEnter - Should the Particle be killed when it enters the zone? `true` or leaves it? `false`
 */var i=new(s("jwj1g"))({initialize:function(t,e){/**
         * An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.
         * This could be a Geometry shape, such as `Phaser.Geom.Circle`, or your own custom object.
         *
         * @name Phaser.GameObjects.Particles.Zones.DeathZone#source
         * @type {Phaser.Types.GameObjects.Particles.DeathZoneSource}
         * @since 3.0.0
         */this.source=t,/**
         * Set to `true` if the Particle should be killed if it enters this zone.
         * Set to `false` to kill the Particle if it leaves this zone.
         *
         * @name Phaser.GameObjects.Particles.Zones.DeathZone#killOnEnter
         * @type {boolean}
         * @since 3.0.0
         */this.killOnEnter=e},/**
     * Checks if the given Particle will be killed or not by this zone.
     *
     * @method Phaser.GameObjects.Particles.Zones.DeathZone#willKill
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle to be checked against this zone.
     *
     * @return {boolean} Return `true` if the Particle is to be killed, otherwise return `false`.
     */willKill:function(t){var e=this.source.contains(t.x,t.y);return e&&this.killOnEnter||!e&&!this.killOnEnter}});t.exports=i}),r("g6KAN",function(t,e){/**
 * @classdesc
 * A zone that places particles on a shape's edges.
 *
 * @class EdgeZone
 * @memberof Phaser.GameObjects.Particles.Zones
 * @constructor
 * @since 3.0.0
 *
 * @param {Phaser.Types.GameObjects.Particles.EdgeZoneSource} source - An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.
 * @param {integer} quantity - The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.
 * @param {number} stepRate - The distance between each particle. When set, `quantity` is implied and should be set to 0.
 * @param {boolean} [yoyo=false] - Whether particles are placed from start to end and then end to start.
 * @param {boolean} [seamless=true] - Whether one endpoint will be removed if it's identical to the other.
 */var i=new(s("jwj1g"))({initialize:function(t,e,i,n,s){void 0===n&&(n=!1),void 0===s&&(s=!0),/**
         * An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.
         *
         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#source
         * @type {Phaser.Types.GameObjects.Particles.EdgeZoneSource|Phaser.Types.GameObjects.Particles.RandomZoneSource}
         * @since 3.0.0
         */this.source=t,/**
         * The points placed on the source edge.
         *
         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#points
         * @type {Phaser.Geom.Point[]}
         * @default []
         * @since 3.0.0
         */this.points=[],/**
         * The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.
         *
         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#quantity
         * @type {integer}
         * @since 3.0.0
         */this.quantity=e,/**
         * The distance between each particle. When set, `quantity` is implied and should be set to 0.
         *
         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#stepRate
         * @type {number}
         * @since 3.0.0
         */this.stepRate=i,/**
         * Whether particles are placed from start to end and then end to start.
         *
         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#yoyo
         * @type {boolean}
         * @since 3.0.0
         */this.yoyo=n,/**
         * The counter used for iterating the EdgeZone's points.
         *
         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#counter
         * @type {number}
         * @default -1
         * @since 3.0.0
         */this.counter=-1,/**
         * Whether one endpoint will be removed if it's identical to the other.
         *
         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#seamless
         * @type {boolean}
         * @since 3.0.0
         */this.seamless=s,/**
         * An internal count of the points belonging to this EdgeZone.
         *
         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_length
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._length=0,/**
         * An internal value used to keep track of the current iteration direction for the EdgeZone's points.
         *
         * 0 = forwards, 1 = backwards
         *
         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_direction
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._direction=0,this.updateSource()},/**
     * Update the {@link Phaser.GameObjects.Particles.Zones.EdgeZone#points} from the EdgeZone's
     * {@link Phaser.GameObjects.Particles.Zones.EdgeZone#source}.
     *
     * Also updates internal properties.
     *
     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#updateSource
     * @since 3.0.0
     *
     * @return {this} This Edge Zone.
     */updateSource:function(){//  Remove ends?
if(this.points=this.source.getPoints(this.quantity,this.stepRate),this.seamless){var t=this.points[0],e=this.points[this.points.length-1];t.x===e.x&&t.y===e.y&&this.points.pop()}var i=this._length;return this._length=this.points.length,this._length<i&&this.counter>this._length&&(this.counter=this._length-1),this},/**
     * Change the source of the EdgeZone.
     *
     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#changeSource
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.EdgeZoneSource} source - An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.
     *
     * @return {this} This Edge Zone.
     */changeSource:function(t){return this.source=t,this.updateSource()},/**
     * Get the next point in the Zone and set its coordinates on the given Particle.
     *
     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#getPoint
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle.
     */getPoint:function(t){0===this._direction?(this.counter++,this.counter>=this._length&&(this.yoyo?(this._direction=1,this.counter=this._length-1):this.counter=0)):(this.counter--,-1===this.counter&&(this.yoyo?(this._direction=0,this.counter=0):this.counter=this._length-1));var e=this.points[this.counter];e&&(t.x=e.x,t.y=e.y)}});t.exports=i}),r("5j1iP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("ilYgh"),r=s("aANNX"),o=s("7BSWl"),a=s("8qWuA"),h=new i({initialize:function(t,e,i,n){void 0===n&&(n=!1),/**
         * The name of this property.
         *
         * @name Phaser.GameObjects.Particles.EmitterOp#propertyKey
         * @type {string}
         * @since 3.0.0
         */this.propertyKey=e,/**
         * The value of this property.
         *
         * @name Phaser.GameObjects.Particles.EmitterOp#propertyValue
         * @type {number}
         * @since 3.0.0
         */this.propertyValue=i,/**
         * The default value of this property.
         *
         * @name Phaser.GameObjects.Particles.EmitterOp#defaultValue
         * @type {number}
         * @since 3.0.0
         */this.defaultValue=i,/**
         * The number of steps for stepped easing between {@link Phaser.GameObjects.Particles.EmitterOp#start} and
         * {@link Phaser.GameObjects.Particles.EmitterOp#end} values, per emit.
         *
         * @name Phaser.GameObjects.Particles.EmitterOp#steps
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.steps=0,/**
         * The step counter for stepped easing, per emit.
         *
         * @name Phaser.GameObjects.Particles.EmitterOp#counter
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.counter=0,/**
         * The start value for this property to ease between.
         *
         * @name Phaser.GameObjects.Particles.EmitterOp#start
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.start=0,/**
         * The end value for this property to ease between.
         *
         * @name Phaser.GameObjects.Particles.EmitterOp#end
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.end=0,/**
         * The easing function to use for updating this property.
         *
         * @name Phaser.GameObjects.Particles.EmitterOp#ease
         * @type {?function}
         * @since 3.0.0
         */this.ease,/**
         * Whether this property can only be modified when a Particle is emitted.
         *
         * Set to `true` to allow only {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} callbacks to be set and
         * affect this property.
         *
         * Set to `false` to allow both {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and
         * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks to be set and affect this property.
         *
         * @name Phaser.GameObjects.Particles.EmitterOp#emitOnly
         * @type {boolean}
         * @since 3.0.0
         */this.emitOnly=n,/**
         * The callback to run for Particles when they are emitted from the Particle Emitter.
         *
         * @name Phaser.GameObjects.Particles.EmitterOp#onEmit
         * @type {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitCallback}
         * @since 3.0.0
         */this.onEmit=this.defaultEmit,/**
         * The callback to run for Particles when they are updated.
         *
         * @name Phaser.GameObjects.Particles.EmitterOp#onUpdate
         * @type {Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateCallback}
         * @since 3.0.0
         */this.onUpdate=this.defaultUpdate,this.loadConfig(t)},/**
     * Load the property from a Particle Emitter configuration object.
     *
     * Optionally accepts a new property key to use, replacing the current one.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#loadConfig
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} [config] - Settings for the Particle Emitter that owns this property.
     * @param {string} [newKey] - The new key to use for this property, if any.
     */loadConfig:function(t,e){void 0===t&&(t={}),e&&(this.propertyKey=e),this.propertyValue=o(t,this.propertyKey,this.defaultValue),this.setMethods(),this.emitOnly&&(this.onUpdate=this.defaultUpdate)},/**
     * Build a JSON representation of this Particle Emitter property.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#toJSON
     * @since 3.0.0
     *
     * @return {object} A JSON representation of this Particle Emitter property.
     */toJSON:function(){return this.propertyValue},/**
     * Change the current value of the property and update its callback methods.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#onChange
     * @since 3.0.0
     *
     * @param {number} value - The value of the property.
     *
     * @return {this} This Emitter Op object.
     */onChange:function(t){return this.propertyValue=t,this.setMethods()},/**
     * Update the {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and
     * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks based on the type of the current
     * {@link Phaser.GameObjects.Particles.EmitterOp#propertyValue}.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#setMethods
     * @since 3.0.0
     *
     * @return {this} This Emitter Op object.
     */setMethods:function(){var t=this.propertyValue,e=typeof t;if("number"===e)//  Explicit static value:
//  x: 400
this.onEmit=this.staticValueEmit,this.onUpdate=this.staticValueUpdate;else if(Array.isArray(t))//  x: [ 100, 200, 300, 400 ]
this.onEmit=this.randomStaticValueEmit;else if("function"===e)//  The same as setting just the onUpdate function and no onEmit (unless this op is an emitOnly one)
//  Custom callback, must return a value:
/*
            x: function (particle, key, t, value)
               {
                   return value + 50;
               }
            */this.emitOnly?this.onEmit=t:this.onUpdate=t;else if("object"===e&&(this.has(t,"random")||this.hasBoth(t,"start","end")||this.hasBoth(t,"min","max"))){this.start=this.has(t,"start")?t.start:t.min,this.end=this.has(t,"end")?t.end:t.max;var i=this.hasBoth(t,"min","max")||!!t.random;//  A random starting value (using 'min | max' instead of 'start | end' automatically implies a random value)
//  x: { start: 100, end: 400, random: true } OR { min: 100, max: 400 } OR { random: [ 100, 400 ] }
if(i){var n=t.random;Array.isArray(n)&&(this.start=n[0],this.end=n[1]),this.onEmit=this.randomRangedValueEmit}if(this.has(t,"steps"))//  A stepped (per emit) range
//  x: { start: 100, end: 400, steps: 64 }
//  Increments a value stored in the emitter
this.steps=t.steps,this.counter=this.start,this.onEmit=this.steppedEmit;else{//  An eased range (defaults to Linear if not specified)
//  x: { start: 100, end: 400, [ ease: 'Linear' ] }
var s=this.has(t,"ease")?t.ease:"Linear";this.ease=r(s),i||(this.onEmit=this.easedValueEmit),//  BUG: alpha, rotate, scaleX, scaleY, or tint are eased here if {min, max} is given.
//  Probably this branch should exclude isRandom entirely.
this.onUpdate=this.easeValueUpdate}}else"object"===e&&this.hasEither(t,"onEmit","onUpdate")&&(this.has(t,"onEmit")&&(this.onEmit=t.onEmit),this.has(t,"onUpdate")&&(this.onUpdate=t.onUpdate));return this},/**
     * Check whether an object has the given property.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#has
     * @since 3.0.0
     *
     * @param {object} object - The object to check.
     * @param {string} key - The key of the property to look for in the object.
     *
     * @return {boolean} `true` if the property exists in the object, `false` otherwise.
     */has:function(t,e){return t.hasOwnProperty(e)},/**
     * Check whether an object has both of the given properties.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#hasBoth
     * @since 3.0.0
     *
     * @param {object} object - The object to check.
     * @param {string} key1 - The key of the first property to check the object for.
     * @param {string} key2 - The key of the second property to check the object for.
     *
     * @return {boolean} `true` if both properties exist in the object, `false` otherwise.
     */hasBoth:function(t,e,i){return t.hasOwnProperty(e)&&t.hasOwnProperty(i)},/**
     * Check whether an object has at least one of the given properties.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#hasEither
     * @since 3.0.0
     *
     * @param {object} object - The object to check.
     * @param {string} key1 - The key of the first property to check the object for.
     * @param {string} key2 - The key of the second property to check the object for.
     *
     * @return {boolean} `true` if at least one of the properties exists in the object, `false` if neither exist.
     */hasEither:function(t,e,i){return t.hasOwnProperty(e)||t.hasOwnProperty(i)},/**
     * The returned value sets what the property will be at the START of the particles life, on emit.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#defaultEmit
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.
     * @param {string} key - The name of the property.
     * @param {number} [value] - The current value of the property.
     *
     * @return {number} The new value of the property.
     */defaultEmit:function(t,e,i){return i},/**
     * The returned value updates the property for the duration of the particles life.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#defaultUpdate
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.
     * @param {string} key - The name of the property.
     * @param {number} t - The T value (between 0 and 1)
     * @param {number} value - The current value of the property.
     *
     * @return {number} The new value of the property.
     */defaultUpdate:function(t,e,i,n){return n},/**
     * An `onEmit` callback that returns the current value of the property.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#staticValueEmit
     * @since 3.0.0
     *
     * @return {number} The current value of the property.
     */staticValueEmit:function(){return this.propertyValue},/**
     * An `onUpdate` callback that returns the current value of the property.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#staticValueUpdate
     * @since 3.0.0
     *
     * @return {number} The current value of the property.
     */staticValueUpdate:function(){return this.propertyValue},/**
     * An `onEmit` callback that returns a random value from the current value array.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#randomStaticValueEmit
     * @since 3.0.0
     *
     * @return {number} The new value of the property.
     */randomStaticValueEmit:function(){var t=Math.floor(Math.random()*this.propertyValue.length);return this.propertyValue[t]},/**
     * An `onEmit` callback that returns a value between the {@link Phaser.GameObjects.Particles.EmitterOp#start} and
     * {@link Phaser.GameObjects.Particles.EmitterOp#end} range.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#randomRangedValueEmit
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.
     * @param {string} key - The key of the property.
     *
     * @return {number} The new value of the property.
     */randomRangedValueEmit:function(t,e){var i=n(this.start,this.end);return t&&t.data[e]&&(t.data[e].min=i),i},/**
     * An `onEmit` callback that returns a stepped value between the
     * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}
     * range.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#steppedEmit
     * @since 3.0.0
     *
     * @return {number} The new value of the property.
     */steppedEmit:function(){var t=this.counter,e=this.counter+(this.end-this.start)/this.steps;return this.counter=a(e,this.start,this.end),t},/**
     * An `onEmit` callback for an eased property.
     *
     * It prepares the particle for easing by {@link Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate}.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#easedValueEmit
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.
     * @param {string} key - The name of the property.
     *
     * @return {number} {@link Phaser.GameObjects.Particles.EmitterOp#start}, as the new value of the property.
     */easedValueEmit:function(t,e){if(t&&t.data[e]){var i=t.data[e];i.min=this.start,i.max=this.end}return this.start},/**
     * An `onUpdate` callback that returns an eased value between the
     * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}
     * range.
     *
     * @method Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.
     * @param {string} key - The name of the property.
     * @param {number} t - The T value (between 0 and 1)
     *
     * @return {number} The new value of the property.
     */easeValueUpdate:function(t,e,i){var n=t.data[e];return(n.max-n.min)*this.ease(i)+n.min}});t.exports=h}),r("aANNX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cV9mL"),n=s("aEzMt");t.exports=function(t,e){//  Default ease function
var s=i.Power0;//  Prepare ease function
if("string"==typeof t){//  String based look-up
//  1) They specified it correctly
if(i.hasOwnProperty(t))s=i[t];else{//  Do some string manipulation to try and find it
var r="";t.indexOf(".")&&("in"===//  quad.in = Quad.easeIn
//  quad.out = Quad.easeOut
//  quad.inout = Quad.easeInOut
(r=t.substr(t.indexOf(".")+1)).toLowerCase()?r="easeIn":"out"===r.toLowerCase()?r="easeOut":"inout"===r.toLowerCase()&&(r="easeInOut")),t=n(t.substr(0,t.indexOf(".")+1)+r),i.hasOwnProperty(t)&&(s=i[t])}}else"function"==typeof t?s=t:Array.isArray(t)&&t.length;//  No custom ease parameters?
if(!e)return s;var o=e.slice(0);//  Return ease function with custom ease parameters
return o.unshift(0),function(t){return o[0]=t,s.apply(this,o)}}}),r("88Y8i",function(t,e){t.exports=function(t,e){for(var i=0;i<e.length;i++)if(t.hasOwnProperty(e[i]))return!0;return!1}}),r("evjs6",function(t,e){t.exports=function(t,e){return t.hasOwnProperty(e)}}),r("8lICh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7SBSk"),r=new i({initialize:function(t){/**
         * An object instance with a `getRandomPoint(point)` method.
         *
         * @name Phaser.GameObjects.Particles.Zones.RandomZone#source
         * @type {Phaser.Types.GameObjects.Particles.RandomZoneSource}
         * @since 3.0.0
         */this.source=t,/**
         * Internal calculation vector.
         *
         * @name Phaser.GameObjects.Particles.Zones.RandomZone#_tempVec
         * @type {Phaser.Math.Vector2}
         * @private
         * @since 3.0.0
         */this._tempVec=new n},/**
     * Get the next point in the Zone and set its coordinates on the given Particle.
     *
     * @method Phaser.GameObjects.Particles.Zones.RandomZone#getPoint
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle.
     */getPoint:function(t){var e=this._tempVec;this.source.getRandomPoint(e),t.x=e.x,t.y=e.y}});t.exports=r}),r("fnOwf",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("1zqlR"),o=s("WUmMp"),a=s("aqhsx"),h=s("hlq7f"),l=s("6Isfk"),u=new i({Extends:r,Mixins:[n.Depth,n.Mask,n.Pipeline,n.Transform,n.Visible,l],initialize:function(t,e,i,n){if(r.call(this,t,"ParticleEmitterManager"),/**
         * The blend mode applied to all emitters and particles.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#blendMode
         * @type {integer}
         * @default -1
         * @private
         * @since 3.0.0
         */this.blendMode=-1,/**
         * The time scale applied to all emitters and particles, affecting flow rate, lifespan, and movement.
         * Values larger than 1 are faster than normal.
         * This is multiplied with any timeScale set on each individual emitter.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#timeScale
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.timeScale=1,/**
         * The texture used to render this Emitter Manager's particles.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#texture
         * @type {Phaser.Textures.Texture}
         * @default null
         * @since 3.0.0
         */this.texture=null,/**
         * The texture frame used to render this Emitter Manager's particles.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#frame
         * @type {Phaser.Textures.Frame}
         * @default null
         * @since 3.0.0
         */this.frame=null,/**
         * Names of this Emitter Manager's texture frames.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#frameNames
         * @type {string[]}
         * @since 3.0.0
         */this.frameNames=[],null!==i&&("object"==typeof i||Array.isArray(i))&&(n=i,i=null),this.setTexture(e,i),this.initPipeline(),/**
         * A list of Emitters being managed by this Emitter Manager.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#emitters
         * @type {Phaser.Structs.List.<Phaser.GameObjects.Particles.ParticleEmitter>}
         * @since 3.0.0
         */this.emitters=new a(this),/**
         * A list of Gravity Wells being managed by this Emitter Manager.
         *
         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#wells
         * @type {Phaser.Structs.List.<Phaser.GameObjects.Particles.GravityWell>}
         * @since 3.0.0
         */this.wells=new a(this),n){//  An array of emitter configs?
Array.isArray(n)||(n=[n]);for(var s=0;s<n.length;s++)this.createEmitter(n[s])}},/**
     * Sets the texture and frame this Emitter Manager will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setTexture
     * @since 3.0.0
     *
     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.
     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.
     *
     * @return {this} This Emitter Manager.
     */setTexture:function(t,e){return this.texture=this.scene.sys.textures.get(t),this.setFrame(e)},/**
     * Sets the frame this Emitter Manager will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setFrame
     * @since 3.0.0
     *
     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.
     *
     * @return {this} This Emitter Manager.
     */setFrame:function(t){this.frame=this.texture.get(t);var e=this.texture.getFramesFromTextureSource(this.frame.sourceIndex),i=[];return e.forEach(function(t){i.push(t.name)}),this.frameNames=i,this.defaultFrame=this.frame,this},/**
     * Assigns texture frames to an emitter.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setEmitterFrames
     * @since 3.0.0
     *
     * @param {(Phaser.Textures.Frame|Phaser.Textures.Frame[])} frames - The texture frames.
     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The particle emitter to modify.
     *
     * @return {this} This Emitter Manager.
     */setEmitterFrames:function(t,e){Array.isArray(t)||(t=[t]);var i=e.frames;i.length=0;for(var n=0;n<t.length;n++){var s=t[n];-1!==this.frameNames.indexOf(s)&&i.push(this.texture.get(s))}return i.length>0?e.defaultFrame=i[0]:e.defaultFrame=this.defaultFrame,this},/**
     * Adds an existing Particle Emitter to this Emitter Manager.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#addEmitter
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Particle Emitter to add to this Emitter Manager.
     *
     * @return {Phaser.GameObjects.Particles.ParticleEmitter} The Particle Emitter that was added to this Emitter Manager.
     */addEmitter:function(t){return this.emitters.add(t)},/**
     * Creates a new Particle Emitter object, adds it to this Emitter Manager and returns a reference to it.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#createEmitter
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} config - Configuration settings for the Particle Emitter to create.
     *
     * @return {Phaser.GameObjects.Particles.ParticleEmitter} The Particle Emitter that was created.
     */createEmitter:function(t){return this.addEmitter(new h(this,t))},/**
     * Removes a Particle Emitter from this Emitter Manager, if the Emitter belongs to this Manager.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#removeEmitter
     * @since 3.22.0
     *
     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter
     *
     * @return {?Phaser.GameObjects.Particles.ParticleEmitter} The Particle Emitter if it was removed or null if it was not.
     */removeEmitter:function(t){return this.emitters.remove(t,!0)},/**
     * Adds an existing Gravity Well object to this Emitter Manager.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#addGravityWell
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Particles.GravityWell} well - The Gravity Well to add to this Emitter Manager.
     *
     * @return {Phaser.GameObjects.Particles.GravityWell} The Gravity Well that was added to this Emitter Manager.
     */addGravityWell:function(t){return this.wells.add(t)},/**
     * Creates a new Gravity Well, adds it to this Emitter Manager and returns a reference to it.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#createGravityWell
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Particles.GravityWellConfig} config - Configuration settings for the Gravity Well to create.
     *
     * @return {Phaser.GameObjects.Particles.GravityWell} The Gravity Well that was created.
     */createGravityWell:function(t){return this.addGravityWell(new o(t))},/**
     * Emits particles from each active emitter.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#emitParticle
     * @since 3.0.0
     *
     * @param {integer} [count] - The number of particles to release from each emitter. The default is the emitter's own {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.
     * @param {number} [x] - The x-coordinate to to emit particles from. The default is the x-coordinate of the emitter's current location.
     * @param {number} [y] - The y-coordinate to to emit particles from. The default is the y-coordinate of the emitter's current location.
     *
     * @return {this} This Emitter Manager.
     */emitParticle:function(t,e,i){for(var n=this.emitters.list,s=0;s<n.length;s++){var r=n[s];r.active&&r.emitParticle(t,e,i)}return this},/**
     * Emits particles from each active emitter.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#emitParticleAt
     * @since 3.0.0
     *
     * @param {number} [x] - The x-coordinate to to emit particles from. The default is the x-coordinate of the emitter's current location.
     * @param {number} [y] - The y-coordinate to to emit particles from. The default is the y-coordinate of the emitter's current location.
     * @param {integer} [count] - The number of particles to release from each emitter. The default is the emitter's own {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.
     *
     * @return {this} This Emitter Manager.
     */emitParticleAt:function(t,e,i){return this.emitParticle(i,t,e)},/**
     * Pauses this Emitter Manager.
     *
     * This has the effect of pausing all emitters, and all particles of those emitters, currently under its control.
     *
     * The particles will still render, but they will not have any of their logic updated.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#pause
     * @since 3.0.0
     *
     * @return {this} This Emitter Manager.
     */pause:function(){return this.active=!1,this},/**
     * Resumes this Emitter Manager, should it have been previously paused.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#resume
     * @since 3.0.0
     *
     * @return {this} This Emitter Manager.
     */resume:function(){return this.active=!0,this},/**
     * Gets all active particle processors (gravity wells).
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#getProcessors
     * @since 3.0.0
     *
     * @return {Phaser.GameObjects.Particles.GravityWell[]} - The active gravity wells.
     */getProcessors:function(){return this.wells.getAll("active",!0)},/**
     * Updates all active emitters.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#preUpdate
     * @since 3.0.0
     *
     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */preUpdate:function(t,e){//  Scale the delta
e*=this.timeScale;for(var i=this.emitters.list,n=0;n<i.length;n++){var s=i[n];s.active&&s.preUpdate(t,e)}},/**
     * A NOOP method so you can pass an EmitterManager to a Container.
     * Calling this method will do nothing. It is intentionally empty.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setAlpha
     * @private
     * @since 3.10.0
     */setAlpha:function(){},/**
     * A NOOP method so you can pass an EmitterManager to a Container.
     * Calling this method will do nothing. It is intentionally empty.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setScrollFactor
     * @private
     * @since 3.10.0
     */setScrollFactor:function(){},/**
     * A NOOP method so you can pass an EmitterManager to a Container.
     * Calling this method will do nothing. It is intentionally empty.
     *
     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setBlendMode
     * @private
     * @since 3.15.0
     */setBlendMode:function(){}});t.exports=u}),r("6Isfk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("4vAtu"),r=s("2flRj"),t.exports={renderWebGL:n,renderCanvas:r}}),r("4vAtu",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){var o=e.emitters.list,a=o.length;if(0!==a){var h=this.pipeline,l=h._tempMatrix1.copyFrom(s.matrix),u=h._tempMatrix2,c=h._tempMatrix3,d=h._tempMatrix4.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY);l.multiply(d),t.setPipeline(h);var f=s.roundPixels,p=e.defaultFrame.glTexture,g=i.getTintAppendFloatAlphaAndSwap;h.setTexture2D(p,0);for(var v=0;v<a;v++){var m=o[v],y=m.alive,x=y.length;if(m.visible&&0!==x){var w=s.scrollX*m.scrollFactorX,T=s.scrollY*m.scrollFactorY;r&&(//  Multiply the camera by the parent matrix
l.multiplyWithOffset(r,-w,-T),w=0,T=0),t.setBlendMode(m.blendMode)&&h.setTexture2D(p,0),m.mask&&(m.mask.preRenderWebGL(t,m,s),h.setTexture2D(p,0));for(var b=0;b<x;b++){var S=y[b],A=S.alpha*s.alpha;if(!(A<=0)){var E=S.frame,_=-E.halfWidth,C=-E.halfHeight,M=_+E.width,P=C+E.height;c.applyITRS(0,0,S.rotation,S.scaleX,S.scaleY),c.e=S.x-w,c.f=S.y-T,l.multiply(c,u);var O=u.getX(_,C),R=u.getY(_,C),L=u.getX(_,P),k=u.getY(_,P),D=u.getX(M,P),F=u.getY(M,P),I=u.getX(M,C),B=u.getY(M,C);f&&(O=Math.round(O),R=Math.round(R),L=Math.round(L),k=Math.round(k),D=Math.round(D),F=Math.round(F),I=Math.round(I),B=Math.round(B));var N=g(S.tint,A);h.batchQuad(O,R,L,k,D,F,I,B,E.u0,E.v0,E.u1,E.v1,N,N,N,N,0,p,0)}}m.mask&&(m.mask.postRenderWebGL(t,s),h.setTexture2D(p,0))}}}}}),r("2flRj",function(t,e){t.exports=function(t,e,i,n,s){var r=e.emitters.list,o=r.length;if(0!==o){var a=t._tempMatrix1.copyFrom(n.matrix),h=t._tempMatrix2,l=t._tempMatrix3,u=t._tempMatrix4.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY);a.multiply(u);var c=n.roundPixels,d=t.currentContext;d.save();for(var f=0;f<o;f++){var p=r[f],g=p.alive,v=g.length;if(p.visible&&0!==v){var m=n.scrollX*p.scrollFactorX,y=n.scrollY*p.scrollFactorY;s&&(//  Multiply the camera by the parent matrix
a.multiplyWithOffset(s,-m,-y),m=0,y=0),d.globalCompositeOperation=t.blendModes[p.blendMode];for(var x=0;x<v;x++){var w=g[x],T=w.alpha*n.alpha;if(!(T<=0)){var b=w.frame,S=b.canvasData,A=-b.halfWidth,E=-b.halfHeight;l.applyITRS(0,0,w.rotation,w.scaleX,w.scaleY),l.e=w.x-m,l.f=w.y-y,a.multiply(l,h),d.globalAlpha=T,d.save(),h.copyToContext(d),c&&(A=Math.round(A),E=Math.round(E)),d.imageSmoothingEnabled=!(!t.antialias||b.source.scaleMode),d.drawImage(b.source.image,S.x,S.y,S.width,S.height,A,E,S.width,S.height),d.restore()}}}}d.restore()}}}),r("3zceK",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.GameObjects.Particles.Zones
 */t.exports={DeathZone:s("bSAIj"),EdgeZone:s("g6KAN"),RandomZone:s("8lICh")}}),r("75mFg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("gXuc8"),o=new i({Extends:r,Mixins:[n.PathFollower],initialize:function(t,e,i,n,s,o){r.call(this,t,i,n,s,o),this.path=e},/**
     * Internal update handler that advances this PathFollower along the path.
     *
     * Called automatically by the Scene step, should not typically be called directly.
     *
     * @method Phaser.GameObjects.PathFollower#preUpdate
     * @protected
     * @since 3.0.0
     *
     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */preUpdate:function(t,e){this.anims.update(t,e),this.pathUpdate(t)}});t.exports=o}),r("iCX4n",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("3qUcC"),n=s("2LSzx"),r=s("kKoer"),o=s("jwj1g"),a=s("4FF1v"),h=s("bRAqZ"),l=s("7O4PF"),u=s("1zqlR"),c=s("jLdVd"),d=s("gaO4e"),f=s("gS40I"),p=new o({Extends:u,Mixins:[a.Alpha,a.BlendMode,a.ComputedSize,a.Crop,a.Depth,a.Flip,a.GetBounds,a.Mask,a.Origin,a.Pipeline,a.ScrollFactor,a.Tint,a.Transform,a.Visible,c],initialize:function(t,e,i,s,o,a,l){void 0===e&&(e=0),void 0===i&&(i=0),void 0===s&&(s=32),void 0===o&&(o=32),u.call(this,t,"RenderTexture"),/**
         * A reference to either the Canvas or WebGL Renderer that the Game instance is using.
         *
         * @name Phaser.GameObjects.RenderTexture#renderer
         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}
         * @since 3.2.0
         */this.renderer=t.sys.game.renderer,/**
         * A reference to the Texture Manager.
         *
         * @name Phaser.GameObjects.RenderTexture#textureManager
         * @type {Phaser.Textures.TextureManager}
         * @since 3.12.0
         */this.textureManager=t.sys.textures,/**
         * The tint of the Render Texture when rendered.
         *
         * @name Phaser.GameObjects.RenderTexture#globalTint
         * @type {number}
         * @default 0xffffff
         * @since 3.2.0
         */this.globalTint=16777215,/**
         * The alpha of the Render Texture when rendered.
         *
         * @name Phaser.GameObjects.RenderTexture#globalAlpha
         * @type {number}
         * @default 1
         * @since 3.2.0
         */this.globalAlpha=1,/**
         * The HTML Canvas Element that the Render Texture is drawing to when using the Canvas Renderer.
         *
         * @name Phaser.GameObjects.RenderTexture#canvas
         * @type {HTMLCanvasElement}
         * @since 3.2.0
         */this.canvas=null,/**
         * A reference to the GL Frame Buffer this Render Texture is drawing to.
         * This is only set if Phaser is running with the WebGL Renderer.
         *
         * @name Phaser.GameObjects.RenderTexture#framebuffer
         * @type {?WebGLFramebuffer}
         * @since 3.2.0
         */this.framebuffer=null,/**
         * Is this Render Texture dirty or not? If not it won't spend time clearing or filling itself.
         *
         * @name Phaser.GameObjects.RenderTexture#dirty
         * @type {boolean}
         * @since 3.12.0
         */this.dirty=!1,/**
         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.
         *
         * @name Phaser.GameObjects.RenderTexture#_crop
         * @type {object}
         * @private
         * @since 3.12.0
         */this._crop=this.resetCropObject(),/**
         * The Texture corresponding to this Render Texture.
         *
         * @name Phaser.GameObjects.RenderTexture#texture
         * @type {Phaser.Textures.Texture}
         * @since 3.12.0
         */this.texture=null,/**
         * The Frame corresponding to this Render Texture.
         *
         * @name Phaser.GameObjects.RenderTexture#frame
         * @type {Phaser.Textures.Frame}
         * @since 3.12.0
         */this.frame=null,/**
         * Internal saved texture flag.
         *
         * @name Phaser.GameObjects.RenderTexture#_saved
         * @type {boolean}
         * @private
         * @since 3.12.0
         */this._saved=!1,void 0===a?(this.canvas=r.create2D(this,s,o),//  Create a new Texture for this Text object
this.texture=t.sys.textures.addCanvas(f(),this.canvas),//  Get the frame
this.frame=this.texture.get()):(this.texture=t.sys.textures.get(a),//  Get the frame
this.frame=this.texture.get(l),this.canvas=this.frame.source.image,this._saved=!0,this.dirty=!0,this.width=this.frame.cutWidth,this.height=this.frame.cutHeight),/**
         * A reference to the Rendering Context belonging to the Canvas Element this Render Texture is drawing to.
         *
         * @name Phaser.GameObjects.RenderTexture#context
         * @type {CanvasRenderingContext2D}
         * @since 3.2.0
         */this.context=this.canvas.getContext("2d"),/**
         * Internal erase mode flag.
         *
         * @name Phaser.GameObjects.RenderTexture#_eraseMode
         * @type {boolean}
         * @private
         * @since 3.16.0
         */this._eraseMode=!1,/**
         * An internal Camera that can be used to move around the Render Texture.
         * Control it just like you would any Scene Camera. The difference is that it only impacts the placement of what
         * is drawn to the Render Texture. You can scroll, zoom and rotate this Camera.
         *
         * @name Phaser.GameObjects.RenderTexture#camera
         * @type {Phaser.Cameras.Scene2D.BaseCamera}
         * @since 3.12.0
         */this.camera=new n(0,0,s,o),/**
         * A reference to the WebGL Rendering Context.
         *
         * @name Phaser.GameObjects.RenderTexture#gl
         * @type {WebGLRenderingContext}
         * @default null
         * @since 3.0.0
         */this.gl=null,/**
         * A reference to the WebGLTexture that is being rendered to in a WebGL Context.
         *
         * @name Phaser.GameObjects.RenderTexture#glTexture
         * @type {WebGLTexture}
         * @default null
         * @readonly
         * @since 3.19.0
         */this.glTexture=null;var c=this.renderer;if(c.type===h.WEBGL){var d=c.gl;this.gl=d,this.glTexture=this.frame.source.glTexture,this.drawGameObject=this.batchGameObjectWebGL,this.framebuffer=c.createFramebuffer(s,o,this.glTexture,!1)}else c.type===h.CANVAS&&(this.drawGameObject=this.batchGameObjectCanvas);this.camera.setScene(t),this.setPosition(e,i),void 0===a&&this.setSize(s,o),this.setOrigin(0,0),this.initPipeline()},/**
     * Sets the size of this Game Object.
     * 
     * @method Phaser.GameObjects.RenderTexture#setSize
     * @since 3.0.0
     *
     * @param {number} width - The width of this Game Object.
     * @param {number} height - The height of this Game Object.
     * 
     * @return {this} This Game Object instance.
     */setSize:function(t,e){return this.resize(t,e)},/**
     * Resizes the Render Texture to the new dimensions given.
     * 
     * If Render Texture was created from specific frame, only the size of the frame will be changed. The size of the source
     * texture will not change.
     *
     * If Render Texture was not created from specific frame, the following will happen:
     * In WebGL it will destroy and then re-create the frame buffer being used by the Render Texture.
     * In Canvas it will resize the underlying canvas element.
     * Both approaches will erase everything currently drawn to the Render Texture.
     *
     * If the dimensions given are the same as those already being used, calling this method will do nothing.
     *
     * @method Phaser.GameObjects.RenderTexture#resize
     * @since 3.10.0
     *
     * @param {number} width - The new width of the Render Texture.
     * @param {number} [height=width] - The new height of the Render Texture. If not specified, will be set the same as the `width`.
     *
     * @return {this} This Render Texture.
     */resize:function(t,e){if(void 0===e&&(e=t),t!==this.width||e!==this.height){if("__BASE"===this.frame.name){if(//  Resize the texture
this.canvas.width=t,this.canvas.height=e,this.texture.width=t,this.texture.height=e,this.gl){var i=this.gl;this.renderer.deleteTexture(this.frame.source.glTexture),this.renderer.deleteFramebuffer(this.framebuffer);var n=this.renderer.createTexture2D(0,i.NEAREST,i.NEAREST,i.CLAMP_TO_EDGE,i.CLAMP_TO_EDGE,i.RGBA,null,t,e,!1);this.framebuffer=this.renderer.createFramebuffer(t,e,n,!1),this.frame.source.isRenderTexture=!0,this.frame.glTexture=n,this.glTexture=n}this.frame.source.width=t,this.frame.source.height=e,this.camera.setSize(t,e),this.frame.setSize(t,e),this.width=t,this.height=e}}else{//  Resize the frame
var s=this.texture.getSourceImage();this.frame.cutX+t>s.width&&(t=s.width-this.frame.cutX),this.frame.cutY+e>s.height&&(e=s.height-this.frame.cutY),this.frame.setSize(t,e,this.frame.cutX,this.frame.cutY)}this.updateDisplayOrigin();var r=this.input;return r&&!r.customHitArea&&(r.hitArea.width=t,r.hitArea.height=e),this},/**
     * Set the tint to use when rendering this Render Texture.
     *
     * @method Phaser.GameObjects.RenderTexture#setGlobalTint
     * @since 3.2.0
     *
     * @param {integer} tint - The tint value.
     *
     * @return {this} This Render Texture.
     */setGlobalTint:function(t){return this.globalTint=t,this},/**
     * Set the alpha to use when rendering this Render Texture.
     *
     * @method Phaser.GameObjects.RenderTexture#setGlobalAlpha
     * @since 3.2.0
     *
     * @param {number} alpha - The alpha value.
     *
     * @return {this} This Render Texture.
     */setGlobalAlpha:function(t){return this.globalAlpha=t,this},/**
     * Stores a copy of this Render Texture in the Texture Manager using the given key.
     * 
     * After doing this, any texture based Game Object, such as a Sprite, can use the contents of this
     * Render Texture by using the texture key:
     * 
     * ```javascript
     * var rt = this.add.renderTexture(0, 0, 128, 128);
     * 
     * // Draw something to the Render Texture
     * 
     * rt.saveTexture('doodle');
     * 
     * this.add.image(400, 300, 'doodle');
     * ```
     * 
     * Updating the contents of this Render Texture will automatically update _any_ Game Object
     * that is using it as a texture. Calling `saveTexture` again will not save another copy
     * of the same texture, it will just rename the key of the existing copy.
     * 
     * By default it will create a single base texture. You can add frames to the texture
     * by using the `Texture.add` method. After doing this, you can then allow Game Objects
     * to use a specific frame from a Render Texture.
     *
     * @method Phaser.GameObjects.RenderTexture#saveTexture
     * @since 3.12.0
     *
     * @param {string} key - The unique key to store the texture as within the global Texture Manager.
     *
     * @return {Phaser.Textures.Texture} The Texture that was saved.
     */saveTexture:function(t){return this.textureManager.renameTexture(this.texture.key,t),this._saved=!0,this.texture},/**
     * Fills the Render Texture with the given color.
     *
     * @method Phaser.GameObjects.RenderTexture#fill
     * @since 3.2.0
     *
     * @param {number} rgb - The color to fill the Render Texture with.
     * @param {number} [alpha=1] - The alpha value used by the fill.
     * @param {number} [x=0] - The left coordinate of the fill rectangle.
     * @param {number} [y=0] - The top coordinate of the fill rectangle.
     * @param {number} [width=this.frame.cutWidth] - The width of the fill rectangle.
     * @param {number} [height=this.frame.cutHeight] - The height of the fill rectangle.
     *
     * @return {this} This Render Texture instance.
     */fill:function(t,e,i,n,s,r){void 0===e&&(e=1),void 0===i&&(i=0),void 0===n&&(n=0),void 0===s&&(s=this.frame.cutWidth),void 0===r&&(r=this.frame.cutHeight);var o=(t>>16|0)&255,a=(t>>8|0)&255,h=(0|t)&255,l=this.gl,u=this.frame;if(this.camera.preRender(1,1),l){var c=this.camera._cx,f=this.camera._cy,p=this.camera._cw,g=this.camera._ch;this.renderer.setFramebuffer(this.framebuffer,!1),this.renderer.pushScissor(c,f,p,g,g);var v=this.pipeline;v.projOrtho(0,this.texture.width,0,this.texture.height,-1e3,1e3),v.drawFillRect(i,n,s,r,d.getTintFromFloats(o/255,a/255,h/255,1),e),this.renderer.setFramebuffer(null,!1),this.renderer.popScissor(),v.projOrtho(0,v.width,v.height,0,-1e3,1e3)}else this.renderer.setContext(this.context),this.context.fillStyle="rgba("+o+","+a+","+h+","+e+")",this.context.fillRect(i+u.cutX,n+u.cutY,s,r),this.renderer.setContext();return this.dirty=!0,this},/**
     * Clears the Render Texture.
     *
     * @method Phaser.GameObjects.RenderTexture#clear
     * @since 3.2.0
     *
     * @return {this} This Render Texture instance.
     */clear:function(){if(this.dirty){var t=this.gl;if(t){var e=this.renderer;e.setFramebuffer(this.framebuffer,!0),(this.frame.cutWidth!==this.canvas.width||this.frame.cutHeight!==this.canvas.height)&&t.scissor(this.frame.cutX,this.frame.cutY,this.frame.cutWidth,this.frame.cutHeight),t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),e.setFramebuffer(null,!0)}else{var i=this.context;i.save(),i.setTransform(1,0,0,1,0,0),i.clearRect(this.frame.cutX,this.frame.cutY,this.frame.cutWidth,this.frame.cutHeight),i.restore()}this.dirty=!1}return this},/**
     * Draws the given object, or an array of objects, to this Render Texture using a blend mode of ERASE.
     * This has the effect of erasing any filled pixels in the objects from this Render Texture.
     * 
     * It can accept any of the following:
     * 
     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.
     * * Dynamic and Static Tilemap Layers.
     * * A Group. The contents of which will be iterated and drawn in turn.
     * * A Container. The contents of which will be iterated fully, and drawn in turn.
     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.
     * * Another Render Texture.
     * * A Texture Frame instance.
     * * A string. This is used to look-up a texture from the Texture Manager.
     * 
     * Note: You cannot erase a Render Texture from itself.
     * 
     * If passing in a Group or Container it will only draw children that return `true`
     * when their `willRender()` method is called. I.e. a Container with 10 children,
     * 5 of which have `visible=false` will only draw the 5 visible ones.
     * 
     * If passing in an array of Game Objects it will draw them all, regardless if
     * they pass a `willRender` check or not.
     * 
     * You can pass in a string in which case it will look for a texture in the Texture
     * Manager matching that string, and draw the base frame.
     * 
     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of
     * the coordinates differ based on what objects are being drawn. If the object is
     * a Group, Container or Display List, the coordinates are _added_ to the positions
     * of the children. For all other types of object, the coordinates are exact.
     * 
     * Calling this method causes the WebGL batch to flush, so it can write the texture
     * data to the framebuffer being used internally. The batch is flushed at the end,
     * after the entries have been iterated. So if you've a bunch of objects to draw,
     * try and pass them in an array in one single call, rather than making lots of
     * separate calls.
     *
     * @method Phaser.GameObjects.RenderTexture#erase
     * @since 3.16.0
     *
     * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.
     * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.
     * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.
     *
     * @return {this} This Render Texture instance.
     */erase:function(t,e,n){this._eraseMode=!0;var s=this.renderer.currentBlendMode;return this.renderer.setBlendMode(i.ERASE),this.draw(t,e,n,1,16777215),this.renderer.setBlendMode(s),this._eraseMode=!1,this},/**
     * Draws the given object, or an array of objects, to this Render Texture.
     * 
     * It can accept any of the following:
     * 
     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.
     * * Dynamic and Static Tilemap Layers.
     * * A Group. The contents of which will be iterated and drawn in turn.
     * * A Container. The contents of which will be iterated fully, and drawn in turn.
     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.
     * * Another Render Texture.
     * * A Texture Frame instance.
     * * A string. This is used to look-up a texture from the Texture Manager.
     * 
     * Note: You cannot draw a Render Texture to itself.
     * 
     * If passing in a Group or Container it will only draw children that return `true`
     * when their `willRender()` method is called. I.e. a Container with 10 children,
     * 5 of which have `visible=false` will only draw the 5 visible ones.
     * 
     * If passing in an array of Game Objects it will draw them all, regardless if
     * they pass a `willRender` check or not.
     * 
     * You can pass in a string in which case it will look for a texture in the Texture
     * Manager matching that string, and draw the base frame. If you need to specify
     * exactly which frame to draw then use the method `drawFrame` instead.
     * 
     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of
     * the coordinates differ based on what objects are being drawn. If the object is
     * a Group, Container or Display List, the coordinates are _added_ to the positions
     * of the children. For all other types of object, the coordinates are exact.
     * 
     * The `alpha` and `tint` values are only used by Texture Frames.
     * Game Objects use their own alpha and tint values when being drawn.
     * 
     * Calling this method causes the WebGL batch to flush, so it can write the texture
     * data to the framebuffer being used internally. The batch is flushed at the end,
     * after the entries have been iterated. So if you've a bunch of objects to draw,
     * try and pass them in an array in one single call, rather than making lots of
     * separate calls.
     *
     * @method Phaser.GameObjects.RenderTexture#draw
     * @since 3.2.0
     *
     * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.
     * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.
     * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.
     * @param {number} [alpha] -  The alpha value. Only used for Texture Frames and if not specified defaults to the `globalAlpha` property. Game Objects use their own current alpha value.
     * @param {number} [tint] -  WebGL only. The tint color value. Only used for Texture Frames and if not specified defaults to the `globalTint` property. Game Objects use their own current tint value.
     *
     * @return {this} This Render Texture instance.
     */draw:function(t,e,i,n,s){void 0===n&&(n=this.globalAlpha),s=void 0===s?(this.globalTint>>16)+(65280&this.globalTint)+((255&this.globalTint)<<16):(s>>16)+(65280&s)+((255&s)<<16),Array.isArray(t)||(t=[t]);var r=this.gl;if(this.camera.preRender(1,1),r){var o=this.camera._cx,a=this.camera._cy,h=this.camera._cw,l=this.camera._ch;this.renderer.setFramebuffer(this.framebuffer,!1),this.renderer.pushScissor(o,a,h,l,l);var u=this.pipeline;u.projOrtho(0,this.texture.width,0,this.texture.height,-1e3,1e3),this.batchList(t,e,i,n,s),u.flush(),this.renderer.setFramebuffer(null,!1),this.renderer.popScissor(),u.projOrtho(0,u.width,u.height,0,-1e3,1e3)}else this.renderer.setContext(this.context),this.batchList(t,e,i,n,s),this.renderer.setContext();return this.dirty=!0,this},/**
     * Draws the Texture Frame to the Render Texture at the given position.
     * 
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     * 
     * ```javascript
     * var rt = this.add.renderTexture(0, 0, 800, 600);
     * rt.drawFrame(key, frame);
     * ```
     * 
     * You can optionally provide a position, alpha and tint value to apply to the frame
     * before it is drawn.
     * 
     * Calling this method will cause a batch flush, so if you've got a stack of things to draw
     * in a tight loop, try using the `draw` method instead.
     * 
     * If you need to draw a Sprite to this Render Texture, use the `draw` method instead.
     *
     * @method Phaser.GameObjects.RenderTexture#drawFrame
     * @since 3.12.0
     *
     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.
     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.
     * @param {number} [x=0] - The x position to draw the frame at.
     * @param {number} [y=0] - The y position to draw the frame at.
     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.
     * @param {number} [tint] - WebGL only. The tint color to use. If not specified it uses the `globalTint` property.
     *
     * @return {this} This Render Texture instance.
     */drawFrame:function(t,e,i,n,s,r){void 0===i&&(i=0),void 0===n&&(n=0),void 0===s&&(s=this.globalAlpha),r=void 0===r?(this.globalTint>>16)+(65280&this.globalTint)+((255&this.globalTint)<<16):(r>>16)+(65280&r)+((255&r)<<16);var o=this.gl,a=this.textureManager.getFrame(t,e);if(a){if(this.camera.preRender(1,1),o){var h=this.camera._cx,l=this.camera._cy,u=this.camera._cw,c=this.camera._ch;this.renderer.setFramebuffer(this.framebuffer,!1),this.renderer.pushScissor(h,l,u,c,c);var d=this.pipeline;d.projOrtho(0,this.texture.width,0,this.texture.height,-1e3,1e3),d.batchTextureFrame(a,i+this.frame.cutX,n+this.frame.cutY,r,s,this.camera.matrix,null),d.flush(),this.renderer.setFramebuffer(null,!1),this.renderer.popScissor(),d.projOrtho(0,d.width,d.height,0,-1e3,1e3)}else this.batchTextureFrame(a,i+this.frame.cutX,n+this.frame.cutY,s,r);this.dirty=!0}return this},/**
     * Internal method that handles the drawing of an array of children.
     *
     * @method Phaser.GameObjects.RenderTexture#batchList
     * @private
     * @since 3.12.0
     *
     * @param {array} children - The array of Game Objects to draw.
     * @param {number} [x] - The x position to offset the Game Object by.
     * @param {number} [y] - The y position to offset the Game Object by.
     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.
     * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.
     */batchList:function(t,e,i,n,s){for(var r=0;r<t.length;r++){var o=t[r];o&&o!==this&&(o.renderWebGL||o.renderCanvas?this.drawGameObject(o,e,i):o.isParent||o.list?this.batchGroup(o.getChildren(),e,i):"string"==typeof o?this.batchTextureFrameKey(o,null,e,i,n,s):o instanceof l?this.batchTextureFrame(o,e,i,n,s):Array.isArray(o)&&this.batchList(o,e,i,n,s))}},/**
     * Internal method that handles the drawing a Phaser Group contents.
     *
     * @method Phaser.GameObjects.RenderTexture#batchGroup
     * @private
     * @since 3.12.0
     *
     * @param {array} children - The array of Game Objects to draw.
     * @param {number} [x=0] - The x position to offset the Game Object by.
     * @param {number} [y=0] - The y position to offset the Game Object by.
     */batchGroup:function(t,e,i){void 0===e&&(e=0),void 0===i&&(i=0),e+=this.frame.cutX,i+=this.frame.cutY;for(var n=0;n<t.length;n++){var s=t[n];if(s.willRender()){var r=s.x+e,o=s.y+i;this.drawGameObject(s,r,o)}}},/**
     * Internal method that handles drawing a single Phaser Game Object to this Render Texture using WebGL.
     *
     * @method Phaser.GameObjects.RenderTexture#batchGameObjectWebGL
     * @private
     * @since 3.12.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.
     * @param {number} [x] - The x position to draw the Game Object at.
     * @param {number} [y] - The y position to draw the Game Object at.
     */batchGameObjectWebGL:function(t,e,i){void 0===e&&(e=t.x),void 0===i&&(i=t.y);var n=t.x,s=t.y;this._eraseMode||this.renderer.setBlendMode(t.blendMode),t.setPosition(e+this.frame.cutX,i+this.frame.cutY),t.renderWebGL(this.renderer,t,0,this.camera,null),t.setPosition(n,s)},/**
     * Internal method that handles drawing a single Phaser Game Object to this Render Texture using Canvas.
     *
     * @method Phaser.GameObjects.RenderTexture#batchGameObjectCanvas
     * @private
     * @since 3.12.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.
     * @param {number} [x] - The x position to draw the Game Object at.
     * @param {number} [y] - The y position to draw the Game Object at.
     */batchGameObjectCanvas:function(t,e,n){void 0===e&&(e=t.x),void 0===n&&(n=t.y);var s=t.x,r=t.y;if(this._eraseMode){var o=t.blendMode;t.blendMode=i.ERASE}t.setPosition(e+this.frame.cutX,n+this.frame.cutY),t.renderCanvas(this.renderer,t,0,this.camera,null),t.setPosition(s,r),this._eraseMode&&(t.blendMode=o)},/**
     * Internal method that handles the drawing of an array of children.
     *
     * @method Phaser.GameObjects.RenderTexture#batchTextureFrameKey
     * @private
     * @since 3.12.0
     *
     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.
     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.
     * @param {number} [x=0] - The x position to offset the Game Object by.
     * @param {number} [y=0] - The y position to offset the Game Object by.
     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.
     * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.
     */batchTextureFrameKey:function(t,e,i,n,s,r){var o=this.textureManager.getFrame(t,e);o&&this.batchTextureFrame(o,i,n,s,r)},/**
     * Internal method that handles the drawing of a Texture Frame to this Render Texture.
     *
     * @method Phaser.GameObjects.RenderTexture#batchTextureFrame
     * @private
     * @since 3.12.0
     *
     * @param {Phaser.Textures.Frame} textureFrame - The Texture Frame to draw.
     * @param {number} [x=0] - The x position to draw the Frame at.
     * @param {number} [y=0] - The y position to draw the Frame at.
     * @param {number} [tint] - A tint color to be applied to the frame drawn to the Render Texture.
     */batchTextureFrame:function(t,e,i,n,s){if(void 0===e&&(e=0),void 0===i&&(i=0),e+=this.frame.cutX,i+=this.frame.cutY,this.gl)this.pipeline.batchTextureFrame(t,e,i,s,n,this.camera.matrix,null);else{var r=this.context,o=t.canvasData,a=t.source.image,h=this.camera.matrix;r.globalAlpha=this.globalAlpha,r.setTransform(h[0],h[1],h[2],h[3],h[4],h[5]),r.drawImage(a,o.x,o.y,o.width,o.height,e,i,o.width,o.height)}},/**
     * Takes a snapshot of the given area of this Render Texture.
     * 
     * The snapshot is taken immediately.
     * 
     * To capture the whole Render Texture see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.
     * 
     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.
     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,
     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,
     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
     *
     * @method Phaser.GameObjects.RenderTexture#snapshotArea
     * @since 3.19.0
     *
     * @param {integer} x - The x coordinate to grab from.
     * @param {integer} y - The y coordinate to grab from.
     * @param {integer} width - The width of the area to grab.
     * @param {integer} height - The height of the area to grab.
     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.
     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.
     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.
     *
     * @return {this} This Render Texture instance.
     */snapshotArea:function(t,e,i,n,s,r,o){return this.gl?this.renderer.snapshotFramebuffer(this.framebuffer,this.width,this.height,s,!1,t,e,i,n,r,o):this.renderer.snapshotCanvas(this.canvas,s,!1,t,e,i,n,r,o),this},/**
     * Takes a snapshot of the whole of this Render Texture.
     * 
     * The snapshot is taken immediately.
     * 
     * To capture just a portion of the Render Texture see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.
     * 
     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.
     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,
     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,
     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
     *
     * @method Phaser.GameObjects.RenderTexture#snapshot
     * @since 3.19.0
     *
     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.
     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.
     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.
     *
     * @return {this} This Render Texture instance.
     */snapshot:function(t,e,i){return this.gl?this.renderer.snapshotFramebuffer(this.framebuffer,this.width,this.height,t,!1,0,0,this.width,this.height,e,i):this.renderer.snapshotCanvas(this.canvas,t,!1,0,0,this.width,this.height,e,i),this},/**
     * Takes a snapshot of the given pixel from this Render Texture.
     * 
     * The snapshot is taken immediately.
     * 
     * To capture the whole Render Texture see the `snapshot` method. To capture a specific portion, see `snapshotArea`.
     * 
     * Unlike the other two snapshot methods, this one will send your callback a `Color` object containing the color data for
     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,
     * using less memory, than the other snapshot methods.
     *
     * @method Phaser.GameObjects.RenderTexture#snapshotPixel
     * @since 3.19.0
     *
     * @param {integer} x - The x coordinate of the pixel to get.
     * @param {integer} y - The y coordinate of the pixel to get.
     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.
     *
     * @return {this} This Render Texture instance.
     */snapshotPixel:function(t,e,i){return this.gl?this.renderer.snapshotFramebuffer(this.framebuffer,this.width,this.height,i,!0,t,e):this.renderer.snapshotCanvas(this.canvas,i,!0,t,e),this},/**
     * Internal destroy handler, called as part of the destroy process.
     *
     * @method Phaser.GameObjects.RenderTexture#preDestroy
     * @protected
     * @since 3.9.0
     */preDestroy:function(){this._saved||(r.remove(this.canvas),this.gl&&this.renderer.deleteFramebuffer(this.framebuffer),this.texture.destroy(),this.camera.destroy(),this.canvas=null,this.context=null,this.framebuffer=null,this.texture=null,this.glTexture=null)}});t.exports=p}),r("jLdVd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("5Y7eC"),r=s("jH2v7"),t.exports={renderWebGL:n,renderCanvas:r}}),r("5Y7eC",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){var o=e.frame,a=o.width,h=o.height,l=i.getTintAppendFloatAlpha;this.pipeline.batchTexture(e,o.glTexture,a,h,e.x,e.y,a,h,e.scaleX,e.scaleY,e.rotation,e.flipX,!e.flipY,e.scrollFactorX,e.scrollFactorY,e.displayOriginX,e.displayOriginY,0,0,a,h,l(e._tintTL,s.alpha*e._alphaTL),l(e._tintTR,s.alpha*e._alphaTR),l(e._tintBL,s.alpha*e._alphaBL),l(e._tintBR,s.alpha*e._alphaBR),e._isTinted&&e.tintFill,0,0,s,r),//  Force clear the current texture so that items next in the batch (like Graphics) don't try and use it
t.setBlankTexture(!0)}}),r("jH2v7",function(t,e){t.exports=function(t,e,i,n,s){t.batchSprite(e,e.frame,n,s)}}),r("gS40I",function(t,e){t.exports=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(t){var e=16*Math.random()|0;return("x"===t?e:3&e|8).toString(16)})}}),r("eCKky",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("htQ0a"),n=s("hVk4C"),r={Parse:s("1p2Y9")};//   Merge in the consts
r=n(!1,r,i),t.exports=r}),r("htQ0a",function(t,e){t.exports={/**
     * Text Set 1 =  !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~
     * 
     * @name Phaser.GameObjects.RetroFont.TEXT_SET1
     * @type {string}
     * @since 3.6.0
     */TEXT_SET1:" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",/**
     * Text Set 2 =  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ
     * 
     * @name Phaser.GameObjects.RetroFont.TEXT_SET2
     * @type {string}
     * @since 3.6.0
     */TEXT_SET2:" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ",/**
     * Text Set 3 = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 
     * 
     * @name Phaser.GameObjects.RetroFont.TEXT_SET3
     * @type {string}
     * @since 3.6.0
     */TEXT_SET3:"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",/**
     * Text Set 4 = ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789
     * 
     * @name Phaser.GameObjects.RetroFont.TEXT_SET4
     * @type {string}
     * @since 3.6.0
     */TEXT_SET4:"ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",/**
     * Text Set 5 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789
     * 
     * @name Phaser.GameObjects.RetroFont.TEXT_SET5
     * @type {string}
     * @since 3.6.0
     */TEXT_SET5:"ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",/**
     * Text Set 6 = ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.' 
     * 
     * @name Phaser.GameObjects.RetroFont.TEXT_SET6
     * @type {string}
     * @since 3.6.0
     */TEXT_SET6:"ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ",/**
     * Text Set 7 = AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39
     * 
     * @name Phaser.GameObjects.RetroFont.TEXT_SET7
     * @type {string}
     * @since 3.6.0
     */TEXT_SET7:"AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39",/**
     * Text Set 8 = 0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ
     * 
     * @name Phaser.GameObjects.RetroFont.TEXT_SET8
     * @type {string}
     * @since 3.6.0
     */TEXT_SET8:"0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",/**
     * Text Set 9 = ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!
     * 
     * @name Phaser.GameObjects.RetroFont.TEXT_SET9
     * @type {string}
     * @since 3.6.0
     */TEXT_SET9:"ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!",/**
     * Text Set 10 = ABCDEFGHIJKLMNOPQRSTUVWXYZ
     * 
     * @name Phaser.GameObjects.RetroFont.TEXT_SET10
     * @type {string}
     * @since 3.6.0
     */TEXT_SET10:"ABCDEFGHIJKLMNOPQRSTUVWXYZ",/**
     * Text Set 11 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789
     * 
     * @name Phaser.GameObjects.RetroFont.TEXT_SET11
     * @since 3.6.0
     * @type {string}
     */TEXT_SET11:"ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789"}}),r("1p2Y9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5pMDk");t.exports=function(t,e){var n=e.width,s=e.height,r=Math.floor(n/2),o=Math.floor(s/2),a=i(e,"chars","");if(""!==a){var h=i(e,"image",""),l=i(e,"offset.x",0),u=i(e,"offset.y",0),c=i(e,"spacing.x",0),d=i(e,"spacing.y",0),f=i(e,"lineSpacing",0),p=i(e,"charsPerRow",null);null===p&&(p=t.sys.textures.getFrame(h).width/n)>a.length&&(p=a.length);for(var g=l,v=u,m={retroFont:!0,font:h,size:n,lineHeight:s+f,chars:{}},y=0,x=0;x<a.length;x++){// var node = letters[i];
var w=a.charCodeAt(x);m.chars[w]={x:g,y:v,width:n,height:s,centerX:r,centerY:o,xOffset:0,yOffset:0,xAdvance:n,data:{},kerning:{}},++y===p?(y=0,g=l,v+=s+d):g+=n+c}return{data:m,frame:null,texture:h}}}}),r("4dBPv",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("1zqlR"),o=s("lz7x8"),a=s("7SBSk"),h=new i({Extends:r,Mixins:[n.AlphaSingle,n.BlendMode,n.Depth,n.Flip,n.Mask,n.Pipeline,n.Size,n.Texture,n.Transform,n.Visible,n.ScrollFactor,o],initialize:function(t,e,i,s,o,h,l,u,c){void 0===s&&(s="__DEFAULT"),void 0===h&&(h=2),void 0===l&&(l=!0),r.call(this,t,"Rope"),/**
         * The Animation Controller of this Rope.
         *
         * @name Phaser.GameObjects.Rope#anims
         * @type {Phaser.GameObjects.Components.Animation}
         * @since 3.23.0
         */this.anims=new n.Animation(this),/**
         * An array containing the points data for this Rope.
         * 
         * Each point should be given as a Vector2Like object (i.e. a Vector2, Geom.Point or object with public x/y properties).
         * 
         * The point coordinates are given in local space, where 0 x 0 is the start of the Rope strip.
         * 
         * You can modify the contents of this array directly in real-time to create interesting effects.
         * If you do so, be sure to call `setDirty` _after_ modifying this array, so that the vertices data is
         * updated before the next render. Alternatively, you can use the `setPoints` method instead.
         * 
         * Should you need to change the _size_ of this array, then you should always use the `setPoints` method.
         *
         * @name Phaser.GameObjects.Rope#points
         * @type {Phaser.Types.Math.Vector2Like[]}
         * @since 3.23.0
         */this.points=h,/**
         * An array containing the vertices data for this Rope.
         * 
         * This data is calculated automatically in the `updateVertices` method, based on the points provided.
         *
         * @name Phaser.GameObjects.Rope#vertices
         * @type {Float32Array}
         * @since 3.23.0
         */this.vertices,/**
         * An array containing the uv data for this Rope.
         * 
         * This data is calculated automatically in the `setPoints` method, based on the points provided.
         *
         * @name Phaser.GameObjects.Rope#uv
         * @type {Float32Array}
         * @since 3.23.0
         */this.uv,/**
         * An array containing the color data for this Rope.
         * 
         * Colors should be given as numeric RGB values, such as 0xff0000.
         * You should provide _two_ color values for every point in the Rope, one for the top and one for the bottom of each quad.
         * 
         * You can modify the contents of this array directly in real-time, however, should you need to change the _size_
         * of the array, then you should use the `setColors` method instead.
         *
         * @name Phaser.GameObjects.Rope#colors
         * @type {Uint32Array}
         * @since 3.23.0
         */this.colors,/**
         * An array containing the alpha data for this Rope.
         * 
         * Alphas should be given as float values, such as 0.5.
         * You should provide _two_ alpha values for every point in the Rope, one for the top and one for the bottom of each quad.
         * 
         * You can modify the contents of this array directly in real-time, however, should you need to change the _size_
         * of the array, then you should use the `setAlphas` method instead.
         *
         * @name Phaser.GameObjects.Rope#alphas
         * @type {Float32Array}
         * @since 3.23.0
         */this.alphas,/**
         * The tint fill mode.
         * 
         * 0 = An additive tint (the default), where vertices colors are blended with the texture.
         * 1 = A fill tint, where the vertices colors replace the texture, but respects texture alpha.
         * 2 = A complete tint, where the vertices colors replace the texture, including alpha, entirely.
         * 
         * @name Phaser.GameObjects.Rope#tintFill
         * @type {integer}
         * @since 3.23.0
         */this.tintFill="__DEFAULT"===s?2:0,/**
         * If the Rope is marked as `dirty` it will automatically recalculate its vertices
         * the next time it renders. You can also force this by calling `updateVertices`.
         * 
         * @name Phaser.GameObjects.Rope#dirty
         * @type {boolean}
         * @since 3.23.0
         */this.dirty=!1,/**
         * Are the Rope vertices aligned horizontally, in a strip, or vertically, in a column?
         * 
         * This property is set during instantiation and cannot be changed directly.
         * See the `setVertical` and `setHorizontal` methods.
         * 
         * @name Phaser.GameObjects.Rope#horizontal
         * @type {boolean}
         * @readonly
         * @since 3.23.0
         */this.horizontal=l,/**
         * The horizontally flipped state of the Game Object.
         * 
         * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
         * Flipping always takes place from the middle of the texture and does not impact the scale value.
         * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
         * 
         * @name Phaser.GameObjects.Rope#_flipX
         * @type {boolean}
         * @default false
         * @private
         * @since 3.23.0
         */this._flipX=!1,/**
         * The vertically flipped state of the Game Object.
         * 
         * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
         * Flipping always takes place from the middle of the texture and does not impact the scale value.
         * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
         * 
         * @name Phaser.GameObjects.Rope#flipY
         * @type {boolean}
         * @default false
         * @private
         * @since 3.23.0
         */this._flipY=!1,/**
         * Internal Vector2 used for vertices updates.
         * 
         * @name Phaser.GameObjects.Rope#_perp
         * @type {Phaser.Math.Vector2}
         * @private
         * @since 3.23.0
         */this._perp=new a,/**
         * You can optionally choose to render the vertices of this Rope to a Graphics instance.
         * 
         * Achieve this by setting the `debugCallback` and the `debugGraphic` properties.
         * 
         * You can do this in a single call via the `Rope.setDebug` method, which will use the
         * built-in debug function. You can also set it to your own callback. The callback
         * will be invoked _once per render_ and sent the following parameters:
         * 
         * `debugCallback(src, meshLength, verts)`
         * 
         * `src` is the Rope instance being debugged.
         * `meshLength` is the number of mesh vertices in total.
         * `verts` is an array of the translated vertex coordinates.
         * 
         * To disable rendering, set this property back to `null`.
         * 
         * @name Phaser.GameObjects.Rope#debugCallback
         * @type {function}
         * @since 3.23.0
         */this.debugCallback=null,/**
         * The Graphics instance that the debug vertices will be drawn to, if `setDebug` has
         * been called.
         * 
         * @name Phaser.GameObjects.Rope#debugGraphic
         * @type {Phaser.GameObjects.Graphics}
         * @since 3.23.0
         */this.debugGraphic=null,this.setTexture(s,o),this.setPosition(e,i),this.setSizeToFrame(),this.initPipeline("TextureTintStripPipeline"),Array.isArray(h)&&this.resizeArrays(h.length),this.setPoints(h,u,c),this.updateVertices()},/**
     * The Rope update loop.
     *
     * @method Phaser.GameObjects.Rope#preUpdate
     * @protected
     * @since 3.23.0
     *
     * @param {number} time - The current timestamp.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */preUpdate:function(t,e){var i=this.anims.currentFrame;this.anims.update(t,e),this.anims.currentFrame!==i&&(this.updateUVs(),this.updateVertices())},/**
     * Start playing the given animation.
     *
     * @method Phaser.GameObjects.Rope#play
     * @since 3.23.0
     *
     * @param {string} key - The string-based key of the animation to play.
     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.
     * @param {integer} [startFrame=0] - Optionally start the animation playing from this frame index.
     *
     * @return {this} This Game Object.
     */play:function(t,e,i){return this.anims.play(t,e,i),this},/**
     * Flags this Rope as being dirty. A dirty rope will recalculate all of its vertices data
     * the _next_ time it renders. You should set this rope as dirty if you update the points
     * array directly.
     * 
     * @method Phaser.GameObjects.Rope#setDirty
     * @since 3.23.0
     * 
     * @return {this} This Game Object instance.
     */setDirty:function(){return this.dirty=!0,this},/**
     * Sets the alignment of the points in this Rope to be horizontal, in a strip format.
     * 
     * Calling this method will reset this Rope. The current points, vertices, colors and alpha
     * values will be reset to thoes values given as parameters.
     * 
     * @method Phaser.GameObjects.Rope#setHorizontal
     * @since 3.23.0
     * 
     * @param {(integer|Phaser.Types.Math.Vector2Like[])} [points] - An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided the current points length is used.
     * @param {(number|number[])} [colors] - Either a single color value, or an array of values.
     * @param {(number|number[])} [alphas] - Either a single alpha value, or an array of values.
     * 
     * @return {this} This Game Object instance.
     */setHorizontal:function(t,e,i){return(void 0===t&&(t=this.points.length),this.horizontal)?this:(this.horizontal=!0,this.setPoints(t,e,i))},/**
     * Sets the alignment of the points in this Rope to be vertical, in a column format.
     * 
     * Calling this method will reset this Rope. The current points, vertices, colors and alpha
     * values will be reset to thoes values given as parameters.
     * 
     * @method Phaser.GameObjects.Rope#setVertical
     * @since 3.23.0
     * 
     * @param {(integer|Phaser.Types.Math.Vector2Like[])} [points] - An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided the current points length is used.
     * @param {(number|number[])} [colors] - Either a single color value, or an array of values.
     * @param {(number|number[])} [alphas] - Either a single alpha value, or an array of values.
     * 
     * @return {this} This Game Object instance.
     */setVertical:function(t,e,i){return(void 0===t&&(t=this.points.length),this.horizontal)?(this.horizontal=!1,this.setPoints(t,e,i)):this},/**
     * Sets the tint fill mode.
     * 
     * Mode 0 is an additive tint, the default, which blends the vertices colors with the texture.
     * This mode respects the texture alpha.
     * 
     * Mode 1 is a fill tint. Unlike an additive tint, a fill-tint literally replaces the pixel colors
     * from the texture with those in the tint. You can use this for effects such as making a player flash 'white'
     * if hit by something. This mode respects the texture alpha.
     * 
     * Mode 2 is a complete tint. The texture colors and alpha are replaced entirely by the vertices colors.
     * 
     * See the `setColors` method for details of how to color each of the vertices.
     *
     * @method Phaser.GameObjects.Rope#setTintFill
     * @webglOnly
     * @since 3.23.0
     *
     * @param {integer} [value=0] - Set to 0 for an Additive tint, 1 for a fill tint with alpha, or 2 for a fill tint without alpha.
     * 
     * @return {this} This Game Object instance.
     */setTintFill:function(t){return void 0===t&&(t=0),this.tintFill=t,this},/**
     * Set the alpha values used by the Rope during rendering.
     * 
     * You can provide the values in a number of ways:
     * 
     * 1) One single numeric value: `setAlphas(0.5)` - This will set a single alpha for the whole Rope.
     * 2) Two numeric value: `setAlphas(1, 0.5)` - This will set a 'top' and 'bottom' alpha value across the whole Rope.
     * 3) An array of values: `setAlphas([ 1, 0.5, 0.2 ])`
     * 
     * If you provide an array of values and the array has exactly the same number of values as `points` in the Rope, it
     * will use each alpha value per rope segment.
     * 
     * If the provided array has a different number of values than `points` then it will use the values in order, from
     * the first Rope segment and on, until it runs out of values. This allows you to control the alpha values at all
     * vertices in the Rope.
     * 
     * Note this method is called `setAlphas` (plural) and not `setAlpha`.
     * 
     * @method Phaser.GameObjects.Rope#setAlphas
     * @since 3.23.0
     * 
     * @param {(number|number[])} [alphas] - Either a single alpha value, or an array of values. If nothing is provided alpha is reset to 1.
     * @param {number} [bottomAlpha] - An optional bottom alpha value. See the method description for details.
     * 
     * @return {this} This Game Object instance.
     */setAlphas:function(t,e){var i,n=this.points.length;if(n<1)return this;var s=this.alphas;void 0===t?t=[1]:Array.isArray(t)||void 0!==e||(t=[t]);var r=0;if(void 0!==e)for(i=0;i<n;i++)s[r=2*i]=t,s[r+1]=e;else if(t.length===n)for(i=0;i<n;i++)s[r=2*i]=t[i],s[r+1]=t[i];else{var o=t[0];for(i=0;i<n;i++)r=2*i,t.length>r&&(o=t[r]),s[r]=o,t.length>r+1&&(o=t[r+1]),s[r+1]=o}return this},/**
     * Set the color values used by the Rope during rendering.
     * 
     * Colors are used to control the level of tint applied across the Rope texture.
     * 
     * You can provide the values in a number of ways:
     * 
     * * One single numeric value: `setColors(0xff0000)` - This will set a single color tint for the whole Rope.
     * * An array of values: `setColors([ 0xff0000, 0x00ff00, 0x0000ff ])`
     * 
     * If you provide an array of values and the array has exactly the same number of values as `points` in the Rope, it
     * will use each color per rope segment.
     * 
     * If the provided array has a different number of values than `points` then it will use the values in order, from
     * the first Rope segment and on, until it runs out of values. This allows you to control the color values at all
     * vertices in the Rope.
     * 
     * @method Phaser.GameObjects.Rope#setColors
     * @since 3.23.0
     * 
     * @param {(number|number[])} [colors] - Either a single color value, or an array of values. If nothing is provided color is reset to 0xffffff.
     * 
     * @return {this} This Game Object instance.
     */setColors:function(t){var e,i=this.points.length;if(i<1)return this;var n=this.colors;void 0===t?t=[16777215]:Array.isArray(t)||(t=[t]);var s=0;if(t.length===i)for(e=0;e<i;e++)n[s=2*e]=t[e],n[s+1]=t[e];else{var r=t[0];for(e=0;e<i;e++)s=2*e,t.length>s&&(r=t[s]),n[s]=r,t.length>s+1&&(r=t[s+1]),n[s+1]=r}return this},/**
     * Sets the points used by this Rope.
     * 
     * The points should be provided as an array of Vector2, or vector2-like objects (i.e. those with public x/y properties).
     * 
     * Each point corresponds to one segment of the Rope. The more points in the array, the more segments the rope has.
     * 
     * Point coordinates are given in local-space, not world-space, and are directly related to the size of the texture
     * this Rope object is using.
     * 
     * For example, a Rope using a 512 px wide texture, split into 4 segments (128px each) would use the following points:
     * 
     * ```javascript
     * rope.setPoints([
     *   { x: 0, y: 0 },
     *   { x: 128, y: 0 },
     *   { x: 256, y: 0 },
     *   { x: 384, y: 0 }
     * ]);
     * ```
     * 
     * Or, you can provide an integer to do the same thing:
     * 
     * ```javascript
     * rope.setPoints(4);
     * ```
     * 
     * Which will divide the Rope into 4 equally sized segments based on the frame width.
     * 
     * Note that calling this method with a different number of points than the Rope has currently will
     * _reset_ the color and alpha values, unless you provide them as arguments to this method.
     * 
     * @method Phaser.GameObjects.Rope#setPoints
     * @since 3.23.0
     * 
     * @param {(integer|Phaser.Types.Math.Vector2Like[])} [points=2] - An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided a simple quad is created.
     * @param {(number|number[])} [colors] - Either a single color value, or an array of values.
     * @param {(number|number[])} [alphas] - Either a single alpha value, or an array of values.
     * 
     * @return {this} This Game Object instance.
     */setPoints:function(t,e,i){if(void 0===t&&(t=2),"number"==typeof t){//  Generate an array based on the points
var n,s,r,o=t;if(o<2&&(o=2),t=[],this.horizontal)for(n=0,r=-this.frame.halfWidth,s=this.frame.width/(o-1);n<o;n++)t.push({x:r+n*s,y:0});else for(n=0,r=-this.frame.halfHeight,s=this.frame.height/(o-1);n<o;n++)t.push({x:0,y:r+n*s})}var a=t.length,h=this.points.length;return a<1?console.warn("Rope: Not enough points given"):(1===a&&(t.unshift({x:0,y:0}),a++),h!==a&&this.resizeArrays(a),this.points=t,this.updateUVs(),null!=e&&this.setColors(e),null!=i&&this.setAlphas(i)),this},/**
     * Updates all of the UVs based on the Rope.points and `flipX` and `flipY` settings.
     * 
     * @method Phaser.GameObjects.Rope#updateUVs
     * @since 3.23.0
     * 
     * @return {this} This Game Object instance.
     */updateUVs:function(){for(var t=this.uv,e=this.points.length,i=this.frame.u0,n=this.frame.v0,s=this.frame.u1,r=this.frame.v1,o=(s-i)/(e-1),a=(r-n)/(e-1),h=0;h<e;h++){var l,u,c,d,f=4*h;this.horizontal?(this._flipX?(l=s-h*o,c=s-h*o):(l=i+h*o,c=i+h*o),this._flipY?(u=r,d=n):(u=n,d=r)):(this._flipX?(l=i,c=s):(l=s,c=i),this._flipY?(u=r-h*a,d=r-h*a):(u=n+h*a,d=n+h*a)),t[f+0]=l,t[f+1]=u,t[f+2]=c,t[f+3]=d}return this},/**
     * Resizes all of the internal arrays: `vertices`, `uv`, `colors` and `alphas` to the new
     * given Rope segment total.
     * 
     * @method Phaser.GameObjects.Rope#resizeArrays
     * @since 3.23.0
     * 
     * @param {integer} newSize - The amount of segments to split the Rope in to.
     * 
     * @return {this} This Game Object instance.
     */resizeArrays:function(t){var e=this.colors,i=this.alphas;this.vertices=new Float32Array(4*t),this.uv=new Float32Array(4*t),e=new Uint32Array(2*t),i=new Float32Array(2*t);for(var n=0;n<2*t;n++)e[n]=16777215,i[n]=1;return this.colors=e,this.alphas=i,//  updateVertices during next render
this.dirty=!0,this},/**
     * Updates the vertices based on the Rope points.
     * 
     * This method is called automatically during rendering if `Rope.dirty` is `true`, which is set
     * by the `setPoints` and `setDirty` methods. You should flag the Rope as being dirty if you modify
     * the Rope points directly.
     * 
     * @method Phaser.GameObjects.Rope#updateVertices
     * @since 3.23.0
     * 
     * @return {this} This Game Object instance.
     */updateVertices:function(){var t,e=this._perp,i=this.points,n=this.vertices,s=i.length;if(this.dirty=!1,!(s<1)){for(var r=i[0],o=this.horizontal?this.frame.halfHeight:this.frame.halfWidth,a=0;a<s;a++){var h=i[a],l=4*a;t=a<s-1?i[a+1]:h,e.x=t.y-r.y,e.y=-(t.x-r.x);var u=e.length();e.x/=u,e.y/=u,e.x*=o,e.y*=o,n[l]=h.x+e.x,n[l+1]=h.y+e.y,n[l+2]=h.x-e.x,n[l+3]=h.y-e.y,r=h}return this}},/**
     * This method enables rendering of the Rope vertices to the given Graphics instance.
     * 
     * If you enable this feature, you must call `Graphics.clear()` in your Scene `update`,
     * otherwise the Graphics instance will fill-in with draw calls. This is not done automatically
     * to allow for you to debug render multiple Rope objects to a single Graphics instance.
     * 
     * The Rope class has a built-in debug rendering callback `Rope.renderDebugVerts`, however
     * you can also provide your own callback to be used instead. Do this by setting the `callback` parameter.
     * 
     * The callback is invoked _once per render_ and sent the following parameters:
     * 
     * `callback(src, meshLength, verts)`
     * 
     * `src` is the Rope instance being debugged.
     * `meshLength` is the number of mesh vertices in total.
     * `verts` is an array of the translated vertex coordinates.
     * 
     * If using your own callback you do not have to provide a Graphics instance to this method.
     * 
     * To disable debug rendering, to either your own callback or the built-in one, call this method
     * with no arguments.
     * 
     * @method Phaser.GameObjects.Rope#setDebug
     * @since 3.23.0
     * 
     * @param {Phaser.GameObjects.Graphics} [graphic] - The Graphic instance to render to if using the built-in callback.
     * @param {function} [callback] - The callback to invoke during debug render. Leave as undefined to use the built-in callback.
     * 
     * @return {this} This Game Object instance.
     */setDebug:function(t,e){return this.debugGraphic=t,t||e?e?this.debugCallback=e:this.debugCallback=this.renderDebugVerts:this.debugCallback=null,this},/**
     * The built-in Rope vertices debug rendering method.
     * 
     * See `Rope.setDebug` for more details.
     *
     * @method Phaser.GameObjects.Rope#renderDebugVerts
     * @since 3.23.0
     * 
     * @param {Phaser.GameObjects.Rope} src - The Rope object being rendered.
     * @param {integer} meshLength - The number of vertices in the mesh.
     * @param {number[]} verts - An array of translated vertex coordinates.
     */renderDebugVerts:function(t,e,i){var n=t.debugGraphic,s=i[0],r=i[1],o=i[2],a=i[3];n.lineBetween(s,r,o,a);for(var h=4;h<e;h+=4){var l=i[h+0],u=i[h+1],c=i[h+2],d=i[h+3];n.lineBetween(s,r,l,u),n.lineBetween(o,a,c,d),n.lineBetween(o,a,l,u),n.lineBetween(l,u,c,d),s=l,r=u,o=c,a=d}},/**
     * Handles the pre-destroy step for the Rope, which removes the Animation component and typed arrays.
     *
     * @method Phaser.GameObjects.Rope#preDestroy
     * @private
     * @since 3.23.0
     */preDestroy:function(){this.anims.destroy(),this.anims=void 0,this.points=null,this.vertices=null,this.uv=null,this.colors=null,this.alphas=null,this.debugCallback=null,this.debugGraphic=null},/**
     * The horizontally flipped state of the Game Object.
     * 
     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * 
     * @name Phaser.GameObjects.Rope#flipX
     * @type {boolean}
     * @default false
     * @since 3.23.0
     */flipX:{get:function(){return this._flipX},set:function(t){return this._flipX=t,this.updateUVs()}},/**
     * The vertically flipped state of the Game Object.
     * 
     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
     * Flipping always takes place from the middle of the texture and does not impact the scale value.
     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.
     * 
     * @name Phaser.GameObjects.Rope#flipY
     * @type {boolean}
     * @default false
     * @since 3.23.0
     */flipY:{get:function(){return this._flipY},set:function(t){return this._flipY=t,this.updateUVs()}}});t.exports=h}),r("lz7x8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("4g0TB"),r=s("1pSqx"),t.exports={renderWebGL:n,renderCanvas:r}}),r("4g0TB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){var o=e.pipeline;t.setPipeline(o,e);var a=o._tempMatrix1,h=o._tempMatrix2,l=o._tempMatrix3;h.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),a.copyFrom(s.matrix),r?(//  Multiply the camera by the parent matrix
a.multiplyWithOffset(r,-s.scrollX*e.scrollFactorX,-s.scrollY*e.scrollFactorY),//  Undo the camera scroll
h.e=e.x,h.f=e.y):(h.e-=s.scrollX*e.scrollFactorX,h.f-=s.scrollY*e.scrollFactorY),//  Multiply by the Sprite matrix, store result in calcMatrix
a.multiply(h,l);var u=e.frame.glTexture,c=e.vertices,d=e.uv,f=e.colors,p=e.alphas,g=e.alpha,v=i.getTintAppendFloatAlphaAndSwap,m=s.roundPixels,y=c.length,x=Math.floor(.5*y);//  Because it's a triangle strip and we don't want lots of degenerate triangles joining things up
o.flush(),o.setTexture2D(u,0);var w=o.vertexViewF32,T=o.vertexViewU32,b=o.vertexCount*o.vertexComponentCount-1,S=0,A=e.tintFill;e.dirty&&e.updateVertices();for(var E=e.debugCallback,_=[],C=0;C<y;C+=2){var M=c[C+0],P=c[C+1],O=M*l.a+P*l.c+l.e,R=M*l.b+P*l.d+l.f;m&&(O=Math.round(O),R=Math.round(R)),w[++b]=O,w[++b]=R,w[++b]=d[C+0],w[++b]=d[C+1],w[++b]=A,T[++b]=v(f[S],s.alpha*(p[S]*g)),S++,E&&(_[C+0]=O,_[C+1]=R)}E&&E.call(e,e,y,_),o.vertexCount+=x}}),r("1pSqx",function(t,e){t.exports=function(){}}),r("1jO0s",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6686h"),n=s("kKoer"),r=s("jwj1g"),o=s("4FF1v"),a=s("aqcI1"),h=s("1zqlR"),l=s("iSoIR"),u=s("5pMDk"),c=s("kJrIV"),d=s("7mHzJ"),f=s("5eaQo"),p=new r({Extends:h,Mixins:[o.Alpha,o.BlendMode,o.ComputedSize,o.Crop,o.Depth,o.Flip,o.GetBounds,o.Mask,o.Origin,o.Pipeline,o.ScrollFactor,o.Tint,o.Transform,o.Visible,d],initialize:function(t,e,i,s,r){void 0===e&&(e=0),void 0===i&&(i=0),h.call(this,t,"Text"),/**
         * The renderer in use by this Text object.
         *
         * @name Phaser.GameObjects.Text#renderer
         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}
         * @since 3.12.0
         */this.renderer=t.sys.game.renderer,this.setPosition(e,i),this.setOrigin(0,0),this.initPipeline(),/**
         * The canvas element that the text is rendered to.
         *
         * @name Phaser.GameObjects.Text#canvas
         * @type {HTMLCanvasElement}
         * @since 3.0.0
         */this.canvas=n.create(this),/**
         * The context of the canvas element that the text is rendered to.
         *
         * @name Phaser.GameObjects.Text#context
         * @type {CanvasRenderingContext2D}
         * @since 3.0.0
         */this.context=this.canvas.getContext("2d"),/**
         * The Text Style object.
         *
         * Manages the style of this Text object.
         *
         * @name Phaser.GameObjects.Text#style
         * @type {Phaser.GameObjects.TextStyle}
         * @since 3.0.0
         */this.style=new f(this,r),/**
         * Whether to automatically round line positions.
         *
         * @name Phaser.GameObjects.Text#autoRound
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.autoRound=!0,/**
         * The Regular Expression that is used to split the text up into lines, in
         * multi-line text. By default this is `/(?:\r\n|\r|\n)/`.
         * You can change this RegExp to be anything else that you may need.
         *
         * @name Phaser.GameObjects.Text#splitRegExp
         * @type {object}
         * @since 3.0.0
         */this.splitRegExp=/(?:\r\n|\r|\n)/,/**
         * The text to display.
         *
         * @name Phaser.GameObjects.Text#_text
         * @type {string}
         * @private
         * @since 3.12.0
         */this._text=void 0,/**
         * Specify a padding value which is added to the line width and height when calculating the Text size.
         * Allows you to add extra spacing if the browser is unable to accurately determine the true font dimensions.
         *
         * @name Phaser.GameObjects.Text#padding
         * @type {{left:number,right:number,top:number,bottom:number}}
         * @since 3.0.0
         */this.padding={left:0,right:0,top:0,bottom:0},/**
         * The width of this Text object.
         *
         * @name Phaser.GameObjects.Text#width
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.width=1,/**
         * The height of this Text object.
         *
         * @name Phaser.GameObjects.Text#height
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.height=1,/**
         * The line spacing value.
         * This value is added to the font height to calculate the overall line height.
         * Only has an effect if this Text object contains multiple lines of text.
         * 
         * If you update this property directly, instead of using the `setLineSpacing` method, then
         * be sure to call `updateText` after, or you won't see the change reflected in the Text object.
         *
         * @name Phaser.GameObjects.Text#lineSpacing
         * @type {number}
         * @since 3.13.0
         */this.lineSpacing=0,/**
         * Whether the text or its settings have changed and need updating.
         *
         * @name Phaser.GameObjects.Text#dirty
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.dirty=!1,0===this.style.resolution&&(this.style.resolution=t.sys.game.config.resolution),/**
         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.
         *
         * @name Phaser.GameObjects.Text#_crop
         * @type {object}
         * @private
         * @since 3.12.0
         */this._crop=this.resetCropObject(),//  Create a Texture for this Text object
this.texture=t.sys.textures.addCanvas(null,this.canvas,!0),//  Get the frame
this.frame=this.texture.get(),//  Set the resolution
this.frame.source.resolution=this.style.resolution,this.renderer&&this.renderer.gl&&(//  Clear the default 1x1 glTexture, as we override it later
this.renderer.deleteTexture(this.frame.source.glTexture),this.frame.source.glTexture=null),this.initRTL(),this.setText(s),r&&r.padding&&this.setPadding(r.padding),r&&r.lineSpacing&&this.setLineSpacing(r.lineSpacing),t.sys.game.events.on(a.CONTEXT_RESTORED,function(){this.dirty=!0},this)},/**
     * Initialize right to left text.
     *
     * @method Phaser.GameObjects.Text#initRTL
     * @since 3.0.0
     */initRTL:function(){this.style.rtl&&(//  Here is where the crazy starts.
//
//  Due to browser implementation issues, you cannot fillText BiDi text to a canvas
//  that is not part of the DOM. It just completely ignores the direction property.
this.canvas.dir="rtl",//  Experimental atm, but one day ...
this.context.direction="rtl",//  Add it to the DOM, but hidden within the parent canvas.
this.canvas.style.display="none",i(this.canvas,this.scene.sys.canvas),//  And finally we set the x origin
this.originX=1)},/**
     * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal
     * bounds.
     *
     * @method Phaser.GameObjects.Text#runWordWrap
     * @since 3.0.0
     *
     * @param {string} text - The text to perform word wrap detection against.
     *
     * @return {string} The text after wrapping has been applied.
     */runWordWrap:function(t){var e=this.style;if(e.wordWrapCallback){var i=e.wordWrapCallback.call(e.wordWrapCallbackScope,t,this);return Array.isArray(i)&&(i=i.join("\n")),i}return e.wordWrapWidth?e.wordWrapUseAdvanced?this.advancedWordWrap(t,this.context,this.style.wordWrapWidth):this.basicWordWrap(t,this.context,this.style.wordWrapWidth):t},/**
     * Advanced wrapping algorithm that will wrap words as the line grows longer than its horizontal
     * bounds. Consecutive spaces will be collapsed and replaced with a single space. Lines will be
     * trimmed of white space before processing. Throws an error if wordWrapWidth is less than a
     * single character.
     *
     * @method Phaser.GameObjects.Text#advancedWordWrap
     * @since 3.0.0
     *
     * @param {string} text - The text to perform word wrap detection against.
     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.
     * @param {number} wordWrapWidth - The word wrap width.
     *
     * @return {string} The wrapped text.
     */advancedWordWrap:function(t,e,i){for(var n="",s=t.replace(/ +/gi," ").split(this.splitRegExp),r=s.length,o=0;o<r;o++){var a=s[o],h="";if(// Trim whitespace
a=a.replace(/^ *|\s*$/gi,""),e.measureText(a).width<i){n+=a+"\n";continue}for(var l=i,u=a.split(" "),c=0;c<u.length;c++){var d=u[c],f=d+" ",p=e.measureText(f).width;if(p>l){// Break word
if(0===c){for(// Shave off letters from word until it's small enough
var g=f;g.length&&(g=g.slice(0,-1),!((p=e.measureText(g).width)<=l)););// If wordWrapWidth is too small for even a single letter, shame user
// failure with a fatal error
if(!g.length)throw Error("This text's wordWrapWidth setting is less than a single character!");// Replace current word in array with remainder
var v=d.substr(g.length);u[c]=v,// Append first piece to output
h+=g}// If existing word length is 0, don't include it
var m=u[c].length?c:c+1,y=u.slice(m).join(" ").replace(/[ \n]*$/gi,"");// Prepend remainder to next line
s[o+1]=y+" "+(s[o+1]||""),r=s.length;break;// Processing on this line
// Append word with space to output
}h+=f,l-=p}// Append processed line to output
n+=h.replace(/[ \n]*$/gi,"")+"\n"}return n.replace(/[\s|\n]*$/gi,"")},/**
     * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal
     * bounds. Spaces are not collapsed and whitespace is not trimmed.
     *
     * @method Phaser.GameObjects.Text#basicWordWrap
     * @since 3.0.0
     *
     * @param {string} text - The text to perform word wrap detection against.
     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.
     * @param {number} wordWrapWidth - The word wrap width.
     *
     * @return {string} The wrapped text.
     */basicWordWrap:function(t,e,i){for(var n="",s=t.split(this.splitRegExp),r=s.length-1,o=e.measureText(" ").width,a=0;a<=r;a++){for(var h=i,l=s[a].split(" "),u=l.length-1,c=0;c<=u;c++){var d=l[c],f=e.measureText(d).width,p=f+o;p>h&&c>0&&(n+="\n",h=i),n+=d,c<u?(n+=" ",h-=p):h-=f}a<r&&(n+="\n")}return n},/**
     * Runs the given text through this Text objects word wrapping and returns the results as an
     * array, where each element of the array corresponds to a wrapped line of text.
     *
     * @method Phaser.GameObjects.Text#getWrappedText
     * @since 3.0.0
     *
     * @param {string} text - The text for which the wrapping will be calculated. If unspecified, the Text objects current text will be used.
     *
     * @return {string[]} An array of strings with the pieces of wrapped text.
     */getWrappedText:function(t){return void 0===t&&(t=this._text),this.style.syncFont(this.canvas,this.context),this.runWordWrap(t).split(this.splitRegExp)},/**
     * Set the text to display.
     *
     * An array of strings will be joined with `\n` line breaks.
     *
     * @method Phaser.GameObjects.Text#setText
     * @since 3.0.0
     *
     * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this Text object.
     *
     * @return {this} This Text object.
     */setText:function(t){return t||0===t||(t=""),Array.isArray(t)&&(t=t.join("\n")),t!==this._text&&(this._text=t.toString(),this.updateText()),this},/**
     * Set the text style.
     *
     * @example
     * text.setStyle({
     *     fontSize: '64px',
     *     fontFamily: 'Arial',
     *     color: '#ffffff',
     *     align: 'center',
     *     backgroundColor: '#ff00ff'
     * });
     *
     * @method Phaser.GameObjects.Text#setStyle
     * @since 3.0.0
     *
     * @param {object} style - The style settings to set.
     *
     * @return {this} This Text object.
     */setStyle:function(t){return this.style.setStyle(t)},/**
     * Set the font.
     *
     * If a string is given, the font family is set.
     *
     * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`
     * properties of that object are set.
     *
     * **Important:** The font name must be quoted if it contains certain combinations of digits or
     * special characters:
     *
     * ```javascript
     * Text.setFont('"Press Start 2P"');
     * ```
     *
     * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all
     * quoted properly, too:
     *
     * ```javascript
     * Text.setFont('Georgia, "Goudy Bookletter 1911", Times, serif');
     * ```
     *
     * @method Phaser.GameObjects.Text#setFont
     * @since 3.0.0
     *
     * @param {string} font - The font family or font settings to set.
     *
     * @return {this} This Text object.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Valid_family_names
     */setFont:function(t){return this.style.setFont(t)},/**
     * Set the font family.
     *
     * **Important:** The font name must be quoted if it contains certain combinations of digits or
     * special characters:
     *
     * ```javascript
     * Text.setFont('"Press Start 2P"');
     * ```
     * 
     * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all
     * quoted properly, too:
     * 
     * ```javascript
     * Text.setFont('Georgia, "Goudy Bookletter 1911", Times, serif');
     * ```
     *
     * @method Phaser.GameObjects.Text#setFontFamily
     * @since 3.0.0
     *
     * @param {string} family - The font family.
     *
     * @return {this} This Text object.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Valid_family_names
     */setFontFamily:function(t){return this.style.setFontFamily(t)},/**
     * Set the font size.
     *
     * @method Phaser.GameObjects.Text#setFontSize
     * @since 3.0.0
     *
     * @param {number} size - The font size.
     *
     * @return {this} This Text object.
     */setFontSize:function(t){return this.style.setFontSize(t)},/**
     * Set the font style.
     *
     * @method Phaser.GameObjects.Text#setFontStyle
     * @since 3.0.0
     *
     * @param {string} style - The font style.
     *
     * @return {this} This Text object.
     */setFontStyle:function(t){return this.style.setFontStyle(t)},/**
     * Set a fixed width and height for the text.
     *
     * Pass in `0` for either of these parameters to disable fixed width or height respectively.
     *
     * @method Phaser.GameObjects.Text#setFixedSize
     * @since 3.0.0
     *
     * @param {number} width - The fixed width to set. `0` disables fixed width.
     * @param {number} height - The fixed height to set. `0` disables fixed height.
     *
     * @return {this} This Text object.
     */setFixedSize:function(t,e){return this.style.setFixedSize(t,e)},/**
     * Set the background color.
     *
     * @method Phaser.GameObjects.Text#setBackgroundColor
     * @since 3.0.0
     *
     * @param {string} color - The background color.
     *
     * @return {this} This Text object.
     */setBackgroundColor:function(t){return this.style.setBackgroundColor(t)},/**
     * Set the fill style to be used by the Text object.
     *
     * This can be any valid CanvasRenderingContext2D fillStyle value, such as
     * a color (in hex, rgb, rgba, hsl or named values), a gradient or a pattern.
     *
     * See the [MDN fillStyle docs](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle) for more details.
     *
     * @method Phaser.GameObjects.Text#setFill
     * @since 3.0.0
     *
     * @param {(string|any)} color - The text fill style. Can be any valid CanvasRenderingContext `fillStyle` value.
     *
     * @return {this} This Text object.
     */setFill:function(t){return this.style.setFill(t)},/**
     * Set the text fill color.
     *
     * @method Phaser.GameObjects.Text#setColor
     * @since 3.0.0
     *
     * @param {string} color - The text fill color.
     *
     * @return {this} This Text object.
     */setColor:function(t){return this.style.setColor(t)},/**
     * Set the stroke settings.
     *
     * @method Phaser.GameObjects.Text#setStroke
     * @since 3.0.0
     *
     * @param {string} color - The stroke color.
     * @param {number} thickness - The stroke thickness.
     *
     * @return {this} This Text object.
     */setStroke:function(t,e){return this.style.setStroke(t,e)},/**
     * Set the shadow settings.
     *
     * @method Phaser.GameObjects.Text#setShadow
     * @since 3.0.0
     *
     * @param {number} [x=0] - The horizontal shadow offset.
     * @param {number} [y=0] - The vertical shadow offset.
     * @param {string} [color='#000'] - The shadow color.
     * @param {number} [blur=0] - The shadow blur radius.
     * @param {boolean} [shadowStroke=false] - Whether to stroke the shadow.
     * @param {boolean} [shadowFill=true] - Whether to fill the shadow.
     *
     * @return {this} This Text object.
     */setShadow:function(t,e,i,n,s,r){return this.style.setShadow(t,e,i,n,s,r)},/**
     * Set the shadow offset.
     *
     * @method Phaser.GameObjects.Text#setShadowOffset
     * @since 3.0.0
     *
     * @param {number} x - The horizontal shadow offset.
     * @param {number} y - The vertical shadow offset.
     *
     * @return {this} This Text object.
     */setShadowOffset:function(t,e){return this.style.setShadowOffset(t,e)},/**
     * Set the shadow color.
     *
     * @method Phaser.GameObjects.Text#setShadowColor
     * @since 3.0.0
     *
     * @param {string} color - The shadow color.
     *
     * @return {this} This Text object.
     */setShadowColor:function(t){return this.style.setShadowColor(t)},/**
     * Set the shadow blur radius.
     *
     * @method Phaser.GameObjects.Text#setShadowBlur
     * @since 3.0.0
     *
     * @param {number} blur - The shadow blur radius.
     *
     * @return {this} This Text object.
     */setShadowBlur:function(t){return this.style.setShadowBlur(t)},/**
     * Enable or disable shadow stroke.
     *
     * @method Phaser.GameObjects.Text#setShadowStroke
     * @since 3.0.0
     *
     * @param {boolean} enabled - Whether shadow stroke is enabled or not.
     *
     * @return {this} This Text object.
     */setShadowStroke:function(t){return this.style.setShadowStroke(t)},/**
     * Enable or disable shadow fill.
     *
     * @method Phaser.GameObjects.Text#setShadowFill
     * @since 3.0.0
     *
     * @param {boolean} enabled - Whether shadow fill is enabled or not.
     *
     * @return {this} This Text object.
     */setShadowFill:function(t){return this.style.setShadowFill(t)},/**
     * Set the width (in pixels) to use for wrapping lines. Pass in null to remove wrapping by width.
     *
     * @method Phaser.GameObjects.Text#setWordWrapWidth
     * @since 3.0.0
     *
     * @param {?number} width - The maximum width of a line in pixels. Set to null to remove wrapping.
     * @param {boolean} [useAdvancedWrap=false] - Whether or not to use the advanced wrapping
     * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,
     * spaces and whitespace are left as is.
     *
     * @return {this} This Text object.
     */setWordWrapWidth:function(t,e){return this.style.setWordWrapWidth(t,e)},/**
     * Set a custom callback for wrapping lines. Pass in null to remove wrapping by callback.
     *
     * @method Phaser.GameObjects.Text#setWordWrapCallback
     * @since 3.0.0
     *
     * @param {TextStyleWordWrapCallback} callback - A custom function that will be responsible for wrapping the
     * text. It will receive two arguments: text (the string to wrap), textObject (this Text
     * instance). It should return the wrapped lines either as an array of lines or as a string with
     * newline characters in place to indicate where breaks should happen.
     * @param {object} [scope=null] - The scope that will be applied when the callback is invoked.
     *
     * @return {this} This Text object.
     */setWordWrapCallback:function(t,e){return this.style.setWordWrapCallback(t,e)},/**
     * Set the alignment of the text in this Text object.
     * 
     * The argument can be one of: `left`, `right`, `center` or `justify`.
     * 
     * Alignment only works if the Text object has more than one line of text.
     *
     * @method Phaser.GameObjects.Text#setAlign
     * @since 3.0.0
     *
     * @param {string} [align='left'] - The text alignment for multi-line text.
     *
     * @return {this} This Text object.
     */setAlign:function(t){return this.style.setAlign(t)},/**
     * Set the resolution used by this Text object.
     *
     * By default it will be set to match the resolution set in the Game Config,
     * but you can override it via this method, or by specifying it in the Text style configuration object.
     * 
     * It allows for much clearer text on High DPI devices, at the cost of memory because it uses larger
     * internal Canvas textures for the Text.
     * 
     * Therefore, please use with caution, as the more high res Text you have, the more memory it uses.
     *
     * @method Phaser.GameObjects.Text#setResolution
     * @since 3.12.0
     *
     * @param {number} value - The resolution for this Text object to use.
     *
     * @return {this} This Text object.
     */setResolution:function(t){return this.style.setResolution(t)},/**
     * Sets the line spacing value.
     *
     * This value is _added_ to the height of the font when calculating the overall line height.
     * This only has an effect if this Text object consists of multiple lines of text.
     *
     * @method Phaser.GameObjects.Text#setLineSpacing
     * @since 3.13.0
     *
     * @param {number} value - The amount to add to the font height to achieve the overall line height.
     *
     * @return {this} This Text object.
     */setLineSpacing:function(t){return this.lineSpacing=t,this.updateText()},/**
     * Set the text padding.
     *
     * 'left' can be an object.
     *
     * If only 'left' and 'top' are given they are treated as 'x' and 'y'.
     *
     * @method Phaser.GameObjects.Text#setPadding
     * @since 3.0.0
     *
     * @param {(number|Phaser.Types.GameObjects.Text.TextPadding)} left - The left padding value, or a padding config object.
     * @param {number} top - The top padding value.
     * @param {number} right - The right padding value.
     * @param {number} bottom - The bottom padding value.
     *
     * @return {this} This Text object.
     */setPadding:function(t,e,i,n){if("object"==typeof t){var s=t,r=u(s,"x",null);null!==r?(t=r,i=r):(t=u(s,"left",0),i=u(s,"right",t));var o=u(s,"y",null);null!==o?(e=o,n=o):(e=u(s,"top",0),n=u(s,"bottom",e))}else void 0===t&&(t=0),void 0===e&&(e=t),void 0===i&&(i=t),void 0===n&&(n=e);return this.padding.left=t,this.padding.top=e,this.padding.right=i,this.padding.bottom=n,this.updateText()},/**
     * Set the maximum number of lines to draw.
     *
     * @method Phaser.GameObjects.Text#setMaxLines
     * @since 3.0.0
     *
     * @param {integer} [max=0] - The maximum number of lines to draw.
     *
     * @return {this} This Text object.
     */setMaxLines:function(t){return this.style.setMaxLines(t)},/**
     * Update the displayed text.
     *
     * @method Phaser.GameObjects.Text#updateText
     * @since 3.0.0
     *
     * @return {this} This Text object.
     */updateText:function(){var t,e,i,n=this.canvas,s=this.context,r=this.style,o=r.resolution,a=r.metrics;r.syncFont(n,s);var h=this._text;(r.wordWrapWidth||r.wordWrapCallback)&&(h=this.runWordWrap(this._text));//  Split text into lines
var u=h.split(this.splitRegExp),c=l(this,a,u),d=this.padding;0===r.fixedWidth?(this.width=c.width+d.left+d.right,t=c.width):(this.width=r.fixedWidth,(t=this.width-d.left-d.right)<c.width&&(t=c.width)),0===r.fixedHeight?this.height=c.height+d.top+d.bottom:this.height=r.fixedHeight;var f=this.width,p=this.height;this.updateDisplayOrigin(),f*=o,p*=o,f=Math.max(f,1),p=Math.max(p,1),n.width!==f||n.height!==p?(n.width=f,n.height=p,this.frame.setSize(f,p),//  Because resizing the canvas resets the context
r.syncFont(n,s)):s.clearRect(0,0,f,p),s.save(),s.scale(o,o),r.backgroundColor&&(s.fillStyle=r.backgroundColor,s.fillRect(0,0,f,p)),r.syncStyle(n,s),s.textBaseline="alphabetic",//  Apply padding
s.translate(d.left,d.top);//  Draw text line by line
for(var g=0;g<c.lines;g++){if(e=r.strokeThickness/2,i=r.strokeThickness/2+g*c.lineHeight+a.ascent,g>0&&(i+=c.lineSpacing*g),r.rtl)e=f-e;else if("right"===r.align)e+=t-c.lineWidths[g];else if("center"===r.align)e+=(t-c.lineWidths[g])/2;else if("justify"===r.align&&c.lineWidths[g]/c.width>=.85){for(var v=c.width-c.lineWidths[g],m=s.measureText(" ").width,y=u[g].trim(),x=y.split(" "),w=Math.floor((v+=(u[g].length-y.length)*m)/m),T=0;w>0;)x[T]+=" ",T=(T+1)%(x.length-1||1),--w;u[g]=x.join(" ")}this.autoRound&&(e=Math.round(e),i=Math.round(i)),r.strokeThickness&&(this.style.syncShadow(s,r.shadowStroke),s.strokeText(u[g],e,i)),r.color&&(this.style.syncShadow(s,r.shadowFill),s.fillText(u[g],e,i))}s.restore(),this.renderer&&this.renderer.gl&&(this.frame.source.glTexture=this.renderer.canvasToTexture(n,this.frame.source.glTexture,!0),this.frame.glTexture=this.frame.source.glTexture),this.dirty=!0;var b=this.input;return b&&!b.customHitArea&&(b.hitArea.width=this.width,b.hitArea.height=this.height),this},/**
     * Get the current text metrics.
     *
     * @method Phaser.GameObjects.Text#getTextMetrics
     * @since 3.0.0
     *
     * @return {object} The text metrics.
     */getTextMetrics:function(){return this.style.getTextMetrics()},/**
     * The text string being rendered by this Text Game Object.
     *
     * @name Phaser.GameObjects.Text#text
     * @type {string}
     * @since 3.0.0
     */text:{get:function(){return this._text},set:function(t){this.setText(t)}},/**
     * Build a JSON representation of the Text object.
     *
     * @method Phaser.GameObjects.Text#toJSON
     * @since 3.0.0
     *
     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Text object.
     */toJSON:function(){var t=o.ToJSON(this),e={autoRound:this.autoRound,text:this._text,style:this.style.toJSON(),padding:{left:this.padding.left,right:this.padding.right,top:this.padding.top,bottom:this.padding.bottom}};return t.data=e,t},/**
     * Internal destroy handler, called as part of the destroy process.
     *
     * @method Phaser.GameObjects.Text#preDestroy
     * @protected
     * @since 3.0.0
     */preDestroy:function(){this.style.rtl&&c(this.canvas),n.remove(this.canvas),this.texture.destroy()}});t.exports=p}),r("iSoIR",function(t,e){t.exports=function(t,e,i){var n=t.canvas,s=t.context,r=t.style,o=[],a=0,h=i.length;r.maxLines>0&&r.maxLines<i.length&&(h=r.maxLines),r.syncFont(n,s);//  Text Width
for(var l=0;l<h;l++){var u=r.strokeThickness;u+=s.measureText(i[l]).width,r.wordWrap&&(u-=s.measureText(" ").width),o[l]=Math.ceil(u),a=Math.max(a,o[l])}//  Text Height
var c=e.fontSize+r.strokeThickness,d=c*h,f=t.lineSpacing;return h>1&&(d+=f*(h-1)),{width:a,height:d,lines:h,lineWidths:o,lineSpacing:f,lineHeight:c}}}),r("7mHzJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("1bMaY"),r=s("6MEbf"),t.exports={renderWebGL:n,renderCanvas:r}}),r("1bMaY",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){if(0!==e.width&&0!==e.height){var o=e.frame,a=o.width,h=o.height,l=i.getTintAppendFloatAlpha;this.pipeline.batchTexture(e,o.glTexture,a,h,e.x,e.y,a/e.style.resolution,h/e.style.resolution,e.scaleX,e.scaleY,e.rotation,e.flipX,e.flipY,e.scrollFactorX,e.scrollFactorY,e.displayOriginX,e.displayOriginY,0,0,a,h,l(e._tintTL,s.alpha*e._alphaTL),l(e._tintTR,s.alpha*e._alphaTR),l(e._tintBL,s.alpha*e._alphaBL),l(e._tintBR,s.alpha*e._alphaBR),e._isTinted&&e.tintFill,0,0,s,r)}}}),r("6MEbf",function(t,e){t.exports=function(t,e,i,n,s){0!==e.width&&0!==e.height&&t.batchSprite(e,e.frame,n,s)}}),r("5eaQo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("cSaNN"),r=s("5pMDk"),o=s("5ZcOH"),a={fontFamily:["fontFamily","Courier"],fontSize:["fontSize","16px"],fontStyle:["fontStyle",""],backgroundColor:["backgroundColor",null],color:["color","#fff"],stroke:["stroke","#fff"],strokeThickness:["strokeThickness",0],shadowOffsetX:["shadow.offsetX",0],shadowOffsetY:["shadow.offsetY",0],shadowColor:["shadow.color","#000"],shadowBlur:["shadow.blur",0],shadowStroke:["shadow.stroke",!1],shadowFill:["shadow.fill",!1],align:["align","left"],maxLines:["maxLines",0],fixedWidth:["fixedWidth",0],fixedHeight:["fixedHeight",0],resolution:["resolution",0],rtl:["rtl",!1],testString:["testString","|M\xc3qgy"],baselineX:["baselineX",1.2],baselineY:["baselineY",1.4],wordWrapWidth:["wordWrap.width",null],wordWrapCallback:["wordWrap.callback",null],wordWrapCallbackScope:["wordWrap.callbackScope",null],wordWrapUseAdvanced:["wordWrap.useAdvancedWrap",!1]},h=new i({initialize:function(t,e){/**
         * The Text object that this TextStyle is styling.
         *
         * @name Phaser.GameObjects.TextStyle#parent
         * @type {Phaser.GameObjects.Text}
         * @since 3.0.0
         */this.parent=t,/**
         * The font family.
         *
         * @name Phaser.GameObjects.TextStyle#fontFamily
         * @type {string}
         * @default 'Courier'
         * @since 3.0.0
         */this.fontFamily,/**
         * The font size.
         *
         * @name Phaser.GameObjects.TextStyle#fontSize
         * @type {string}
         * @default '16px'
         * @since 3.0.0
         */this.fontSize,/**
         * The font style.
         *
         * @name Phaser.GameObjects.TextStyle#fontStyle
         * @type {string}
         * @since 3.0.0
         */this.fontStyle,/**
         * The background color.
         *
         * @name Phaser.GameObjects.TextStyle#backgroundColor
         * @type {string}
         * @since 3.0.0
         */this.backgroundColor,/**
         * The text fill color.
         *
         * @name Phaser.GameObjects.TextStyle#color
         * @type {string}
         * @default '#fff'
         * @since 3.0.0
         */this.color,/**
         * The text stroke color.
         *
         * @name Phaser.GameObjects.TextStyle#stroke
         * @type {string}
         * @default '#fff'
         * @since 3.0.0
         */this.stroke,/**
         * The text stroke thickness.
         *
         * @name Phaser.GameObjects.TextStyle#strokeThickness
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.strokeThickness,/**
         * The horizontal shadow offset.
         *
         * @name Phaser.GameObjects.TextStyle#shadowOffsetX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.shadowOffsetX,/**
         * The vertical shadow offset.
         *
         * @name Phaser.GameObjects.TextStyle#shadowOffsetY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.shadowOffsetY,/**
         * The shadow color.
         *
         * @name Phaser.GameObjects.TextStyle#shadowColor
         * @type {string}
         * @default '#000'
         * @since 3.0.0
         */this.shadowColor,/**
         * The shadow blur radius.
         *
         * @name Phaser.GameObjects.TextStyle#shadowBlur
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.shadowBlur,/**
         * Whether shadow stroke is enabled or not.
         *
         * @name Phaser.GameObjects.TextStyle#shadowStroke
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.shadowStroke,/**
         * Whether shadow fill is enabled or not.
         *
         * @name Phaser.GameObjects.TextStyle#shadowFill
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.shadowFill,/**
         * The text alignment.
         *
         * @name Phaser.GameObjects.TextStyle#align
         * @type {string}
         * @default 'left'
         * @since 3.0.0
         */this.align,/**
         * The maximum number of lines to draw.
         *
         * @name Phaser.GameObjects.TextStyle#maxLines
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.maxLines,/**
         * The fixed width of the text.
         *
         * `0` means no fixed with.
         *
         * @name Phaser.GameObjects.TextStyle#fixedWidth
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.fixedWidth,/**
         * The fixed height of the text.
         *
         * `0` means no fixed height.
         *
         * @name Phaser.GameObjects.TextStyle#fixedHeight
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.fixedHeight,/**
         * The resolution the text is rendered to its internal canvas at.
         * The default is 0, which means it will use the resolution set in the Game Config.
         *
         * @name Phaser.GameObjects.TextStyle#resolution
         * @type {number}
         * @default 0
         * @since 3.12.0
         */this.resolution,/**
         * Whether the text should render right to left.
         *
         * @name Phaser.GameObjects.TextStyle#rtl
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.rtl,/**
         * The test string to use when measuring the font.
         *
         * @name Phaser.GameObjects.TextStyle#testString
         * @type {string}
         * @default '|Mqgy'
         * @since 3.0.0
         */this.testString,/**
         * The amount of horizontal padding added to the width of the text when calculating the font metrics.
         *
         * @name Phaser.GameObjects.TextStyle#baselineX
         * @type {number}
         * @default 1.2
         * @since 3.3.0
         */this.baselineX,/**
         * The amount of vertical padding added to the height of the text when calculating the font metrics.
         *
         * @name Phaser.GameObjects.TextStyle#baselineY
         * @type {number}
         * @default 1.4
         * @since 3.3.0
         */this.baselineY,/**
         * The font style, size and family.
         *
         * @name Phaser.GameObjects.TextStyle#_font
         * @type {string}
         * @private
         * @since 3.0.0
         */this._font,//  Set to defaults + user style
this.setStyle(e,!1,!0);var i=r(e,"metrics",!1);i?this.metrics={ascent:r(i,"ascent",0),descent:r(i,"descent",0),fontSize:r(i,"fontSize",0)}:this.metrics=o(this)},/**
     * Set the text style.
     *
     * @example
     * text.setStyle({
     *     fontSize: '64px',
     *     fontFamily: 'Arial',
     *     color: '#ffffff',
     *     align: 'center',
     *     backgroundColor: '#ff00ff'
     * });
     *
     * @method Phaser.GameObjects.TextStyle#setStyle
     * @since 3.0.0
     *
     * @param {Phaser.Types.GameObjects.Text.TextStyle} style - The style settings to set.
     * @param {boolean} [updateText=true] - Whether to update the text immediately.
     * @param {boolean} [setDefaults=false] - Use the default values is not set, or the local values.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setStyle:function(t,e,i){for(var s in void 0===e&&(e=!0),void 0===i&&(i=!1),t&&t.hasOwnProperty("fontSize")&&"number"==typeof t.fontSize&&(t.fontSize=t.fontSize.toString()+"px"),a){var o=i?a[s][1]:this[s];"wordWrapCallback"===s||"wordWrapCallbackScope"===s?this[s]=r(t,a[s][0],o):this[s]=n(t,a[s][0],o)}//  Allow for 'font' override
var h=r(t,"font",null);null!==h&&this.setFont(h,!1),this._font=[this.fontStyle,this.fontSize,this.fontFamily].join(" ").trim();//  Allow for 'fill' to be used in place of 'color'
var l=r(t,"fill",null);return(null!==l&&(this.color=l),e)?this.update(!0):this.parent},/**
     * Synchronize the font settings to the given Canvas Rendering Context.
     *
     * @method Phaser.GameObjects.TextStyle#syncFont
     * @since 3.0.0
     *
     * @param {HTMLCanvasElement} canvas - The Canvas Element.
     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.
     */syncFont:function(t,e){e.font=this._font},/**
     * Synchronize the text style settings to the given Canvas Rendering Context.
     *
     * @method Phaser.GameObjects.TextStyle#syncStyle
     * @since 3.0.0
     *
     * @param {HTMLCanvasElement} canvas - The Canvas Element.
     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.
     */syncStyle:function(t,e){e.textBaseline="alphabetic",e.fillStyle=this.color,e.strokeStyle=this.stroke,e.lineWidth=this.strokeThickness,e.lineCap="round",e.lineJoin="round"},/**
     * Synchronize the shadow settings to the given Canvas Rendering Context.
     *
     * @method Phaser.GameObjects.TextStyle#syncShadow
     * @since 3.0.0
     *
     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.
     * @param {boolean} enabled - Whether shadows are enabled or not.
     */syncShadow:function(t,e){e?(t.shadowOffsetX=this.shadowOffsetX,t.shadowOffsetY=this.shadowOffsetY,t.shadowColor=this.shadowColor,t.shadowBlur=this.shadowBlur):(t.shadowOffsetX=0,t.shadowOffsetY=0,t.shadowColor=0,t.shadowBlur=0)},/**
     * Update the style settings for the parent Text object.
     *
     * @method Phaser.GameObjects.TextStyle#update
     * @since 3.0.0
     *
     * @param {boolean} recalculateMetrics - Whether to recalculate font and text metrics.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */update:function(t){return t&&(this._font=[this.fontStyle,this.fontSize,this.fontFamily].join(" ").trim(),this.metrics=o(this)),this.parent.updateText()},/**
     * Set the font.
     *
     * If a string is given, the font family is set.
     *
     * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`
     * properties of that object are set.
     *
     * @method Phaser.GameObjects.TextStyle#setFont
     * @since 3.0.0
     *
     * @param {(string|object)} font - The font family or font settings to set.
     * @param {boolean} [updateText=true] - Whether to update the text immediately.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setFont:function(t,e){void 0===e&&(e=!0);var i=t,n="",s="";if("string"!=typeof t)i=r(t,"fontFamily","Courier"),n=r(t,"fontSize","16px"),s=r(t,"fontStyle","");else{var o=t.split(" "),a=0;s=o.length>2?o[a++]:"",n=o[a++]||"16px",i=o[a++]||"Courier"}return(i!==this.fontFamily||n!==this.fontSize||s!==this.fontStyle)&&(this.fontFamily=i,this.fontSize=n,this.fontStyle=s,e&&this.update(!0)),this.parent},/**
     * Set the font family.
     *
     * @method Phaser.GameObjects.TextStyle#setFontFamily
     * @since 3.0.0
     *
     * @param {string} family - The font family.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setFontFamily:function(t){return this.fontFamily!==t&&(this.fontFamily=t,this.update(!0)),this.parent},/**
     * Set the font style.
     *
     * @method Phaser.GameObjects.TextStyle#setFontStyle
     * @since 3.0.0
     *
     * @param {string} style - The font style.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setFontStyle:function(t){return this.fontStyle!==t&&(this.fontStyle=t,this.update(!0)),this.parent},/**
     * Set the font size.
     *
     * @method Phaser.GameObjects.TextStyle#setFontSize
     * @since 3.0.0
     *
     * @param {(number|string)} size - The font size.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setFontSize:function(t){return"number"==typeof t&&(t=t.toString()+"px"),this.fontSize!==t&&(this.fontSize=t,this.update(!0)),this.parent},/**
     * Set the test string to use when measuring the font.
     *
     * @method Phaser.GameObjects.TextStyle#setTestString
     * @since 3.0.0
     *
     * @param {string} string - The test string to use when measuring the font.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setTestString:function(t){return this.testString=t,this.update(!0)},/**
     * Set a fixed width and height for the text.
     *
     * Pass in `0` for either of these parameters to disable fixed width or height respectively.
     *
     * @method Phaser.GameObjects.TextStyle#setFixedSize
     * @since 3.0.0
     *
     * @param {number} width - The fixed width to set.
     * @param {number} height - The fixed height to set.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setFixedSize:function(t,e){return this.fixedWidth=t,this.fixedHeight=e,t&&(this.parent.width=t),e&&(this.parent.height=e),this.update(!1)},/**
     * Set the background color.
     *
     * @method Phaser.GameObjects.TextStyle#setBackgroundColor
     * @since 3.0.0
     *
     * @param {string} color - The background color.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setBackgroundColor:function(t){return this.backgroundColor=t,this.update(!1)},/**
     * Set the text fill color.
     *
     * @method Phaser.GameObjects.TextStyle#setFill
     * @since 3.0.0
     *
     * @param {string} color - The text fill color.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setFill:function(t){return this.color=t,this.update(!1)},/**
     * Set the text fill color.
     *
     * @method Phaser.GameObjects.TextStyle#setColor
     * @since 3.0.0
     *
     * @param {string} color - The text fill color.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setColor:function(t){return this.color=t,this.update(!1)},/**
     * Set the resolution used by the Text object.
     *
     * By default it will be set to match the resolution set in the Game Config,
     * but you can override it via this method. It allows for much clearer text on High DPI devices,
     * at the cost of memory because it uses larger internal Canvas textures for the Text.
     * 
     * Please use with caution, as the more high res Text you have, the more memory it uses up.
     *
     * @method Phaser.GameObjects.TextStyle#setResolution
     * @since 3.12.0
     *
     * @param {number} value - The resolution for this Text object to use.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setResolution:function(t){return this.resolution=t,this.update(!1)},/**
     * Set the stroke settings.
     *
     * @method Phaser.GameObjects.TextStyle#setStroke
     * @since 3.0.0
     *
     * @param {string} color - The stroke color.
     * @param {number} thickness - The stroke thickness.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setStroke:function(t,e){return void 0===e&&(e=this.strokeThickness),void 0===t&&0!==this.strokeThickness?(//  Reset the stroke to zero (disabling it)
this.strokeThickness=0,this.update(!0)):(this.stroke!==t||this.strokeThickness!==e)&&(this.stroke=t,this.strokeThickness=e,this.update(!0)),this.parent},/**
     * Set the shadow settings.
     * 
     * Calling this method always re-measures the parent Text object,
     * so only call it when you actually change the shadow settings.
     *
     * @method Phaser.GameObjects.TextStyle#setShadow
     * @since 3.0.0
     *
     * @param {number} [x=0] - The horizontal shadow offset.
     * @param {number} [y=0] - The vertical shadow offset.
     * @param {string} [color='#000'] - The shadow color.
     * @param {number} [blur=0] - The shadow blur radius.
     * @param {boolean} [shadowStroke=false] - Whether to stroke the shadow.
     * @param {boolean} [shadowFill=true] - Whether to fill the shadow.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setShadow:function(t,e,i,n,s,r){return void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i="#000"),void 0===n&&(n=0),void 0===s&&(s=!1),void 0===r&&(r=!0),this.shadowOffsetX=t,this.shadowOffsetY=e,this.shadowColor=i,this.shadowBlur=n,this.shadowStroke=s,this.shadowFill=r,this.update(!1)},/**
     * Set the shadow offset.
     *
     * @method Phaser.GameObjects.TextStyle#setShadowOffset
     * @since 3.0.0
     *
     * @param {number} [x=0] - The horizontal shadow offset.
     * @param {number} [y=0] - The vertical shadow offset.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setShadowOffset:function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),this.shadowOffsetX=t,this.shadowOffsetY=e,this.update(!1)},/**
     * Set the shadow color.
     *
     * @method Phaser.GameObjects.TextStyle#setShadowColor
     * @since 3.0.0
     *
     * @param {string} [color='#000'] - The shadow color.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setShadowColor:function(t){return void 0===t&&(t="#000"),this.shadowColor=t,this.update(!1)},/**
     * Set the shadow blur radius.
     *
     * @method Phaser.GameObjects.TextStyle#setShadowBlur
     * @since 3.0.0
     *
     * @param {number} [blur=0] - The shadow blur radius.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setShadowBlur:function(t){return void 0===t&&(t=0),this.shadowBlur=t,this.update(!1)},/**
     * Enable or disable shadow stroke.
     *
     * @method Phaser.GameObjects.TextStyle#setShadowStroke
     * @since 3.0.0
     *
     * @param {boolean} enabled - Whether shadow stroke is enabled or not.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setShadowStroke:function(t){return this.shadowStroke=t,this.update(!1)},/**
     * Enable or disable shadow fill.
     *
     * @method Phaser.GameObjects.TextStyle#setShadowFill
     * @since 3.0.0
     *
     * @param {boolean} enabled - Whether shadow fill is enabled or not.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setShadowFill:function(t){return this.shadowFill=t,this.update(!1)},/**
     * Set the width (in pixels) to use for wrapping lines.
     *
     * Pass in null to remove wrapping by width.
     *
     * @method Phaser.GameObjects.TextStyle#setWordWrapWidth
     * @since 3.0.0
     *
     * @param {number} width - The maximum width of a line in pixels. Set to null to remove wrapping.
     * @param {boolean} [useAdvancedWrap=false] - Whether or not to use the advanced wrapping
     * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,
     * spaces and whitespace are left as is.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setWordWrapWidth:function(t,e){return void 0===e&&(e=!1),this.wordWrapWidth=t,this.wordWrapUseAdvanced=e,this.update(!1)},/**
     * Set a custom callback for wrapping lines.
     *
     * Pass in null to remove wrapping by callback.
     *
     * @method Phaser.GameObjects.TextStyle#setWordWrapCallback
     * @since 3.0.0
     *
     * @param {TextStyleWordWrapCallback} callback - A custom function that will be responsible for wrapping the
     * text. It will receive two arguments: text (the string to wrap), textObject (this Text
     * instance). It should return the wrapped lines either as an array of lines or as a string with
     * newline characters in place to indicate where breaks should happen.
     * @param {object} [scope=null] - The scope that will be applied when the callback is invoked.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setWordWrapCallback:function(t,e){return void 0===e&&(e=null),this.wordWrapCallback=t,this.wordWrapCallbackScope=e,this.update(!1)},/**
     * Set the alignment of the text in this Text object.
     * 
     * The argument can be one of: `left`, `right`, `center` or `justify`.
     * 
     * Alignment only works if the Text object has more than one line of text.
     *
     * @method Phaser.GameObjects.TextStyle#setAlign
     * @since 3.0.0
     *
     * @param {string} [align='left'] - The text alignment for multi-line text.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setAlign:function(t){return void 0===t&&(t="left"),this.align=t,this.update(!1)},/**
     * Set the maximum number of lines to draw.
     *
     * @method Phaser.GameObjects.TextStyle#setMaxLines
     * @since 3.0.0
     *
     * @param {integer} [max=0] - The maximum number of lines to draw.
     *
     * @return {Phaser.GameObjects.Text} The parent Text object.
     */setMaxLines:function(t){return void 0===t&&(t=0),this.maxLines=t,this.update(!1)},/**
     * Get the current text metrics.
     *
     * @method Phaser.GameObjects.TextStyle#getTextMetrics
     * @since 3.0.0
     *
     * @return {Phaser.Types.GameObjects.Text.TextMetrics} The text metrics.
     */getTextMetrics:function(){var t=this.metrics;return{ascent:t.ascent,descent:t.descent,fontSize:t.fontSize}},/**
     * Build a JSON representation of this Text Style.
     *
     * @method Phaser.GameObjects.TextStyle#toJSON
     * @since 3.0.0
     *
     * @return {object} A JSON representation of this Text Style.
     */toJSON:function(){var t={};for(var e in a)t[e]=this[e];return t.metrics=this.getTextMetrics(),t},/**
     * Destroy this Text Style.
     *
     * @method Phaser.GameObjects.TextStyle#destroy
     * @since 3.0.0
     */destroy:function(){this.parent=void 0}});t.exports=h}),r("5ZcOH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kKoer");t.exports=function(t){// @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
var e,n,s=i.create(this),r=s.getContext("2d");t.syncFont(s,r);var o=Math.ceil(r.measureText(t.testString).width*t.baselineX),a=o,h=2*a;a=a*t.baselineY|0,s.width=o,s.height=h,r.fillStyle="#f00",r.fillRect(0,0,o,h),r.font=t._font,r.textBaseline="alphabetic",r.fillStyle="#000",r.fillText(t.testString,0,a);var l={ascent:0,descent:0,fontSize:0};if(!r.getImageData(0,0,o,h))return l.ascent=a,l.descent=a+6,l.fontSize=l.ascent+l.descent,i.remove(s),l;var u=r.getImageData(0,0,o,h).data,c=u.length,d=4*o,f=0,p=!1;// ascent. scan from top to bottom until we find a non red pixel
for(e=0;e<a;e++){for(n=0;n<d;n+=4)if(255!==u[f+n]){p=!0;break}if(p)break;f+=d}// descent. scan from bottom to top until we find a non red pixel
for(l.ascent=a-e,f=c-d,p=!1,e=h;e>a;e--){for(n=0;n<d;n+=4)if(255!==u[f+n]){p=!0;break}if(p)break;f-=d}return l.descent=e-a,l.fontSize=l.ascent+l.descent,i.remove(s),l}}),r("kwyUq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kKoer"),n=s("jwj1g"),r=s("4FF1v"),o=s("aqcI1"),a=s("1zqlR"),h=s("6QpKi"),l=s("g0MK9"),u=s("5kpeZ"),c=s("7SBSk"),d=new n({Extends:a,Mixins:[r.Alpha,r.BlendMode,r.ComputedSize,r.Crop,r.Depth,r.Flip,r.GetBounds,r.Mask,r.Origin,r.Pipeline,r.ScrollFactor,r.Tint,r.Transform,r.Visible,u],initialize:function(t,e,n,s,r,l,u){var d=t.sys.game.renderer;a.call(this,t,"TileSprite");var f=t.sys.textures.get(l),p=f.get(u);s&&r?(s=Math.floor(s),r=Math.floor(r)):(s=p.width,r=p.height),/**
         * Internal tile position vector.
         *
         * @name Phaser.GameObjects.TileSprite#_tilePosition
         * @type {Phaser.Math.Vector2}
         * @private
         * @since 3.12.0
         */this._tilePosition=new c,/**
         * Internal tile scale vector.
         *
         * @name Phaser.GameObjects.TileSprite#_tileScale
         * @type {Phaser.Math.Vector2}
         * @private
         * @since 3.12.0
         */this._tileScale=new c(1,1),/**
         * Whether the Tile Sprite has changed in some way, requiring an re-render of its tile texture.
         *
         * Such changes include the texture frame and scroll position of the Tile Sprite.
         *
         * @name Phaser.GameObjects.TileSprite#dirty
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.dirty=!1,/**
         * The renderer in use by this Tile Sprite.
         *
         * @name Phaser.GameObjects.TileSprite#renderer
         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}
         * @since 3.0.0
         */this.renderer=d,/**
         * The Canvas element that the TileSprite renders its fill pattern in to.
         * Only used in Canvas mode.
         *
         * @name Phaser.GameObjects.TileSprite#canvas
         * @type {?HTMLCanvasElement}
         * @since 3.12.0
         */this.canvas=i.create(this,s,r),/**
         * The Context of the Canvas element that the TileSprite renders its fill pattern in to.
         * Only used in Canvas mode.
         *
         * @name Phaser.GameObjects.TileSprite#context
         * @type {CanvasRenderingContext2D}
         * @since 3.12.0
         */this.context=this.canvas.getContext("2d"),/**
         * The Texture the TileSprite is using as its fill pattern.
         *
         * @name Phaser.GameObjects.TileSprite#displayTexture
         * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}
         * @private
         * @since 3.12.0
         */this.displayTexture=f,/**
         * The Frame the TileSprite is using as its fill pattern.
         *
         * @name Phaser.GameObjects.TileSprite#displayFrame
         * @type {Phaser.Textures.Frame}
         * @private
         * @since 3.12.0
         */this.displayFrame=p,/**
         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.
         *
         * @name Phaser.GameObjects.TileSprite#_crop
         * @type {object}
         * @private
         * @since 3.12.0
         */this._crop=this.resetCropObject(),/**
         * The Texture this Game Object is using to render with.
         *
         * @name Phaser.GameObjects.TileSprite#texture
         * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}
         * @since 3.0.0
         */this.texture=t.sys.textures.addCanvas(null,this.canvas,!0),/**
         * The Texture Frame this Game Object is using to render with.
         *
         * @name Phaser.GameObjects.TileSprite#frame
         * @type {Phaser.Textures.Frame}
         * @since 3.0.0
         */this.frame=this.texture.get(),/**
         * The next power of two value from the width of the Fill Pattern frame.
         *
         * @name Phaser.GameObjects.TileSprite#potWidth
         * @type {integer}
         * @since 3.0.0
         */this.potWidth=h(p.width),/**
         * The next power of two value from the height of the Fill Pattern frame.
         *
         * @name Phaser.GameObjects.TileSprite#potHeight
         * @type {integer}
         * @since 3.0.0
         */this.potHeight=h(p.height),/**
         * The Canvas that the TileSprites texture is rendered to.
         * This is used to create a WebGL texture from.
         *
         * @name Phaser.GameObjects.TileSprite#fillCanvas
         * @type {HTMLCanvasElement}
         * @since 3.12.0
         */this.fillCanvas=i.create2D(this,this.potWidth,this.potHeight),/**
         * The Canvas Context used to render the TileSprites texture.
         *
         * @name Phaser.GameObjects.TileSprite#fillContext
         * @type {CanvasRenderingContext2D}
         * @since 3.12.0
         */this.fillContext=this.fillCanvas.getContext("2d"),/**
         * The texture that the Tile Sprite is rendered to, which is then rendered to a Scene.
         * In WebGL this is a WebGLTexture. In Canvas it's a Canvas Fill Pattern.
         *
         * @name Phaser.GameObjects.TileSprite#fillPattern
         * @type {?(WebGLTexture|CanvasPattern)}
         * @since 3.12.0
         */this.fillPattern=null,this.setPosition(e,n),this.setSize(s,r),this.setFrame(u),this.setOriginFromFrame(),this.initPipeline(),t.sys.game.events.on(o.CONTEXT_RESTORED,function(t){var e=t.gl;this.dirty=!0,this.fillPattern=null,this.fillPattern=t.createTexture2D(0,e.LINEAR,e.LINEAR,e.REPEAT,e.REPEAT,e.RGBA,this.fillCanvas,this.potWidth,this.potHeight)},this)},/**
     * Sets the texture and frame this Game Object will use to render with.
     *
     * Textures are referenced by their string-based keys, as stored in the Texture Manager.
     *
     * @method Phaser.GameObjects.TileSprite#setTexture
     * @since 3.0.0
     *
     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.
     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.
     *
     * @return {this} This Game Object instance.
     */setTexture:function(t,e){return this.displayTexture=this.scene.sys.textures.get(t),this.setFrame(e)},/**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * @method Phaser.GameObjects.TileSprite#setFrame
     * @since 3.0.0
     *
     * @param {(string|integer)} frame - The name or index of the frame within the Texture.
     *
     * @return {this} This Game Object instance.
     */setFrame:function(t){var e=this.displayTexture.get(t);return this.potWidth=h(e.width),this.potHeight=h(e.height),//  So updateCanvas is triggered
this.canvas.width=0,e.cutWidth&&e.cutHeight?this.renderFlags|=8:this.renderFlags&=-9,this.displayFrame=e,this.dirty=!0,this.updateTileTexture(),this},/**
     * Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.
     *
     * @method Phaser.GameObjects.TileSprite#setTilePosition
     * @since 3.3.0
     *
     * @param {number} [x] - The x position of this sprite's tiling texture.
     * @param {number} [y] - The y position of this sprite's tiling texture.
     *
     * @return {this} This Tile Sprite instance.
     */setTilePosition:function(t,e){return void 0!==t&&(this.tilePositionX=t),void 0!==e&&(this.tilePositionY=e),this},/**
     * Sets {@link Phaser.GameObjects.TileSprite#tileScaleX} and {@link Phaser.GameObjects.TileSprite#tileScaleY}.
     *
     * @method Phaser.GameObjects.TileSprite#setTileScale
     * @since 3.12.0
     *
     * @param {number} [x] - The horizontal scale of the tiling texture. If not given it will use the current `tileScaleX` value.
     * @param {number} [y=x] - The vertical scale of the tiling texture. If not given it will use the `x` value.
     *
     * @return {this} This Tile Sprite instance.
     */setTileScale:function(t,e){return void 0===t&&(t=this.tileScaleX),void 0===e&&(e=t),this.tileScaleX=t,this.tileScaleY=e,this},/**
     * Render the tile texture if it is dirty, or if the frame has changed.
     *
     * @method Phaser.GameObjects.TileSprite#updateTileTexture
     * @private
     * @since 3.0.0
     */updateTileTexture:function(){if(this.dirty&&this.renderer){//  Draw the displayTexture to our fillCanvas
var t=this.displayFrame;if(t.source.isRenderTexture||t.source.isGLTexture){console.warn("TileSprites can only use Image or Canvas based textures"),this.dirty=!1;return}var e=this.fillContext,i=this.fillCanvas,n=this.potWidth,s=this.potHeight;this.renderer.gl||(n=t.cutWidth,s=t.cutHeight),e.clearRect(0,0,n,s),i.width=n,i.height=s,e.drawImage(t.source.image,t.cutX,t.cutY,t.cutWidth,t.cutHeight,0,0,n,s),this.renderer.gl?this.fillPattern=this.renderer.canvasToTexture(i,this.fillPattern):this.fillPattern=e.createPattern(i,"repeat"),this.updateCanvas(),this.dirty=!1}},/**
     * Draw the fill pattern to the internal canvas.
     *
     * @method Phaser.GameObjects.TileSprite#updateCanvas
     * @private
     * @since 3.12.0
     */updateCanvas:function(){var t=this.canvas;if((t.width!==this.width||t.height!==this.height)&&(t.width=this.width,t.height=this.height,this.frame.setSize(this.width,this.height),this.updateDisplayOrigin(),this.dirty=!0),!this.dirty||this.renderer&&this.renderer.gl){this.dirty=!1;return}var e=this.context;this.scene.sys.game.config.antialias||l.disable(e);var i=this._tileScale.x,n=this._tileScale.y,s=this._tilePosition.x,r=this._tilePosition.y;e.clearRect(0,0,this.width,this.height),e.save(),e.scale(i,n),e.translate(-s,-r),e.fillStyle=this.fillPattern,e.fillRect(s,r,this.width/i,this.height/n),e.restore(),this.dirty=!1},/**
     * Internal destroy handler, called as part of the destroy process.
     *
     * @method Phaser.GameObjects.TileSprite#preDestroy
     * @protected
     * @since 3.9.0
     */preDestroy:function(){this.renderer&&this.renderer.gl&&this.renderer.deleteTexture(this.fillPattern),i.remove(this.canvas),i.remove(this.fillCanvas),this.fillPattern=null,this.fillContext=null,this.fillCanvas=null,this.displayTexture=null,this.displayFrame=null,this.texture.destroy(),this.renderer=null},/**
     * The horizontal scroll position of the Tile Sprite.
     *
     * @name Phaser.GameObjects.TileSprite#tilePositionX
     * @type {number}
     * @default 0
     * @since 3.0.0
     */tilePositionX:{get:function(){return this._tilePosition.x},set:function(t){this._tilePosition.x=t,this.dirty=!0}},/**
     * The vertical scroll position of the Tile Sprite.
     *
     * @name Phaser.GameObjects.TileSprite#tilePositionY
     * @type {number}
     * @default 0
     * @since 3.0.0
     */tilePositionY:{get:function(){return this._tilePosition.y},set:function(t){this._tilePosition.y=t,this.dirty=!0}},/**
     * The horizontal scale of the Tile Sprite texture.
     *
     * @name Phaser.GameObjects.TileSprite#tileScaleX
     * @type {number}
     * @default 1
     * @since 3.11.0
     */tileScaleX:{get:function(){return this._tileScale.x},set:function(t){this._tileScale.x=t,this.dirty=!0}},/**
     * The vertical scale of the Tile Sprite texture.
     *
     * @name Phaser.GameObjects.TileSprite#tileScaleY
     * @type {number}
     * @default 1
     * @since 3.11.0
     */tileScaleY:{get:function(){return this._tileScale.y},set:function(t){this._tileScale.y=t,this.dirty=!0}}});t.exports=d}),r("5kpeZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("fehBS"),r=s("9KTFl"),t.exports={renderWebGL:n,renderCanvas:r}}),r("fehBS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){e.updateCanvas();var o=i.getTintAppendFloatAlpha;this.pipeline.batchTexture(e,e.fillPattern,e.displayFrame.width*e.tileScaleX,e.displayFrame.height*e.tileScaleY,e.x,e.y,e.width,e.height,e.scaleX,e.scaleY,e.rotation,e.flipX,e.flipY,e.scrollFactorX,e.scrollFactorY,e.originX*e.width,e.originY*e.height,0,0,e.width,e.height,o(e._tintTL,s.alpha*e._alphaTL),o(e._tintTR,s.alpha*e._alphaTR),o(e._tintBL,s.alpha*e._alphaBL),o(e._tintBR,s.alpha*e._alphaBR),e._isTinted&&e.tintFill,e.tilePositionX%e.displayFrame.width/e.displayFrame.width,e.tilePositionY%e.displayFrame.height/e.displayFrame.height,s,r)}}),r("9KTFl",function(t,e){t.exports=function(t,e,i,n,s){e.updateCanvas(),t.batchSprite(e,e.frame,n,s)}}),r("Cfqdl",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("iEUUO"),r=s("4FF1v"),o=s("jIv3O"),a=s("aqcI1"),h=s("1zqlR"),l=s("kcpiS"),u=s("gS40I"),c=s("dQCPJ"),d=s("bNtDi"),f=new i({Extends:h,Mixins:[r.Alpha,r.BlendMode,r.Depth,r.Flip,r.GetBounds,r.Mask,r.Origin,r.Pipeline,r.ScrollFactor,r.Size,r.TextureCrop,r.Tint,r.Transform,r.Visible,c],initialize:function(t,e,i,n){h.call(this,t,"Video"),/**
         * A reference to the HTML Video Element this Video Game Object is playing.
         * Will be `null` until a video is loaded for playback.
         *
         * @name Phaser.GameObjects.Video#video
         * @type {?HTMLVideoElement}
         * @since 3.20.0
         */this.video=null,/**
         * The Phaser Texture this Game Object is using to render the video to.
         * Will be `null` until a video is loaded for playback.
         *
         * @name Phaser.GameObjects.Video#videoTexture
         * @type {?Phaser.Textures.Texture}
         * @since 3.20.0
         */this.videoTexture=null,/**
         * A reference to the TextureSource belong to the `videoTexture` Texture object.
         * Will be `null` until a video is loaded for playback.
         *
         * @name Phaser.GameObjects.Video#videoTextureSource
         * @type {?Phaser.Textures.TextureSource}
         * @since 3.20.0
         */this.videoTextureSource=null,/**
         * A Phaser CanvasTexture instance that holds the most recent snapshot taken from the video.
         * This will only be set if `snapshot` or `snapshotArea` have been called, and will be `null` until that point.
         *
         * @name Phaser.GameObjects.Video#snapshotTexture
         * @type {?Phaser.Textures.CanvasTexture}
         * @since 3.20.0
         */this.snapshotTexture=null,/**
         * If you have saved this video to a texture via the `saveTexture` method, this controls if the video
         * is rendered with `flipY` in WebGL or not. You often need to set this if you wish to use the video texture
         * as the input source for a shader. If you find your video is appearing upside down within a shader or
         * custom pipeline, flip this property.
         *
         * @name Phaser.GameObjects.Video#flipY
         * @type {boolean}
         * @since 3.20.0
         */this.flipY=!1,/**
         * The key used by the texture as stored in the Texture Manager.
         *
         * @name Phaser.GameObjects.Video#_key
         * @type {string}
         * @private
         * @since 3.20.0
         */this._key=u(),/**
         * An internal flag holding the current state of the video lock, should document interaction be required
         * before playback can begin.
         *
         * @name Phaser.GameObjects.Video#touchLocked
         * @type {boolean}
         * @since 3.20.0
         */this.touchLocked=!0,/**
         * Should the video auto play when document interaction is required and happens?
         *
         * @name Phaser.GameObjects.Video#playWhenUnlocked
         * @type {boolean}
         * @since 3.20.0
         */this.playWhenUnlocked=!1,/**
         * When starting playback of a video Phaser will monitor its `readyState` using a `setTimeout` call.
         * The `setTimeout` happens once every `Video.retryInterval` ms. It will carry on monitoring the video
         * state in this manner until the `retryLimit` is reached and then abort.
         *
         * @name Phaser.GameObjects.Video#retryLimit
         * @type {integer}
         * @since 3.20.0
         */this.retryLimit=20,/**
         * The current retry attempt.
         *
         * @name Phaser.GameObjects.Video#retry
         * @type {integer}
         * @since 3.20.0
         */this.retry=0,/**
         * The number of ms between each retry while monitoring the ready state of a downloading video.
         *
         * @name Phaser.GameObjects.Video#retryInterval
         * @type {integer}
         * @since 3.20.0
         */this.retryInterval=500,/**
         * The setTimeout callback ID.
         *
         * @name Phaser.GameObjects.Video#_retryID
         * @type {integer}
         * @private
         * @since 3.20.0
         */this._retryID=null,/**
         * The video was muted due to a system event, such as the game losing focus.
         *
         * @name Phaser.GameObjects.Video#_systemMuted
         * @type {boolean}
         * @private
         * @since 3.20.0
         */this._systemMuted=!1,/**
         * The video was muted due to game code, not a system event.
         *
         * @name Phaser.GameObjects.Video#_codeMuted
         * @type {boolean}
         * @private
         * @since 3.20.0
         */this._codeMuted=!1,/**
         * The video was paused due to a system event, such as the game losing focus.
         *
         * @name Phaser.GameObjects.Video#_systemPaused
         * @type {boolean}
         * @private
         * @since 3.20.0
         */this._systemPaused=!1,/**
         * The video was paused due to game code, not a system event.
         *
         * @name Phaser.GameObjects.Video#_codePaused
         * @type {boolean}
         * @private
         * @since 3.20.0
         */this._codePaused=!1,/**
         * The locally bound event callback handlers.
         *
         * @name Phaser.GameObjects.Video#_callbacks
         * @type {any}
         * @private
         * @since 3.20.0
         */this._callbacks={play:this.playHandler.bind(this),error:this.loadErrorHandler.bind(this),end:this.completeHandler.bind(this),time:this.timeUpdateHandler.bind(this),seeking:this.seekingHandler.bind(this),seeked:this.seekedHandler.bind(this)},/**
         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.
         *
         * @name Phaser.GameObjects.Video#_crop
         * @type {object}
         * @private
         * @since 3.20.0
         */this._crop=this.resetCropObject(),/**
         * An object containing in and out markers for sequence playback.
         *
         * @name Phaser.GameObjects.Video#markers
         * @type {any}
         * @since 3.20.0
         */this.markers={},/**
         * The in marker.
         *
         * @name Phaser.GameObjects.Video#_markerIn
         * @type {integer}
         * @private
         * @since 3.20.0
         */this._markerIn=-1,/**
         * The out marker.
         *
         * @name Phaser.GameObjects.Video#_markerOut
         * @type {integer}
         * @private
         * @since 3.20.0
         */this._markerOut=d.MAX_SAFE_INTEGER,/**
         * The last time the TextureSource was updated.
         *
         * @name Phaser.GameObjects.Video#_lastUpdate
         * @type {integer}
         * @private
         * @since 3.20.0
         */this._lastUpdate=0,/**
         * The key of the video being played from the Video cache, if any.
         *
         * @name Phaser.GameObjects.Video#_cacheKey
         * @type {string}
         * @private
         * @since 3.20.0
         */this._cacheKey="",/**
         * Is the video currently seeking?
         *
         * @name Phaser.GameObjects.Video#_isSeeking
         * @type {boolean}
         * @private
         * @since 3.20.0
         */this._isSeeking=!1,/**
         * Should the Video element that this Video is using, be removed from the DOM
         * when this Video is destroyed?
         *
         * @name Phaser.GameObjects.Video#removeVideoElementOnDestroy
         * @type {boolean}
         * @since 3.21.0
         */this.removeVideoElementOnDestroy=!1,this.setPosition(e,i),this.initPipeline(),n&&this.changeSource(n,!1);var s=t.sys.game.events;s.on(a.PAUSE,this.globalPause,this),s.on(a.RESUME,this.globalResume,this);var r=t.sys.sound;r&&r.on(l.GLOBAL_MUTE,this.globalMute,this)},/**
     * Starts this video playing.
     *
     * If the video is already playing, or has been queued to play with `changeSource` then this method just returns.
     * 
     * Videos can only autoplay if the browser has been unlocked. This happens if you have interacted with the browser, i.e.
     * by clicking on it or pressing a key, or due to server settings. The policies that control autoplaying are vast and
     * vary between browser. You can read more here: https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide
     * 
     * If your video doesn't contain any audio, then set the `noAudio` parameter to `true` when the video is loaded,
     * and it will often allow the video to play immediately:
     * 
     * ```javascript
     * preload () {
     *   this.load.video('pixar', 'nemo.mp4', 'loadeddata', false, true);
     * }
     * ```
     * 
     * The 5th parameter in the load call tells Phaser that the video doesn't contain any audio tracks. Video without
     * audio can autoplay without requiring a user interaction. Video with audio cannot do this unless it satisfies
     * the browsers MEI settings. See the MDN Autoplay Guide for details.
     * 
     * If you need audio in your videos, then you'll have to consider the fact that the video cannot start playing until the
     * user has interacted with the browser, into your game flow.
     *
     * @method Phaser.GameObjects.Video#play
     * @since 3.20.0
     * 
     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.
     * @param {integer} [markerIn] - Optional in marker time, in seconds, for playback of a sequence of the video.
     * @param {integer} [markerOut] - Optional out marker time, in seconds, for playback of a sequence of the video.
     * 
     * @return {this} This Video Game Object for method chaining.
     */play:function(t,e,i){if(this.touchLocked&&this.playWhenUnlocked||this.isPlaying())return this;var n=this.video;if(!n)return console.warn("Video not loaded"),this;void 0===t&&(t=n.loop);var s=this.scene.sys.sound;s&&s.mute&&this.setMute(!0),isNaN(e)||(this._markerIn=e),!isNaN(i)&&i>e&&(this._markerOut=i),n.loop=t;var r=this._callbacks,o=n.play();return void 0!==o?o.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this)):(//  Old-school browsers with no Promises
n.addEventListener("playing",r.play,!0),n.readyState<2&&(this.retry=this.retryLimit,this._retryID=window.setTimeout(this.checkVideoProgress.bind(this),this.retryInterval))),//  Set these _after_ calling `play` or they don't fire (useful, thanks browsers)
n.addEventListener("ended",r.end,!0),n.addEventListener("timeupdate",r.time,!0),n.addEventListener("seeking",r.seeking,!0),n.addEventListener("seeked",r.seeked,!0),this},/**
     * This method allows you to change the source of the current video element. It works by first stopping the
     * current video, if playing. Then deleting the video texture, if one has been created. Finally, it makes a
     * new video texture and starts playback of the new source through the existing video element.
     * 
     * The reason you may wish to do this is because videos that require interaction to unlock, remain in an unlocked
     * state, even if you change the source of the video. By changing the source to a new video you avoid having to
     * go through the unlock process again.
     *
     * @method Phaser.GameObjects.Video#changeSource
     * @since 3.20.0
     * 
     * @param {string} key - The key of the Video this Game Object will swap to playing, as stored in the Video Cache.
     * @param {boolean} [autoplay=true] - Should the video start playing immediately, once the swap is complete?
     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.
     * @param {integer} [markerIn] - Optional in marker time, in seconds, for playback of a sequence of the video.
     * @param {integer} [markerOut] - Optional out marker time, in seconds, for playback of a sequence of the video.
     * 
     * @return {this} This Video Game Object for method chaining.
     */changeSource:function(t,e,i,n,s){void 0===e&&(e=!0),this.video&&this.stop();var r=this.scene.sys.cache.video.get(t);return r?(this.video=r,this._cacheKey=t,this._codePaused=r.paused,this._codeMuted=r.muted,this.videoTexture?(this.scene.sys.textures.remove(this._key),this.videoTexture=this.scene.sys.textures.create(this._key,r,r.videoWidth,r.videoHeight),this.videoTextureSource=this.videoTexture.source[0],this.videoTexture.add("__BASE",0,0,0,r.videoWidth,r.videoHeight),this.setTexture(this.videoTexture),this.setSizeToFrame(),this.updateDisplayOrigin(),this.emit(o.VIDEO_CREATED,this,r.videoWidth,r.videoHeight)):this.updateTexture(),r.currentTime=0,this._lastUpdate=0,e&&this.play(i,n,s)):this.video=null,this},/**
     * Adds a sequence marker to this video.
     * 
     * Markers allow you to split a video up into sequences, delineated by a start and end time, given in seconds.
     * 
     * You can then play back specific markers via the `playMarker` method.
     * 
     * Note that marker timing is _not_ frame-perfect. You should construct your videos in such a way that you allow for
     * plenty of extra padding before and after each sequence to allow for discrepancies in browser seek and currentTime accuracy.
     * 
     * See https://github.com/w3c/media-and-entertainment/issues/4 for more details about this issue.
     *
     * @method Phaser.GameObjects.Video#addMarker
     * @since 3.20.0
     * 
     * @param {string} key - A unique name to give this marker.
     * @param {integer} markerIn - The time, in seconds, representing the start of this marker.
     * @param {integer} markerOut - The time, in seconds, representing the end of this marker.
     * 
     * @return {this} This Video Game Object for method chaining.
     */addMarker:function(t,e,i){return isNaN(e)||!(e>=0)||isNaN(i)||(this.markers[t]=[e,i]),this},/**
     * Plays a pre-defined sequence in this video.
     * 
     * Markers allow you to split a video up into sequences, delineated by a start and end time, given in seconds and
     * specified via the `addMarker` method.
     * 
     * Note that marker timing is _not_ frame-perfect. You should construct your videos in such a way that you allow for
     * plenty of extra padding before and after each sequence to allow for discrepancies in browser seek and currentTime accuracy.
     * 
     * See https://github.com/w3c/media-and-entertainment/issues/4 for more details about this issue.
     *
     * @method Phaser.GameObjects.Video#playMarker
     * @since 3.20.0
     * 
     * @param {string} key - The name of the marker sequence to play.
     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.
     * 
     * @return {this} This Video Game Object for method chaining.
     */playMarker:function(t,e){var i=this.markers[t];return i&&this.play(e,i[0],i[1]),this},/**
     * Removes a previously set marker from this video.
     * 
     * If the marker is currently playing it will _not_ stop playback.
     *
     * @method Phaser.GameObjects.Video#removeMarker
     * @since 3.20.0
     * 
     * @param {string} key - The name of the marker to remove.
     * 
     * @return {this} This Video Game Object for method chaining.
     */removeMarker:function(t){return delete this.markers[t],this},/**
     * Takes a snapshot of the current frame of the video and renders it to a CanvasTexture object,
     * which is then returned. You can optionally resize the grab by passing a width and height.
     * 
     * This method returns a reference to the `Video.snapshotTexture` object. Calling this method
     * multiple times will overwrite the previous snapshot with the most recent one.
     *
     * @method Phaser.GameObjects.Video#snapshot
     * @since 3.20.0
     * 
     * @param {integer} [width] - The width of the resulting CanvasTexture.
     * @param {integer} [height] - The height of the resulting CanvasTexture.
     * 
     * @return {Phaser.Textures.CanvasTexture} 
     */snapshot:function(t,e){return void 0===t&&(t=this.width),void 0===e&&(e=this.height),this.snapshotArea(0,0,this.width,this.height,t,e)},/**
     * Takes a snapshot of the specified area of the current frame of the video and renders it to a CanvasTexture object,
     * which is then returned. You can optionally resize the grab by passing a different `destWidth` and `destHeight`.
     * 
     * This method returns a reference to the `Video.snapshotTexture` object. Calling this method
     * multiple times will overwrite the previous snapshot with the most recent one.
     *
     * @method Phaser.GameObjects.Video#snapshotArea
     * @since 3.20.0
     * 
     * @param {integer} [x=0] - The horizontal location of the top-left of the area to grab from.
     * @param {integer} [y=0] - The vertical location of the top-left of the area to grab from.
     * @param {integer} [srcWidth] - The width of area to grab from the video. If not given it will grab the full video dimensions.
     * @param {integer} [srcHeight] - The height of area to grab from the video. If not given it will grab the full video dimensions.
     * @param {integer} [destWidth] - The destination width of the grab, allowing you to resize it.
     * @param {integer} [destHeight] - The destination height of the grab, allowing you to resize it.
     * 
     * @return {Phaser.Textures.CanvasTexture} 
     */snapshotArea:function(t,e,i,n,s,r){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=this.width),void 0===n&&(n=this.height),void 0===s&&(s=i),void 0===r&&(r=n);var o=this.video,a=this.snapshotTexture;return a?a.setSize(s,r):(a=this.scene.sys.textures.createCanvas(u(),s,r),this.snapshotTexture=a),o&&a.context.drawImage(o,t,e,i,n,0,0,s,r),a.update()},/**
     * Stores a copy of this Videos `snapshotTexture` in the Texture Manager using the given key.
     * 
     * This texture is created when the `snapshot` or `snapshotArea` methods are called.
     * 
     * After doing this, any texture based Game Object, such as a Sprite, can use the contents of the
     * snapshot by using the texture key:
     * 
     * ```javascript
     * var vid = this.add.video(0, 0, 'intro');
     * 
     * vid.snapshot();
     * 
     * vid.saveSnapshotTexture('doodle');
     * 
     * this.add.image(400, 300, 'doodle');
     * ```
     * 
     * Updating the contents of the `snapshotTexture`, for example by calling `snapshot` again,
     * will automatically update _any_ Game Object that is using it as a texture.
     * Calling `saveSnapshotTexture` again will not save another copy of the same texture,
     * it will just rename the existing one.
     * 
     * By default it will create a single base texture. You can add frames to the texture
     * by using the `Texture.add` method. After doing this, you can then allow Game Objects
     * to use a specific frame.
     *
     * @method Phaser.GameObjects.Video#saveSnapshotTexture
     * @since 3.20.0
     *
     * @param {string} key - The unique key to store the texture as within the global Texture Manager.
     *
     * @return {Phaser.Textures.CanvasTexture} The Texture that was saved.
     */saveSnapshotTexture:function(t){return this.snapshotTexture?this.scene.sys.textures.renameTexture(this.snapshotTexture.key,t):this.snapshotTexture=this.scene.sys.textures.createCanvas(t,this.width,this.height),this.snapshotTexture},/**
     * Loads a Video from the given URL, ready for playback with the `Video.play` method.
     * 
     * You can control at what point the browser determines the video as being ready for playback via
     * the `loadEvent` parameter. See https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement
     * for more details.
     *
     * @method Phaser.GameObjects.Video#loadURL
     * @since 3.20.0
     * 
     * @param {string} url - The URL of the video to load or be streamed.
     * @param {string} [loadEvent='loadeddata'] - The load event to listen for. Either `loadeddata`, `canplay` or `canplaythrough`.
     * @param {boolean} [noAudio=false] - Does the video have an audio track? If not you can enable auto-playing on it.
     * 
     * @return {this} This Video Game Object for method chaining.
     */loadURL:function(t,e,i){void 0===e&&(e="loadeddata"),void 0===i&&(i=!1),this.video&&this.stop(),this.videoTexture&&this.scene.sys.textures.remove(this._key);var n=document.createElement("video");return n.controls=!1,i&&(n.muted=!0,n.defaultMuted=!0,n.setAttribute("autoplay","autoplay")),n.setAttribute("playsinline","playsinline"),n.setAttribute("preload","auto"),n.addEventListener("error",this._callbacks.error,!0),n.src=t,n.load(),this.video=n,this},/**
     * This internal method is called automatically if the playback Promise resolves successfully.
     *
     * @method Phaser.GameObjects.Video#playPromiseSuccessHandler
     * @fires Phaser.GameObjects.Events#VIDEO_PLAY
     * @private
     * @since 3.20.0
     */playPromiseSuccessHandler:function(){this.touchLocked=!1,this.emit(o.VIDEO_PLAY,this),this._markerIn>-1&&(this.video.currentTime=this._markerIn)},/**
     * This internal method is called automatically if the playback Promise fails to resolve.
     *
     * @method Phaser.GameObjects.Video#playPromiseErrorHandler
     * @fires Phaser.GameObjects.Events#VIDEO_ERROR
     * @private
     * @since 3.20.0
     * 
     * @param {any} error - The Promise resolution error.
     */playPromiseErrorHandler:function(t){this.scene.sys.input.once("pointerdown",this.unlockHandler,this),this.touchLocked=!0,this.playWhenUnlocked=!0,this.emit(o.VIDEO_ERROR,this,t)},/**
     * Called when the video emits a `playing` event during load.
     * 
     * This is only listened for if the browser doesn't support Promises.
     *
     * @method Phaser.GameObjects.Video#playHandler
     * @fires Phaser.GameObjects.Events#VIDEO_PLAY
     * @since 3.20.0
     */playHandler:function(){this.touchLocked=!1,this.emit(o.VIDEO_PLAY,this),this.video.removeEventListener("playing",this._callbacks.play,!0)},/**
     * This internal method is called automatically if the video fails to load.
     *
     * @method Phaser.GameObjects.Video#loadErrorHandler
     * @fires Phaser.GameObjects.Events#VIDEO_ERROR
     * @private
     * @since 3.20.0
     * 
     * @param {Event} event - The error Event.
     */loadErrorHandler:function(t){this.stop(),this.emit(o.VIDEO_ERROR,this,t)},/**
     * This internal method is called if the video couldn't be played because it was interaction locked
     * by the browser, but an input event has since been received.
     *
     * @method Phaser.GameObjects.Video#unlockHandler
     * @fires Phaser.GameObjects.Events#VIDEO_UNLOCKED
     * @fires Phaser.GameObjects.Events#VIDEO_PLAY
     * @private
     * @since 3.20.0
     * 
     * @param {any} error - The Promise resolution error.
     */unlockHandler:function(){this.touchLocked=!1,this.playWhenUnlocked=!1,this.emit(o.VIDEO_UNLOCKED,this),this._markerIn>-1&&(this.video.currentTime=this._markerIn),this.video.play(),this.emit(o.VIDEO_PLAY,this)},/**
     * Called when the video completes playback, i.e. reaches an `ended` state.
     * 
     * This will never happen if the video is coming from a live stream, where the duration is `Infinity`.
     *
     * @method Phaser.GameObjects.Video#completeHandler
     * @fires Phaser.GameObjects.Events#VIDEO_COMPLETE
     * @since 3.20.0
     */completeHandler:function(){this.emit(o.VIDEO_COMPLETE,this)},/**
     * Called when the video emits a `timeUpdate` event during playback.
     * 
     * This event is too slow and irregular to be used for actual video timing or texture updating,
     * but we can use it to determine if a video has looped.
     *
     * @method Phaser.GameObjects.Video#timeUpdateHandler
     * @fires Phaser.GameObjects.Events#VIDEO_LOOP
     * @since 3.20.0
     */timeUpdateHandler:function(){this.video&&this.video.currentTime<this._lastUpdate&&(this.emit(o.VIDEO_LOOP,this),this._lastUpdate=0)},/**
     * The internal update step.
     *
     * @method Phaser.GameObjects.Video#preUpdate
     * @private
     * @since 3.20.0
     */preUpdate:function(){var t=this.video;if(t){var e=t.currentTime;//  Don't render a new frame unless the video has actually changed time
e!==this._lastUpdate&&(this._lastUpdate=e,this.updateTexture(),e>=this._markerOut&&(t.loop?(t.currentTime=this._markerIn,this.updateTexture(),this._lastUpdate=e,this.emit(o.VIDEO_LOOP,this)):(this.emit(o.VIDEO_COMPLETE,this),this.stop())))}},/**
     * Internal callback that monitors the download progress of a video after changing its source.
     *
     * @method Phaser.GameObjects.Video#checkVideoProgress
     * @fires Phaser.GameObjects.Events#VIDEO_TIMEOUT
     * @private
     * @since 3.20.0
     */checkVideoProgress:function(){this.video.readyState>=2?this.updateTexture():(this.retry--,this.retry>0?this._retryID=window.setTimeout(this.checkVideoProgress.bind(this),this.retryInterval):this.emit(o.VIDEO_TIMEOUT,this))},/**
     * Internal method that is called when enough video data has been received in order to create a texture
     * from it. The texture is assigned to the `Video.videoTexture` property and given a base frame that
     * encompases the whole video size.
     *
     * @method Phaser.GameObjects.Video#updateTexture
     * @since 3.20.0
     */updateTexture:function(){var t=this.video,e=t.videoWidth,i=t.videoHeight;if(this.videoTexture){var n=this.videoTextureSource;n.source!==t&&(n.source=t,n.width=e,n.height=i),n.update()}else this.videoTexture=this.scene.sys.textures.create(this._key,t,e,i),this.videoTextureSource=this.videoTexture.source[0],this.videoTexture.add("__BASE",0,0,0,e,i),this.setTexture(this.videoTexture),this.setSizeToFrame(),this.updateDisplayOrigin(),this.emit(o.VIDEO_CREATED,this,e,i)},/**
     * Returns the key of the currently played video, as stored in the Video Cache.
     * If the video did not come from the cache this will return an empty string.
     *
     * @method Phaser.GameObjects.Video#getVideoKey
     * @since 3.20.0
     * 
     * @return {string} The key of the video being played from the Video Cache, if any.
     */getVideoKey:function(){return this._cacheKey},/**
     * Seeks to a given point in the video. The value is given as a float between 0 and 1,
     * where 0 represents the start of the video and 1 represents the end.
     * 
     * Seeking only works if the video has a duration, so will not work for live streams.
     * 
     * When seeking begins, this video will emit a `seeking` event. When the video completes
     * seeking (i.e. reaches its designated timestamp) it will emit a `seeked` event.
     * 
     * If you wish to seek based on time instead, use the `Video.setCurrentTime` method.
     *
     * @method Phaser.GameObjects.Video#seekTo
     * @since 3.20.0
     * 
     * @param {number} value - The point in the video to seek to. A value between 0 and 1.
     * 
     * @return {this} This Video Game Object for method chaining.
     */seekTo:function(t){var e=this.video;if(e){var i=e.duration;i===1/0||isNaN(i)||this.setCurrentTime(i*t)}return this},/**
     * A double-precision floating-point value indicating the current playback time in seconds.
     * If the media has not started to play and has not been seeked, this value is the media's initial playback time.
     *
     * @method Phaser.GameObjects.Video#getCurrentTime
     * @since 3.20.0
     * 
     * @return {number} A double-precision floating-point value indicating the current playback time in seconds.
     */getCurrentTime:function(){return this.video?this.video.currentTime:0},/**
     * Seeks to a given playback time in the video. The value is given in _seconds_ or as a string.
     * 
     * Seeking only works if the video has a duration, so will not work for live streams.
     * 
     * When seeking begins, this video will emit a `seeking` event. When the video completes
     * seeking (i.e. reaches its designated timestamp) it will emit a `seeked` event.
     * 
     * You can provide a string prefixed with either a `+` or a `-`, such as `+2.5` or `-2.5`.
     * In this case it will seek to +/- the value given, relative to the _current time_.
     * 
     * If you wish to seek based on a duration percentage instead, use the `Video.seekTo` method.
     *
     * @method Phaser.GameObjects.Video#setCurrentTime
     * @since 3.20.0
     * 
     * @param {(string|number)} value - The playback time to seek to in seconds. Can be expressed as a string, such as `+2` to seek 2 seconds ahead from the current time.
     * 
     * @return {this} This Video Game Object for method chaining.
     */setCurrentTime:function(t){var e=this.video;if(e){if("string"==typeof t){var i=t[0],n=parseFloat(t.substr(1));"+"===i?t=e.currentTime+n:"-"===i&&(t=e.currentTime-n)}e.currentTime=t,this._lastUpdate=t}return this},/**
     * Returns a boolean indicating if this Video is currently seeking, or not.
     *
     * @method Phaser.GameObjects.Video#isSeeking
     * @since 3.20.0
     * 
     * @return {boolean} A boolean indicating if this Video is currently seeking, or not.
     */isSeeking:function(){return this._isSeeking},/**
     * Internal seeking handler.
     *
     * @method Phaser.GameObjects.Video#seekingHandler
     * @fires Phaser.GameObjects.Events#VIDEO_SEEKING
     * @private
     * @since 3.20.0
     */seekingHandler:function(){this._isSeeking=!0,this.emit(o.VIDEO_SEEKING,this)},/**
     * Internal seeked handler.
     *
     * @method Phaser.GameObjects.Video#seekedHandler
     * @fires Phaser.GameObjects.Events#VIDEO_SEEKED
     * @private
     * @since 3.20.0
     */seekedHandler:function(){this._isSeeking=!1,this.emit(o.VIDEO_SEEKED,this),this.video&&this.updateTexture()},/**
     * Returns the current progress of the video. Progress is defined as a value between 0 (the start)
     * and 1 (the end).
     * 
     * Progress can only be returned if the video has a duration, otherwise it will always return zero.
     *
     * @method Phaser.GameObjects.Video#getProgress
     * @since 3.20.0
     * 
     * @return {number} The current progress of playback. If the video has no duration, will always return zero.
     */getProgress:function(){var t=this.video;if(t){var e=t.currentTime,i=t.duration;if(i!==1/0&&!isNaN(i))return e/i}return 0},/**
     * A double-precision floating-point value which indicates the duration (total length) of the media in seconds,
     * on the media's timeline. If no media is present on the element, or the media is not valid, the returned value is NaN.
     * 
     * If the media has no known end (such as for live streams of unknown duration, web radio, media incoming from WebRTC,
     * and so forth), this value is +Infinity.
     * 
     * @method Phaser.GameObjects.Video#getDuration
     * @since 3.20.0
     * 
     * @return {number} A double-precision floating-point value indicating the duration of the media in seconds.
     */getDuration:function(){return this.video?this.video.duration:0},/**
     * Sets the muted state of the currently playing video, if one is loaded.
     *
     * @method Phaser.GameObjects.Video#setMute
     * @since 3.20.0
     * 
     * @param {boolean} [value=true] - The mute value. `true` if the video should be muted, otherwise `false`.
     * 
     * @return {this} This Video Game Object for method chaining.
     */setMute:function(t){void 0===t&&(t=!0),this._codeMuted=t;var e=this.video;return e&&(e.muted=!!this._systemMuted||t),this},/**
     * Returns a boolean indicating if this Video is currently muted.
     *
     * @method Phaser.GameObjects.Video#isMuted
     * @since 3.20.0
     * 
     * @return {boolean} A boolean indicating if this Video is currently muted, or not.
     */isMuted:function(){return this._codeMuted},/**
     * Internal global mute handler. Will mute the video, if playing, if the global sound system mutes.
     *
     * @method Phaser.GameObjects.Video#globalMute
     * @private
     * @since 3.20.0
     * 
     * @param {(Phaser.Sound.WebAudioSoundManager|Phaser.Sound.HTML5AudioSoundManager)} soundManager - A reference to the Sound Manager that emitted the event.
     * @param {boolean} mute - The mute value. `true` if the Sound Manager is now muted, otherwise `false`.
     */globalMute:function(t,e){this._systemMuted=e;var i=this.video;i&&(i.muted=!!this._codeMuted||e)},/**
     * Internal global pause handler. Will pause the video if the Game itself pauses.
     *
     * @method Phaser.GameObjects.Video#globalPause
     * @private
     * @since 3.20.0
     */globalPause:function(){this._systemPaused=!0,this.video&&this.video.pause()},/**
     * Internal global resume handler. Will resume a paused video if the Game itself resumes.
     *
     * @method Phaser.GameObjects.Video#globalResume
     * @private
     * @since 3.20.0
     */globalResume:function(){this._systemPaused=!1,this.video&&!this._codePaused&&this.video.play()},/**
     * Sets the paused state of the currently loaded video.
     * 
     * If the video is playing, calling this method with `true` will pause playback.
     * If the video is paused, calling this method with `false` will resume playback.
     * 
     * If no video is loaded, this method does nothing.
     *
     * @method Phaser.GameObjects.Video#setPaused
     * @since 3.20.0
     * 
     * @param {boolean} [value=true] - The paused value. `true` if the video should be paused, `false` to resume it.
     * 
     * @return {this} This Video Game Object for method chaining.
     */setPaused:function(t){void 0===t&&(t=!0);var e=this.video;return this._codePaused=t,!e||(t?e.paused||e.pause():t||!e.paused||this._systemPaused||e.play()),this},/**
     * Returns a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).
     * 
     * @method Phaser.GameObjects.Video#getVolume
     * @since 3.20.0
     * 
     * @return {number} A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).
     */getVolume:function(){return this.video?this.video.volume:1},/**
     * Sets the volume of the currently playing video.
     * 
     * The value given is a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).
     * 
     * @method Phaser.GameObjects.Video#setVolume
     * @since 3.20.0
     * 
     * @param {number} [value=1] - A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).
     * 
     * @return {this} This Video Game Object for method chaining.
     */setVolume:function(t){return void 0===t&&(t=1),this.video&&(this.video.volume=n(t,0,1)),this},/**
     * Returns a double that indicates the rate at which the media is being played back.
     * 
     * @method Phaser.GameObjects.Video#getPlaybackRate
     * @since 3.20.0
     * 
     * @return {number} A double that indicates the rate at which the media is being played back.
     */getPlaybackRate:function(){return this.video?this.video.playbackRate:1},/**
     * Sets the playback rate of the current video.
     * 
     * The value given is a double that indicates the rate at which the media is being played back.
     * 
     * @method Phaser.GameObjects.Video#setPlaybackRate
     * @since 3.20.0
     * 
     * @param {number} [rate] - A double that indicates the rate at which the media is being played back.
     * 
     * @return {this} This Video Game Object for method chaining.
     */setPlaybackRate:function(t){return this.video&&(this.video.playbackRate=t),this},/**
     * Returns a boolean which indicates whether the media element should start over when it reaches the end.
     * 
     * @method Phaser.GameObjects.Video#getLoop
     * @since 3.20.0
     * 
     * @return {boolean} A boolean which indicates whether the media element will start over when it reaches the end.
     */getLoop:function(){return!!this.video&&this.video.loop},/**
     * Sets the loop state of the current video.
     * 
     * The value given is a boolean which indicates whether the media element will start over when it reaches the end.
     * 
     * Not all videos can loop, for example live streams.
     * 
     * Please note that not all browsers support _seamless_ video looping for all encoding formats.
     * 
     * @method Phaser.GameObjects.Video#setLoop
     * @since 3.20.0
     * 
     * @param {boolean} [value=true] - A boolean which indicates whether the media element will start over when it reaches the end.
     * 
     * @return {this} This Video Game Object for method chaining.
     */setLoop:function(t){return void 0===t&&(t=!0),this.video&&(this.video.loop=t),this},/**
     * Returns a boolean which indicates whether the video is currently playing.
     * 
     * @method Phaser.GameObjects.Video#isPlaying
     * @since 3.20.0
     * 
     * @return {boolean} A boolean which indicates whether the video is playing, or not.
     */isPlaying:function(){return!!this.video&&!(this.video.paused||this.video.ended)},/**
     * Returns a boolean which indicates whether the video is currently paused.
     * 
     * @method Phaser.GameObjects.Video#isPaused
     * @since 3.20.0
     * 
     * @return {boolean} A boolean which indicates whether the video is paused, or not.
     */isPaused:function(){return this.video&&this.video.paused||this._codePaused||this._systemPaused},/**
     * Stores this Video in the Texture Manager using the given key as a dynamic texture,
     * which any texture-based Game Object, such as a Sprite, can use as its texture:
     * 
     * ```javascript
     * var vid = this.add.video(0, 0, 'intro');
     * 
     * vid.play();
     * 
     * vid.saveTexture('doodle');
     * 
     * this.add.image(400, 300, 'doodle');
     * ```
     * 
     * The saved texture is automatically updated as the video plays. If you pause this video,
     * or change its source, then the saved texture updates instantly.
     * 
     * Calling `saveTexture` again will not save another copy of the same texture, it will just rename the existing one.
     * 
     * By default it will create a single base texture. You can add frames to the texture
     * by using the `Texture.add` method. After doing this, you can then allow Game Objects
     * to use a specific frame.
     * 
     * If you intend to save the texture so you can use it as the input for a Shader, you may need to set the
     * `flipY` parameter to `true` if you find the video renders upside down in your shader.
     *
     * @method Phaser.GameObjects.Video#saveTexture
     * @since 3.20.0
     *
     * @param {string} key - The unique key to store the texture as within the global Texture Manager.
     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y` during upload?
     *
     * @return {Phaser.Textures.Texture} The Texture that was saved.
     */saveTexture:function(t,e){return void 0===e&&(e=!1),this.videoTexture&&this.scene.sys.textures.renameTexture(this._key,t),this._key=t,this.flipY=e,this.videoTextureSource&&this.videoTextureSource.setFlipY(e),this.videoTexture},/**
     * Stops the video playing and clears all internal event listeners.
     *
     * If you only wish to pause playback of the video, and resume it a later time, use the `Video.pause` method instead.
     * 
     * If the video hasn't finished downloading, calling this method will not abort the download. To do that you need to
     * call `destroy` instead.
     *
     * @method Phaser.GameObjects.Video#stop
     * @fires Phaser.GameObjects.Events#VIDEO_STOP
     * @since 3.20.0
     * 
     * @return {this} This Video Game Object for method chaining.
     */stop:function(){var t=this.video;if(t){var e=this._callbacks;for(var i in e)t.removeEventListener(i,e[i],!0);t.pause()}return this._retryID&&window.clearTimeout(this._retryID),this.emit(o.VIDEO_STOP,this),this},/**
     * Removes the Video element from the DOM by calling parentNode.removeChild on itself.
     * 
     * Also removes the autoplay and src attributes and nulls the Video reference.
     * 
     * You should not call this method if you were playing a video from the Video Cache that
     * you wish to play again in your game, or if another Video object is also using the same
     * video.
     * 
     * If you loaded an external video via `Video.loadURL` then you should call this function
     * to clear up once you are done with the instance.
     *
     * @method Phaser.GameObjects.Video#removeVideoElement
     * @since 3.20.0
     */removeVideoElement:function(){var t=this.video;if(t){for(t.parentNode&&t.parentNode.removeChild(t);t.hasChildNodes();)t.removeChild(t.firstChild);t.removeAttribute("autoplay"),t.removeAttribute("src"),this.video=null}},/**
     * Handles the pre-destroy step for the Video object.
     * 
     * This calls `Video.stop` and optionally `Video.removeVideoElement`.
     * 
     * If any Sprites are using this Video as their texture it is up to you to manage those.
     *
     * @method Phaser.GameObjects.Video#preDestroy
     * @private
     * @since 3.21.0
     */preDestroy:function(){this.stop(),this.removeVideoElementOnDestroy&&this.removeVideoElement();var t=this.scene.sys.game.events;t.off(a.PAUSE,this.globalPause,this),t.off(a.RESUME,this.globalResume,this);var e=this.scene.sys.sound;e&&e.off(l.GLOBAL_MUTE,this.globalMute,this),this._retryID&&window.clearTimeout(this._retryID)}});t.exports=f}),r("dQCPJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("42xhp"),r=s("fs2FX"),t.exports={renderWebGL:n,renderCanvas:r}}),r("42xhp",function(t,e){t.exports=function(t,e,i,n,s){e.videoTexture&&this.pipeline.batchSprite(e,n,s)}}),r("fs2FX",function(t,e){t.exports=function(t,e,i,n,s){e.videoTexture&&t.batchSprite(e,e.frame,n,s)}}),r("6cKpG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("1zqlR"),o=s("1LRPh"),a=new i({Extends:r,Mixins:[n.AlphaSingle,n.BlendMode,n.ComputedSize,n.Depth,n.GetBounds,n.Mask,n.Origin,n.Pipeline,n.ScrollFactor,n.Transform,n.Visible],initialize:function(t,e,i){void 0===e&&(e="Shape"),r.call(this,t,e),/**
         * The source Shape data. Typically a geometry object.
         * You should not manipulate this directly.
         *
         * @name Phaser.GameObjects.Shape#data
         * @type {any}
         * @readonly
         * @since 3.13.0
         */this.geom=i,/**
         * Holds the polygon path data for filled rendering.
         *
         * @name Phaser.GameObjects.Shape#pathData
         * @type {number[]}
         * @readonly
         * @since 3.13.0
         */this.pathData=[],/**
         * Holds the earcut polygon path index data for filled rendering.
         *
         * @name Phaser.GameObjects.Shape#pathIndexes
         * @type {integer[]}
         * @readonly
         * @since 3.13.0
         */this.pathIndexes=[],/**
         * The fill color used by this Shape.
         *
         * @name Phaser.GameObjects.Shape#fillColor
         * @type {number}
         * @since 3.13.0
         */this.fillColor=16777215,/**
         * The fill alpha value used by this Shape.
         *
         * @name Phaser.GameObjects.Shape#fillAlpha
         * @type {number}
         * @since 3.13.0
         */this.fillAlpha=1,/**
         * The stroke color used by this Shape.
         *
         * @name Phaser.GameObjects.Shape#strokeColor
         * @type {number}
         * @since 3.13.0
         */this.strokeColor=16777215,/**
         * The stroke alpha value used by this Shape.
         *
         * @name Phaser.GameObjects.Shape#strokeAlpha
         * @type {number}
         * @since 3.13.0
         */this.strokeAlpha=1,/**
         * The stroke line width used by this Shape.
         *
         * @name Phaser.GameObjects.Shape#lineWidth
         * @type {number}
         * @since 3.13.0
         */this.lineWidth=1,/**
         * Controls if this Shape is filled or not.
         * Note that some Shapes do not support being filled (such as Line shapes)
         *
         * @name Phaser.GameObjects.Shape#isFilled
         * @type {boolean}
         * @since 3.13.0
         */this.isFilled=!1,/**
         * Controls if this Shape is stroked or not.
         * Note that some Shapes do not support being stroked (such as Iso Box shapes)
         *
         * @name Phaser.GameObjects.Shape#isStroked
         * @type {boolean}
         * @since 3.13.0
         */this.isStroked=!1,/**
         * Controls if this Shape path is closed during rendering when stroked.
         * Note that some Shapes are always closed when stroked (such as Ellipse shapes)
         *
         * @name Phaser.GameObjects.Shape#closePath
         * @type {boolean}
         * @since 3.13.0
         */this.closePath=!0,/**
         * Private internal value.
         * A Line used when parsing internal path data to avoid constant object re-creation.
         *
         * @name Phaser.GameObjects.Curve#_tempLine
         * @type {Phaser.Geom.Line}
         * @private
         * @since 3.13.0
         */this._tempLine=new o,this.initPipeline()},/**
     * Sets the fill color and alpha for this Shape.
     * 
     * If you wish for the Shape to not be filled then call this method with no arguments, or just set `isFilled` to `false`.
     * 
     * Note that some Shapes do not support fill colors, such as the Line shape.
     * 
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Shape#setFillStyle
     * @since 3.13.0
     * 
     * @param {number} [color] - The color used to fill this shape. If not provided the Shape will not be filled.
     * @param {number} [alpha=1] - The alpha value used when filling this shape, if a fill color is given.
     *
     * @return {this} This Game Object instance.
     */setFillStyle:function(t,e){return void 0===e&&(e=1),void 0===t?this.isFilled=!1:(this.fillColor=t,this.fillAlpha=e,this.isFilled=!0),this},/**
     * Sets the stroke color and alpha for this Shape.
     * 
     * If you wish for the Shape to not be stroked then call this method with no arguments, or just set `isStroked` to `false`.
     * 
     * Note that some Shapes do not support being stroked, such as the Iso Box shape.
     * 
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Shape#setStrokeStyle
     * @since 3.13.0
     * 
     * @param {number} [lineWidth] - The width of line to stroke with. If not provided or undefined the Shape will not be stroked.
     * @param {number} [color] - The color used to stroke this shape. If not provided the Shape will not be stroked.
     * @param {number} [alpha=1] - The alpha value used when stroking this shape, if a stroke color is given.
     *
     * @return {this} This Game Object instance.
     */setStrokeStyle:function(t,e,i){return void 0===i&&(i=1),void 0===t?this.isStroked=!1:(this.lineWidth=t,this.strokeColor=e,this.strokeAlpha=i,this.isStroked=!0),this},/**
     * Sets if this Shape path is closed during rendering when stroked.
     * Note that some Shapes are always closed when stroked (such as Ellipse shapes)
     * 
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Shape#setClosePath
     * @since 3.13.0
     * 
     * @param {boolean} value - Set to `true` if the Shape should be closed when stroked, otherwise `false`.
     *
     * @return {this} This Game Object instance.
     */setClosePath:function(t){return this.closePath=t,this},/**
     * Internal destroy handler, called as part of the destroy process.
     *
     * @method Phaser.GameObjects.Shape#preDestroy
     * @protected
     * @since 3.13.0
     */preDestroy:function(){this.geom=null,this._tempLine=null,this.pathData=[],this.pathIndexes=[]}});t.exports=a}),r("ab6uD",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("aeVtI"),n=s("jwj1g"),r=s("2zqSA"),o=s("hjbjS"),a=s("eQ4tZ"),h=s("bNtDi"),l=s("6cKpG"),u=new n({Extends:l,Mixins:[i],initialize:function(t,e,i,n,s,r,o,h,u){void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=128),void 0===s&&(s=0),void 0===r&&(r=360),void 0===o&&(o=!1),l.call(this,t,"Arc",new a(0,0,n)),/**
         * Private internal value. Holds the start angle in degrees.
         *
         * @name Phaser.GameObjects.Arc#_startAngle
         * @type {integer}
         * @private
         * @since 3.13.0
         */this._startAngle=s,/**
         * Private internal value. Holds the end angle in degrees.
         *
         * @name Phaser.GameObjects.Arc#_endAngle
         * @type {integer}
         * @private
         * @since 3.13.0
         */this._endAngle=r,/**
         * Private internal value. Holds the winding order of the start and end angles.
         *
         * @name Phaser.GameObjects.Arc#_anticlockwise
         * @type {boolean}
         * @private
         * @since 3.13.0
         */this._anticlockwise=o,/**
         * Private internal value. Holds the number of iterations used when drawing the arc.
         *
         * @name Phaser.GameObjects.Arc#_iterations
         * @type {number}
         * @default 0.01
         * @private
         * @since 3.13.0
         */this._iterations=.01,this.setPosition(e,i);var c=2*this.geom.radius;this.setSize(c,c),void 0!==h&&this.setFillStyle(h,u),this.updateDisplayOrigin(),this.updateData()},/**
     * The number of iterations used when drawing the arc.
     * Increase this value for smoother arcs, at the cost of more polygons being rendered.
     * Modify this value by small amounts, such as 0.01.
     *
     * @name Phaser.GameObjects.Arc#iterations
     * @type {number}
     * @default 0.01
     * @since 3.13.0
     */iterations:{get:function(){return this._iterations},set:function(t){this._iterations=t,this.updateData()}},/**
     * The radius of the arc.
     *
     * @name Phaser.GameObjects.Arc#radius
     * @type {number}
     * @since 3.13.0
     */radius:{get:function(){return this.geom.radius},set:function(t){this.geom.radius=t;var e=2*t;this.setSize(e,e),this.updateDisplayOrigin(),this.updateData()}},/**
     * The start angle of the arc, in degrees.
     *
     * @name Phaser.GameObjects.Arc#startAngle
     * @type {integer}
     * @since 3.13.0
     */startAngle:{get:function(){return this._startAngle},set:function(t){this._startAngle=t,this.updateData()}},/**
     * The end angle of the arc, in degrees.
     *
     * @name Phaser.GameObjects.Arc#endAngle
     * @type {integer}
     * @since 3.13.0
     */endAngle:{get:function(){return this._endAngle},set:function(t){this._endAngle=t,this.updateData()}},/**
     * The winding order of the start and end angles.
     *
     * @name Phaser.GameObjects.Arc#anticlockwise
     * @type {boolean}
     * @since 3.13.0
     */anticlockwise:{get:function(){return this._anticlockwise},set:function(t){this._anticlockwise=t,this.updateData()}},/**
     * Sets the radius of the arc.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Arc#setRadius
     * @since 3.13.0
     * 
     * @param {number} value - The value to set the radius to.
     *
     * @return {this} This Game Object instance.
     */setRadius:function(t){return this.radius=t,this},/**
     * Sets the number of iterations used when drawing the arc.
     * Increase this value for smoother arcs, at the cost of more polygons being rendered.
     * Modify this value by small amounts, such as 0.01.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Arc#setIterations
     * @since 3.13.0
     * 
     * @param {number} value - The value to set the iterations to.
     *
     * @return {this} This Game Object instance.
     */setIterations:function(t){return void 0===t&&(t=.01),this.iterations=t,this},/**
     * Sets the starting angle of the arc, in degrees.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Arc#setStartAngle
     * @since 3.13.0
     * 
     * @param {integer} value - The value to set the starting angle to.
     *
     * @return {this} This Game Object instance.
     */setStartAngle:function(t,e){return this._startAngle=t,void 0!==e&&(this._anticlockwise=e),this.updateData()},/**
     * Sets the ending angle of the arc, in degrees.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Arc#setEndAngle
     * @since 3.13.0
     * 
     * @param {integer} value - The value to set the ending angle to.
     *
     * @return {this} This Game Object instance.
     */setEndAngle:function(t,e){return this._endAngle=t,void 0!==e&&(this._anticlockwise=e),this.updateData()},/**
     * Internal method that updates the data and path values.
     *
     * @method Phaser.GameObjects.Arc#updateData
     * @private
     * @since 3.13.0
     *
     * @return {this} This Game Object instance.
     */updateData:function(){var t,e=this._iterations,i=e,n=this.geom.radius,s=r(this._startAngle),a=r(this._endAngle),l=this._anticlockwise;a-=s,l?a<-h.PI2?a=-h.PI2:a>0&&(a=-h.PI2+a%h.PI2):a>h.PI2?a=h.PI2:a<0&&(a=h.PI2+a%h.PI2);for(var u=[n+Math.cos(s)*n,n+Math.sin(s)*n];i<1;)t=a*i+s,u.push(n+Math.cos(t)*n,n+Math.sin(t)*n),i+=e;return t=a+s,u.push(n+Math.cos(t)*n,n+Math.sin(t)*n),u.push(n+Math.cos(s)*n,n+Math.sin(s)*n),this.pathIndexes=o(u),this.pathData=u,this}});t.exports=u}),r("aeVtI",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("9Jtnt"),r=s("cZJbB"),t.exports={renderWebGL:n,renderCanvas:r}}),r("9Jtnt",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("73AUV"),n=s("ythtQ");t.exports=function(t,e,s,r,o){var a=this.pipeline,h=a._tempMatrix1,l=a._tempMatrix2,u=a._tempMatrix3;t.setPipeline(a),l.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),h.copyFrom(r.matrix),o?(//  Multiply the camera by the parent matrix
h.multiplyWithOffset(o,-r.scrollX*e.scrollFactorX,-r.scrollY*e.scrollFactorY),//  Undo the camera scroll
l.e=e.x,l.f=e.y):(l.e-=r.scrollX*e.scrollFactorX,l.f-=r.scrollY*e.scrollFactorY),h.multiply(l,u);var c=e._displayOriginX,d=e._displayOriginY,f=r.alpha*e.alpha;e.isFilled&&i(a,u,e,f,c,d),e.isStroked&&n(a,e,f,c,d)}}),r("73AUV",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r,o){for(var a=i.getTintAppendFloatAlphaAndSwap(n.fillColor,n.fillAlpha*s),h=n.pathData,l=n.pathIndexes,u=0;u<l.length;u+=3){var c=2*l[u],d=2*l[u+1],f=2*l[u+2],p=h[c+0]-r,g=h[c+1]-o,v=h[d+0]-r,m=h[d+1]-o,y=h[f+0]-r,x=h[f+1]-o,w=e.getX(p,g),T=e.getY(p,g),b=e.getX(v,m),S=e.getY(v,m),A=e.getX(y,x),E=e.getY(y,x);t.setTexture2D(),t.batchTri(w,T,b,S,A,E,0,0,1,1,a,a,a,t.tintEffect)}}}),r("ythtQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){var o=t.strokeTint,a=i.getTintAppendFloatAlphaAndSwap(e.strokeColor,e.strokeAlpha*n);o.TL=a,o.TR=a,o.BL=a,o.BR=a;var h=e.pathData,l=h.length-1,u=e.lineWidth,c=u/2,d=h[0]-s,f=h[1]-r;e.closePath||(l-=2);for(var p=2;p<l;p+=2){var g=h[p]-s,v=h[p+1]-r;t.setTexture2D(),t.batchLine(d,f,g,v,c,c,u,p-2,!!e.closePath&&p===l-1),d=g,f=v}}}),r("cZJbB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2zqSA"),n=s("Jk7wq"),r=s("jNDrF"),o=s("csLaZ");t.exports=function(t,e,s,a,h){var l=t.currentContext;if(o(t,l,e,a,h)){var u=e.radius;l.beginPath(),l.arc(u-e.originX*(2*u),u-e.originY*(2*u),u,i(e._startAngle),i(e._endAngle),e.anticlockwise),e.closePath&&l.closePath(),e.isFilled&&(n(l,e),l.fill()),e.isStroked&&(r(l,e),l.stroke()),//  Restore the context saved in SetTransform
l.restore()}}}),r("Jk7wq",function(t,e){t.exports=function(t,e,i,n){var s=i||e.fillColor,r=n||e.fillAlpha;t.fillStyle="rgba("+((16711680&s)>>>16)+","+((65280&s)>>>8)+","+(255&s)+","+r+")"}}),r("jNDrF",function(t,e){t.exports=function(t,e,i,n){var s=i||e.strokeColor,r=n||e.strokeAlpha;t.strokeStyle="rgba("+((16711680&s)>>>16)+","+((65280&s)>>>8)+","+(255&s)+","+r+")",t.lineWidth=e.lineWidth}}),r("20vs1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("8LeHq"),r=s("hjbjS"),o=s("cwr8X"),a=s("6cKpG"),h=new i({Extends:a,Mixins:[n],initialize:function(t,e,i,n,s,r){void 0===e&&(e=0),void 0===i&&(i=0),a.call(this,t,"Curve",n),/**
         * Private internal value.
         * The number of points used to draw the curve. Higher values create smoother renders at the cost of more triangles being drawn.
         *
         * @name Phaser.GameObjects.Curve#_smoothness
         * @type {integer}
         * @private
         * @since 3.13.0
         */this._smoothness=32,/**
         * Private internal value.
         * The Curve bounds rectangle.
         *
         * @name Phaser.GameObjects.Curve#_curveBounds
         * @type {Phaser.Geom.Rectangle}
         * @private
         * @since 3.13.0
         */this._curveBounds=new o,this.closePath=!1,this.setPosition(e,i),void 0!==s&&this.setFillStyle(s,r),this.updateData()},/**
     * The smoothness of the curve. The number of points used when rendering it.
     * Increase this value for smoother curves, at the cost of more polygons being rendered.
     *
     * @name Phaser.GameObjects.Curve#smoothness
     * @type {integer}
     * @default 32
     * @since 3.13.0
     */smoothness:{get:function(){return this._smoothness},set:function(t){this._smoothness=t,this.updateData()}},/**
     * Sets the smoothness of the curve. The number of points used when rendering it.
     * Increase this value for smoother curves, at the cost of more polygons being rendered.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Curve#setSmoothness
     * @since 3.13.0
     * 
     * @param {integer} value - The value to set the smoothness to.
     *
     * @return {this} This Game Object instance.
     */setSmoothness:function(t){return this._smoothness=t,this.updateData()},/**
     * Internal method that updates the data and path values.
     *
     * @method Phaser.GameObjects.Curve#updateData
     * @private
     * @since 3.13.0
     *
     * @return {this} This Game Object instance.
     */updateData:function(){var t=this._curveBounds,e=this._smoothness;//  Update the bounds in case the underlying data has changed
this.geom.getBounds(t,e),this.setSize(t.width,t.height),this.updateDisplayOrigin();for(var i=[],n=this.geom.getPoints(e),s=0;s<n.length;s++)i.push(n[s].x,n[s].y);return i.push(n[0].x,n[0].y),this.pathIndexes=r(i),this.pathData=i,this}});t.exports=h}),r("8LeHq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("aQDOz"),r=s("qOCLi"),t.exports={renderWebGL:n,renderCanvas:r}}),r("aQDOz",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("73AUV"),n=s("ythtQ");t.exports=function(t,e,s,r,o){var a=this.pipeline,h=a._tempMatrix1,l=a._tempMatrix2,u=a._tempMatrix3;t.setPipeline(a),l.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),h.copyFrom(r.matrix),o?(//  Multiply the camera by the parent matrix
h.multiplyWithOffset(o,-r.scrollX*e.scrollFactorX,-r.scrollY*e.scrollFactorY),//  Undo the camera scroll
l.e=e.x,l.f=e.y):(l.e-=r.scrollX*e.scrollFactorX,l.f-=r.scrollY*e.scrollFactorY),h.multiply(l,u);var c=e._displayOriginX+e._curveBounds.x,d=e._displayOriginY+e._curveBounds.y,f=r.alpha*e.alpha;e.isFilled&&i(a,u,e,f,c,d),e.isStroked&&n(a,e,f,c,d)}}),r("qOCLi",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("Jk7wq"),n=s("jNDrF"),r=s("csLaZ");t.exports=function(t,e,s,o,a){var h=t.currentContext;if(r(t,h,e,o,a)){var l=e._displayOriginX+e._curveBounds.x,u=e._displayOriginY+e._curveBounds.y,c=e.pathData,d=c.length-1,f=c[0]-l,p=c[1]-u;h.beginPath(),h.moveTo(f,p),e.closePath||(d-=2);for(var g=2;g<d;g+=2){var v=c[g]-l,m=c[g+1]-u;h.lineTo(v,m)}e.closePath&&h.closePath(),e.isFilled&&(i(h,e),h.fill()),e.isStroked&&(n(h,e),h.stroke()),//  Restore the context saved in SetTransform
h.restore()}}}),r("i1Pn1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("hjbjS"),r=s("6gxoQ"),o=s("eaZcG"),a=s("6cKpG"),h=new i({Extends:a,Mixins:[r],initialize:function(t,e,i,n,s,r,h){void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=128),void 0===s&&(s=128),a.call(this,t,"Ellipse",new o(n/2,s/2,n,s)),/**
         * Private internal value.
         * The number of points used to draw the curve. Higher values create smoother renders at the cost of more triangles being drawn.
         *
         * @name Phaser.GameObjects.Ellipse#_smoothness
         * @type {integer}
         * @private
         * @since 3.13.0
         */this._smoothness=64,this.setPosition(e,i),this.width=n,this.height=s,void 0!==r&&this.setFillStyle(r,h),this.updateDisplayOrigin(),this.updateData()},/**
     * The smoothness of the ellipse. The number of points used when rendering it.
     * Increase this value for a smoother ellipse, at the cost of more polygons being rendered.
     *
     * @name Phaser.GameObjects.Ellipse#smoothness
     * @type {integer}
     * @default 64
     * @since 3.13.0
     */smoothness:{get:function(){return this._smoothness},set:function(t){this._smoothness=t,this.updateData()}},/**
     * Sets the size of the ellipse by changing the underlying geometry data, rather than scaling the object.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Ellipse#setSize
     * @since 3.13.0
     * 
     * @param {number} width - The width of the ellipse.
     * @param {number} height - The height of the ellipse.
     *
     * @return {this} This Game Object instance.
     */setSize:function(t,e){return this.geom.setSize(t,e),this.updateData()},/**
     * Sets the smoothness of the ellipse. The number of points used when rendering it.
     * Increase this value for a smoother ellipse, at the cost of more polygons being rendered.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Ellipse#setSmoothness
     * @since 3.13.0
     * 
     * @param {integer} value - The value to set the smoothness to.
     *
     * @return {this} This Game Object instance.
     */setSmoothness:function(t){return this._smoothness=t,this.updateData()},/**
     * Internal method that updates the data and path values.
     *
     * @method Phaser.GameObjects.Ellipse#updateData
     * @private
     * @since 3.13.0
     *
     * @return {this} This Game Object instance.
     */updateData:function(){for(var t=[],e=this.geom.getPoints(this._smoothness),i=0;i<e.length;i++)t.push(e[i].x,e[i].y);return t.push(e[0].x,e[0].y),this.pathIndexes=n(t),this.pathData=t,this}});t.exports=h}),r("6gxoQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("8RuSi"),r=s("fGmrN"),t.exports={renderWebGL:n,renderCanvas:r}}),r("8RuSi",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("73AUV"),n=s("ythtQ");t.exports=function(t,e,s,r,o){var a=this.pipeline,h=a._tempMatrix1,l=a._tempMatrix2,u=a._tempMatrix3;t.setPipeline(a),l.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),h.copyFrom(r.matrix),o?(//  Multiply the camera by the parent matrix
h.multiplyWithOffset(o,-r.scrollX*e.scrollFactorX,-r.scrollY*e.scrollFactorY),//  Undo the camera scroll
l.e=e.x,l.f=e.y):(l.e-=r.scrollX*e.scrollFactorX,l.f-=r.scrollY*e.scrollFactorY),h.multiply(l,u);var c=e._displayOriginX,d=e._displayOriginY,f=r.alpha*e.alpha;e.isFilled&&i(a,u,e,f,c,d),e.isStroked&&n(a,e,f,c,d)}}),r("fGmrN",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("Jk7wq"),n=s("jNDrF"),r=s("csLaZ");t.exports=function(t,e,s,o,a){var h=t.currentContext;if(r(t,h,e,o,a)){var l=e._displayOriginX,u=e._displayOriginY,c=e.pathData,d=c.length-1,f=c[0]-l,p=c[1]-u;h.beginPath(),h.moveTo(f,p),e.closePath||(d-=2);for(var g=2;g<d;g+=2){var v=c[g]-l,m=c[g+1]-u;h.lineTo(v,m)}h.closePath(),e.isFilled&&(i(h,e),h.fill()),e.isStroked&&(n(h,e),h.stroke()),//  Restore the context saved in SetTransform
h.restore()}}}),r("3qA3v",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("6cKpG"),r=s("fCxvb"),o=new i({Extends:n,Mixins:[r],initialize:function(t,e,i,s,r,o,a,h,l,u,c){void 0===e&&(e=0),void 0===i&&(i=0),void 0===s&&(s=128),void 0===r&&(r=128),void 0===o&&(o=32),void 0===a&&(a=32),n.call(this,t,"Grid",null),/**
         * The width of each grid cell.
         * Must be a positive value.
         *
         * @name Phaser.GameObjects.Grid#cellWidth
         * @type {number}
         * @since 3.13.0
         */this.cellWidth=o,/**
         * The height of each grid cell.
         * Must be a positive value.
         *
         * @name Phaser.GameObjects.Grid#cellHeight
         * @type {number}
         * @since 3.13.0
         */this.cellHeight=a,/**
         * Will the grid render its cells in the `fillColor`?
         *
         * @name Phaser.GameObjects.Grid#showCells
         * @type {boolean}
         * @since 3.13.0
         */this.showCells=!0,/**
         * The color of the lines between each grid cell.
         *
         * @name Phaser.GameObjects.Grid#outlineFillColor
         * @type {number}
         * @since 3.13.0
         */this.outlineFillColor=0,/**
         * The alpha value for the color of the lines between each grid cell.
         *
         * @name Phaser.GameObjects.Grid#outlineFillAlpha
         * @type {number}
         * @since 3.13.0
         */this.outlineFillAlpha=0,/**
         * Will the grid display the lines between each cell when it renders?
         *
         * @name Phaser.GameObjects.Grid#showOutline
         * @type {boolean}
         * @since 3.13.0
         */this.showOutline=!0,/**
         * Will the grid render the alternating cells in the `altFillColor`?
         *
         * @name Phaser.GameObjects.Grid#showAltCells
         * @type {boolean}
         * @since 3.13.0
         */this.showAltCells=!1,/**
         * The color the alternating grid cells will be filled with, i.e. 0xff0000 for red.
         *
         * @name Phaser.GameObjects.Grid#altFillColor
         * @type {number}
         * @since 3.13.0
         */this.altFillColor,/**
         * The alpha the alternating grid cells will be filled with.
         * You can also set the alpha of the overall Shape using its `alpha` property.
         *
         * @name Phaser.GameObjects.Grid#altFillAlpha
         * @type {number}
         * @since 3.13.0
         */this.altFillAlpha,this.setPosition(e,i),this.setSize(s,r),void 0!==h&&this.setFillStyle(h,l),void 0!==u&&this.setOutlineStyle(u,c),this.updateDisplayOrigin()},/**
     * Sets the fill color and alpha level the grid cells will use when rendering.
     * 
     * If this method is called with no values then the grid cells will not be rendered, 
     * however the grid lines and alternating cells may still be.
     * 
     * Also see the `setOutlineStyle` and `setAltFillStyle` methods.
     * 
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Grid#setFillStyle
     * @since 3.13.0
     * 
     * @param {number} [fillColor] - The color the grid cells will be filled with, i.e. 0xff0000 for red.
     * @param {number} [fillAlpha=1] - The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     *
     * @return {this} This Game Object instance.
     */setFillStyle:function(t,e){return void 0===e&&(e=1),void 0===t?this.showCells=!1:(this.fillColor=t,this.fillAlpha=e,this.showCells=!0),this},/**
     * Sets the fill color and alpha level that the alternating grid cells will use.
     * 
     * If this method is called with no values then alternating grid cells will not be rendered in a different color.
     * 
     * Also see the `setOutlineStyle` and `setFillStyle` methods.
     * 
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Grid#setAltFillStyle
     * @since 3.13.0
     * 
     * @param {number} [fillColor] - The color the alternating grid cells will be filled with, i.e. 0xff0000 for red.
     * @param {number} [fillAlpha=1] - The alpha the alternating grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     *
     * @return {this} This Game Object instance.
     */setAltFillStyle:function(t,e){return void 0===e&&(e=1),void 0===t?this.showAltCells=!1:(this.altFillColor=t,this.altFillAlpha=e,this.showAltCells=!0),this},/**
     * Sets the fill color and alpha level that the lines between each grid cell will use.
     * 
     * If this method is called with no values then the grid lines will not be rendered at all, however
     * the cells themselves may still be if they have colors set.
     * 
     * Also see the `setFillStyle` and `setAltFillStyle` methods.
     * 
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Grid#setOutlineStyle
     * @since 3.13.0
     * 
     * @param {number} [fillColor] - The color the lines between the grid cells will be filled with, i.e. 0xff0000 for red.
     * @param {number} [fillAlpha=1] - The alpha the lines between the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
     *
     * @return {this} This Game Object instance.
     */setOutlineStyle:function(t,e){return void 0===e&&(e=1),void 0===t?this.showOutline=!1:(this.outlineFillColor=t,this.outlineFillAlpha=e,this.showOutline=!0),this}});t.exports=o}),r("fCxvb",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("1dztA"),r=s("jLoQL"),t.exports={renderWebGL:n,renderCanvas:r}}),r("1dztA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){var o,a,h=this.pipeline,l=h._tempMatrix1,u=h._tempMatrix2,c=h._tempMatrix3;t.setPipeline(h),u.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),l.copyFrom(s.matrix),r?(//  Multiply the camera by the parent matrix
l.multiplyWithOffset(r,-s.scrollX*e.scrollFactorX,-s.scrollY*e.scrollFactorY),//  Undo the camera scroll
u.e=e.x,u.f=e.y):(u.e-=s.scrollX*e.scrollFactorX,u.f-=s.scrollY*e.scrollFactorY),l.multiply(u,c),c.translate(-e._displayOriginX,-e._displayOriginY);var d=s.alpha*e.alpha,f=e.width,p=e.height,g=e.cellWidth,v=e.cellHeight,m=Math.ceil(f/g),y=Math.ceil(p/v),x=g,w=v,T=g-(m*g-f),b=v-(y*v-p),S=e.showCells,A=e.showAltCells,E=e.showOutline,_=0,C=0,M=0,P=0,O=0;if(E&&(//  To make room for the grid lines (in case alpha < 1)
x--,w--,T===g&&T--,b===v&&b--),S&&e.fillAlpha>0)for(C=0,o=h.fillTint,a=i.getTintAppendFloatAlphaAndSwap(e.fillColor,e.fillAlpha*d),o.TL=a,o.TR=a,o.BL=a,o.BR=a;C<y;C++)for(A&&(M=C%2),_=0;_<m;_++){if(A&&M){M=0;continue}M++,P=_<m-1?x:T,O=C<y-1?w:b,h.setTexture2D(),h.batchFillRect(_*g,C*v,P,O)}if(A&&e.altFillAlpha>0)for(C=0,o=h.fillTint,a=i.getTintAppendFloatAlphaAndSwap(e.altFillColor,e.altFillAlpha*d),o.TL=a,o.TR=a,o.BL=a,o.BR=a;C<y;C++)for(A&&(M=C%2),_=0;_<m;_++){if(A&&!M){M=1;continue}M=0,P=_<m-1?x:T,O=C<y-1?w:b,h.setTexture2D(),h.batchFillRect(_*g,C*v,P,O)}if(E&&e.outlineFillAlpha>0){var R=h.strokeTint,L=i.getTintAppendFloatAlphaAndSwap(e.outlineFillColor,e.outlineFillAlpha*d);for(_=1,R.TL=L,R.TR=L,R.BL=L,R.BR=L;_<m;_++){var k=_*g;h.setTexture2D(),h.batchLine(k,0,k,p,1,1,1,0,!1)}for(C=1;C<y;C++){var D=C*v;h.setTexture2D(),h.batchLine(0,D,f,D,1,1,1,0,!1)}}}}),r("jLoQL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("Jk7wq"),n=s("jNDrF"),r=s("csLaZ");t.exports=function(t,e,s,o,a){var h=t.currentContext;if(r(t,h,e,o,a)){var l=-e._displayOriginX,u=-e._displayOriginY,c=o.alpha*e.alpha,d=e.width,f=e.height,p=e.cellWidth,g=e.cellHeight,v=Math.ceil(d/p),m=Math.ceil(f/g),y=p,x=g,w=p-(v*p-d),T=g-(m*g-f),b=e.showCells,S=e.showAltCells,A=e.showOutline,E=0,_=0,C=0,M=0,P=0;if(A&&(//  To make room for the grid lines (in case alpha < 1)
y--,x--,w===p&&w--,T===g&&T--),b&&e.fillAlpha>0)for(i(h,e),_=0;_<m;_++)for(S&&(C=_%2),E=0;E<v;E++){if(S&&C){C=0;continue}C++,M=E<v-1?y:w,P=_<m-1?x:T,h.fillRect(l+E*p,u+_*g,M,P)}if(S&&e.altFillAlpha>0)for(i(h,e,e.altFillColor,e.altFillAlpha*c),_=0;_<m;_++)for(S&&(C=_%2),E=0;E<v;E++){if(S&&!C){C=1;continue}C=0,M=E<v-1?y:w,P=_<m-1?x:T,h.fillRect(l+E*p,u+_*g,M,P)}if(A&&e.outlineFillAlpha>0){for(n(h,e,e.outlineFillColor,e.outlineFillAlpha*c),E=1;E<v;E++){var O=E*p;h.beginPath(),h.moveTo(O+l,u),h.lineTo(O+l,f+u),h.stroke()}for(_=1;_<m;_++){var R=_*g;h.beginPath(),h.moveTo(l,R+u),h.lineTo(l+d,R+u),h.stroke()}}//  Restore the context saved in SetTransform
h.restore()}}}),r("ibqbn",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6Rb69"),n=s("jwj1g"),r=s("6cKpG"),o=new n({Extends:r,Mixins:[i],initialize:function(t,e,i,n,s,o,a,h){void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=48),void 0===s&&(s=32),void 0===o&&(o=15658734),void 0===a&&(a=10066329),void 0===h&&(h=13421772),r.call(this,t,"IsoBox",null),/**
         * The projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.
         *
         * @name Phaser.GameObjects.IsoBox#projection
         * @type {integer}
         * @default 4
         * @since 3.13.0
         */this.projection=4,/**
         * The color used to fill in the top of the iso box.
         *
         * @name Phaser.GameObjects.IsoBox#fillTop
         * @type {number}
         * @since 3.13.0
         */this.fillTop=o,/**
         * The color used to fill in the left-facing side of the iso box.
         *
         * @name Phaser.GameObjects.IsoBox#fillLeft
         * @type {number}
         * @since 3.13.0
         */this.fillLeft=a,/**
         * The color used to fill in the right-facing side of the iso box.
         *
         * @name Phaser.GameObjects.IsoBox#fillRight
         * @type {number}
         * @since 3.13.0
         */this.fillRight=h,/**
         * Controls if the top-face of the iso box be rendered.
         *
         * @name Phaser.GameObjects.IsoBox#showTop
         * @type {boolean}
         * @default true
         * @since 3.13.0
         */this.showTop=!0,/**
         * Controls if the left-face of the iso box be rendered.
         *
         * @name Phaser.GameObjects.IsoBox#showLeft
         * @type {boolean}
         * @default true
         * @since 3.13.0
         */this.showLeft=!0,/**
         * Controls if the right-face of the iso box be rendered.
         *
         * @name Phaser.GameObjects.IsoBox#showRight
         * @type {boolean}
         * @default true
         * @since 3.13.0
         */this.showRight=!0,this.isFilled=!0,this.setPosition(e,i),this.setSize(n,s),this.updateDisplayOrigin()},/**
     * Sets the projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.IsoBox#setProjection
     * @since 3.13.0
     * 
     * @param {integer} value - The value to set the projection to.
     *
     * @return {this} This Game Object instance.
     */setProjection:function(t){return this.projection=t,this},/**
     * Sets which faces of the iso box will be rendered.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.IsoBox#setFaces
     * @since 3.13.0
     * 
     * @param {boolean} [showTop=true] - Show the top-face of the iso box.
     * @param {boolean} [showLeft=true] - Show the left-face of the iso box.
     * @param {boolean} [showRight=true] - Show the right-face of the iso box.
     *
     * @return {this} This Game Object instance.
     */setFaces:function(t,e,i){return void 0===t&&(t=!0),void 0===e&&(e=!0),void 0===i&&(i=!0),this.showTop=t,this.showLeft=e,this.showRight=i,this},/**
     * Sets the fill colors for each face of the iso box.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.IsoBox#setFillStyle
     * @since 3.13.0
     * 
     * @param {number} [fillTop] - The color used to fill the top of the iso box.
     * @param {number} [fillLeft] - The color used to fill in the left-facing side of the iso box.
     * @param {number} [fillRight] - The color used to fill in the right-facing side of the iso box.
     *
     * @return {this} This Game Object instance.
     */setFillStyle:function(t,e,i){return this.fillTop=t,this.fillLeft=e,this.fillRight=i,this.isFilled=!0,this}});t.exports=o}),r("6Rb69",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("56Unh"),r=s("4Im19"),t.exports={renderWebGL:n,renderCanvas:r}}),r("56Unh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){var o,a,h,l,u,c,d,f,p,g=this.pipeline,v=g._tempMatrix1,m=g._tempMatrix2,y=g._tempMatrix3;t.setPipeline(g),m.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),v.copyFrom(s.matrix),r?(//  Multiply the camera by the parent matrix
v.multiplyWithOffset(r,-s.scrollX*e.scrollFactorX,-s.scrollY*e.scrollFactorY),//  Undo the camera scroll
m.e=e.x,m.f=e.y):(m.e-=s.scrollX*e.scrollFactorX,m.f-=s.scrollY*e.scrollFactorY),v.multiply(m,y);var x=e.width,w=e.height,T=x/2,b=x/e.projection,S=s.alpha*e.alpha;e.isFilled&&(e.showTop&&(o=i.getTintAppendFloatAlphaAndSwap(e.fillTop,S),a=y.getX(-T,-w),h=y.getY(-T,-w),l=y.getX(0,-b-w),u=y.getY(0,-b-w),c=y.getX(T,-w),d=y.getY(T,-w),f=y.getX(0,b-w),p=y.getY(0,b-w),g.setTexture2D(),g.batchQuad(a,h,l,u,c,d,f,p,0,0,1,1,o,o,o,o,2)),e.showLeft&&(o=i.getTintAppendFloatAlphaAndSwap(e.fillLeft,S),a=y.getX(-T,0),h=y.getY(-T,0),l=y.getX(0,b),u=y.getY(0,b),c=y.getX(0,b-w),d=y.getY(0,b-w),f=y.getX(-T,-w),p=y.getY(-T,-w),g.setTexture2D(),g.batchQuad(a,h,l,u,c,d,f,p,0,0,1,1,o,o,o,o,2)),e.showRight&&(o=i.getTintAppendFloatAlphaAndSwap(e.fillRight,S),a=y.getX(T,0),h=y.getY(T,0),l=y.getX(0,b),u=y.getY(0,b),c=y.getX(0,b-w),d=y.getY(0,b-w),f=y.getX(T,-w),p=y.getY(T,-w),g.setTexture2D(),g.batchQuad(a,h,l,u,c,d,f,p,0,0,1,1,o,o,o,o,2)))}}),r("4Im19",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("Jk7wq"),n=s("csLaZ");t.exports=function(t,e,s,r,o){var a=t.currentContext;if(n(t,a,e,r,o)&&e.isFilled){var h=e.width,l=e.height,u=h/2,c=h/e.projection;e.showTop&&(i(a,e,e.fillTop),a.beginPath(),a.moveTo(-u,-l),a.lineTo(0,-c-l),a.lineTo(u,-l),a.lineTo(u,-1),a.lineTo(0,c-1),a.lineTo(-u,-1),a.lineTo(-u,-l),a.fill()),e.showLeft&&(i(a,e,e.fillLeft),a.beginPath(),a.moveTo(-u,0),a.lineTo(0,c),a.lineTo(0,c-l),a.lineTo(-u,-l),a.lineTo(-u,0),a.fill()),e.showRight&&(i(a,e,e.fillRight),a.beginPath(),a.moveTo(u,0),a.lineTo(0,c),a.lineTo(0,c-l),a.lineTo(u,-l),a.lineTo(u,0),a.fill()),//  Restore the context saved in SetTransform
a.restore()}}}),r("e1XH0",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("ebEO8"),r=s("6cKpG"),o=new i({Extends:r,Mixins:[n],initialize:function(t,e,i,n,s,o,a,h,l){void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=48),void 0===s&&(s=32),void 0===o&&(o=!1),void 0===a&&(a=15658734),void 0===h&&(h=10066329),void 0===l&&(l=13421772),r.call(this,t,"IsoTriangle",null),/**
         * The projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.
         *
         * @name Phaser.GameObjects.IsoTriangle#projection
         * @type {integer}
         * @default 4
         * @since 3.13.0
         */this.projection=4,/**
         * The color used to fill in the top of the iso triangle. This is only used if the triangle is reversed.
         *
         * @name Phaser.GameObjects.IsoTriangle#fillTop
         * @type {number}
         * @since 3.13.0
         */this.fillTop=a,/**
         * The color used to fill in the left-facing side of the iso triangle.
         *
         * @name Phaser.GameObjects.IsoTriangle#fillLeft
         * @type {number}
         * @since 3.13.0
         */this.fillLeft=h,/**
         * The color used to fill in the right-facing side of the iso triangle.
         *
         * @name Phaser.GameObjects.IsoTriangle#fillRight
         * @type {number}
         * @since 3.13.0
         */this.fillRight=l,/**
         * Controls if the top-face of the iso triangle be rendered.
         *
         * @name Phaser.GameObjects.IsoTriangle#showTop
         * @type {boolean}
         * @default true
         * @since 3.13.0
         */this.showTop=!0,/**
         * Controls if the left-face of the iso triangle be rendered.
         *
         * @name Phaser.GameObjects.IsoTriangle#showLeft
         * @type {boolean}
         * @default true
         * @since 3.13.0
         */this.showLeft=!0,/**
         * Controls if the right-face of the iso triangle be rendered.
         *
         * @name Phaser.GameObjects.IsoTriangle#showRight
         * @type {boolean}
         * @default true
         * @since 3.13.0
         */this.showRight=!0,/**
         * Sets if the iso triangle will be rendered upside down or not.
         *
         * @name Phaser.GameObjects.IsoTriangle#isReversed
         * @type {boolean}
         * @default false
         * @since 3.13.0
         */this.isReversed=o,this.isFilled=!0,this.setPosition(e,i),this.setSize(n,s),this.updateDisplayOrigin()},/**
     * Sets the projection level of the iso triangle. Change this to change the 'angle' at which you are looking at the pyramid.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.IsoTriangle#setProjection
     * @since 3.13.0
     * 
     * @param {integer} value - The value to set the projection to.
     *
     * @return {this} This Game Object instance.
     */setProjection:function(t){return this.projection=t,this},/**
     * Sets if the iso triangle will be rendered upside down or not.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.IsoTriangle#setReversed
     * @since 3.13.0
     * 
     * @param {boolean} reversed - Sets if the iso triangle will be rendered upside down or not.
     *
     * @return {this} This Game Object instance.
     */setReversed:function(t){return this.isReversed=t,this},/**
     * Sets which faces of the iso triangle will be rendered.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.IsoTriangle#setFaces
     * @since 3.13.0
     * 
     * @param {boolean} [showTop=true] - Show the top-face of the iso triangle (only if `reversed` is true)
     * @param {boolean} [showLeft=true] - Show the left-face of the iso triangle.
     * @param {boolean} [showRight=true] - Show the right-face of the iso triangle.
     *
     * @return {this} This Game Object instance.
     */setFaces:function(t,e,i){return void 0===t&&(t=!0),void 0===e&&(e=!0),void 0===i&&(i=!0),this.showTop=t,this.showLeft=e,this.showRight=i,this},/**
     * Sets the fill colors for each face of the iso triangle.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.IsoTriangle#setFillStyle
     * @since 3.13.0
     * 
     * @param {number} [fillTop] - The color used to fill the top of the iso triangle.
     * @param {number} [fillLeft] - The color used to fill in the left-facing side of the iso triangle.
     * @param {number} [fillRight] - The color used to fill in the right-facing side of the iso triangle.
     *
     * @return {this} This Game Object instance.
     */setFillStyle:function(t,e,i){return this.fillTop=t,this.fillLeft=e,this.fillRight=i,this.isFilled=!0,this}});t.exports=o}),r("ebEO8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("k96iD"),r=s("emE63"),t.exports={renderWebGL:n,renderCanvas:r}}),r("k96iD",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){var o,a,h,l,u,c,d,f=this.pipeline,p=f._tempMatrix1,g=f._tempMatrix2,v=f._tempMatrix3;t.setPipeline(f),g.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),p.copyFrom(s.matrix),r?(//  Multiply the camera by the parent matrix
p.multiplyWithOffset(r,-s.scrollX*e.scrollFactorX,-s.scrollY*e.scrollFactorY),//  Undo the camera scroll
g.e=e.x,g.f=e.y):(g.e-=s.scrollX*e.scrollFactorX,g.f-=s.scrollY*e.scrollFactorY),p.multiply(g,v);var m=e.width,y=e.height,x=m/2,w=m/e.projection,T=e.isReversed,b=s.alpha*e.alpha;if(e.isFilled){//  Top Face
if(e.showTop&&T){o=i.getTintAppendFloatAlphaAndSwap(e.fillTop,b),a=v.getX(-x,-y),h=v.getY(-x,-y),l=v.getX(0,-w-y),u=v.getY(0,-w-y),c=v.getX(x,-y),d=v.getY(x,-y);var S=v.getX(0,w-y),A=v.getY(0,w-y);f.setTexture2D(),f.batchQuad(a,h,l,u,c,d,S,A,0,0,1,1,o,o,o,o,2)}e.showLeft&&(o=i.getTintAppendFloatAlphaAndSwap(e.fillLeft,b),T?(a=v.getX(-x,-y),h=v.getY(-x,-y)):(a=v.getX(-x,0),h=v.getY(-x,0)),l=v.getX(0,w),u=v.getY(0,w),c=v.getX(0,w-y),d=v.getY(0,w-y),f.batchTri(a,h,l,u,c,d,0,0,1,1,o,o,o,2)),e.showRight&&(o=i.getTintAppendFloatAlphaAndSwap(e.fillRight,b),T?(a=v.getX(x,-y),h=v.getY(x,-y)):(a=v.getX(x,0),h=v.getY(x,0)),l=v.getX(0,w),u=v.getY(0,w),c=v.getX(0,w-y),d=v.getY(0,w-y),f.setTexture2D(),f.batchTri(a,h,l,u,c,d,0,0,1,1,o,o,o,2))}}}),r("emE63",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("Jk7wq"),n=s("csLaZ");t.exports=function(t,e,s,r,o){var a=t.currentContext;if(n(t,a,e,r,o)&&e.isFilled){var h=e.width,l=e.height,u=h/2,c=h/e.projection,d=e.isReversed;e.showTop&&d&&(i(a,e,e.fillTop),a.beginPath(),a.moveTo(-u,-l),a.lineTo(0,-c-l),a.lineTo(u,-l),a.lineTo(0,c-l),a.fill()),e.showLeft&&(i(a,e,e.fillLeft),a.beginPath(),d?a.moveTo(-u,-l):a.moveTo(-u,0),a.lineTo(0,c),a.lineTo(0,c-l),a.fill()),e.showRight&&(i(a,e,e.fillRight),a.beginPath(),d?a.moveTo(u,-l):a.moveTo(u,0),a.lineTo(0,c),a.lineTo(0,c-l),a.fill()),//  Restore the context saved in SetTransform
a.restore()}}}),r("cW0dL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("6cKpG"),r=s("1LRPh"),o=s("47J3k"),a=new i({Extends:n,Mixins:[o],initialize:function(t,e,i,s,o,a,h,l,u){void 0===e&&(e=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===o&&(o=0),void 0===a&&(a=128),void 0===h&&(h=0),n.call(this,t,"Line",new r(s,o,a,h));var c=this.geom.right-this.geom.left,d=this.geom.bottom-this.geom.top;/**
         * The width (or thickness) of the line.
         * See the setLineWidth method for extra details on changing this on WebGL.
         *
         * @name Phaser.GameObjects.Line#lineWidth
         * @type {number}
         * @since 3.13.0
         */this.lineWidth=1,/**
         * Private internal value. Holds the start width of the line.
         *
         * @name Phaser.GameObjects.Line#_startWidth
         * @type {number}
         * @private
         * @since 3.13.0
         */this._startWidth=1,/**
         * Private internal value. Holds the end width of the line.
         *
         * @name Phaser.GameObjects.Line#_endWidth
         * @type {number}
         * @private
         * @since 3.13.0
         */this._endWidth=1,this.setPosition(e,i),this.setSize(c,d),void 0!==l&&this.setStrokeStyle(1,l,u),this.updateDisplayOrigin()},/**
     * Sets the width of the line.
     * 
     * When using the WebGL renderer you can have different start and end widths.
     * When using the Canvas renderer only the `startWidth` value is used. The `endWidth` is ignored.
     * 
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Line#setLineWidth
     * @since 3.13.0
     * 
     * @param {number} startWidth - The start width of the line.
     * @param {number} [endWidth] - The end width of the line. Only used in WebGL.
     *
     * @return {this} This Game Object instance.
     */setLineWidth:function(t,e){return void 0===e&&(e=t),this._startWidth=t,this._endWidth=e,this.lineWidth=t,this},/**
     * Sets the start and end coordinates of this Line.
     *
     * @method Phaser.GameObjects.Line#setTo
     * @since 3.13.0
     *
     * @param {number} [x1=0] - The horizontal position of the start of the line.
     * @param {number} [y1=0] - The vertical position of the start of the line.
     * @param {number} [x2=0] - The horizontal position of the end of the line.
     * @param {number} [y2=0] - The vertical position of the end of the line.
     *
     * @return {this} This Line object.
     */setTo:function(t,e,i,n){return this.geom.setTo(t,e,i,n),this}});t.exports=a}),r("47J3k",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("ksL2x"),r=s("jli4L"),t.exports={renderWebGL:n,renderCanvas:r}}),r("ksL2x",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){var o=this.pipeline,a=o._tempMatrix1,h=o._tempMatrix2;t.setPipeline(o),h.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),a.copyFrom(s.matrix),r?(//  Multiply the camera by the parent matrix
a.multiplyWithOffset(r,-s.scrollX*e.scrollFactorX,-s.scrollY*e.scrollFactorY),//  Undo the camera scroll
h.e=e.x,h.f=e.y):(h.e-=s.scrollX*e.scrollFactorX,h.f-=s.scrollY*e.scrollFactorY);var l=e._displayOriginX,u=e._displayOriginY,c=s.alpha*e.alpha;if(e.isStroked){var d=o.strokeTint,f=i.getTintAppendFloatAlphaAndSwap(e.strokeColor,e.strokeAlpha*c);d.TL=f,d.TR=f,d.BL=f,d.BR=f;var p=e._startWidth,g=e._endWidth;o.setTexture2D(),o.batchLine(e.geom.x1-l,e.geom.y1-u,e.geom.x2-l,e.geom.y2-u,p,g,1,0,!1,h,a)}}}),r("jli4L",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jNDrF"),n=s("csLaZ");t.exports=function(t,e,s,r,o){var a=t.currentContext;if(n(t,a,e,r,o)){var h=e._displayOriginX,l=e._displayOriginY;e.isStroked&&(i(a,e),a.beginPath(),a.moveTo(e.geom.x1-h,e.geom.y1-l),a.lineTo(e.geom.x2-h,e.geom.y2-l),a.stroke()),//  Restore the context saved in SetTransform
a.restore()}}}),r("4HMPS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gtAef"),n=s("jwj1g"),r=s("hjbjS"),o=s("hF14a"),a=s("7cxCo"),h=s("6cKpG"),l=s("6FcU2"),u=new n({Extends:h,Mixins:[i],initialize:function(t,e,i,n,s,r){void 0===e&&(e=0),void 0===i&&(i=0),h.call(this,t,"Polygon",new a(n));var l=o(this.geom);this.setPosition(e,i),this.setSize(l.width,l.height),void 0!==s&&this.setFillStyle(s,r),this.updateDisplayOrigin(),this.updateData()},/**
     * Smooths the polygon over the number of iterations specified.
     * The base polygon data will be updated and replaced with the smoothed values.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Polygon#smooth
     * @since 3.13.0
     * 
     * @param {integer} [iterations=1] - The number of times to apply the polygon smoothing.
     *
     * @return {this} This Game Object instance.
     */smooth:function(t){void 0===t&&(t=1);for(var e=0;e<t;e++)l(this.geom);return this.updateData()},/**
     * Internal method that updates the data and path values.
     *
     * @method Phaser.GameObjects.Polygon#updateData
     * @private
     * @since 3.13.0
     *
     * @return {this} This Game Object instance.
     */updateData:function(){for(var t=[],e=this.geom.points,i=0;i<e.length;i++)t.push(e[i].x,e[i].y);return t.push(e[0].x,e[0].y),this.pathIndexes=r(t),this.pathData=t,this}});t.exports=u}),r("gtAef",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("740Mg"),r=s("l8jYW"),t.exports={renderWebGL:n,renderCanvas:r}}),r("740Mg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("73AUV"),n=s("ythtQ");t.exports=function(t,e,s,r,o){var a=this.pipeline,h=a._tempMatrix1,l=a._tempMatrix2,u=a._tempMatrix3;t.setPipeline(a),l.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),h.copyFrom(r.matrix),o?(//  Multiply the camera by the parent matrix
h.multiplyWithOffset(o,-r.scrollX*e.scrollFactorX,-r.scrollY*e.scrollFactorY),//  Undo the camera scroll
l.e=e.x,l.f=e.y):(l.e-=r.scrollX*e.scrollFactorX,l.f-=r.scrollY*e.scrollFactorY),h.multiply(l,u);var c=e._displayOriginX,d=e._displayOriginY,f=r.alpha*e.alpha;e.isFilled&&i(a,u,e,f,c,d),e.isStroked&&n(a,e,f,c,d)}}),r("l8jYW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("Jk7wq"),n=s("jNDrF"),r=s("csLaZ");t.exports=function(t,e,s,o,a){var h=t.currentContext;if(r(t,h,e,o,a)){var l=e._displayOriginX,u=e._displayOriginY,c=e.pathData,d=c.length-1,f=c[0]-l,p=c[1]-u;h.beginPath(),h.moveTo(f,p),e.closePath||(d-=2);for(var g=2;g<d;g+=2){var v=c[g]-l,m=c[g+1]-u;h.lineTo(v,m)}h.closePath(),e.isFilled&&(i(h,e),h.fill()),e.isStroked&&(n(h,e),h.stroke()),//  Restore the context saved in SetTransform
h.restore()}}}),r("hF14a",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cwr8X");t.exports=function(t,e){void 0===e&&(e=new i);for(var n,s=1/0,r=1/0,o=-1/0,a=-1/0,h=0;h<t.points.length;h++)s=Math.min(s,(n=t.points[h]).x),r=Math.min(r,n.y),o=Math.max(o,n.x),a=Math.max(a,n.y);return e.x=s,e.y=r,e.width=o-s,e.height=a-r,e}}),r("7cxCo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("ivFeg"),r=s("gU0SF"),o=s("gZ2BZ"),a=new i({initialize:function(t){/**
         * The geometry constant type of this object: `GEOM_CONST.POLYGON`.
         * Used for fast type comparisons.
         *
         * @name Phaser.Geom.Polygon#type
         * @type {integer}
         * @readonly
         * @since 3.19.0
         */this.type=o.POLYGON,/**
         * The area of this Polygon.
         *
         * @name Phaser.Geom.Polygon#area
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.area=0,/**
         * An array of number pair objects that make up this polygon. I.e. [ {x,y}, {x,y}, {x,y} ]
         *
         * @name Phaser.Geom.Polygon#points
         * @type {Phaser.Geom.Point[]}
         * @since 3.0.0
         */this.points=[],t&&this.setTo(t)},/**
     * Check to see if the Polygon contains the given x / y coordinates.
     *
     * @method Phaser.Geom.Polygon#contains
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate to check within the polygon.
     * @param {number} y - The y coordinate to check within the polygon.
     *
     * @return {boolean} `true` if the coordinates are within the polygon, otherwise `false`.
     */contains:function(t,e){return n(this,t,e)},/**
     * Sets this Polygon to the given points.
     *
     * The points can be set from a variety of formats:
     *
     * - A string containing paired values separated by a single space: `'40 0 40 20 100 20 100 80 40 80 40 100 0 50'`
     * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
     * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
     * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
     * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
     *
     * `setTo` may also be called without any arguments to remove all points.
     *
     * @method Phaser.Geom.Polygon#setTo
     * @since 3.0.0
     *
     * @param {array} points - Points defining the perimeter of this polygon. Please check function description above for the different supported formats.
     *
     * @return {this} This Polygon object.
     */setTo:function(t){if(this.area=0,this.points=[],"string"==typeof t&&(t=t.split(" ")),!Array.isArray(t))return this;//  The points argument is an array, so iterate through it
for(var e,i=Number.MAX_VALUE,n=0;n<t.length;n++)e={x:0,y:0},"number"==typeof t[n]||"string"==typeof t[n]?(e.x=parseFloat(t[n]),e.y=parseFloat(t[n+1]),n++):Array.isArray(t[n])?(//  An array of arrays?
e.x=t[n][0],e.y=t[n][1]):(e.x=t[n].x,e.y=t[n].y),this.points.push(e),e.y<i&&(i=e.y);return this.calculateArea(i),this},/**
     * Calculates the area of the Polygon. This is available in the property Polygon.area
     *
     * @method Phaser.Geom.Polygon#calculateArea
     * @since 3.0.0
     *
     * @return {number} The area of the polygon.
     */calculateArea:function(){if(this.points.length<3)return this.area=0,this.area;for(var t,e,i=0,n=0;n<this.points.length-1;n++)t=this.points[n],i+=((e=this.points[n+1]).x-t.x)*(t.y+e.y);return t=this.points[0],e=this.points[this.points.length-1],i+=(t.x-e.x)*(e.y+t.y),this.area=-(.5*i),this.area},/**
     * Returns an array of Point objects containing the coordinates of the points around the perimeter of the Polygon,
     * based on the given quantity or stepRate values.
     *
     * @method Phaser.Geom.Polygon#getPoints
     * @since 3.12.0
     *
     * @generic {Phaser.Geom.Point[]} O - [output,$return]
     *
     * @param {integer} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
     * @param {number} [stepRate] - Sets the quantity by getting the perimeter of the Polygon and dividing it by the stepRate.
     * @param {(array|Phaser.Geom.Point[])} [output] - An array to insert the points in to. If not provided a new array will be created.
     *
     * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the perimeter of the Polygon.
     */getPoints:function(t,e,i){return r(this,t,e,i)}});t.exports=a}),r("ivFeg",function(t,e){t.exports=function(t,e,i){for(var n=!1,s=-1,r=t.points.length-1;++s<t.points.length;r=s){var o=t.points[s].x,a=t.points[s].y,h=t.points[r].x,l=t.points[r].y;(a<=i&&i<l||l<=i&&i<a)&&e<(h-o)*(i-a)/(l-a)+o&&(n=!n)}return n}}),r("gU0SF",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7Smss"),n=s("1LRPh"),r=s("dKsEw");t.exports=function(t,e,s,o){void 0===o&&(o=[]);var a=t.points,h=r(t);//  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.
!e&&s>0&&(e=h/s);for(var l=0;l<e;l++)for(var u=h*(l/e),c=0,d=0;d<a.length;d++){var f=a[d],p=a[(d+1)%a.length],g=new n(f.x,f.y,p.x,p.y),v=i(g);if(u<c||u>c+v){c+=v;continue}var m=g.getPoint((u-c)/v);o.push(m);break}return o}}),r("dKsEw",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7Smss"),n=s("1LRPh");t.exports=function(t){for(var e=t.points,s=0,r=0;r<e.length;r++){var o=e[r],a=e[(r+1)%e.length];s+=i(new n(o.x,o.y,a.x,a.y))}return s}}),r("6FcU2",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Igor Ognichenko <ognichenko.igor@gmail.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @ignore
 */var i=function(t,e){return t[0]=e[0],t[1]=e[1],t};t.exports=function(t){var e,n=[],s=t.points;for(e=0;e<s.length;e++)n.push([s[e].x,s[e].y]);var r=[];for(n.length>0&&r.push(i([0,0],n[0])),e=0;e<n.length-1;e++){var o=n[e],a=n[e+1],h=o[0],l=o[1],u=a[0],c=a[1];r.push([.85*h+.15*u,.85*l+.15*c]),r.push([.15*h+.85*u,.15*l+.85*c])}return n.length>1&&r.push(i([0,0],n[n.length-1])),t.setTo(r)}}),r("gGVmO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("cwr8X"),r=s("6cKpG"),o=s("44cxW"),a=new i({Extends:r,Mixins:[o],initialize:function(t,e,i,s,o,a,h){void 0===e&&(e=0),void 0===i&&(i=0),void 0===s&&(s=128),void 0===o&&(o=128),r.call(this,t,"Rectangle",new n(0,0,s,o)),this.setPosition(e,i),this.setSize(s,o),void 0!==a&&this.setFillStyle(a,h),this.updateDisplayOrigin(),this.updateData()},/**
     * Internal method that updates the data and path values.
     *
     * @method Phaser.GameObjects.Rectangle#updateData
     * @private
     * @since 3.13.0
     *
     * @return {this} This Game Object instance.
     */updateData:function(){var t=[],e=this.geom,i=this._tempLine;return e.getLineA(i),t.push(i.x1,i.y1,i.x2,i.y2),e.getLineB(i),t.push(i.x2,i.y2),e.getLineC(i),t.push(i.x2,i.y2),e.getLineD(i),t.push(i.x2,i.y2),this.pathData=t,this}});t.exports=a}),r("44cxW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("3XWuA"),r=s("8BcBI"),t.exports={renderWebGL:n,renderCanvas:r}}),r("3XWuA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ythtQ"),n=s("gaO4e");t.exports=function(t,e,s,r,o){var a=this.pipeline,h=a._tempMatrix1,l=a._tempMatrix2,u=a._tempMatrix3;t.setPipeline(a),l.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),h.copyFrom(r.matrix),o?(//  Multiply the camera by the parent matrix
h.multiplyWithOffset(o,-r.scrollX*e.scrollFactorX,-r.scrollY*e.scrollFactorY),//  Undo the camera scroll
l.e=e.x,l.f=e.y):(l.e-=r.scrollX*e.scrollFactorX,l.f-=r.scrollY*e.scrollFactorY),h.multiply(l,u);var c=e._displayOriginX,d=e._displayOriginY,f=r.alpha*e.alpha;if(e.isFilled){var p=a.fillTint,g=n.getTintAppendFloatAlphaAndSwap(e.fillColor,e.fillAlpha*f);p.TL=g,p.TR=g,p.BL=g,p.BR=g,a.setTexture2D(),a.batchFillRect(-c,-d,e.width,e.height)}e.isStroked&&i(a,e,f,c,d)}}),r("8BcBI",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("Jk7wq"),n=s("jNDrF"),r=s("csLaZ");t.exports=function(t,e,s,o,a){var h=t.currentContext;if(r(t,h,e,o,a)){var l=e._displayOriginX,u=e._displayOriginY;e.isFilled&&(i(h,e),h.fillRect(-l,-u,e.width,e.height)),e.isStroked&&(n(h,e),h.beginPath(),h.rect(-l,-u,e.width,e.height),h.stroke()),//  Restore the context saved in SetTransform
h.restore()}}}),r("lemMU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1xhT6"),n=s("jwj1g"),r=s("hjbjS"),o=s("6cKpG"),a=new n({Extends:o,Mixins:[i],initialize:function(t,e,i,n,s,r,a,h){void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=5),void 0===s&&(s=32),void 0===r&&(r=64),o.call(this,t,"Star",null),/**
         * Private internal value.
         * The number of points in the star.
         *
         * @name Phaser.GameObjects.Star#_points
         * @type {integer}
         * @private
         * @since 3.13.0
         */this._points=n,/**
         * Private internal value.
         * The inner radius of the star.
         *
         * @name Phaser.GameObjects.Star#_innerRadius
         * @type {number}
         * @private
         * @since 3.13.0
         */this._innerRadius=s,/**
         * Private internal value.
         * The outer radius of the star.
         *
         * @name Phaser.GameObjects.Star#_outerRadius
         * @type {number}
         * @private
         * @since 3.13.0
         */this._outerRadius=r,this.setPosition(e,i),this.setSize(2*r,2*r),void 0!==a&&this.setFillStyle(a,h),this.updateDisplayOrigin(),this.updateData()},/**
     * Sets the number of points that make up the Star shape.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Star#setPoints
     * @since 3.13.0
     * 
     * @param {integer} value - The amount of points the Star will have.
     *
     * @return {this} This Game Object instance.
     */setPoints:function(t){return this._points=t,this.updateData()},/**
     * Sets the inner radius of the Star shape.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Star#setInnerRadius
     * @since 3.13.0
     * 
     * @param {number} value - The amount to set the inner radius to.
     *
     * @return {this} This Game Object instance.
     */setInnerRadius:function(t){return this._innerRadius=t,this.updateData()},/**
     * Sets the outer radius of the Star shape.
     * This call can be chained.
     *
     * @method Phaser.GameObjects.Star#setOuterRadius
     * @since 3.13.0
     * 
     * @param {number} value - The amount to set the outer radius to.
     *
     * @return {this} This Game Object instance.
     */setOuterRadius:function(t){return this._outerRadius=t,this.updateData()},/**
     * The number of points that make up the Star shape.
     *
     * @name Phaser.GameObjects.Star#points
     * @type {integer}
     * @default 5
     * @since 3.13.0
     */points:{get:function(){return this._points},set:function(t){this._points=t,this.updateData()}},/**
     * The inner radius of the Star shape.
     *
     * @name Phaser.GameObjects.Star#innerRadius
     * @type {number}
     * @default 32
     * @since 3.13.0
     */innerRadius:{get:function(){return this._innerRadius},set:function(t){this._innerRadius=t,this.updateData()}},/**
     * The outer radius of the Star shape.
     *
     * @name Phaser.GameObjects.Star#outerRadius
     * @type {number}
     * @default 64
     * @since 3.13.0
     */outerRadius:{get:function(){return this._outerRadius},set:function(t){this._outerRadius=t,this.updateData()}},/**
     * Internal method that updates the data and path values.
     *
     * @method Phaser.GameObjects.Star#updateData
     * @private
     * @since 3.13.0
     *
     * @return {this} This Game Object instance.
     */updateData:function(){var t=[],e=this._points,i=this._innerRadius,n=this._outerRadius,s=Math.PI/2*3,o=Math.PI/e;t.push(n,n+-n);for(var a=0;a<e;a++)t.push(n+Math.cos(s)*n,n+Math.sin(s)*n),s+=o,t.push(n+Math.cos(s)*i,n+Math.sin(s)*i),s+=o;return t.push(n,n+-n),this.pathIndexes=r(t),this.pathData=t,this}});t.exports=a}),r("1xhT6",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("hVc6g"),r=s("47EX2"),t.exports={renderWebGL:n,renderCanvas:r}}),r("hVc6g",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("73AUV"),n=s("ythtQ");t.exports=function(t,e,s,r,o){var a=this.pipeline,h=a._tempMatrix1,l=a._tempMatrix2,u=a._tempMatrix3;t.setPipeline(a),l.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),h.copyFrom(r.matrix),o?(//  Multiply the camera by the parent matrix
h.multiplyWithOffset(o,-r.scrollX*e.scrollFactorX,-r.scrollY*e.scrollFactorY),//  Undo the camera scroll
l.e=e.x,l.f=e.y):(l.e-=r.scrollX*e.scrollFactorX,l.f-=r.scrollY*e.scrollFactorY),h.multiply(l,u);var c=e._displayOriginX,d=e._displayOriginY,f=r.alpha*e.alpha;e.isFilled&&i(a,u,e,f,c,d),e.isStroked&&n(a,e,f,c,d)}}),r("47EX2",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("Jk7wq"),n=s("jNDrF"),r=s("csLaZ");t.exports=function(t,e,s,o,a){var h=t.currentContext;if(r(t,h,e,o,a)){var l=e._displayOriginX,u=e._displayOriginY,c=e.pathData,d=c.length-1,f=c[0]-l,p=c[1]-u;h.beginPath(),h.moveTo(f,p),e.closePath||(d-=2);for(var g=2;g<d;g+=2){var v=c[g]-l,m=c[g+1]-u;h.lineTo(v,m)}h.closePath(),e.isFilled&&(i(h,e),h.fill()),e.isStroked&&(n(h,e),h.stroke()),//  Restore the context saved in SetTransform
h.restore()}}}),r("b6DRH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("6cKpG"),r=s("1TF8x"),o=s("dbjo1"),a=new i({Extends:n,Mixins:[o],initialize:function(t,e,i,s,o,a,h,l,u,c,d){void 0===e&&(e=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===o&&(o=128),void 0===a&&(a=64),void 0===h&&(h=0),void 0===l&&(l=128),void 0===u&&(u=128),n.call(this,t,"Triangle",new r(s,o,a,h,l,u));var f=this.geom.right-this.geom.left,p=this.geom.bottom-this.geom.top;this.setPosition(e,i),this.setSize(f,p),void 0!==c&&this.setFillStyle(c,d),this.updateDisplayOrigin(),this.updateData()},/**
     * Sets the data for the lines that make up this Triangle shape.
     *
     * @method Phaser.GameObjects.Triangle#setTo
     * @since 3.13.0
     *
     * @param {number} [x1=0] - The horizontal position of the first point in the triangle.
     * @param {number} [y1=0] - The vertical position of the first point in the triangle.
     * @param {number} [x2=0] - The horizontal position of the second point in the triangle.
     * @param {number} [y2=0] - The vertical position of the second point in the triangle.
     * @param {number} [x3=0] - The horizontal position of the third point in the triangle.
     * @param {number} [y3=0] - The vertical position of the third point in the triangle.
     *
     * @return {this} This Game Object instance.
     */setTo:function(t,e,i,n,s,r){return this.geom.setTo(t,e,i,n,s,r),this.updateData()},/**
     * Internal method that updates the data and path values.
     *
     * @method Phaser.GameObjects.Triangle#updateData
     * @private
     * @since 3.13.0
     *
     * @return {this} This Game Object instance.
     */updateData:function(){var t=[],e=this.geom,i=this._tempLine;return e.getLineA(i),t.push(i.x1,i.y1,i.x2,i.y2),e.getLineB(i),t.push(i.x2,i.y2),e.getLineC(i),t.push(i.x2,i.y2),this.pathData=t,this}});t.exports=a}),r("1TF8x",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7e4Vb"),r=s("dzuyF"),o=s("50jzU"),a=s("gZ2BZ"),h=s("1LRPh"),l=s("2MADn"),u=new i({initialize:function(t,e,i,n,s,r){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=0),void 0===s&&(s=0),void 0===r&&(r=0),/**
         * The geometry constant type of this object: `GEOM_CONST.TRIANGLE`.
         * Used for fast type comparisons.
         *
         * @name Phaser.Geom.Triangle#type
         * @type {integer}
         * @readonly
         * @since 3.19.0
         */this.type=a.TRIANGLE,/**
         * `x` coordinate of the first point.
         *
         * @name Phaser.Geom.Triangle#x1
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.x1=t,/**
         * `y` coordinate of the first point.
         *
         * @name Phaser.Geom.Triangle#y1
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.y1=e,/**
         * `x` coordinate of the second point.
         *
         * @name Phaser.Geom.Triangle#x2
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.x2=i,/**
         * `y` coordinate of the second point.
         *
         * @name Phaser.Geom.Triangle#y2
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.y2=n,/**
         * `x` coordinate of the third point.
         *
         * @name Phaser.Geom.Triangle#x3
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.x3=s,/**
         * `y` coordinate of the third point.
         *
         * @name Phaser.Geom.Triangle#y3
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.y3=r},/**
     * Checks whether a given points lies within the triangle.
     *
     * @method Phaser.Geom.Triangle#contains
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate of the point to check.
     * @param {number} y - The y coordinate of the point to check.
     *
     * @return {boolean} `true` if the coordinate pair is within the triangle, otherwise `false`.
     */contains:function(t,e){return n(this,t,e)},/**
     * Returns a specific point  on the triangle.
     *
     * @method Phaser.Geom.Triangle#getPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point} O - [output,$return]
     *
     * @param {number} position - Position as float within `0` and `1`. `0` equals the first point.
     * @param {(Phaser.Geom.Point|object)} [output] - Optional Point, or point-like object, that the calculated point will be written to.
     *
     * @return {(Phaser.Geom.Point|object)} Calculated `Point` that represents the requested position. It is the same as `output` when this parameter has been given.
     */getPoint:function(t,e){return r(this,t,e)},/**
     * Calculates a list of evenly distributed points on the triangle. It is either possible to pass an amount of points to be generated (`quantity`) or the distance between two points (`stepRate`).
     *
     * @method Phaser.Geom.Triangle#getPoints
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point[]} O - [output,$return]
     *
     * @param {integer} quantity - Number of points to be generated. Can be falsey when `stepRate` should be used. All points have the same distance along the triangle.
     * @param {number} [stepRate] - Distance between two points. Will only be used when `quantity` is falsey.
     * @param {(array|Phaser.Geom.Point[])} [output] - Optional Array for writing the calculated points into. Otherwise a new array will be created.
     *
     * @return {(array|Phaser.Geom.Point[])} Returns a list of calculated `Point` instances or the filled array passed as parameter `output`.
     */getPoints:function(t,e,i){return o(this,t,e,i)},/**
     * Returns a random point along the triangle.
     *
     * @method Phaser.Geom.Triangle#getRandomPoint
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Point} O - [point,$return]
     *
     * @param {Phaser.Geom.Point} [point] - Optional `Point` that should be modified. Otherwise a new one will be created.
     *
     * @return {Phaser.Geom.Point} Random `Point`. When parameter `point` has been provided it will be returned.
     */getRandomPoint:function(t){return l(this,t)},/**
     * Sets all three points of the triangle. Leaving out any coordinate sets it to be `0`.
     *
     * @method Phaser.Geom.Triangle#setTo
     * @since 3.0.0
     *
     * @param {number} [x1=0] - `x` coordinate of the first point.
     * @param {number} [y1=0] - `y` coordinate of the first point.
     * @param {number} [x2=0] - `x` coordinate of the second point.
     * @param {number} [y2=0] - `y` coordinate of the second point.
     * @param {number} [x3=0] - `x` coordinate of the third point.
     * @param {number} [y3=0] - `y` coordinate of the third point.
     *
     * @return {this} This Triangle object.
     */setTo:function(t,e,i,n,s,r){return void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=0),void 0===s&&(s=0),void 0===r&&(r=0),this.x1=t,this.y1=e,this.x2=i,this.y2=n,this.x3=s,this.y3=r,this},/**
     * Returns a Line object that corresponds to Line A of this Triangle.
     *
     * @method Phaser.Geom.Triangle#getLineA
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Line} O - [line,$return]
     *
     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
     *
     * @return {Phaser.Geom.Line} A Line object that corresponds to line A of this Triangle.
     */getLineA:function(t){return void 0===t&&(t=new h),t.setTo(this.x1,this.y1,this.x2,this.y2),t},/**
     * Returns a Line object that corresponds to Line B of this Triangle.
     *
     * @method Phaser.Geom.Triangle#getLineB
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Line} O - [line,$return]
     *
     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
     *
     * @return {Phaser.Geom.Line} A Line object that corresponds to line B of this Triangle.
     */getLineB:function(t){return void 0===t&&(t=new h),t.setTo(this.x2,this.y2,this.x3,this.y3),t},/**
     * Returns a Line object that corresponds to Line C of this Triangle.
     *
     * @method Phaser.Geom.Triangle#getLineC
     * @since 3.0.0
     *
     * @generic {Phaser.Geom.Line} O - [line,$return]
     *
     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
     *
     * @return {Phaser.Geom.Line} A Line object that corresponds to line C of this Triangle.
     */getLineC:function(t){return void 0===t&&(t=new h),t.setTo(this.x3,this.y3,this.x1,this.y1),t},/**
     * Left most X coordinate of the triangle. Setting it moves the triangle on the X axis accordingly.
     *
     * @name Phaser.Geom.Triangle#left
     * @type {number}
     * @since 3.0.0
     */left:{get:function(){return Math.min(this.x1,this.x2,this.x3)},set:function(t){var e=0;e=this.x1<=this.x2&&this.x1<=this.x3?this.x1-t:this.x2<=this.x1&&this.x2<=this.x3?this.x2-t:this.x3-t,this.x1-=e,this.x2-=e,this.x3-=e}},/**
     * Right most X coordinate of the triangle. Setting it moves the triangle on the X axis accordingly.
     *
     * @name Phaser.Geom.Triangle#right
     * @type {number}
     * @since 3.0.0
     */right:{get:function(){return Math.max(this.x1,this.x2,this.x3)},set:function(t){var e=0;e=this.x1>=this.x2&&this.x1>=this.x3?this.x1-t:this.x2>=this.x1&&this.x2>=this.x3?this.x2-t:this.x3-t,this.x1-=e,this.x2-=e,this.x3-=e}},/**
     * Top most Y coordinate of the triangle. Setting it moves the triangle on the Y axis accordingly.
     *
     * @name Phaser.Geom.Triangle#top
     * @type {number}
     * @since 3.0.0
     */top:{get:function(){return Math.min(this.y1,this.y2,this.y3)},set:function(t){var e=0;e=this.y1<=this.y2&&this.y1<=this.y3?this.y1-t:this.y2<=this.y1&&this.y2<=this.y3?this.y2-t:this.y3-t,this.y1-=e,this.y2-=e,this.y3-=e}},/**
     * Bottom most Y coordinate of the triangle. Setting it moves the triangle on the Y axis accordingly.
     *
     * @name Phaser.Geom.Triangle#bottom
     * @type {number}
     * @since 3.0.0
     */bottom:{get:function(){return Math.max(this.y1,this.y2,this.y3)},set:function(t){var e=0;e=this.y1>=this.y2&&this.y1>=this.y3?this.y1-t:this.y2>=this.y1&&this.y2>=this.y3?this.y2-t:this.y3-t,this.y1-=e,this.y2-=e,this.y3-=e}}});t.exports=u}),r("7e4Vb",function(t,e){t.exports=function(t,e,i){var n=t.x3-t.x1,s=t.y3-t.y1,r=t.x2-t.x1,o=t.y2-t.y1,a=e-t.x1,h=i-t.y1,l=n*n+s*s,u=n*r+s*o,c=n*a+s*h,d=r*r+o*o,f=r*a+o*h,p=l*d-u*u,g=0===p?0:1/p,v=(d*c-u*f)*g,m=(l*f-u*c)*g;return v>=0&&m>=0&&v+m<1}}),r("dzuyF",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9"),n=s("7Smss");t.exports=function(t,e,s){void 0===s&&(s=new i);var r=t.getLineA(),o=t.getLineB(),a=t.getLineC();if(e<=0||e>=1)return s.x=r.x1,s.y=r.y1,s;var h=n(r),l=n(o),u=n(a),c=(h+l+u)*e,d=0;return c<h?(//  Line 1
d=c/h,s.x=r.x1+(r.x2-r.x1)*d,s.y=r.y1+(r.y2-r.y1)*d):c>h+l?(//  Line 3
c-=h+l,d=c/u,s.x=a.x1+(a.x2-a.x1)*d,s.y=a.y1+(a.y2-a.y1)*d):(//  Line 2
c-=h,d=c/l,s.x=o.x1+(o.x2-o.x1)*d,s.y=o.y1+(o.y2-o.y1)*d),s}}),r("50jzU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7Smss"),n=s("cSEB9");t.exports=function(t,e,s,r){void 0===r&&(r=[]);var o=t.getLineA(),a=t.getLineB(),h=t.getLineC(),l=i(o),u=i(a),c=i(h),d=l+u+c;//  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.
!e&&s>0&&(e=d/s);for(var f=0;f<e;f++){var p=d*(f/e),g=0,v=new n;p<l?(//  Line 1
g=p/l,v.x=o.x1+(o.x2-o.x1)*g,v.y=o.y1+(o.y2-o.y1)*g):p>l+u?(//  Line 3
p-=l+u,g=p/c,v.x=h.x1+(h.x2-h.x1)*g,v.y=h.y1+(h.y2-h.y1)*g):(//  Line 2
p-=l,g=p/u,v.x=a.x1+(a.x2-a.x1)*g,v.y=a.y1+(a.y2-a.y1)*g),r.push(v)}return r}}),r("dbjo1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("1L5sv"),r=s("egkoU"),t.exports={renderWebGL:n,renderCanvas:r}}),r("1L5sv",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ythtQ"),n=s("gaO4e");t.exports=function(t,e,s,r,o){var a=this.pipeline,h=a._tempMatrix1,l=a._tempMatrix2,u=a._tempMatrix3;t.setPipeline(a),l.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),h.copyFrom(r.matrix),o?(//  Multiply the camera by the parent matrix
h.multiplyWithOffset(o,-r.scrollX*e.scrollFactorX,-r.scrollY*e.scrollFactorY),//  Undo the camera scroll
l.e=e.x,l.f=e.y):(l.e-=r.scrollX*e.scrollFactorX,l.f-=r.scrollY*e.scrollFactorY),h.multiply(l,u);var c=e._displayOriginX,d=e._displayOriginY,f=r.alpha*e.alpha;if(e.isFilled){var p=a.fillTint,g=n.getTintAppendFloatAlphaAndSwap(e.fillColor,e.fillAlpha*f);p.TL=g,p.TR=g,p.BL=g,p.BR=g;var v=e.geom.x1-c,m=e.geom.y1-d,y=e.geom.x2-c,x=e.geom.y2-d,w=e.geom.x3-c,T=e.geom.y3-d;a.setTexture2D(),a.batchFillTriangle(v,m,y,x,w,T,l,h)}e.isStroked&&i(a,e,f,c,d)}}),r("egkoU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("Jk7wq"),n=s("jNDrF"),r=s("csLaZ");t.exports=function(t,e,s,o,a){var h=t.currentContext;if(r(t,h,e,o,a)){var l=e._displayOriginX,u=e._displayOriginY,c=e.geom.x1-l,d=e.geom.y1-u,f=e.geom.x2-l,p=e.geom.y2-u,g=e.geom.x3-l,v=e.geom.y3-u;h.beginPath(),h.moveTo(c,d),h.lineTo(f,p),h.lineTo(g,v),h.closePath(),e.isFilled&&(i(h,e),h.fill()),e.isStroked&&(n(h,e),h.stroke()),//  Restore the context saved in SetTransform
h.restore()}}}),r("i3l6S",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2cD2D");/**
 * Creates a new Blitter Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Blitter Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#blitter
 * @since 3.0.0
 *
 * @param {number} x - The x position of the Game Object.
 * @param {number} y - The y position of the Game Object.
 * @param {string} key - The key of the Texture the Blitter object will use.
 * @param {(string|integer)} [frame] - The default Frame children of the Blitter will use.
 * 
 * @return {Phaser.GameObjects.Blitter} The Game Object that was created.
 */s("kge7H").register("blitter",function(t,e,n,s){return this.displayList.add(new i(this.scene,t,e,n,s))});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("gE6ET",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ixgBh");/**
 * Creates a new Container Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Container Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#container
 * @since 3.4.0
 *
 * @param {number} x - The horizontal position of this Game Object in the world.
 * @param {number} y - The vertical position of this Game Object in the world.
 * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Container.
 *
 * @return {Phaser.GameObjects.Container} The Game Object that was created.
 */s("kge7H").register("container",function(t,e,n){return this.displayList.add(new i(this.scene,t,e,n))})}),r("ghXwl",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gZAGH");/**
 * DOM Element Game Objects are a way to control and manipulate HTML Elements over the top of your game.
 * 
 * In order for DOM Elements to display you have to enable them by adding the following to your game
 * configuration object:
 * 
 * ```javascript
 * dom {
 *   createContainer: true
 * }
 * ```
 * 
 * When this is added, Phaser will automatically create a DOM Container div that is positioned over the top
 * of the game canvas. This div is sized to match the canvas, and if the canvas size changes, as a result of
 * settings within the Scale Manager, the dom container is resized accordingly.
 * 
 * You can create a DOM Element by either passing in DOMStrings, or by passing in a reference to an existing
 * Element that you wish to be placed under the control of Phaser. For example:
 * 
 * ```javascript
 * this.add.dom(x, y, 'div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');
 * ```
 * 
 * The above code will insert a div element into the DOM Container at the given x/y coordinate. The DOMString in
 * the 4th argument sets the initial CSS style of the div and the final argument is the inner text. In this case,
 * it will create a lime colored div that is 220px by 100px in size with the text Phaser in it, in an Arial font.
 * 
 * You should nearly always, without exception, use explicitly sized HTML Elements, in order to fully control
 * alignment and positioning of the elements next to regular game content.
 * 
 * Rather than specify the CSS and HTML directly you can use the `load.html` File Loader to load it into the
 * cache and then use the `createFromCache` method instead. You can also use `createFromHTML` and various other
 * methods available in this class to help construct your elements.
 * 
 * Once the element has been created you can then control it like you would any other Game Object. You can set its
 * position, scale, rotation, alpha and other properties. It will move as the main Scene Camera moves and be clipped
 * at the edge of the canvas. It's important to remember some limitations of DOM Elements: The obvious one is that
 * they appear above or below your game canvas. You cannot blend them into the display list, meaning you cannot have
 * a DOM Element, then a Sprite, then another DOM Element behind it.
 * 
 * They also cannot be enabled for input. To do that, you have to use the `addListener` method to add native event
 * listeners directly. The final limitation is to do with cameras. The DOM Container is sized to match the game canvas
 * entirely and clipped accordingly. DOM Elements respect camera scrolling and scrollFactor settings, but if you
 * change the size of the camera so it no longer matches the size of the canvas, they won't be clipped accordingly.
 * 
 * Also, all DOM Elements are inserted into the same DOM Container, regardless of which Scene they are created in.
 * 
 * DOM Elements are a powerful way to align native HTML with your Phaser Game Objects. For example, you can insert
 * a login form for a multiplayer game directly into your title screen. Or a text input box for a highscore table.
 * Or a banner ad from a 3rd party service. Or perhaps you'd like to use them for high resolution text display and
 * UI. The choice is up to you, just remember that you're dealing with standard HTML and CSS floating over the top
 * of your game, and should treat it accordingly.
 *
 * Note: This method will only be available if the DOM Element Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#dom
 * @since 3.17.0
 *
 * @param {number} x - The horizontal position of this DOM Element in the world.
 * @param {number} y - The vertical position of this DOM Element in the world.
 * @param {(HTMLElement|string)} [element] - An existing DOM element, or a string. If a string starting with a # it will do a `getElementById` look-up on the string (minus the hash). Without a hash, it represents the type of element to create, i.e. 'div'.
 * @param {(string|any)} [style] - If a string, will be set directly as the elements `style` property value. If a plain object, will be iterated and the values transferred. In both cases the values replacing whatever CSS styles may have been previously set.
 * @param {string} [innerText] - If given, will be set directly as the elements `innerText` property value, replacing whatever was there before.
 *
 * @return {Phaser.GameObjects.DOMElement} The Game Object that was created.
 */s("kge7H").register("dom",function(t,e,n,s,r){var o=new i(this.scene,t,e,n,s,r);return this.displayList.add(o),this.updateList.add(o),o})}),r("pLPkQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5soSO");/**
 * Creates a new Dynamic Bitmap Text Game Object and adds it to the Scene.
 * 
 * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.
 * 
 * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to
 * match the font structure.
 * 
 * Dynamic Bitmap Text objects are different from Static Bitmap Text in that they invoke a callback for each
 * letter being rendered during the render pass. This callback allows you to manipulate the properties of
 * each letter being rendered, such as its position, scale or tint, allowing you to create interesting effects
 * like jiggling text, which can't be done with Static text. This means that Dynamic Text takes more processing
 * time, so only use them if you require the callback ability they have.
 *
 * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
 * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by
 * processing the font texture in an image editor, applying fills and any other effects required.
 *
 * To create multi-line text insert \r, \n or \r\n escape codes into the text string.
 *
 * To create a BitmapText data files you need a 3rd party app such as:
 *
 * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/
 * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner
 * Littera (Web-based, free): http://kvazars.com/littera/
 *
 * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of
 * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson
 *
 * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#dynamicBitmapText
 * @since 3.0.0
 *
 * @param {number} x - The x position of the Game Object.
 * @param {number} y - The y position of the Game Object.
 * @param {string} font - The key of the font to use from the BitmapFont cache.
 * @param {(string|string[])} [text] - The string, or array of strings, to be set as the content of this Bitmap Text.
 * @param {number} [size] - The font size to set.
 *
 * @return {Phaser.GameObjects.DynamicBitmapText} The Game Object that was created.
 */s("kge7H").register("dynamicBitmapText",function(t,e,n,s,r){return this.displayList.add(new i(this.scene,t,e,n,s,r))});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("3f2P6",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("9I9TZ");/**
 * Creates a new Extern Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Extern Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#extern
 * @since 3.16.0
 *
 * @return {Phaser.GameObjects.Extern} The Game Object that was created.
 */s("kge7H").register("extern",function(){var t=new i(this.scene);return this.displayList.add(t),this.updateList.add(t),t});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("5tfzZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2Irqj");/**
 * Creates a new Graphics Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Graphics Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#graphics
 * @since 3.0.0
 *
 * @param {Phaser.Types.GameObjects.Graphics.Options} [config] - The Graphics configuration.
 *
 * @return {Phaser.GameObjects.Graphics} The Game Object that was created.
 */s("kge7H").register("graphics",function(t){return this.displayList.add(new i(this.scene,t))});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("knm1M",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hDBsd");/**
 * Creates a new Group Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Group Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#group
 * @since 3.0.0
 *
 * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupConfig[])} [children] - Game Objects to add to this Group; or the `config` argument.
 * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - A Group Configuration object.
 *
 * @return {Phaser.GameObjects.Group} The Game Object that was created.
 */s("kge7H").register("group",function(t,e){return this.updateList.add(new i(this.scene,t,e))})}),r("dI5N4",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("8qGvv");/**
 * Creates a new Image Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Image Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#image
 * @since 3.0.0
 *
 * @param {number} x - The horizontal position of this Game Object in the world.
 * @param {number} y - The vertical position of this Game Object in the world.
 * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
 * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.
 *
 * @return {Phaser.GameObjects.Image} The Game Object that was created.
 */s("kge7H").register("image",function(t,e,n,s){return this.displayList.add(new i(this.scene,t,e,n,s))});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("fgDAM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("fnOwf");/**
 * Creates a new Particle Emitter Manager Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Particles Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#particles
 * @since 3.0.0
 *
 * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
 * @param {(string|integer|object)} [frame] - An optional frame from the Texture this Game Object is rendering with.
 * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig|Phaser.Types.GameObjects.Particles.ParticleEmitterConfig[]} [emitters] - Configuration settings for one or more emitters to create.
 *
 * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} The Game Object that was created.
 */i.register("particles",function(t,e,i){var s=new n(this.scene,t,e,i);return this.displayList.add(s),this.updateList.add(s),s});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("iE8dp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("75mFg");/**
 * Creates a new PathFollower Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the PathFollower Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#follower
 * @since 3.0.0
 *
 * @param {Phaser.Curves.Path} path - The Path this PathFollower is connected to.
 * @param {number} x - The horizontal position of this Game Object in the world.
 * @param {number} y - The vertical position of this Game Object in the world.
 * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
 * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.
 *
 * @return {Phaser.GameObjects.PathFollower} The Game Object that was created.
 */i.register("follower",function(t,e,i,s,r){var o=new n(this.scene,t,e,i,s,r);return this.displayList.add(o),this.updateList.add(o),o});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("60zoM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("iCX4n");/**
 * Creates a new Render Texture Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.
 * 
 * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and
 * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic
 * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.
 *
 * @method Phaser.GameObjects.GameObjectFactory#renderTexture
 * @since 3.2.0
 *
 * @param {number} x - The horizontal position of this Game Object in the world.
 * @param {number} y - The vertical position of this Game Object in the world.
 * @param {integer} [width=32] - The width of the Render Texture.
 * @param {integer} [height=32] - The height of the Render Texture.
 * @property {string} [key] - The texture key to make the RenderTexture from.
 * @property {string} [frame] - the frame to make the RenderTexture from.
 * 
 * @return {Phaser.GameObjects.RenderTexture} The Game Object that was created.
 */i.register("renderTexture",function(t,e,i,s,r,o){return this.displayList.add(new n(this.scene,t,e,i,s,r,o))})}),r("43Yb1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("4dBPv");s("kge7H").register("rope",function(t,e,n,s,r,o,a,h){var l=new i(this.scene,t,e,n,s,r,o,a,h);return this.displayList.add(l),this.updateList.add(l)});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("5SbTm",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("gXuc8");/**
 * Creates a new Sprite Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Sprite Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#sprite
 * @since 3.0.0
 *
 * @param {number} x - The horizontal position of this Game Object in the world.
 * @param {number} y - The vertical position of this Game Object in the world.
 * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
 * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.
 *
 * @return {Phaser.GameObjects.Sprite} The Game Object that was created.
 */i.register("sprite",function(t,e,i,s){var r=new n(this.scene,t,e,i,s);return this.displayList.add(r),this.updateList.add(r),r});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("iv8Vm",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gvPR8");/**
 * Creates a new Bitmap Text Game Object and adds it to the Scene.
 * 
 * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.
 * 
 * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to
 * match the font structure.
 * 
 * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
 * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by
 * processing the font texture in an image editor, applying fills and any other effects required.
 *
 * To create multi-line text insert \r, \n or \r\n escape codes into the text string.
 *
 * To create a BitmapText data files you need a 3rd party app such as:
 *
 * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/
 * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner
 * Littera (Web-based, free): http://kvazars.com/littera/
 *
 * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of
 * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson
 *
 * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#bitmapText
 * @since 3.0.0
 *
 * @param {number} x - The x position of the Game Object.
 * @param {number} y - The y position of the Game Object.
 * @param {string} font - The key of the font to use from the BitmapFont cache.
 * @param {(string|string[])} [text] - The string, or array of strings, to be set as the content of this Bitmap Text.
 * @param {number} [size] - The font size to set.
 * @param {integer} [align=0] - The alignment of the text in a multi-line BitmapText object.
 *
 * @return {Phaser.GameObjects.BitmapText} The Game Object that was created.
 */s("kge7H").register("bitmapText",function(t,e,n,s,r,o){return this.displayList.add(new i(this.scene,t,e,n,s,r,o))});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("8BYGq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1jO0s");/**
 * Creates a new Text Game Object and adds it to the Scene.
 * 
 * A Text Game Object.
 * 
 * Text objects work by creating their own internal hidden Canvas and then renders text to it using
 * the standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered
 * to your game during the render pass.
 * 
 * Because it uses the Canvas API you can take advantage of all the features this offers, such as
 * applying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts
 * loaded externally, such as Google or TypeKit Web fonts.
 *
 * You can only display fonts that are currently loaded and available to the browser: therefore fonts must
 * be pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,
 * or have the fonts ready available in the CSS on the page in which your Phaser game resides.
 *
 * See {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts
 * across mobile browsers.
 * 
 * A note on performance: Every time the contents of a Text object changes, i.e. changing the text being
 * displayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the
 * new texture to the GPU. This can be an expensive operation if used often, or with large quantities of
 * Text objects in your game. If you run into performance issues you would be better off using Bitmap Text
 * instead, as it benefits from batching and avoids expensive Canvas API calls.
 *
 * Note: This method will only be available if the Text Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#text
 * @since 3.0.0
 *
 * @param {number} x - The horizontal position of this Game Object in the world.
 * @param {number} y - The vertical position of this Game Object in the world.
 * @param {(string|string[])} text - The text this Text object will display.
 * @param {object} [style] - The Text style configuration object.
 *
 * @return {Phaser.GameObjects.Text} The Game Object that was created.
 */s("kge7H").register("text",function(t,e,n,s){return this.displayList.add(new i(this.scene,t,e,n,s))});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("ivPvd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kwyUq");/**
 * Creates a new TileSprite Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#tileSprite
 * @since 3.0.0
 *
 * @param {number} x - The horizontal position of this Game Object in the world.
 * @param {number} y - The vertical position of this Game Object in the world.
 * @param {integer} width - The width of the Game Object. If zero it will use the size of the texture frame.
 * @param {integer} height - The height of the Game Object. If zero it will use the size of the texture frame.
 * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
 * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.
 *
 * @return {Phaser.GameObjects.TileSprite} The Game Object that was created.
 */s("kge7H").register("tileSprite",function(t,e,n,s,r,o){return this.displayList.add(new i(this.scene,t,e,n,s,r,o))});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("6HUvG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("dZGDG");/**
 * Creates a new Zone Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Zone Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#zone
 * @since 3.0.0
 *
 * @param {number} x - The horizontal position of this Game Object in the world.
 * @param {number} y - The vertical position of this Game Object in the world.
 * @param {number} width - The width of the Game Object.
 * @param {number} height - The height of the Game Object.
 * 
 * @return {Phaser.GameObjects.Zone} The Game Object that was created.
 */s("kge7H").register("zone",function(t,e,n,s){return this.displayList.add(new i(this.scene,t,e,n,s))});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("aFn2V",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("Cfqdl");/**
 * Creates a new Video Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Video Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#video
 * @since 3.20.0
 *
 * @param {number} x - The horizontal position of this Game Object in the world.
 * @param {number} y - The vertical position of this Game Object in the world.
 * @param {string} [key] - Optional key of the Video this Game Object will play, as stored in the Video Cache.
 *
 * @return {Phaser.GameObjects.Video} The Game Object that was created.
 */s("kge7H").register("video",function(t,e,n){var s=new i(this.scene,t,e,n);return this.displayList.add(s),this.updateList.add(s),s});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("kh6qR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ab6uD"),n=s("kge7H");/**
 * Creates a new Arc Shape Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Arc Game Object has been built into Phaser.
 * 
 * The Arc Shape is a Game Object that can be added to a Scene, Group or Container. You can
 * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
 * it for input or physics. It provides a quick and easy way for you to render this shape in your
 * game without using a texture, while still taking advantage of being fully batched in WebGL.
 * 
 * This shape supports both fill and stroke colors.
 * 
 * When it renders it displays an arc shape. You can control the start and end angles of the arc,
 * as well as if the angles are winding clockwise or anti-clockwise. With the default settings
 * it renders as a complete circle. By changing the angles you can create other arc shapes,
 * such as half-circles.
 *
 * @method Phaser.GameObjects.GameObjectFactory#arc
 * @since 3.13.0
 *
 * @param {number} [x=0] - The horizontal position of this Game Object in the world.
 * @param {number} [y=0] - The vertical position of this Game Object in the world.
 * @param {number} [radius=128] - The radius of the arc.
 * @param {integer} [startAngle=0] - The start angle of the arc, in degrees.
 * @param {integer} [endAngle=360] - The end angle of the arc, in degrees.
 * @param {boolean} [anticlockwise=false] - The winding order of the start and end angles.
 * @param {number} [fillColor] - The color the arc will be filled with, i.e. 0xff0000 for red.
 * @param {number} [fillAlpha] - The alpha the arc will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
 *
 * @return {Phaser.GameObjects.Arc} The Game Object that was created.
 */n.register("arc",function(t,e,n,s,r,o,a,h){return this.displayList.add(new i(this.scene,t,e,n,s,r,o,a,h))}),/**
 * Creates a new Circle Shape Game Object and adds it to the Scene.
 * 
 * A Circle is an Arc with no defined start and end angle, making it render as a complete circle.
 *
 * Note: This method will only be available if the Arc Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#circle
 * @since 3.13.0
 *
 * @param {number} [x=0] - The horizontal position of this Game Object in the world.
 * @param {number} [y=0] - The vertical position of this Game Object in the world.
 * @param {number} [radius=128] - The radius of the circle.
 * @param {number} [fillColor] - The color the circle will be filled with, i.e. 0xff0000 for red.
 * @param {number} [fillAlpha] - The alpha the circle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
 *
 * @return {Phaser.GameObjects.Arc} The Game Object that was created.
 */n.register("circle",function(t,e,n,s,r){return this.displayList.add(new i(this.scene,t,e,n,0,360,!1,s,r))})}),r("kVr0M",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("20vs1");/**
 * Creates a new Curve Shape Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Curve Game Object has been built into Phaser.
 * 
 * The Curve Shape is a Game Object that can be added to a Scene, Group or Container. You can
 * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
 * it for input or physics. It provides a quick and easy way for you to render this shape in your
 * game without using a texture, while still taking advantage of being fully batched in WebGL.
 * 
 * This shape supports both fill and stroke colors.
 * 
 * To render a Curve Shape you must first create a `Phaser.Curves.Curve` object, then pass it to
 * the Curve Shape in the constructor.
 * 
 * The Curve shape also has a `smoothness` property and corresponding `setSmoothness` method.
 * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations
 * that take place during construction. Increase and decrease the default value for smoother, or more
 * jagged, shapes.
 *
 * @method Phaser.GameObjects.GameObjectFactory#curve
 * @since 3.13.0
 *
 * @param {number} [x=0] - The horizontal position of this Game Object in the world.
 * @param {number} [y=0] - The vertical position of this Game Object in the world.
 * @param {Phaser.Curves.Curve} [curve] - The Curve object to use to create the Shape.
 * @param {number} [fillColor] - The color the curve will be filled with, i.e. 0xff0000 for red.
 * @param {number} [fillAlpha] - The alpha the curve will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
 *
 * @return {Phaser.GameObjects.Curve} The Game Object that was created.
 */i.register("curve",function(t,e,i,s,r){return this.displayList.add(new n(this.scene,t,e,i,s,r))})}),r("1f8NL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("i1Pn1");/**
 * Creates a new Ellipse Shape Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Ellipse Game Object has been built into Phaser.
 * 
 * The Ellipse Shape is a Game Object that can be added to a Scene, Group or Container. You can
 * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
 * it for input or physics. It provides a quick and easy way for you to render this shape in your
 * game without using a texture, while still taking advantage of being fully batched in WebGL.
 * 
 * This shape supports both fill and stroke colors.
 * 
 * When it renders it displays an ellipse shape. You can control the width and height of the ellipse.
 * If the width and height match it will render as a circle. If the width is less than the height,
 * it will look more like an egg shape.
 * 
 * The Ellipse shape also has a `smoothness` property and corresponding `setSmoothness` method.
 * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations
 * that take place during construction. Increase and decrease the default value for smoother, or more
 * jagged, shapes.
 *
 * @method Phaser.GameObjects.GameObjectFactory#ellipse
 * @since 3.13.0
 *
 * @param {number} [x=0] - The horizontal position of this Game Object in the world.
 * @param {number} [y=0] - The vertical position of this Game Object in the world.
 * @param {number} [width=128] - The width of the ellipse. An ellipse with equal width and height renders as a circle.
 * @param {number} [height=128] - The height of the ellipse. An ellipse with equal width and height renders as a circle.
 * @param {number} [fillColor] - The color the ellipse will be filled with, i.e. 0xff0000 for red.
 * @param {number} [fillAlpha] - The alpha the ellipse will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
 *
 * @return {Phaser.GameObjects.Ellipse} The Game Object that was created.
 */s("kge7H").register("ellipse",function(t,e,n,s,r,o){return this.displayList.add(new i(this.scene,t,e,n,s,r,o))})}),r("kJGm5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("3qA3v");/**
 * Creates a new Grid Shape Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Grid Game Object has been built into Phaser.
 * 
 * The Grid Shape is a Game Object that can be added to a Scene, Group or Container. You can
 * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
 * it for input or physics. It provides a quick and easy way for you to render this shape in your
 * game without using a texture, while still taking advantage of being fully batched in WebGL.
 * 
 * This shape supports only fill colors and cannot be stroked.
 * 
 * A Grid Shape allows you to display a grid in your game, where you can control the size of the
 * grid as well as the width and height of the grid cells. You can set a fill color for each grid
 * cell as well as an alternate fill color. When the alternate fill color is set then the grid
 * cells will alternate the fill colors as they render, creating a chess-board effect. You can
 * also optionally have an outline fill color. If set, this draws lines between the grid cells
 * in the given color. If you specify an outline color with an alpha of zero, then it will draw
 * the cells spaced out, but without the lines between them.
 *
 * @method Phaser.GameObjects.GameObjectFactory#grid
 * @since 3.13.0
 *
 * @param {number} [x=0] - The horizontal position of this Game Object in the world.
 * @param {number} [y=0] - The vertical position of this Game Object in the world.
 * @param {number} [width=128] - The width of the grid.
 * @param {number} [height=128] - The height of the grid.
 * @param {number} [cellWidth=32] - The width of one cell in the grid.
 * @param {number} [cellHeight=32] - The height of one cell in the grid.
 * @param {number} [fillColor] - The color the grid cells will be filled with, i.e. 0xff0000 for red.
 * @param {number} [fillAlpha] - The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
 * @param {number} [outlineFillColor] - The color of the lines between the grid cells.
 * @param {number} [outlineFillAlpha] - The alpha of the lines between the grid cells.
 *
 * @return {Phaser.GameObjects.Grid} The Game Object that was created.
 */i.register("grid",function(t,e,i,s,r,o,a,h,l,u){return this.displayList.add(new n(this.scene,t,e,i,s,r,o,a,h,l,u))})}),r("4MiAm",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("ibqbn");/**
 * Creates a new IsoBox Shape Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the IsoBox Game Object has been built into Phaser.
 * 
 * The IsoBox Shape is a Game Object that can be added to a Scene, Group or Container. You can
 * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
 * it for input or physics. It provides a quick and easy way for you to render this shape in your
 * game without using a texture, while still taking advantage of being fully batched in WebGL.
 * 
 * This shape supports only fill colors and cannot be stroked.
 * 
 * An IsoBox is an 'isometric' rectangle. Each face of it has a different fill color. You can set
 * the color of the top, left and right faces of the rectangle respectively. You can also choose
 * which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.
 * 
 * You cannot view an IsoBox from under-neath, however you can change the 'angle' by setting
 * the `projection` property.
 *
 * @method Phaser.GameObjects.GameObjectFactory#isobox
 * @since 3.13.0
 *
 * @param {number} [x=0] - The horizontal position of this Game Object in the world.
 * @param {number} [y=0] - The vertical position of this Game Object in the world.
 * @param {number} [size=48] - The width of the iso box in pixels. The left and right faces will be exactly half this value.
 * @param {number} [height=32] - The height of the iso box. The left and right faces will be this tall. The overall height of the isobox will be this value plus half the `size` value.
 * @param {number} [fillTop=0xeeeeee] - The fill color of the top face of the iso box.
 * @param {number} [fillLeft=0x999999] - The fill color of the left face of the iso box.
 * @param {number} [fillRight=0xcccccc] - The fill color of the right face of the iso box.
 *
 * @return {Phaser.GameObjects.IsoBox} The Game Object that was created.
 */i.register("isobox",function(t,e,i,s,r,o,a){return this.displayList.add(new n(this.scene,t,e,i,s,r,o,a))})}),r("5wABL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("e1XH0");/**
 * Creates a new IsoTriangle Shape Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the IsoTriangle Game Object has been built into Phaser.
 * 
 * The IsoTriangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
 * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
 * it for input or physics. It provides a quick and easy way for you to render this shape in your
 * game without using a texture, while still taking advantage of being fully batched in WebGL.
 * 
 * This shape supports only fill colors and cannot be stroked.
 * 
 * An IsoTriangle is an 'isometric' triangle. Think of it like a pyramid. Each face has a different
 * fill color. You can set the color of the top, left and right faces of the triangle respectively
 * You can also choose which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.
 * 
 * You cannot view an IsoTriangle from under-neath, however you can change the 'angle' by setting
 * the `projection` property. The `reversed` property controls if the IsoTriangle is rendered upside
 * down or not.
 *
 * @method Phaser.GameObjects.GameObjectFactory#isotriangle
 * @since 3.13.0
 *
 * @param {number} [x=0] - The horizontal position of this Game Object in the world.
 * @param {number} [y=0] - The vertical position of this Game Object in the world.
 * @param {number} [size=48] - The width of the iso triangle in pixels. The left and right faces will be exactly half this value.
 * @param {number} [height=32] - The height of the iso triangle. The left and right faces will be this tall. The overall height of the iso triangle will be this value plus half the `size` value.
 * @param {boolean} [reversed=false] - Is the iso triangle upside down?
 * @param {number} [fillTop=0xeeeeee] - The fill color of the top face of the iso triangle.
 * @param {number} [fillLeft=0x999999] - The fill color of the left face of the iso triangle.
 * @param {number} [fillRight=0xcccccc] - The fill color of the right face of the iso triangle.
 *
 * @return {Phaser.GameObjects.IsoTriangle} The Game Object that was created.
 */i.register("isotriangle",function(t,e,i,s,r,o,a,h){return this.displayList.add(new n(this.scene,t,e,i,s,r,o,a,h))})}),r("jyuVH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("cW0dL");/**
 * Creates a new Line Shape Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Line Game Object has been built into Phaser.
 * 
 * The Line Shape is a Game Object that can be added to a Scene, Group or Container. You can
 * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
 * it for input or physics. It provides a quick and easy way for you to render this shape in your
 * game without using a texture, while still taking advantage of being fully batched in WebGL.
 * 
 * This shape supports only stroke colors and cannot be filled.
 * 
 * A Line Shape allows you to draw a line between two points in your game. You can control the
 * stroke color and thickness of the line. In WebGL only you can also specify a different
 * thickness for the start and end of the line, allowing you to render lines that taper-off.
 * 
 * If you need to draw multiple lines in a sequence you may wish to use the Polygon Shape instead.
 *
 * @method Phaser.GameObjects.GameObjectFactory#line
 * @since 3.13.0
 *
 * @param {number} [x=0] - The horizontal position of this Game Object in the world.
 * @param {number} [y=0] - The vertical position of this Game Object in the world.
 * @param {number} [x1=0] - The horizontal position of the start of the line.
 * @param {number} [y1=0] - The vertical position of the start of the line.
 * @param {number} [x2=128] - The horizontal position of the end of the line.
 * @param {number} [y2=0] - The vertical position of the end of the line.
 * @param {number} [strokeColor] - The color the line will be drawn in, i.e. 0xff0000 for red.
 * @param {number} [strokeAlpha] - The alpha the line will be drawn in. You can also set the alpha of the overall Shape using its `alpha` property.
 *
 * @return {Phaser.GameObjects.Line} The Game Object that was created.
 */i.register("line",function(t,e,i,s,r,o,a,h){return this.displayList.add(new n(this.scene,t,e,i,s,r,o,a,h))})}),r("1dcev",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("4HMPS");/**
 * Creates a new Polygon Shape Game Object and adds it to the Scene.
 * 
 * Note: This method will only be available if the Polygon Game Object has been built into Phaser.
 * 
 * The Polygon Shape is a Game Object that can be added to a Scene, Group or Container. You can
 * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
 * it for input or physics. It provides a quick and easy way for you to render this shape in your
 * game without using a texture, while still taking advantage of being fully batched in WebGL.
 * 
 * This shape supports both fill and stroke colors.
 * 
 * The Polygon Shape is created by providing a list of points, which are then used to create an
 * internal Polygon geometry object. The points can be set from a variety of formats:
 *
 * - An array of Point or Vector2 objects: `[new Phaser.Math.Vector2(x1, y1), ...]`
 * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
 * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
 * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
 * 
 * By default the `x` and `y` coordinates of this Shape refer to the center of it. However, depending
 * on the coordinates of the points provided, the final shape may be rendered offset from its origin.
 *
 * @method Phaser.GameObjects.GameObjectFactory#polygon
 * @since 3.13.0
 *
 * @param {number} [x=0] - The horizontal position of this Game Object in the world.
 * @param {number} [y=0] - The vertical position of this Game Object in the world.
 * @param {any} [points] - The points that make up the polygon.
 * @param {number} [fillColor] - The color the polygon will be filled with, i.e. 0xff0000 for red.
 * @param {number} [fillAlpha] - The alpha the polygon will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
 *
 * @return {Phaser.GameObjects.Polygon} The Game Object that was created.
 */i.register("polygon",function(t,e,i,s,r){return this.displayList.add(new n(this.scene,t,e,i,s,r))})}),r("9pPj8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("gGVmO");/**
 * Creates a new Rectangle Shape Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Rectangle Game Object has been built into Phaser.
 * 
 * The Rectangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
 * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
 * it for input or physics. It provides a quick and easy way for you to render this shape in your
 * game without using a texture, while still taking advantage of being fully batched in WebGL.
 * 
 * This shape supports both fill and stroke colors.
 * 
 * You can change the size of the rectangle by changing the `width` and `height` properties.
 *
 * @method Phaser.GameObjects.GameObjectFactory#rectangle
 * @since 3.13.0
 *
 * @param {number} [x=0] - The horizontal position of this Game Object in the world.
 * @param {number} [y=0] - The vertical position of this Game Object in the world.
 * @param {number} [width=128] - The width of the rectangle.
 * @param {number} [height=128] - The height of the rectangle.
 * @param {number} [fillColor] - The color the rectangle will be filled with, i.e. 0xff0000 for red.
 * @param {number} [fillAlpha] - The alpha the rectangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
 *
 * @return {Phaser.GameObjects.Rectangle} The Game Object that was created.
 */i.register("rectangle",function(t,e,i,s,r,o){return this.displayList.add(new n(this.scene,t,e,i,s,r,o))})}),r("7gJso",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("lemMU");/**
 * Creates a new Star Shape Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Star Game Object has been built into Phaser.
 * 
 * The Star Shape is a Game Object that can be added to a Scene, Group or Container. You can
 * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
 * it for input or physics. It provides a quick and easy way for you to render this shape in your
 * game without using a texture, while still taking advantage of being fully batched in WebGL.
 * 
 * This shape supports both fill and stroke colors.
 * 
 * As the name implies, the Star shape will display a star in your game. You can control several
 * aspects of it including the number of points that constitute the star. The default is 5. If
 * you change it to 4 it will render as a diamond. If you increase them, you'll get a more spiky
 * star shape.
 * 
 * You can also control the inner and outer radius, which is how 'long' each point of the star is.
 * Modify these values to create more interesting shapes.
 *
 * @method Phaser.GameObjects.GameObjectFactory#star
 * @since 3.13.0
 *
 * @param {number} [x=0] - The horizontal position of this Game Object in the world.
 * @param {number} [y=0] - The vertical position of this Game Object in the world.
 * @param {number} [points=5] - The number of points on the star.
 * @param {number} [innerRadius=32] - The inner radius of the star.
 * @param {number} [outerRadius=64] - The outer radius of the star.
 * @param {number} [fillColor] - The color the star will be filled with, i.e. 0xff0000 for red.
 * @param {number} [fillAlpha] - The alpha the star will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
 *
 * @return {Phaser.GameObjects.Star} The Game Object that was created.
 */s("kge7H").register("star",function(t,e,n,s,r,o,a){return this.displayList.add(new i(this.scene,t,e,n,s,r,o,a))})}),r("dhc8H",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("b6DRH");/**
 * Creates a new Triangle Shape Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Triangle Game Object has been built into Phaser.
 * 
 * The Triangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
 * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
 * it for input or physics. It provides a quick and easy way for you to render this shape in your
 * game without using a texture, while still taking advantage of being fully batched in WebGL.
 * 
 * This shape supports both fill and stroke colors.
 * 
 * The Triangle consists of 3 lines, joining up to form a triangular shape. You can control the
 * position of each point of these lines. The triangle is always closed and cannot have an open
 * face. If you require that, consider using a Polygon instead.
 *
 * @method Phaser.GameObjects.GameObjectFactory#triangle
 * @since 3.13.0
 *
 * @param {number} [x=0] - The horizontal position of this Game Object in the world.
 * @param {number} [y=0] - The vertical position of this Game Object in the world.
 * @param {number} [x1=0] - The horizontal position of the first point in the triangle.
 * @param {number} [y1=128] - The vertical position of the first point in the triangle.
 * @param {number} [x2=64] - The horizontal position of the second point in the triangle.
 * @param {number} [y2=0] - The vertical position of the second point in the triangle.
 * @param {number} [x3=128] - The horizontal position of the third point in the triangle.
 * @param {number} [y3=128] - The vertical position of the third point in the triangle.
 * @param {number} [fillColor] - The color the triangle will be filled with, i.e. 0xff0000 for red.
 * @param {number} [fillAlpha] - The alpha the triangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
 *
 * @return {Phaser.GameObjects.Triangle} The Game Object that was created.
 */i.register("triangle",function(t,e,i,s,r,o,a,h,l,u){return this.displayList.add(new n(this.scene,t,e,i,s,r,o,a,h,l,u))})}),r("hS4bP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2cD2D"),n=s("i9cSP"),r=s("ebQQp"),o=s("cSaNN");/**
 * Creates a new Blitter Game Object and returns it.
 *
 * Note: This method will only be available if the Blitter Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#blitter
 * @since 3.0.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Blitter} The Game Object that was created.
 */r.register("blitter",function(t,e){void 0===t&&(t={});var s=o(t,"key",null),r=o(t,"frame",null),a=new i(this.scene,0,0,s,r);return void 0!==e&&(t.add=e),n(this.scene,a,t),a});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("azfIw",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("i9cSP"),n=s("ixgBh"),r=s("ebQQp"),o=s("cSaNN");/**
 * Creates a new Container Game Object and returns it.
 *
 * Note: This method will only be available if the Container Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#container
 * @since 3.4.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Container} The Game Object that was created.
 */r.register("container",function(t,e){void 0===t&&(t={});var s=o(t,"x",0),r=o(t,"y",0),a=new n(this.scene,s,r);return void 0!==e&&(t.add=e),i(this.scene,a,t),a})}),r("aQ5a3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5soSO"),n=s("i9cSP"),r=s("ebQQp"),o=s("cSaNN");/**
 * Creates a new Dynamic Bitmap Text Game Object and returns it.
 *
 * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#dynamicBitmapText
 * @since 3.0.0
 *
 * @param {Phaser.Types.GameObjects.BitmapText.BitmapTextConfig} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.DynamicBitmapText} The Game Object that was created.
 */r.register("dynamicBitmapText",function(t,e){void 0===t&&(t={});var s=o(t,"font",""),r=o(t,"text",""),a=o(t,"size",!1),h=new i(this.scene,0,0,s,r,a);return void 0!==e&&(t.add=e),n(this.scene,h,t),h});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("aSOvl",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ebQQp"),n=s("2Irqj");/**
 * Creates a new Graphics Game Object and returns it.
 *
 * Note: This method will only be available if the Graphics Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#graphics
 * @since 3.0.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Graphics} The Game Object that was created.
 */i.register("graphics",function(t,e){void 0===t&&(t={}),void 0!==e&&(t.add=e);var i=new n(this.scene,t);return t.add&&this.scene.sys.displayList.add(i),i});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("kteFs",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ebQQp"),n=s("hDBsd");/**
 * Creates a new Group Game Object and returns it.
 *
 * Note: This method will only be available if the Group Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#group
 * @since 3.0.0
 *
 * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} config - The configuration object this Game Object will use to create itself.
 *
 * @return {Phaser.GameObjects.Group} The Game Object that was created.
 */i.register("group",function(t){return new n(this.scene,null,t)});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("978g9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("i9cSP"),n=s("ebQQp"),r=s("cSaNN"),o=s("8qGvv");/**
 * Creates a new Image Game Object and returns it.
 *
 * Note: This method will only be available if the Image Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#image
 * @since 3.0.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Image} The Game Object that was created.
 */n.register("image",function(t,e){void 0===t&&(t={});var n=r(t,"key",null),s=r(t,"frame",null),a=new o(this.scene,0,0,n,s);return void 0!==e&&(t.add=e),i(this.scene,a,t),a});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("k6UHi",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ebQQp"),n=s("cSaNN"),r=s("7BSWl"),o=s("fnOwf");/**
 * Creates a new Particle Emitter Manager Game Object and returns it.
 *
 * Note: This method will only be available if the Particles Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#particles
 * @since 3.0.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} The Game Object that was created.
 */i.register("particles",function(t,e){void 0===t&&(t={});var i=n(t,"key",null),s=n(t,"frame",null),a=r(t,"emitters",null),h=new o(this.scene,i,s,a);return void 0!==e&&(t.add=e),r(t,"add",!1)&&this.displayList.add(h),this.updateList.add(h),h})}),r("fc299",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("i9cSP"),n=s("ebQQp"),r=s("cSaNN"),o=s("iCX4n");/**
 * Creates a new Render Texture Game Object and returns it.
 *
 * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#renderTexture
 * @since 3.2.0
 *
 * @param {Phaser.Types.GameObjects.RenderTexture.RenderTextureConfig} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.RenderTexture} The Game Object that was created.
 */n.register("renderTexture",function(t,e){void 0===t&&(t={});var n=r(t,"x",0),s=r(t,"y",0),a=r(t,"width",32),h=r(t,"height",32),l=r(t,"key",void 0),u=r(t,"frame",void 0),c=new o(this.scene,n,s,a,h,l,u);return void 0!==e&&(t.add=e),i(this.scene,c,t),c})}),r("6pbqo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("i9cSP"),n=s("ebQQp"),r=s("cSaNN"),o=s("5pMDk"),a=s("4dBPv");/**
 * Creates a new Rope Game Object and returns it.
 *
 * Note: This method will only be available if the Rope Game Object and WebGL support have been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#rope
 * @since 3.23.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Rope} The Game Object that was created.
 */n.register("rope",function(t,e){void 0===t&&(t={});var n=r(t,"key",null),s=r(t,"frame",null),h=r(t,"horizontal",!0),l=o(t,"points",void 0),u=o(t,"colors",void 0),c=o(t,"alphas",void 0),d=new a(this.scene,0,0,n,s,l,h,u,c);return void 0!==e&&(t.add=e),i(this.scene,d,t),d});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("jEuMc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("i9cSP"),n=s("cDuAM"),r=s("ebQQp"),o=s("cSaNN"),a=s("gXuc8");/**
 * Creates a new Sprite Game Object and returns it.
 *
 * Note: This method will only be available if the Sprite Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#sprite
 * @since 3.0.0
 *
 * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Sprite} The Game Object that was created.
 */r.register("sprite",function(t,e){void 0===t&&(t={});var s=o(t,"key",null),r=o(t,"frame",null),h=new a(this.scene,0,0,s,r);return void 0!==e&&(t.add=e),i(this.scene,h,t),//  Sprite specific config options:
n(h,t),h})}),r("k8onx",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gvPR8"),n=s("i9cSP"),r=s("ebQQp"),o=s("cSaNN"),a=s("5pMDk");/**
 * Creates a new Bitmap Text Game Object and returns it.
 *
 * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#bitmapText
 * @since 3.0.0
 *
 * @param {Phaser.Types.GameObjects.BitmapText.BitmapTextConfig} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 * 
 * @return {Phaser.GameObjects.BitmapText} The Game Object that was created.
 */r.register("bitmapText",function(t,e){void 0===t&&(t={});var s=a(t,"font",""),r=o(t,"text",""),h=o(t,"size",!1),l=a(t,"align",0),u=new i(this.scene,0,0,s,r,h,l);return void 0!==e&&(t.add=e),n(this.scene,u,t),u});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("ejLtj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("i9cSP"),n=s("ebQQp"),r=s("cSaNN"),o=s("1jO0s");/**
 * Creates a new Text Game Object and returns it.
 *
 * Note: This method will only be available if the Text Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#text
 * @since 3.0.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Text} The Game Object that was created.
 */n.register("text",function(t,e){void 0===t&&(t={});// style Object = {
//     font: [ 'font', '16px Courier' ],
//     backgroundColor: [ 'backgroundColor', null ],
//     fill: [ 'fill', '#fff' ],
//     stroke: [ 'stroke', '#fff' ],
//     strokeThickness: [ 'strokeThickness', 0 ],
//     shadowOffsetX: [ 'shadow.offsetX', 0 ],
//     shadowOffsetY: [ 'shadow.offsetY', 0 ],
//     shadowColor: [ 'shadow.color', '#000' ],
//     shadowBlur: [ 'shadow.blur', 0 ],
//     shadowStroke: [ 'shadow.stroke', false ],
//     shadowFill: [ 'shadow.fill', false ],
//     align: [ 'align', 'left' ],
//     maxLines: [ 'maxLines', 0 ],
//     fixedWidth: [ 'fixedWidth', false ],
//     fixedHeight: [ 'fixedHeight', false ],
//     rtl: [ 'rtl', false ]
// }
var n=r(t,"text",""),s=r(t,"style",null),a=r(t,"padding",null);null!==a&&(s.padding=a);var h=new o(this.scene,0,0,n,s);return void 0!==e&&(t.add=e),i(this.scene,h,t),//  Text specific config options:
h.autoRound=r(t,"autoRound",!0),h.resolution=r(t,"resolution",1),h});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("4wQ0d",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("i9cSP"),n=s("ebQQp"),r=s("cSaNN"),o=s("kwyUq");/**
 * Creates a new TileSprite Game Object and returns it.
 *
 * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#tileSprite
 * @since 3.0.0
 *
 * @param {Phaser.Types.GameObjects.TileSprite.TileSpriteConfig} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.TileSprite} The Game Object that was created.
 */n.register("tileSprite",function(t,e){void 0===t&&(t={});var n=r(t,"x",0),s=r(t,"y",0),a=r(t,"width",512),h=r(t,"height",512),l=r(t,"key",""),u=r(t,"frame",""),c=new o(this.scene,n,s,a,h,l,u);return void 0!==e&&(t.add=e),i(this.scene,c,t),c})}),r("1Uncu",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ebQQp"),n=s("cSaNN"),r=s("dZGDG");/**
 * Creates a new Zone Game Object and returns it.
 *
 * Note: This method will only be available if the Zone Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#zone
 * @since 3.0.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 *
 * @return {Phaser.GameObjects.Zone} The Game Object that was created.
 */i.register("zone",function(t){var e=n(t,"x",0),i=n(t,"y",0),s=n(t,"width",1),o=n(t,"height",s);return new r(this.scene,e,i,s,o)});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("3HD58",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("i9cSP"),n=s("ebQQp"),r=s("cSaNN"),o=s("Cfqdl");/**
 * Creates a new Video Game Object and returns it.
 *
 * Note: This method will only be available if the Video Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#video
 * @since 3.20.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Video} The Game Object that was created.
 */n.register("video",function(t,e){void 0===t&&(t={});var n=r(t,"key",null),s=new o(this.scene,0,0,n);return void 0!==e&&(t.add=e),i(this.scene,s,t),s});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("3JO7H",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("1zqlR"),o=s("9Vhyt"),a=s("13GYA"),h=new i({Extends:r,Mixins:[n.BlendMode,n.Depth,n.Mask,n.Pipeline,n.Size,n.Texture,n.Transform,n.Visible,n.ScrollFactor,o],initialize:function(t,e,i,n,s,o,a,h,l){if(r.call(this,t,"Mesh"),n.length!==s.length)throw Error("Mesh Vertex count must match UV count");var u,c=n.length/2|0;if(o.length>0&&o.length<c)throw Error("Mesh Color count must match Vertex count");if(a.length>0&&a.length<c)throw Error("Mesh Alpha count must match Vertex count");if(0===o.length)for(u=0;u<c;++u)o[u]=16777215;if(0===a.length)for(u=0;u<c;++u)a[u]=1;/**
         * An array containing the vertices data for this Mesh.
         *
         * @name Phaser.GameObjects.Mesh#vertices
         * @type {Float32Array}
         * @since 3.0.0
         */this.vertices=new Float32Array(n),/**
         * An array containing the uv data for this Mesh.
         *
         * @name Phaser.GameObjects.Mesh#uv
         * @type {Float32Array}
         * @since 3.0.0
         */this.uv=new Float32Array(s),/**
         * An array containing the color data for this Mesh.
         *
         * @name Phaser.GameObjects.Mesh#colors
         * @type {Uint32Array}
         * @since 3.0.0
         */this.colors=new Uint32Array(o),/**
         * An array containing the alpha data for this Mesh.
         *
         * @name Phaser.GameObjects.Mesh#alphas
         * @type {Float32Array}
         * @since 3.0.0
         */this.alphas=new Float32Array(a),/**
         * Fill or additive mode used when blending the color values?
         * 
         * @name Phaser.GameObjects.Mesh#tintFill
         * @type {boolean}
         * @default false
         * @since 3.11.0
         */this.tintFill=!1,this.setTexture(h,l),this.setPosition(e,i),this.setSizeToFrame(),this.initPipeline()},/**
     * This method is left intentionally empty and does not do anything.
     * It is retained to allow a Mesh or Quad to be added to a Container.
     * 
     * @method Phaser.GameObjects.Mesh#setAlpha
     * @since 3.17.0
     */setAlpha:a});t.exports=h}),r("9Vhyt",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("ksO5X"),r=s("8CzV0"),t.exports={renderWebGL:n,renderCanvas:r}}),r("ksO5X",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s,r){var o=this.pipeline;t.setPipeline(o,e);var a=o._tempMatrix1,h=o._tempMatrix2,l=o._tempMatrix3;h.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),a.copyFrom(s.matrix),r?(//  Multiply the camera by the parent matrix
a.multiplyWithOffset(r,-s.scrollX*e.scrollFactorX,-s.scrollY*e.scrollFactorY),//  Undo the camera scroll
h.e=e.x,h.f=e.y):(h.e-=s.scrollX*e.scrollFactorX,h.f-=s.scrollY*e.scrollFactorY),//  Multiply by the Sprite matrix, store result in calcMatrix
a.multiply(h,l);var u=e.frame.glTexture,c=e.vertices,d=e.uv,f=e.colors,p=e.alphas,g=c.length,v=Math.floor(.5*g);o.vertexCount+v>o.vertexCapacity&&o.flush(),o.setTexture2D(u,0);for(var m=o.vertexViewF32,y=o.vertexViewU32,x=o.vertexCount*o.vertexComponentCount-1,w=0,T=e.tintFill,b=0;b<g;b+=2){var S=c[b+0],A=c[b+1],E=S*l.a+A*l.c+l.e,_=S*l.b+A*l.d+l.f;s.roundPixels&&(E=Math.round(E),_=Math.round(_)),m[++x]=E,m[++x]=_,m[++x]=d[b+0],m[++x]=d[b+1],m[++x]=T,y[++x]=i.getTintAppendFloatAlpha(f[w],s.alpha*p[w]),w++}o.vertexCount+=v}}),r("8CzV0",function(t,e){t.exports=function(){}}),r("frkgB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("3JO7H"),r=new i({Extends:n,initialize:function(t,e,i,s,r){n.call(this,t,e,i,[0,0,0,0,0,0,0,0,0,0,0,0// tr
],[0,0,0,1,1,1,0,0,1,1,1,0// tr
],[16777215,16777215,16777215,16777215,16777215,16777215// tr
],[1,1,1,1,1,1// tr
],s,r),this.resetPosition()},/**
     * Sets the frame this Game Object will use to render with.
     *
     * The Frame has to belong to the current Texture being used.
     *
     * It can be either a string or an index.
     *
     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
     *
     * @method Phaser.GameObjects.Quad#setFrame
     * @since 3.11.0
     *
     * @param {(string|integer)} frame - The name or index of the frame within the Texture.
     *
     * @return {this} This Game Object instance.
     */setFrame:function(t){return this.frame=this.texture.get(t),this.frame.cutWidth&&this.frame.cutHeight?this.renderFlags|=8:this.renderFlags&=-9,t=this.frame,//   TL
this.uv[0]=t.u0,this.uv[1]=t.v0,//   BL
this.uv[2]=t.u0,this.uv[3]=t.v1,//   BR
this.uv[4]=t.u1,this.uv[5]=t.v1,//   TL
this.uv[6]=t.u0,this.uv[7]=t.v0,//   BR
this.uv[8]=t.u1,this.uv[9]=t.v1,//   TR
this.uv[10]=t.u1,this.uv[11]=t.v0,this},/**
     * The top-left x vertex of this Quad.
     *
     * @name Phaser.GameObjects.Quad#topLeftX
     * @type {number}
     * @since 3.0.0
     */topLeftX:{get:function(){return this.x+this.vertices[0]},set:function(t){this.vertices[0]=t-this.x,this.vertices[6]=t-this.x}},/**
     * The top-left y vertex of this Quad.
     *
     * @name Phaser.GameObjects.Quad#topLeftY
     * @type {number}
     * @since 3.0.0
     */topLeftY:{get:function(){return this.y+this.vertices[1]},set:function(t){this.vertices[1]=t-this.y,this.vertices[7]=t-this.y}},/**
     * The top-right x vertex of this Quad.
     *
     * @name Phaser.GameObjects.Quad#topRightX
     * @type {number}
     * @since 3.0.0
     */topRightX:{get:function(){return this.x+this.vertices[10]},set:function(t){this.vertices[10]=t-this.x}},/**
     * The top-right y vertex of this Quad.
     *
     * @name Phaser.GameObjects.Quad#topRightY
     * @type {number}
     * @since 3.0.0
     */topRightY:{get:function(){return this.y+this.vertices[11]},set:function(t){this.vertices[11]=t-this.y}},/**
     * The bottom-left x vertex of this Quad.
     *
     * @name Phaser.GameObjects.Quad#bottomLeftX
     * @type {number}
     * @since 3.0.0
     */bottomLeftX:{get:function(){return this.x+this.vertices[2]},set:function(t){this.vertices[2]=t-this.x}},/**
     * The bottom-left y vertex of this Quad.
     *
     * @name Phaser.GameObjects.Quad#bottomLeftY
     * @type {number}
     * @since 3.0.0
     */bottomLeftY:{get:function(){return this.y+this.vertices[3]},set:function(t){this.vertices[3]=t-this.y}},/**
     * The bottom-right x vertex of this Quad.
     *
     * @name Phaser.GameObjects.Quad#bottomRightX
     * @type {number}
     * @since 3.0.0
     */bottomRightX:{get:function(){return this.x+this.vertices[4]},set:function(t){this.vertices[4]=t-this.x,this.vertices[8]=t-this.x}},/**
     * The bottom-right y vertex of this Quad.
     *
     * @name Phaser.GameObjects.Quad#bottomRightY
     * @type {number}
     * @since 3.0.0
     */bottomRightY:{get:function(){return this.y+this.vertices[5]},set:function(t){this.vertices[5]=t-this.y,this.vertices[9]=t-this.y}},/**
     * The top-left alpha value of this Quad.
     *
     * @name Phaser.GameObjects.Quad#topLeftAlpha
     * @type {number}
     * @since 3.0.0
     */topLeftAlpha:{get:function(){return this.alphas[0]},set:function(t){this.alphas[0]=t,this.alphas[3]=t}},/**
     * The top-right alpha value of this Quad.
     *
     * @name Phaser.GameObjects.Quad#topRightAlpha
     * @type {number}
     * @since 3.0.0
     */topRightAlpha:{get:function(){return this.alphas[5]},set:function(t){this.alphas[5]=t}},/**
     * The bottom-left alpha value of this Quad.
     *
     * @name Phaser.GameObjects.Quad#bottomLeftAlpha
     * @type {number}
     * @since 3.0.0
     */bottomLeftAlpha:{get:function(){return this.alphas[1]},set:function(t){this.alphas[1]=t}},/**
     * The bottom-right alpha value of this Quad.
     *
     * @name Phaser.GameObjects.Quad#bottomRightAlpha
     * @type {number}
     * @since 3.0.0
     */bottomRightAlpha:{get:function(){return this.alphas[2]},set:function(t){this.alphas[2]=t,this.alphas[4]=t}},/**
     * The top-left color value of this Quad.
     *
     * @name Phaser.GameObjects.Quad#topLeftColor
     * @type {number}
     * @since 3.0.0
     */topLeftColor:{get:function(){return this.colors[0]},set:function(t){this.colors[0]=t,this.colors[3]=t}},/**
     * The top-right color value of this Quad.
     *
     * @name Phaser.GameObjects.Quad#topRightColor
     * @type {number}
     * @since 3.0.0
     */topRightColor:{get:function(){return this.colors[5]},set:function(t){this.colors[5]=t}},/**
     * The bottom-left color value of this Quad.
     *
     * @name Phaser.GameObjects.Quad#bottomLeftColor
     * @type {number}
     * @since 3.0.0
     */bottomLeftColor:{get:function(){return this.colors[1]},set:function(t){this.colors[1]=t}},/**
     * The bottom-right color value of this Quad.
     *
     * @name Phaser.GameObjects.Quad#bottomRightColor
     * @type {number}
     * @since 3.0.0
     */bottomRightColor:{get:function(){return this.colors[2]},set:function(t){this.colors[2]=t,this.colors[4]=t}},/**
     * Sets the top-left vertex position of this Quad.
     *
     * @method Phaser.GameObjects.Quad#setTopLeft
     * @since 3.0.0
     *
     * @param {number} x - The horizontal coordinate of the vertex.
     * @param {number} y - The vertical coordinate of the vertex.
     *
     * @return {this} This Game Object.
     */setTopLeft:function(t,e){return this.topLeftX=t,this.topLeftY=e,this},/**
     * Sets the top-right vertex position of this Quad.
     *
     * @method Phaser.GameObjects.Quad#setTopRight
     * @since 3.0.0
     *
     * @param {number} x - The horizontal coordinate of the vertex.
     * @param {number} y - The vertical coordinate of the vertex.
     *
     * @return {this} This Game Object.
     */setTopRight:function(t,e){return this.topRightX=t,this.topRightY=e,this},/**
     * Sets the bottom-left vertex position of this Quad.
     *
     * @method Phaser.GameObjects.Quad#setBottomLeft
     * @since 3.0.0
     *
     * @param {number} x - The horizontal coordinate of the vertex.
     * @param {number} y - The vertical coordinate of the vertex.
     *
     * @return {this} This Game Object.
     */setBottomLeft:function(t,e){return this.bottomLeftX=t,this.bottomLeftY=e,this},/**
     * Sets the bottom-right vertex position of this Quad.
     *
     * @method Phaser.GameObjects.Quad#setBottomRight
     * @since 3.0.0
     *
     * @param {number} x - The horizontal coordinate of the vertex.
     * @param {number} y - The vertical coordinate of the vertex.
     *
     * @return {this} This Game Object.
     */setBottomRight:function(t,e){return this.bottomRightX=t,this.bottomRightY=e,this},/**
     * Resets the positions of the four corner vertices of this Quad.
     *
     * @method Phaser.GameObjects.Quad#resetPosition
     * @since 3.0.0
     *
     * @return {this} This Game Object.
     */resetPosition:function(){var t=this.x,e=this.y,i=Math.floor(this.width/2),n=Math.floor(this.height/2);return this.setTopLeft(t-i,e-n),this.setTopRight(t+i,e-n),this.setBottomLeft(t-i,e+n),this.setBottomRight(t+i,e+n),this},/**
     * Resets the alpha values used by this Quad back to 1.
     *
     * @method Phaser.GameObjects.Quad#resetAlpha
     * @since 3.0.0
     *
     * @return {this} This Game Object.
     */resetAlpha:function(){var t=this.alphas;return t[0]=1,t[1]=1,t[2]=1,t[3]=1,t[4]=1,t[5]=1,this},/**
     * Resets the color values used by this Quad back to 0xffffff.
     *
     * @method Phaser.GameObjects.Quad#resetColors
     * @since 3.0.0
     *
     * @return {this} This Game Object.
     */resetColors:function(){var t=this.colors;return t[0]=16777215,t[1]=16777215,t[2]=16777215,t[3]=16777215,t[4]=16777215,t[5]=16777215,this},/**
     * Resets the position, alpha and color values used by this Quad.
     *
     * @method Phaser.GameObjects.Quad#reset
     * @since 3.0.0
     *
     * @return {this} This Game Object.
     */reset:function(){return this.resetPosition(),this.resetAlpha(),this.resetColors()}});t.exports=r}),r("iwnS9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("1zqlR"),o=s("7BSWl"),a=s("hVk4C"),h=s("knQyO"),l=s("keUuz"),u=s("azs1m"),c=new i({Extends:r,Mixins:[n.ComputedSize,n.Depth,n.GetBounds,n.Mask,n.Origin,n.ScrollFactor,n.Transform,n.Visible,l],initialize:function(t,e,i,n,s,o,a,h){void 0===i&&(i=0),void 0===n&&(n=0),void 0===s&&(s=128),void 0===o&&(o=128),r.call(this,t,"Shader"),/**
         * This Game Object cannot have a blend mode, so skip all checks.
         * 
         * @name Phaser.GameObjects.Shader#blendMode
         * @type {integer}
         * @private
         * @since 3.17.0
         */this.blendMode=-1,/**
         * The underlying shader object being used.
         * Empty by default and set during a call to the `setShader` method.
         * 
         * @name Phaser.GameObjects.Shader#shader
         * @type {Phaser.Display.BaseShader}
         * @since 3.17.0
         */this.shader;var l=t.sys.renderer;/**
         * A reference to the current renderer.
         * Shaders only work with the WebGL Renderer.
         * 
         * @name Phaser.GameObjects.Shader#renderer
         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}
         * @since 3.17.0
         */this.renderer=l,/**
         * The WebGL context belonging to the renderer.
         *
         * @name Phaser.GameObjects.Shader#gl
         * @type {WebGLRenderingContext}
         * @since 3.17.0
         */this.gl=l.gl,/**
         * Raw byte buffer of vertices this Shader uses.
         *
         * @name Phaser.GameObjects.Shader#vertexData
         * @type {ArrayBuffer}
         * @since 3.17.0
         */this.vertexData=new ArrayBuffer(6*(2*Float32Array.BYTES_PER_ELEMENT)),/**
         * The WebGL vertex buffer object this shader uses.
         *
         * @name Phaser.GameObjects.Shader#vertexBuffer
         * @type {WebGLBuffer}
         * @since 3.17.0
         */this.vertexBuffer=l.createVertexBuffer(this.vertexData.byteLength,this.gl.STREAM_DRAW),/**
         * The WebGL shader program this shader uses.
         *
         * @name Phaser.GameObjects.Shader#program
         * @type {WebGLProgram}
         * @since 3.17.0
         */this.program=null,/**
         * Uint8 view to the vertex raw buffer. Used for uploading vertex buffer resources to the GPU.
         *
         * @name Phaser.GameObjects.Shader#bytes
         * @type {Uint8Array}
         * @since 3.17.0
         */this.bytes=new Uint8Array(this.vertexData),/**
         * Float32 view of the array buffer containing the shaders vertices.
         *
         * @name Phaser.GameObjects.Shader#vertexViewF32
         * @type {Float32Array}
         * @since 3.17.0
         */this.vertexViewF32=new Float32Array(this.vertexData),/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.GameObjects.Shader#_tempMatrix1
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.17.0
         */this._tempMatrix1=new u,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.GameObjects.Shader#_tempMatrix2
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.17.0
         */this._tempMatrix2=new u,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.GameObjects.Shader#_tempMatrix3
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.17.0
         */this._tempMatrix3=new u,/**
         * The view matrix the shader uses during rendering.
         * 
         * @name Phaser.GameObjects.Shader#viewMatrix
         * @type {Float32Array}
         * @readonly
         * @since 3.17.0
         */this.viewMatrix=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),/**
         * The projection matrix the shader uses during rendering.
         * 
         * @name Phaser.GameObjects.Shader#projectionMatrix
         * @type {Float32Array}
         * @readonly
         * @since 3.17.0
         */this.projectionMatrix=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),/**
         * The default uniform mappings. These can be added to (or replaced) by specifying your own uniforms when
         * creating this shader game object. The uniforms are updated automatically during the render step.
         * 
         * The defaults are:
         * 
         * `resolution` (2f) - Set to the size of this shader.
         * `time` (1f) - The elapsed game time, in seconds.
         * `mouse` (2f) - If a pointer has been bound (with `setPointer`), this uniform contains its position each frame.
         * `date` (4fv) - A vec4 containing the year, month, day and time in seconds.
         * `sampleRate` (1f) - Sound sample rate. 44100 by default.
         * `iChannel0...3` (sampler2D) - Input channels 0 to 3. `null` by default.
         * 
         * @name Phaser.GameObjects.Shader#uniforms
         * @type {any}
         * @since 3.17.0
         */this.uniforms={},/**
         * The pointer bound to this shader, if any.
         * Set via the chainable `setPointer` method, or by modifying this property directly.
         * 
         * @name Phaser.GameObjects.Shader#pointer
         * @type {Phaser.Input.Pointer}
         * @since 3.17.0
         */this.pointer=null,/**
         * The cached width of the renderer.
         * 
         * @name Phaser.GameObjects.Shader#_rendererWidth
         * @type {number}
         * @private
         * @since 3.17.0
         */this._rendererWidth=l.width,/**
         * The cached height of the renderer.
         * 
         * @name Phaser.GameObjects.Shader#_rendererHeight
         * @type {number}
         * @private
         * @since 3.17.0
         */this._rendererHeight=l.height,/**
         * Internal texture count tracker.
         * 
         * @name Phaser.GameObjects.Shader#_textureCount
         * @type {number}
         * @private
         * @since 3.17.0
         */this._textureCount=0,/**
         * A reference to the GL Frame Buffer this Shader is drawing to.
         * This property is only set if you have called `Shader.setRenderToTexture`.
         *
         * @name Phaser.GameObjects.Shader#framebuffer
         * @type {?WebGLFramebuffer}
         * @since 3.19.0
         */this.framebuffer=null,/**
         * A reference to the WebGLTexture this Shader is rendering to.
         * This property is only set if you have called `Shader.setRenderToTexture`.
         *
         * @name Phaser.GameObjects.Shader#glTexture
         * @type {?WebGLTexture}
         * @since 3.19.0
         */this.glTexture=null,/**
         * A flag that indicates if this Shader has been set to render to a texture instead of the display list.
         * 
         * This property is `true` if you have called `Shader.setRenderToTexture`, otherwise it's `false`.
         * 
         * A Shader that is rendering to a texture _does not_ appear on the display list.
         *
         * @name Phaser.GameObjects.Shader#renderToTexture
         * @type {boolean}
         * @readonly
         * @since 3.19.0
         */this.renderToTexture=!1,/**
         * A reference to the Phaser.Textures.Texture that has been stored in the Texture Manager for this Shader.
         * 
         * This property is only set if you have called `Shader.setRenderToTexture`, otherwise it is `null`.
         *
         * @name Phaser.GameObjects.Shader#texture
         * @type {Phaser.Textures.Texture}
         * @since 3.19.0
         */this.texture=null,this.setPosition(i,n),this.setSize(s,o),this.setOrigin(.5,.5),this.setShader(e,a,h)},/**
     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.
     * Also checks the Game Object against the given Cameras exclusion list.
     *
     * @method Phaser.GameObjects.Shader#willRender
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.
     *
     * @return {boolean} True if the Game Object should be rendered, otherwise false.
     */willRender:function(t){return!!this.renderToTexture||!(r.RENDER_MASK!==this.renderFlags||0!==this.cameraFilter&&this.cameraFilter&t.id)},/**
     * Changes this Shader so instead of rendering to the display list it renders to a
     * WebGL Framebuffer and WebGL Texture instead. This allows you to use the output
     * of this shader as an input for another shader, by mapping a sampler2D uniform
     * to it.
     * 
     * After calling this method the `Shader.framebuffer` and `Shader.glTexture` properties
     * are populated.
     * 
     * Additionally, you can provide a key to this method. Doing so will create a Phaser Texture
     * from this Shader and save it into the Texture Manager, allowing you to then use it for
     * any texture-based Game Object, such as a Sprite or Image:
     * 
     * ```javascript
     * var shader = this.add.shader('myShader', x, y, width, height);
     * 
     * shader.setRenderToTexture('doodle');
     * 
     * this.add.image(400, 300, 'doodle');
     * ```
     * 
     * Note that it stores an active reference to this Shader. That means as this shader updates,
     * so does the texture and any object using it to render with. Also, if you destroy this
     * shader, be sure to clear any objects that may have been using it as a texture too.
     * 
     * You can access the Phaser Texture that is created via the `Shader.texture` property.
     * 
     * By default it will create a single base texture. You can add frames to the texture
     * by using the `Texture.add` method. After doing this, you can then allow Game Objects
     * to use a specific frame from a Render Texture.
     *
     * @method Phaser.GameObjects.Shader#setRenderToTexture
     * @since 3.19.0
     *
     * @param {string} [key] - The unique key to store the texture as within the global Texture Manager.
     * @param {boolean} [flipY=false] - Does this texture need vertically flipping before rendering? This should usually be set to `true` if being fed from a buffer.
     *
     * @return {this} This Shader instance.
     */setRenderToTexture:function(t,e){if(void 0===e&&(e=!1),!this.renderToTexture){var i=this.width,n=this.height,s=this.renderer;this.glTexture=s.createTextureFromSource(null,i,n,0),this.glTexture.flipY=e,this.framebuffer=s.createFramebuffer(i,n,this.glTexture,!1),this._rendererWidth=i,this._rendererHeight=n,this.renderToTexture=!0,this.projOrtho(0,this.width,this.height,0),t&&(this.texture=this.scene.sys.textures.addGLTexture(t,this.glTexture,i,n))}//  And now render at least once, so our texture isn't blank on the first update
if(this.shader){var r=s.currentPipeline;s.clearPipeline(),this.load(),this.flush(),s.rebindPipeline(r)}return this},/**
     * Sets the fragment and, optionally, the vertex shader source code that this Shader will use.
     * This will immediately delete the active shader program, if set, and then create a new one
     * with the given source. Finally, the shader uniforms are initialized.
     *
     * @method Phaser.GameObjects.Shader#setShader
     * @since 3.17.0
     * 
     * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.
     * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.
     * @param {any} [textureData] - Additional texture data.
     * 
     * @return {this} This Shader instance.
     */setShader:function(t,e,i){if(void 0===e&&(e=[]),"string"==typeof t){var n=this.scene.sys.cache.shader;if(!n.has(t))return console.warn("Shader missing: "+t),this;this.shader=n.get(t)}else this.shader=t;var s=this.gl,r=this.renderer;this.program&&s.deleteProgram(this.program);var o=r.createProgram(this.shader.vertexSrc,this.shader.fragmentSrc);//  The default uniforms available within the vertex shader
r.setMatrix4(o,"uViewMatrix",!1,this.viewMatrix),r.setMatrix4(o,"uProjectionMatrix",!1,this.projectionMatrix),r.setFloat2(o,"uResolution",this.width,this.height),this.program=o;var h=new Date,l={resolution:{type:"2f",value:{x:this.width,y:this.height}},time:{type:"1f",value:0},mouse:{type:"2f",value:{x:this.width/2,y:this.height/2}},date:{type:"4fv",value:[h.getFullYear(),h.getMonth(),h.getDate(),3600*h.getHours()+60*h.getMinutes()+h.getSeconds()]},sampleRate:{type:"1f",value:44100},iChannel0:{type:"sampler2D",value:null,textureData:{repeat:!0}},iChannel1:{type:"sampler2D",value:null,textureData:{repeat:!0}},iChannel2:{type:"sampler2D",value:null,textureData:{repeat:!0}},iChannel3:{type:"sampler2D",value:null,textureData:{repeat:!0}}};this.shader.uniforms?this.uniforms=a(!0,{},this.shader.uniforms,l):this.uniforms=l;for(var u=0;u<4;u++)e[u]&&this.setSampler2D("iChannel"+u,e[u],u,i);return this.initUniforms(),this.projOrtho(0,this._rendererWidth,this._rendererHeight,0),this},/**
     * Binds a Phaser Pointer object to this Shader.
     * 
     * The screen position of the pointer will be set in to the shaders `mouse` uniform
     * automatically every frame. Call this method with no arguments to unbind the pointer.
     *
     * @method Phaser.GameObjects.Shader#setPointer
     * @since 3.17.0
     * 
     * @param {Phaser.Input.Pointer} [pointer] - The Pointer to bind to this shader.
     * 
     * @return {this} This Shader instance.
     */setPointer:function(t){return this.pointer=t,this},/**
     * Sets this shader to use an orthographic projection matrix.
     * This matrix is stored locally in the `projectionMatrix` property,
     * as well as being bound to the `uProjectionMatrix` uniform.
     * 
     * @method Phaser.GameObjects.Shader#projOrtho
     * @since 3.17.0
     *
     * @param {number} left - The left value.
     * @param {number} right - The right value.
     * @param {number} bottom - The bottom value.
     * @param {number} top - The top value.
     */projOrtho:function(t,e,i,n){var s=1/(t-e),r=1/(i-n),o=this.projectionMatrix;o[0]=-2*s,o[5]=-2*r,o[10]=-.001,o[12]=(t+e)*s,o[13]=(n+i)*r,o[14]=-0;var a=this.program;this.renderer.setMatrix4(a,"uProjectionMatrix",!1,this.projectionMatrix),this._rendererWidth=e,this._rendererHeight=i},// Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/
// http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf
/**
     * Initializes all of the uniforms this shader uses.
     * 
     * @method Phaser.GameObjects.Shader#initUniforms
     * @private
     * @since 3.17.0
     */initUniforms:function(){var t=this.gl,e=this.renderer.glFuncMap,i=this.program;for(var n in this._textureCount=0,this.uniforms){var s=this.uniforms[n],r=s.type,o=e[r];s.uniformLocation=t.getUniformLocation(i,n),"sampler2D"!==r&&(s.glMatrix=o.matrix,s.glValueLength=o.length,s.glFunc=o.func)}},/**
     * Sets a sampler2D uniform on this shader where the source texture is a WebGLTexture.
     * 
     * This allows you to feed the output from one Shader into another:
     * 
     * ```javascript
     * let shader1 = this.add.shader(baseShader1, 0, 0, 512, 512).setRenderToTexture();
     * let shader2 = this.add.shader(baseShader2, 0, 0, 512, 512).setRenderToTexture('output');
     * 
     * shader1.setSampler2DBuffer('iChannel0', shader2.glTexture, 512, 512);
     * shader2.setSampler2DBuffer('iChannel0', shader1.glTexture, 512, 512);
     * ```
     * 
     * In the above code, the result of baseShader1 is fed into Shader2 as the `iChannel0` sampler2D uniform.
     * The result of baseShader2 is then fed back into shader1 again, creating a feedback loop.
     * 
     * If you wish to use an image from the Texture Manager as a sampler2D input for this shader,
     * see the `Shader.setSampler2D` method.
     * 
     * @method Phaser.GameObjects.Shader#setSampler2DBuffer
     * @since 3.19.0
     * 
     * @param {string} uniformKey - The key of the sampler2D uniform to be updated, i.e. `iChannel0`.
     * @param {WebGLTexture} texture - A WebGLTexture reference.
     * @param {integer} width - The width of the texture.
     * @param {integer} height - The height of the texture.
     * @param {integer} [textureIndex=0] - The texture index.
     * @param {any} [textureData] - Additional texture data.
     * 
     * @return {this} This Shader instance.
     */setSampler2DBuffer:function(t,e,i,n,s,r){void 0===s&&(s=0),void 0===r&&(r={});var o=this.uniforms[t];return o.value=e,r.width=i,r.height=n,o.textureData=r,this._textureCount=s,this.initSampler2D(o),this},/**
     * Sets a sampler2D uniform on this shader.
     * 
     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame
     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.
     * 
     * If you wish to use another Shader as a sampler2D input for this shader, see the `Shader.setSampler2DBuffer` method.
     * 
     * @method Phaser.GameObjects.Shader#setSampler2D
     * @since 3.17.0
     * 
     * @param {string} uniformKey - The key of the sampler2D uniform to be updated, i.e. `iChannel0`.
     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.
     * @param {integer} [textureIndex=0] - The texture index.
     * @param {any} [textureData] - Additional texture data.
     * 
     * @return {this} This Shader instance.
     */setSampler2D:function(t,e,i,n){void 0===i&&(i=0);var s=this.scene.sys.textures;if(s.exists(e)){var r=s.getFrame(e),o=this.uniforms[t],a=r.source;o.textureKey=e,o.source=a.image,o.value=r.glTexture,a.isGLTexture&&(n||(n={}),n.width=a.width,n.height=a.height),n&&(o.textureData=n),this._textureCount=i,this.initSampler2D(o)}return this},/**
     * Sets a property of a uniform already present on this shader.
     * 
     * To modify the value of a uniform such as a 1f or 1i use the `value` property directly:
     * 
     * ```javascript
     * shader.setUniform('size.value', 16);
     * ```
     * 
     * You can use dot notation to access deeper values, for example:
     * 
     * ```javascript
     * shader.setUniform('resolution.value.x', 512);
     * ```
     * 
     * The change to the uniform will take effect the next time the shader is rendered.
     * 
     * @method Phaser.GameObjects.Shader#setUniform
     * @since 3.17.0
     * 
     * @param {string} key - The key of the uniform to modify. Use dots for deep properties, i.e. `resolution.value.x`.
     * @param {any} value - The value to set into the uniform.
     * 
     * @return {this} This Shader instance.
     */setUniform:function(t,e){return h(this.uniforms,t,e),this},/**
     * Returns the uniform object for the given key, or `null` if the uniform couldn't be found.
     * 
     * @method Phaser.GameObjects.Shader#getUniform
     * @since 3.17.0
     * 
     * @param {string} key - The key of the uniform to return the value for.
     * 
     * @return {any} A reference to the uniform object. This is not a copy, so modifying it will update the original object also.
     */getUniform:function(t){return o(this.uniforms,t,null)},/**
     * A short-cut method that will directly set the texture being used by the `iChannel0` sampler2D uniform.
     * 
     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame
     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.
     * 
     * @method Phaser.GameObjects.Shader#setChannel0
     * @since 3.17.0
     * 
     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.
     * @param {any} [textureData] - Additional texture data.
     * 
     * @return {this} This Shader instance.
     */setChannel0:function(t,e){return this.setSampler2D("iChannel0",t,0,e)},/**
     * A short-cut method that will directly set the texture being used by the `iChannel1` sampler2D uniform.
     * 
     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame
     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.
     * 
     * @method Phaser.GameObjects.Shader#setChannel1
     * @since 3.17.0
     * 
     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.
     * @param {any} [textureData] - Additional texture data.
     * 
     * @return {this} This Shader instance.
     */setChannel1:function(t,e){return this.setSampler2D("iChannel1",t,1,e)},/**
     * A short-cut method that will directly set the texture being used by the `iChannel2` sampler2D uniform.
     * 
     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame
     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.
     * 
     * @method Phaser.GameObjects.Shader#setChannel2
     * @since 3.17.0
     * 
     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.
     * @param {any} [textureData] - Additional texture data.
     * 
     * @return {this} This Shader instance.
     */setChannel2:function(t,e){return this.setSampler2D("iChannel2",t,2,e)},/**
     * A short-cut method that will directly set the texture being used by the `iChannel3` sampler2D uniform.
     * 
     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame
     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.
     * 
     * @method Phaser.GameObjects.Shader#setChannel3
     * @since 3.17.0
     * 
     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.
     * @param {any} [textureData] - Additional texture data.
     * 
     * @return {this} This Shader instance.
     */setChannel3:function(t,e){return this.setSampler2D("iChannel3",t,3,e)},/**
     * Internal method that takes a sampler2D uniform and prepares it for use by setting the
     * gl texture parameters.
     * 
     * @method Phaser.GameObjects.Shader#initSampler2D
     * @private
     * @since 3.17.0
     * 
     * @param {any} uniform - The sampler2D uniform to process.
     */initSampler2D:function(t){if(t.value){var e=this.gl;e.activeTexture(e.TEXTURE0+this._textureCount),e.bindTexture(e.TEXTURE_2D,t.value);//  Extended texture data
var i=t.textureData;if(i){// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
//  mag / minFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST
//  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT
//  format can be: gl.LUMINANCE or gl.RGBA
var n=e[o(i,"magFilter","linear").toUpperCase()],s=e[o(i,"minFilter","linear").toUpperCase()],r=e[o(i,"wrapS","repeat").toUpperCase()],a=e[o(i,"wrapT","repeat").toUpperCase()],h=e[o(i,"format","rgba").toUpperCase()];if(i.repeat&&(r=e.REPEAT,a=e.REPEAT),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!!i.flipY),i.width){var l=o(i,"width",512),u=o(i,"height",2),c=o(i,"border",0);//  texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels)
e.texImage2D(e.TEXTURE_2D,0,h,l,u,c,h,e.UNSIGNED_BYTE,null)}else e.texImage2D(e.TEXTURE_2D,0,h,e.RGBA,e.UNSIGNED_BYTE,t.source);e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,n),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,s),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,r),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,a)}this.renderer.setProgram(this.program),e.uniform1i(t.uniformLocation,this._textureCount),this._textureCount++}},/**
     * Synchronizes all of the uniforms this shader uses.
     * Each uniforms gl function is called in turn.
     * 
     * @method Phaser.GameObjects.Shader#syncUniforms
     * @private
     * @since 3.17.0
     */syncUniforms:function(){var t,e,i,n,s,r=this.gl,o=this.uniforms,a=0;for(var h in o)i=(t=o[h]).glFunc,e=t.glValueLength,n=t.uniformLocation,null!==(s=t.value)&&(1===e?t.glMatrix?i.call(r,n,t.transpose,s):i.call(r,n,s):2===e?i.call(r,n,s.x,s.y):3===e?i.call(r,n,s.x,s.y,s.z):4===e?i.call(r,n,s.x,s.y,s.z,s.w):"sampler2D"===t.type&&(r.activeTexture(r["TEXTURE"+a]),r.bindTexture(r.TEXTURE_2D,s),r.uniform1i(n,a),a++))},/**
     * Called automatically during render.
     * 
     * This method performs matrix ITRS and then stores the resulting value in the `uViewMatrix` uniform.
     * It then sets up the vertex buffer and shader, updates and syncs the uniforms ready
     * for flush to be called.
     * 
     * @method Phaser.GameObjects.Shader#load
     * @since 3.17.0
     * 
     * @param {Phaser.GameObjects.Components.TransformMatrix} [matrix2D] - The transform matrix to use during rendering.
     */load:function(t){//  ITRS
var e=this.gl,i=this.width,n=this.height,s=this.renderer,r=this.program,o=this.viewMatrix;if(!this.renderToTexture){var a=-this._displayOriginX,h=-this._displayOriginY;o[0]=t[0],o[1]=t[1],o[4]=t[2],o[5]=t[3],o[8]=t[4],o[9]=t[5],o[12]=o[0]*a+o[4]*h,o[13]=o[1]*a+o[5]*h}//  Update vertex shader uniforms
e.useProgram(r),e.uniformMatrix4fv(e.getUniformLocation(r,"uViewMatrix"),!1,o),e.uniform2f(e.getUniformLocation(r,"uResolution"),this.width,this.height);//  Update fragment shader uniforms
var l=this.uniforms,u=l.resolution;u.value.x=i,u.value.y=n,l.time.value=s.game.loop.getDuration();var c=this.pointer;if(c){var d=l.mouse,f=c.x/i,p=1-c.y/n;d.value.x=f.toFixed(2),d.value.y=p.toFixed(2)}this.syncUniforms()},/**
     * Called automatically during render.
     * 
     * Sets the active shader, loads the vertex buffer and then draws.
     * 
     * @method Phaser.GameObjects.Shader#flush
     * @since 3.17.0
     */flush:function(){//  Bind
var t=this.width,e=this.height,i=this.program,n=this.gl,s=this.vertexBuffer,r=this.renderer,o=2*Float32Array.BYTES_PER_ELEMENT;this.renderToTexture&&(r.setFramebuffer(this.framebuffer),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT)),n.bindBuffer(n.ARRAY_BUFFER,s);var a=n.getAttribLocation(i,"inPosition");-1!==a&&(n.enableVertexAttribArray(a),n.vertexAttribPointer(a,2,n.FLOAT,!1,o,0));//  Draw
var h=this.vertexViewF32;h[3]=e,h[4]=t,h[5]=e,h[8]=t,h[9]=e,h[10]=t,n.bufferSubData(n.ARRAY_BUFFER,0,this.bytes.subarray(0,6*o)),n.drawArrays(n.TRIANGLES,0,6),this.renderToTexture&&r.setFramebuffer(null,!1)},/**
     * A NOOP method so you can pass a Shader to a Container.
     * Calling this method will do nothing. It is intentionally empty.
     *
     * @method Phaser.GameObjects.Shader#setAlpha
     * @private
     * @since 3.17.0
     */setAlpha:function(){},/**
     * A NOOP method so you can pass a Shader to a Container.
     * Calling this method will do nothing. It is intentionally empty.
     *
     * @method Phaser.GameObjects.Shader#setBlendMode
     * @private
     * @since 3.17.0
     */setBlendMode:function(){},/**
     * Internal destroy handler, called as part of the destroy process.
     *
     * @method Phaser.GameObjects.Shader#preDestroy
     * @protected
     * @since 3.17.0
     */preDestroy:function(){var t=this.gl;t.deleteProgram(this.program),t.deleteBuffer(this.vertexBuffer),this.renderToTexture&&(this.renderer.deleteFramebuffer(this.framebuffer),this.texture.destroy(),this.framebuffer=null,this.glTexture=null,this.texture=null)}});t.exports=c}),r("knQyO",function(t,e){t.exports=function(t,e,i){if(t&&"number"!=typeof t){if(t.hasOwnProperty(e))return t[e]=i,!0;if(-1!==e.indexOf(".")){//  Use for loop here so we can break early
for(var n=e.split("."),s=t,r=t,o=0;o<n.length;o++){if(!s.hasOwnProperty(n[o]))return!1;//  Yes it has a key property, let's carry on down
r=s,s=s[n[o]]}return r[n[n.length-1]]=i,!0}}return!1}}),r("keUuz",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("b9kgy"),r=s("8D69K"),t.exports={renderWebGL:n,renderCanvas:r}}),r("b9kgy",function(t,e){t.exports=function(t,e,i,n,s){if(e.shader){var r=t.currentPipeline;if(t.clearPipeline(),e.renderToTexture)e.load(),e.flush();else{var o=e._tempMatrix1,a=e._tempMatrix2,h=e._tempMatrix3;a.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),o.copyFrom(n.matrix),s?(//  Multiply the camera by the parent matrix
o.multiplyWithOffset(s,-n.scrollX*e.scrollFactorX,-n.scrollY*e.scrollFactorY),//  Undo the camera scroll
a.e=e.x,a.f=e.y):(a.e-=n.scrollX*e.scrollFactorX,a.f-=n.scrollY*e.scrollFactorY),o.multiply(a,h),(t.width!==e._rendererWidth||t.height!==e._rendererHeight)&&e.projOrtho(0,t.width,t.height,0),e.load(h.matrix),e.flush()}t.rebindPipeline(r)}}}),r("8D69K",function(t,e){t.exports=function(){}}),r("ek47i",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("3JO7H");s("kge7H").register("mesh",function(t,e,n,s,r,o,a,h){return this.displayList.add(new i(this.scene,t,e,n,s,r,o,a,h))});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("5sQTt",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("frkgB");s("kge7H").register("quad",function(t,e,n,s){return this.displayList.add(new i(this.scene,t,e,n,s))});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("imx1M",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iwnS9");s("kge7H").register("shader",function(t,e,n,s,r,o,a){return this.displayList.add(new i(this.scene,t,e,n,s,r,o,a))})}),r("3VQSR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("i9cSP"),n=s("ebQQp"),r=s("cSaNN"),o=s("5pMDk"),a=s("3JO7H");/**
 * Creates a new Mesh Game Object and returns it.
 *
 * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#mesh
 * @since 3.0.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Mesh} The Game Object that was created.
 */n.register("mesh",function(t,e){void 0===t&&(t={});var n=r(t,"key",null),s=r(t,"frame",null),h=o(t,"vertices",[]),l=o(t,"colors",[]),u=o(t,"alphas",[]),c=o(t,"uv",[]),d=new a(this.scene,0,0,h,c,l,u,n,s);return void 0!==e&&(t.add=e),i(this.scene,d,t),d});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("aW7lj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("i9cSP"),n=s("ebQQp"),r=s("cSaNN"),o=s("frkgB");/**
 * Creates a new Quad Game Object and returns it.
 *
 * Note: This method will only be available if the Quad Game Object and WebGL support have been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#quad
 * @since 3.0.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Quad} The Game Object that was created.
 */n.register("quad",function(t,e){void 0===t&&(t={});var n=r(t,"x",0),s=r(t,"y",0),a=r(t,"key",null),h=r(t,"frame",null),l=new o(this.scene,n,s,a,h);return void 0!==e&&(t.add=e),i(this.scene,l,t),l})}),r("7bRuL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("i9cSP"),n=s("ebQQp"),r=s("cSaNN"),o=s("iwnS9");/**
 * Creates a new Shader Game Object and returns it.
 *
 * Note: This method will only be available if the Shader Game Object and WebGL support have been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#shader
 * @since 3.17.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Shader} The Game Object that was created.
 */n.register("shader",function(t,e){void 0===t&&(t={});var n=r(t,"key",null),s=r(t,"x",0),a=r(t,"y",0),h=r(t,"width",128),l=r(t,"height",128),u=new o(this.scene,n,s,a,h,l);return void 0!==e&&(t.add=e),i(this.scene,u,t),u});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("hDwlH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("gaO4e"),r=new i({initialize:function(t,e,i,n,s,r,o){/**
         * The horizontal position of the light.
         *
         * @name Phaser.GameObjects.Light#x
         * @type {number}
         * @since 3.0.0
         */this.x=t,/**
         * The vertical position of the light.
         *
         * @name Phaser.GameObjects.Light#y
         * @type {number}
         * @since 3.0.0
         */this.y=e,/**
         * The radius of the light.
         *
         * @name Phaser.GameObjects.Light#radius
         * @type {number}
         * @since 3.0.0
         */this.radius=i,/**
         * The red color of the light. A value between 0 and 1.
         *
         * @name Phaser.GameObjects.Light#r
         * @type {number}
         * @since 3.0.0
         */this.r=n,/**
         * The green color of the light. A value between 0 and 1.
         *
         * @name Phaser.GameObjects.Light#g
         * @type {number}
         * @since 3.0.0
         */this.g=s,/**
         * The blue color of the light. A value between 0 and 1.
         *
         * @name Phaser.GameObjects.Light#b
         * @type {number}
         * @since 3.0.0
         */this.b=r,/**
         * The intensity of the light.
         *
         * @name Phaser.GameObjects.Light#intensity
         * @type {number}
         * @since 3.0.0
         */this.intensity=o,/**
         * The horizontal scroll factor of the light.
         *
         * @name Phaser.GameObjects.Light#scrollFactorX
         * @type {number}
         * @since 3.0.0
         */this.scrollFactorX=1,/**
         * The vertical scroll factor of the light.
         *
         * @name Phaser.GameObjects.Light#scrollFactorY
         * @type {number}
         * @since 3.0.0
         */this.scrollFactorY=1},/**
     * Set the properties of the light.
     *
     * Sets both horizontal and vertical scroll factor to 1. Use {@link Phaser.GameObjects.Light#setScrollFactor} to set
     * the scroll factor.
     *
     * @method Phaser.GameObjects.Light#set
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of the light.
     * @param {number} y - The vertical position of the light.
     * @param {number} radius - The radius of the light.
     * @param {number} r - The red color. A value between 0 and 1.
     * @param {number} g - The green color. A value between 0 and 1.
     * @param {number} b - The blue color. A value between 0 and 1.
     * @param {number} intensity - The intensity of the light.
     *
     * @return {this} This Light object.
     */set:function(t,e,i,n,s,r,o){return this.x=t,this.y=e,this.radius=i,this.r=n,this.g=s,this.b=r,this.intensity=o,this.scrollFactorX=1,this.scrollFactorY=1,this},/**
     * Set the scroll factor of the light.
     *
     * @method Phaser.GameObjects.Light#setScrollFactor
     * @since 3.0.0
     *
     * @param {number} x - The horizontal scroll factor of the light.
     * @param {number} y - The vertical scroll factor of the light.
     *
     * @return {this} This Light object.
     */setScrollFactor:function(t,e){return void 0===t&&(t=1),void 0===e&&(e=t),this.scrollFactorX=t,this.scrollFactorY=e,this},/**
     * Set the color of the light from a single integer RGB value.
     *
     * @method Phaser.GameObjects.Light#setColor
     * @since 3.0.0
     *
     * @param {number} rgb - The integer RGB color of the light.
     *
     * @return {this} This Light object.
     */setColor:function(t){var e=n.getFloatsFromUintRGB(t);return this.r=e[0],this.g=e[1],this.b=e[2],this},/**
     * Set the intensity of the light.
     *
     * @method Phaser.GameObjects.Light#setIntensity
     * @since 3.0.0
     *
     * @param {number} intensity - The intensity of the light.
     *
     * @return {this} This Light object.
     */setIntensity:function(t){return this.intensity=t,this},/**
     * Set the position of the light.
     *
     * @method Phaser.GameObjects.Light#setPosition
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of the light.
     * @param {number} y - The vertical position of the light.
     *
     * @return {this} This Light object.
     */setPosition:function(t,e){return this.x=t,this.y=e,this},/**
     * Set the radius of the light.
     *
     * @method Phaser.GameObjects.Light#setRadius
     * @since 3.0.0
     *
     * @param {number} radius - The radius of the light.
     *
     * @return {this} This Light object.
     */setRadius:function(t){return this.radius=t,this}});t.exports=r}),r("5eZQq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("hDwlH"),r=s("gaO4e"),o=new i({initialize:function(){/**
         * The pool of Lights.
         *
         * Used to recycle removed Lights for a more efficient use of memory.
         *
         * @name Phaser.GameObjects.LightsManager#lightPool
         * @type {Phaser.GameObjects.Light[]}
         * @default []
         * @since 3.0.0
         */this.lightPool=[],/**
         * The Lights in the Scene.
         *
         * @name Phaser.GameObjects.LightsManager#lights
         * @type {Phaser.GameObjects.Light[]}
         * @default []
         * @since 3.0.0
         */this.lights=[],/**
         * Lights that have been culled from a Camera's viewport.
         *
         * Lights in this list will not be rendered.
         *
         * @name Phaser.GameObjects.LightsManager#culledLights
         * @type {Phaser.GameObjects.Light[]}
         * @default []
         * @since 3.0.0
         */this.culledLights=[],/**
         * The ambient color.
         *
         * @name Phaser.GameObjects.LightsManager#ambientColor
         * @type {{ r: number, g: number, b: number }}
         * @since 3.0.0
         */this.ambientColor={r:.1,g:.1,b:.1},/**
         * Whether the Lights Manager is enabled.
         *
         * @name Phaser.GameObjects.LightsManager#active
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.active=!1,/**
         * The maximum number of lights that a single Camera and the lights shader can process.
         * Change this via the `maxLights` property in your game config, as it cannot be changed at runtime.
         *
         * @name Phaser.GameObjects.LightsManager#maxLights
         * @type {integer}
         * @readonly
         * @since 3.15.0
         */this.maxLights=-1},/**
     * Enable the Lights Manager.
     *
     * @method Phaser.GameObjects.LightsManager#enable
     * @since 3.0.0
     *
     * @return {Phaser.GameObjects.LightsManager} This Lights Manager object.
     */enable:function(){return -1===this.maxLights&&(this.maxLights=this.scene.sys.game.renderer.config.maxLights),this.active=!0,this},/**
     * Disable the Lights Manager.
     *
     * @method Phaser.GameObjects.LightsManager#disable
     * @since 3.0.0
     *
     * @return {Phaser.GameObjects.LightsManager} This Lights Manager object.
     */disable:function(){return this.active=!1,this},/**
     * Cull any Lights that aren't visible to the given Camera.
     *
     * Culling Lights improves performance by ensuring that only Lights within a Camera's viewport are rendered.
     *
     * @method Phaser.GameObjects.LightsManager#cull
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to cull Lights for.
     *
     * @return {Phaser.GameObjects.Light[]} The culled Lights.
     */cull:function(t){var e=this.lights,i=this.culledLights,n=e.length,s=t.x+t.width/2,r=t.y+t.height/2,o=(t.width+t.height)/2,a={x:0,y:0},h=t.matrix,l=this.systems.game.config.height;i.length=0;for(var u=0;u<n&&i.length<this.maxLights;u++){var c=e[u];h.transformPoint(c.x,c.y,a);//  We'll just use bounding spheres to test if lights should be rendered
var d=s-(a.x-t.scrollX*c.scrollFactorX*t.zoom),f=r-(l-(a.y-t.scrollY*c.scrollFactorY*t.zoom));Math.sqrt(d*d+f*f)<c.radius+o&&i.push(e[u])}return i},/**
     * Iterate over each Light with a callback.
     *
     * @method Phaser.GameObjects.LightsManager#forEachLight
     * @since 3.0.0
     *
     * @param {LightForEach} callback - The callback that is called with each Light.
     *
     * @return {Phaser.GameObjects.LightsManager} This Lights Manager object.
     */forEachLight:function(t){if(t){for(var e=this.lights,i=e.length,n=0;n<i;++n)t(e[n]);return this}},/**
     * Set the ambient light color.
     *
     * @method Phaser.GameObjects.LightsManager#setAmbientColor
     * @since 3.0.0
     *
     * @param {number} rgb - The integer RGB color of the ambient light.
     *
     * @return {Phaser.GameObjects.LightsManager} This Lights Manager object.
     */setAmbientColor:function(t){var e=r.getFloatsFromUintRGB(t);return this.ambientColor.r=e[0],this.ambientColor.g=e[1],this.ambientColor.b=e[2],this},/**
     * Returns the maximum number of Lights allowed to appear at once.
     *
     * @method Phaser.GameObjects.LightsManager#getMaxVisibleLights
     * @since 3.0.0
     *
     * @return {integer} The maximum number of Lights allowed to appear at once.
     */getMaxVisibleLights:function(){return 10},/**
     * Get the number of Lights managed by this Lights Manager.
     *
     * @method Phaser.GameObjects.LightsManager#getLightCount
     * @since 3.0.0
     *
     * @return {integer} The number of Lights managed by this Lights Manager.
     */getLightCount:function(){return this.lights.length},/**
     * Add a Light.
     *
     * @method Phaser.GameObjects.LightsManager#addLight
     * @since 3.0.0
     *
     * @param {number} [x=0] - The horizontal position of the Light.
     * @param {number} [y=0] - The vertical position of the Light.
     * @param {number} [radius=100] - The radius of the Light.
     * @param {number} [rgb=0xffffff] - The integer RGB color of the light.
     * @param {number} [intensity=1] - The intensity of the Light.
     *
     * @return {Phaser.GameObjects.Light} The Light that was added.
     */addLight:function(t,e,i,s,o){var a=null,h=null;return t=void 0===t?0:t,e=void 0===e?0:e,s=void 0===s?16777215:s,i=void 0===i?100:i,o=void 0===o?1:o,a=r.getFloatsFromUintRGB(s),h=null,this.lightPool.length>0?(h=this.lightPool.pop()).set(t,e,i,a[0],a[1],a[2],o):h=new n(t,e,i,a[0],a[1],a[2],o),this.lights.push(h),h},/**
     * Remove a Light.
     *
     * @method Phaser.GameObjects.LightsManager#removeLight
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Light} light - The Light to remove.
     *
     * @return {Phaser.GameObjects.LightsManager} This Lights Manager object.
     */removeLight:function(t){var e=this.lights.indexOf(t);return e>=0&&(this.lightPool.push(t),this.lights.splice(e,1)),this},/**
     * Shut down the Lights Manager.
     *
     * Recycles all active Lights into the Light pool, resets ambient light color and clears the lists of Lights and
     * culled Lights.
     *
     * @method Phaser.GameObjects.LightsManager#shutdown
     * @since 3.0.0
     */shutdown:function(){for(;this.lights.length>0;)this.lightPool.push(this.lights.pop());this.ambientColor={r:.1,g:.1,b:.1},this.culledLights.length=0,this.lights.length=0},/**
     * Destroy the Lights Manager.
     *
     * Cleans up all references by calling {@link Phaser.GameObjects.LightsManager#shutdown}.
     *
     * @method Phaser.GameObjects.LightsManager#destroy
     * @since 3.0.0
     */destroy:function(){this.shutdown()}});t.exports=o}),r("hsf2U",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("5eZQq"),r=s("7AzQW"),o=s("4rtgc"),a=new i({Extends:n,initialize:function(t){/**
         * A reference to the Scene that this Lights Plugin belongs to.
         *
         * @name Phaser.GameObjects.LightsPlugin#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * A reference to the Scene's systems.
         *
         * @name Phaser.GameObjects.LightsPlugin#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,t.sys.settings.isBooted||t.sys.events.once(o.BOOT,this.boot,this),n.call(this)},/**
     * Boot the Lights Plugin.
     *
     * @method Phaser.GameObjects.LightsPlugin#boot
     * @since 3.0.0
     */boot:function(){var t=this.systems.events;t.on(o.SHUTDOWN,this.shutdown,this),t.on(o.DESTROY,this.destroy,this)},/**
     * Destroy the Lights Plugin.
     *
     * Cleans up all references.
     *
     * @method Phaser.GameObjects.LightsPlugin#destroy
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.scene=void 0,this.systems=void 0}});r.register("LightsPlugin",a,"lights"),t.exports=a}),r("kNZrp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gZ2BZ"),n=s("hVk4C"),r={Circle:s("f9k62"),Ellipse:s("cjvaD"),Intersects:s("6Lcv1"),Line:s("3epuM"),Point:s("h9uwP"),Polygon:s("3l7hU"),Rectangle:s("baGGN"),Triangle:s("iq5jH")};//   Merge in the consts
r=n(!1,r,i),t.exports=r}),r("f9k62",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eQ4tZ");i.Area=s("lmCfe"),i.Circumference=s("c6ED3"),i.CircumferencePoint=s("67VV6"),i.Clone=s("21NIG"),i.Contains=s("6hp2k"),i.ContainsPoint=s("1u673"),i.ContainsRect=s("d0OkM"),i.CopyFrom=s("gHJsF"),i.Equals=s("2oHOK"),i.GetBounds=s("8Fcc7"),i.GetPoint=s("dM9Ux"),i.GetPoints=s("80QEd"),i.Offset=s("3Oelj"),i.OffsetPoint=s("4tz7B"),i.Random=s("9zIIl"),t.exports=i}),r("lmCfe",function(t,e){t.exports=function(t){return t.radius>0?Math.PI*t.radius*t.radius:0}}),r("21NIG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eQ4tZ");t.exports=function(t){return new i(t.x,t.y,t.radius)}}),r("1u673",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6hp2k");t.exports=function(t,e){return i(t,e.x,e.y)}}),r("d0OkM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6hp2k");t.exports=function(t,e){return i(t,e.x,e.y)&&i(t,e.right,e.y)&&i(t,e.x,e.bottom)&&i(t,e.right,e.bottom)}}),r("gHJsF",function(t,e){t.exports=function(t,e){return e.setTo(t.x,t.y,t.radius)}}),r("2oHOK",function(t,e){t.exports=function(t,e){return t.x===e.x&&t.y===e.y&&t.radius===e.radius}}),r("8Fcc7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cwr8X");t.exports=function(t,e){return void 0===e&&(e=new i),e.x=t.left,e.y=t.top,e.width=t.diameter,e.height=t.diameter,e}}),r("3Oelj",function(t,e){t.exports=function(t,e,i){return t.x+=e,t.y+=i,t}}),r("4tz7B",function(t,e){t.exports=function(t,e){return t.x+=e.x,t.y+=e.y,t}}),r("cjvaD",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eaZcG");i.Area=s("5yBlY"),i.Circumference=s("dmO0a"),i.CircumferencePoint=s("jKWrM"),i.Clone=s("8SVnL"),i.Contains=s("dsAkp"),i.ContainsPoint=s("jBtAg"),i.ContainsRect=s("7xdhG"),i.CopyFrom=s("7wu1B"),i.Equals=s("ihUzp"),i.GetBounds=s("4ltjE"),i.GetPoint=s("1vBT7"),i.GetPoints=s("61Yre"),i.Offset=s("kImVr"),i.OffsetPoint=s("3W0tJ"),i.Random=s("fH1i1"),t.exports=i}),r("5yBlY",function(t,e){t.exports=function(t){return t.isEmpty()?0:t.getMajorRadius()*t.getMinorRadius()*Math.PI}}),r("8SVnL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eaZcG");t.exports=function(t){return new i(t.x,t.y,t.width,t.height)}}),r("jBtAg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("dsAkp");t.exports=function(t,e){return i(t,e.x,e.y)}}),r("7xdhG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("dsAkp");t.exports=function(t,e){return i(t,e.x,e.y)&&i(t,e.right,e.y)&&i(t,e.x,e.bottom)&&i(t,e.right,e.bottom)}}),r("7wu1B",function(t,e){t.exports=function(t,e){return e.setTo(t.x,t.y,t.width,t.height)}}),r("ihUzp",function(t,e){t.exports=function(t,e){return t.x===e.x&&t.y===e.y&&t.width===e.width&&t.height===e.height}}),r("4ltjE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cwr8X");t.exports=function(t,e){return void 0===e&&(e=new i),e.x=t.left,e.y=t.top,e.width=t.width,e.height=t.height,e}}),r("kImVr",function(t,e){t.exports=function(t,e,i){return t.x+=e,t.y+=i,t}}),r("3W0tJ",function(t,e){t.exports=function(t,e){return t.x+=e.x,t.y+=e.y,t}}),r("6Lcv1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Geom.Intersects
 */t.exports={CircleToCircle:s("1GcYB"),CircleToRectangle:s("14KTi"),GetCircleToCircle:s("1Yyt0"),GetCircleToRectangle:s("l26EM"),GetLineToCircle:s("a9cbd"),GetLineToRectangle:s("jcLFP"),GetRectangleIntersection:s("arUwA"),GetRectangleToRectangle:s("fEZtW"),GetRectangleToTriangle:s("frm8a"),GetTriangleToCircle:s("c7MfJ"),GetTriangleToLine:s("gLM7X"),GetTriangleToTriangle:s("5ltcM"),LineToCircle:s("coG9m"),LineToLine:s("1B2Zx"),LineToRectangle:s("3ARyj"),PointToLine:s("94QvZ"),PointToLineSegment:s("eEky2"),RectangleToRectangle:s("dTOqt"),RectangleToTriangle:s("a5zoR"),RectangleToValues:s("2aBNx"),TriangleToCircle:s("lSVA4"),TriangleToLine:s("1EbtS"),TriangleToTriangle:s("2W0ce")}}),r("1GcYB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bwLQh");t.exports=function(t,e){return i(t.x,t.y,e.x,e.y)<=t.radius+e.radius}}),r("14KTi",function(t,e){t.exports=function(t,e){var i=e.width/2,n=e.height/2,s=Math.abs(t.x-e.x-i),r=Math.abs(t.y-e.y-n),o=i+t.radius,a=n+t.radius;if(s>o||r>a)return!1;if(s<=i||r<=n)return!0;var h=s-i,l=r-n;return h*h+l*l<=t.radius*t.radius}}),r("1Yyt0",function(t,e){/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9"),n=s("1GcYB");t.exports=function(t,e,s){if(void 0===s&&(s=[]),n(t,e)){var r,o,a,h,l=t.x,u=t.y,c=t.radius,d=e.x,f=e.y,p=e.radius;if(u===f)h=(p*p-c*c-d*d+l*l)/(2*(l-d)),r=1,0==(a=(o=-2*f)*o-4*r*(d*d+h*h-2*d*h+f*f-p*p))?s.push(new i(h,-o/(2*r))):a>0&&(s.push(new i(h,(-o+Math.sqrt(a))/(2*r))),s.push(new i(h,(-o-Math.sqrt(a))/(2*r))));else{var g=(l-d)/(u-f),v=(p*p-c*c-d*d+l*l-f*f+u*u)/(2*(u-f));r=g*g+1,0==(a=(o=2*u*g-2*v*g-2*l)*o-4*r*(l*l+u*u+v*v-c*c-2*u*v))?(h=-o/(2*r),s.push(new i(h,v-h*g))):a>0&&(h=(-o+Math.sqrt(a))/(2*r),s.push(new i(h,v-h*g)),h=(-o-Math.sqrt(a))/(2*r),s.push(new i(h,v-h*g)))}}return s}}),r("l26EM",function(t,e){/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("a9cbd"),n=s("14KTi");t.exports=function(t,e,s){if(void 0===s&&(s=[]),n(t,e)){var r=e.getLineA(),o=e.getLineB(),a=e.getLineC(),h=e.getLineD();i(r,t,s),i(o,t,s),i(a,t,s),i(h,t,s)}return s}}),r("a9cbd",function(t,e){/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9"),n=s("coG9m");t.exports=function(t,e,s){if(void 0===s&&(s=[]),n(t,e)){var r,o,a=t.x1,h=t.y1,l=t.x2,u=t.y2,c=e.x,d=e.y,f=e.radius,p=l-a,g=u-h,v=a-c,m=h-d,y=p*p+g*g,x=2*(p*v+g*m),w=x*x-4*y*(v*v+m*m-f*f);if(0===w){var T=-x/(2*y);r=a+T*p,o=h+T*g,T>=0&&T<=1&&s.push(new i(r,o))}else if(w>0){var b=(-x-Math.sqrt(w))/(2*y);r=a+b*p,o=h+b*g,b>=0&&b<=1&&s.push(new i(r,o));var S=(-x+Math.sqrt(w))/(2*y);r=a+S*p,o=h+S*g,S>=0&&S<=1&&s.push(new i(r,o))}}return s}}),r("coG9m",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6hp2k"),n=new(s("cSEB9"));t.exports=function(t,e,s){if(void 0===s&&(s=n),i(e,t.x1,t.y1))return s.x=t.x1,s.y=t.y1,!0;if(i(e,t.x2,t.y2))return s.x=t.x2,s.y=t.y2,!0;var r=t.x2-t.x1,o=t.y2-t.y1,a=e.x-t.x1,h=e.y-t.y1,l=r*r+o*o,u=r,c=o;if(l>0){var d=(a*r+h*o)/l;u*=d,c*=d}return s.x=t.x1+u,s.y=t.y1+c,u*u+c*c<=l&&u*r+c*o>=0&&i(e,s.x,s.y)}}),r("jcLFP",function(t,e){/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9"),n=s("1B2Zx"),r=s("3ARyj");t.exports=function(t,e,s){if(void 0===s&&(s=[]),r(t,e))for(var o=e.getLineA(),a=e.getLineB(),h=e.getLineC(),l=e.getLineD(),u=[new i,new i,new i,new i],c=[n(o,t,u[0]),n(a,t,u[1]),n(h,t,u[2]),n(l,t,u[3])],d=0;d<4;d++)c[d]&&s.push(u[d]);return s}}),r("1B2Zx",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e,n){void 0===n&&(n=new i);var s=t.x1,r=t.y1,o=t.x2,a=t.y2,h=e.x1,l=e.y1,u=e.x2,c=e.y2,d=(c-l)*(o-s)-(u-h)*(a-r);//  Make sure there is not a division by zero - this also indicates that the lines are parallel.
//  If numA and numB were both equal to zero the lines would be on top of each other (coincidental).
//  This check is not done because it is not necessary for this implementation (the parallel check accounts for this).
if(0===d)return!1;//  Calculate the intermediate fractional point that the lines potentially intersect.
var f=((u-h)*(r-l)-(c-l)*(s-h))/d,p=((o-s)*(r-l)-(a-r)*(s-h))/d;return(//  The fractional point will be between 0 and 1 inclusive if the lines intersect.
//  If the fractional calculation is larger than 1 or smaller than 0 the lines would need to be longer to intersect.
f>=0&&f<=1&&p>=0&&p<=1&&(n.x=s+f*(o-s),n.y=r+f*(a-r),!0))}}),r("3ARyj",function(t,e){t.exports=function(t,e){var i=t.x1,n=t.y1,s=t.x2,r=t.y2,o=e.x,a=e.y,h=e.right,l=e.bottom,u=0;//  If the start or end of the line is inside the rect then we assume
//  collision, as rects are solid for our use-case.
if(i>=o&&i<=h&&n>=a&&n<=l||s>=o&&s<=h&&r>=a&&r<=l)return!0;if(i<o&&s>=o){if(//  Left edge
(u=n+(r-n)*(o-i)/(s-i))>a&&u<=l)return!0}else if(i>h&&s<=h&&//  Right edge
(u=n+(r-n)*(h-i)/(s-i))>=a&&u<=l)return!0;if(n<a&&r>=a){if(//  Top edge
(u=i+(s-i)*(a-n)/(r-n))>=o&&u<=h)return!0}else if(n>l&&r<=l&&//  Bottom edge
(u=i+(s-i)*(l-n)/(r-n))>=o&&u<=h)return!0;return!1}}),r("arUwA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cwr8X"),n=s("dTOqt");t.exports=function(t,e,s){return void 0===s&&(s=new i),n(t,e)&&(s.x=Math.max(t.x,e.x),s.y=Math.max(t.y,e.y),s.width=Math.min(t.right,e.right)-s.x,s.height=Math.min(t.bottom,e.bottom)-s.y),s}}),r("dTOqt",function(t,e){t.exports=function(t,e){return!(t.width<=0)&&!(t.height<=0)&&!(e.width<=0)&&!(e.height<=0)&&!(t.right<e.x||t.bottom<e.y||t.x>e.right||t.y>e.bottom)}}),r("fEZtW",function(t,e){/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jcLFP"),n=s("dTOqt");t.exports=function(t,e,s){if(void 0===s&&(s=[]),n(t,e)){var r=t.getLineA(),o=t.getLineB(),a=t.getLineC(),h=t.getLineD();i(r,e,s),i(o,e,s),i(a,e,s),i(h,e,s)}return s}}),r("frm8a",function(t,e){/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("a5zoR"),n=s("jcLFP");t.exports=function(t,e,s){if(void 0===s&&(s=[]),i(t,e)){var r=e.getLineA(),o=e.getLineB(),a=e.getLineC();n(r,t,s),n(o,t,s),n(a,t,s)}return s}}),r("a5zoR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1B2Zx"),n=s("6pEze"),r=s("2ummv"),o=s("l25cG");t.exports=function(t,e){//  First the cheapest ones:
if(e.left>t.right||e.right<t.left||e.top>t.bottom||e.bottom<t.top)return!1;var s=e.getLineA(),a=e.getLineB(),h=e.getLineC();//  Are any of the triangle points within the rectangle?
if(n(t,s.x1,s.y1)||n(t,s.x2,s.y2)||n(t,a.x1,a.y1)||n(t,a.x2,a.y2)||n(t,h.x1,h.y1)||n(t,h.x2,h.y2))return!0;//  Cheap tests over, now to see if any of the lines intersect ...
var l=t.getLineA(),u=t.getLineB(),c=t.getLineC(),d=t.getLineD();return!!(i(s,l)||i(s,u)||i(s,c)||i(s,d)||i(a,l)||i(a,u)||i(a,c)||i(a,d)||i(h,l)||i(h,u)||i(h,c)||i(h,d))||r(e,o(t),!0).length>0}}),r("2ummv",function(t,e){t.exports=function(t,e,i,n){void 0===i&&(i=!1),void 0===n&&(n=[]);for(var s,r,o,a,h,l,u=t.x3-t.x1,c=t.y3-t.y1,d=t.x2-t.x1,f=t.y2-t.y1,p=u*u+c*c,g=u*d+c*f,v=d*d+f*f,m=p*v-g*g,y=0===m?0:1/m,x=t.x1,w=t.y1,T=0;T<e.length&&(s=(v*(h=u*(o=e[T].x-x)+c*(a=e[T].y-w))-g*(l=d*o+f*a))*y,r=(p*l-g*h)*y,!(s>=0)||!(r>=0)||!(s+r<1)||(n.push({x:e[T].x,y:e[T].y}),!i));T++);return n}}),r("l25cG",function(t,e){t.exports=function(t,e){return void 0===e&&(e=[]),e.push({x:t.x,y:t.y}),e.push({x:t.right,y:t.y}),e.push({x:t.right,y:t.bottom}),e.push({x:t.x,y:t.bottom}),e}}),r("c7MfJ",function(t,e){/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("a9cbd"),n=s("lSVA4");t.exports=function(t,e,s){if(void 0===s&&(s=[]),n(t,e)){var r=t.getLineA(),o=t.getLineB(),a=t.getLineC();i(r,e,s),i(o,e,s),i(a,e,s)}return s}}),r("lSVA4",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("coG9m"),n=s("7e4Vb");t.exports=function(t,e){return(//  First the cheapest ones:
!(t.left>e.right)&&!(t.right<e.left)&&!(t.top>e.bottom)&&!(t.bottom<e.top)&&!!(n(t,e.x,e.y)||i(t.getLineA(),e)||i(t.getLineB(),e)||i(t.getLineC(),e)))}}),r("gLM7X",function(t,e){/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9"),n=s("1EbtS"),r=s("1B2Zx");t.exports=function(t,e,s){if(void 0===s&&(s=[]),n(t,e))for(var o=t.getLineA(),a=t.getLineB(),h=t.getLineC(),l=[new i,new i,new i],u=[r(o,e,l[0]),r(a,e,l[1]),r(h,e,l[2])],c=0;c<3;c++)u[c]&&s.push(l[c]);return s}}),r("1EbtS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7e4Vb"),n=s("1B2Zx");t.exports=function(t,e){return!!(i(t,e.getPointA())||i(t,e.getPointB())||n(t.getLineA(),e)||n(t.getLineB(),e)||n(t.getLineC(),e))}}),r("5ltcM",function(t,e){/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2W0ce"),n=s("gLM7X");t.exports=function(t,e,s){if(void 0===s&&(s=[]),i(t,e)){var r=e.getLineA(),o=e.getLineB(),a=e.getLineC();n(t,r,s),n(t,o,s),n(t,a,s)}return s}}),r("2W0ce",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2ummv"),n=s("21YsO"),r=s("1B2Zx");t.exports=function(t,e){//  First the cheapest ones:
if(t.left>e.right||t.right<e.left||t.top>e.bottom||t.bottom<e.top)return!1;var s=t.getLineA(),o=t.getLineB(),a=t.getLineC(),h=e.getLineA(),l=e.getLineB(),u=e.getLineC();//  Now check the lines against each line of TriangleB
if(r(s,h)||r(s,l)||r(s,u)||r(o,h)||r(o,l)||r(o,u)||r(a,h)||r(a,l)||r(a,u))return!0;//  Nope, so check to see if any of the points of triangleA are within triangleB
var c=n(t),d=i(e,c,!0);return d.length>0||(d=i(t,//  Finally check to see if any of the points of triangleB are within triangleA
c=n(e),!0)).length>0}}),r("21YsO",function(t,e){t.exports=function(t,e){return void 0===e&&(e=[]),e.push({x:t.x1,y:t.y1}),e.push({x:t.x2,y:t.y2}),e.push({x:t.x3,y:t.y3}),e}}),r("94QvZ",function(t,e){t.exports=function(t,e,i){void 0===i&&(i=1);var n=e.x1,s=e.y1,r=e.x2,o=e.y2,a=t.x,h=t.y,l=(r-n)*(r-n)+(o-s)*(o-s);if(0===l)return!1;var u=((a-n)*(r-n)+(h-s)*(o-s))/l;return(//  Assume line thickness is circular
u<0?Math.sqrt((n-a)*(n-a)+(s-h)*(s-h))<=i:u>=0&&u<=1?Math.abs(((s-h)*(r-n)-(n-a)*(o-s))/l)*Math.sqrt(l)<=i:Math.sqrt((r-a)*(r-a)+(o-h)*(o-h))<=i)}}),r("eEky2",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("94QvZ");t.exports=function(t,e){if(!i(t,e))return!1;var n=Math.min(e.x1,e.x2),s=Math.max(e.x1,e.x2),r=Math.min(e.y1,e.y2),o=Math.max(e.y1,e.y2);return t.x>=n&&t.x<=s&&t.y>=r&&t.y<=o}}),r("2aBNx",function(t,e){t.exports=function(t,e,i,n,s,r){return void 0===r&&(r=0),!(e>t.right+r||i<t.left-r||n>t.bottom+r||s<t.top-r)}}),r("3epuM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1LRPh");i.Angle=s("42V9N"),i.BresenhamPoints=s("7M14o"),i.CenterOn=s("30LjB"),i.Clone=s("8xns7"),i.CopyFrom=s("fJQsp"),i.Equals=s("g5YG1"),i.Extend=s("dnDRx"),i.GetEasedPoints=s("aarEH"),i.GetMidPoint=s("jlSUE"),i.GetNearestPoint=s("j4fEp"),i.GetNormal=s("gYAFg"),i.GetPoint=s("9T44R"),i.GetPoints=s("fYnml"),i.GetShortestDistance=s("fXXbD"),i.Height=s("a0T7b"),i.Length=s("7Smss"),i.NormalAngle=s("bUxR9"),i.NormalX=s("liIYR"),i.NormalY=s("faSTe"),i.Offset=s("50R0s"),i.PerpSlope=s("gP5y6"),i.Random=s("1Ap5d"),i.ReflectAngle=s("jqAeP"),i.Rotate=s("7jz2j"),i.RotateAroundPoint=s("hyLOP"),i.RotateAroundXY=s("5XjMw"),i.SetToAngle=s("5rSLB"),i.Slope=s("7jmkp"),i.Width=s("dajGv"),t.exports=i}),r("42V9N",function(t,e){t.exports=function(t){return Math.atan2(t.y2-t.y1,t.x2-t.x1)}}),r("30LjB",function(t,e){t.exports=function(t,e,i){var n=e-(t.x1+t.x2)/2,s=i-(t.y1+t.y2)/2;return t.x1+=n,t.y1+=s,t.x2+=n,t.y2+=s,t}}),r("8xns7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1LRPh");t.exports=function(t){return new i(t.x1,t.y1,t.x2,t.y2)}}),r("fJQsp",function(t,e){t.exports=function(t,e){return e.setTo(t.x1,t.y1,t.x2,t.y2)}}),r("g5YG1",function(t,e){t.exports=function(t,e){return t.x1===e.x1&&t.y1===e.y1&&t.x2===e.x2&&t.y2===e.y2}}),r("dnDRx",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7Smss");t.exports=function(t,e,n){void 0===n&&(n=e);var s=i(t),r=t.x2-t.x1,o=t.y2-t.y1;return e&&(t.x1=t.x1-r/s*e,t.y1=t.y1-o/s*e),n&&(t.x2=t.x2+r/s*n,t.y2=t.y2+o/s*n),t}}),r("aarEH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ljUB8"),n=s("aANNX"),r=s("cSEB9");t.exports=function(t,e,s,o,a){void 0===o&&(o=0),void 0===a&&(a=[]);var h,l,u=[],c=t.x1,d=t.y1,f=t.x2-c,p=t.y2-d,g=n(e,a),v=s-1;for(h=0;h<v;h++)l=g(h/v),u.push(new r(c+f*l,d+p*l));//  Remove collinear parts
if(//  Always include the end of the line
l=g(1),u.push(new r(c+f*l,d+p*l)),!(o>0))return u;var m=u[0],y=[m];for(h=1;h<u.length-1;h++){var x=u[h];i(m,x)>=o&&(y.push(x),m=x)}//  Top and tail
var w=u[u.length-1];return i(m,w)<o&&y.pop(),y.push(w),y}}),r("jlSUE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e){return void 0===e&&(e=new i),e.x=(t.x1+t.x2)/2,e.y=(t.y1+t.y2)/2,e}}),r("j4fEp",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Florian Mertens
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e,n){void 0===n&&(n=new i);var s=t.x1,r=t.y1,o=t.x2,a=t.y2,h=(o-s)*(o-s)+(a-r)*(a-r);if(0===h)return n;var l=((e.x-s)*(o-s)+(e.y-r)*(a-r))/h;return n.x=s+l*(o-s),n.y=r+l*(a-r),n}}),r("gYAFg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bNtDi"),n=s("42V9N"),r=s("cSEB9");t.exports=function(t,e){void 0===e&&(e=new r);var s=n(t)-i.TAU;return e.x=Math.cos(s),e.y=Math.sin(s),e}}),r("fXXbD",function(t,e){t.exports=function(t,e){var i=t.x1,n=t.y1,s=t.x2,r=t.y2,o=(s-i)*(s-i)+(r-n)*(r-n);return 0!==o&&Math.abs(((n-e.y)*(s-i)-(i-e.x)*(r-n))/o)*Math.sqrt(o)}}),r("a0T7b",function(t,e){t.exports=function(t){return Math.abs(t.y1-t.y2)}}),r("bUxR9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bNtDi"),n=s("8qWuA"),r=s("42V9N");t.exports=function(t){return n(r(t)-i.TAU,-Math.PI,Math.PI)}}),r("liIYR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bNtDi"),n=s("42V9N");t.exports=function(t){return Math.cos(n(t)-i.TAU)}}),r("faSTe",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bNtDi"),n=s("42V9N");t.exports=function(t){return Math.sin(n(t)-i.TAU)}}),r("50R0s",function(t,e){t.exports=function(t,e,i){return t.x1+=e,t.y1+=i,t.x2+=e,t.y2+=i,t}}),r("gP5y6",function(t,e){t.exports=function(t){return-((t.x2-t.x1)/(t.y2-t.y1))}}),r("jqAeP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("42V9N"),n=s("bUxR9");t.exports=function(t,e){return 2*n(e)-Math.PI-i(t)}}),r("7jz2j",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5XjMw");t.exports=function(t,e){var n=(t.x1+t.x2)/2,s=(t.y1+t.y2)/2;return i(t,n,s,e)}}),r("5XjMw",function(t,e){t.exports=function(t,e,i,n){var s=Math.cos(n),r=Math.sin(n),o=t.x1-e,a=t.y1-i;return t.x1=o*s-a*r+e,t.y1=o*r+a*s+i,o=t.x2-e,a=t.y2-i,t.x2=o*s-a*r+e,t.y2=o*r+a*s+i,t}}),r("hyLOP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5XjMw");t.exports=function(t,e,n){return i(t,e.x,e.y,n)}}),r("5rSLB",function(t,e){t.exports=function(t,e,i,n,s){return t.x1=e,t.y1=i,t.x2=e+Math.cos(n)*s,t.y2=i+Math.sin(n)*s,t}}),r("7jmkp",function(t,e){t.exports=function(t){return(t.y2-t.y1)/(t.x2-t.x1)}}),r("dajGv",function(t,e){t.exports=function(t){return Math.abs(t.x1-t.x2)}}),r("h9uwP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");i.Ceil=s("9kqT3"),i.Clone=s("j4GZD"),i.CopyFrom=s("aCcI3"),i.Equals=s("dGmMZ"),i.Floor=s("i9Nu4"),i.GetCentroid=s("uxGA5"),i.GetMagnitude=s("2O8LR"),i.GetMagnitudeSq=s("dwTuL"),i.GetRectangleFromPoints=s("1srlv"),i.Interpolate=s("h6ZDO"),i.Invert=s("1K2PV"),i.Negative=s("5TVbn"),i.Project=s("35Dlw"),i.ProjectUnit=s("5BtJe"),i.SetMagnitude=s("5C2M9"),t.exports=i}),r("9kqT3",function(t,e){t.exports=function(t){return t.setTo(Math.ceil(t.x),Math.ceil(t.y))}}),r("j4GZD",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t){return new i(t.x,t.y)}}),r("aCcI3",function(t,e){t.exports=function(t,e){return e.setTo(t.x,t.y)}}),r("dGmMZ",function(t,e){t.exports=function(t,e){return t.x===e.x&&t.y===e.y}}),r("i9Nu4",function(t,e){t.exports=function(t){return t.setTo(Math.floor(t.x),Math.floor(t.y))}}),r("uxGA5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e){if(void 0===e&&(e=new i),!Array.isArray(t))throw Error("GetCentroid points argument must be an array");var n=t.length;if(n<1)throw Error("GetCentroid points array must not be empty");if(1===n)e.x=t[0].x,e.y=t[0].y;else{for(var s=0;s<n;s++)e.x+=t[s].x,e.y+=t[s].y;e.x/=n,e.y/=n}return e}}),r("2O8LR",function(t,e){t.exports=function(t){return Math.sqrt(t.x*t.x+t.y*t.y)}}),r("dwTuL",function(t,e){t.exports=function(t){return t.x*t.x+t.y*t.y}}),r("1srlv",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cwr8X");t.exports=function(t,e){void 0===e&&(e=new i);for(var n=Number.NEGATIVE_INFINITY,s=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,o=Number.POSITIVE_INFINITY,a=0;a<t.length;a++){var h=t[a];h.x>n&&(n=h.x),h.x<s&&(s=h.x),h.y>r&&(r=h.y),h.y<o&&(o=h.y)}return e.x=s,e.y=o,e.width=n-s,e.height=r-o,e}}),r("h6ZDO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e,n,s){return void 0===n&&(n=0),void 0===s&&(s=new i),s.x=t.x+(e.x-t.x)*n,s.y=t.y+(e.y-t.y)*n,s}}),r("1K2PV",function(t,e){t.exports=function(t){return t.setTo(t.y,t.x)}}),r("5TVbn",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e){return void 0===e&&(e=new i),e.setTo(-t.x,-t.y)}}),r("35Dlw",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9"),n=s("dwTuL");t.exports=function(t,e,s){void 0===s&&(s=new i);var r=(t.x*e.x+t.y*e.y)/n(e);return 0!==r&&(s.x=r*e.x,s.y=r*e.y),s}}),r("5BtJe",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e,n){void 0===n&&(n=new i);var s=t.x*e.x+t.y*e.y;return 0!==s&&(n.x=s*e.x,n.y=s*e.y),n}}),r("5C2M9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2O8LR");t.exports=function(t,e){if(0!==t.x||0!==t.y){var n=i(t);t.x/=n,t.y/=n}return t.x*=e,t.y*=e,t}}),r("3l7hU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7cxCo");i.Clone=s("jvjVg"),i.Contains=s("ivFeg"),i.ContainsPoint=s("83SOr"),i.GetAABB=s("hF14a"),i.GetNumberArray=s("bumfP"),i.GetPoints=s("gU0SF"),i.Perimeter=s("dKsEw"),i.Reverse=s("hGI9q"),i.Smooth=s("6FcU2"),t.exports=i}),r("jvjVg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7cxCo");t.exports=function(t){return new i(t.points)}}),r("83SOr",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ivFeg");t.exports=function(t,e){return i(t,e.x,e.y)}}),r("bumfP",function(t,e){t.exports=function(t,e){void 0===e&&(e=[]);for(var i=0;i<t.points.length;i++)e.push(t.points[i].x),e.push(t.points[i].y);return e}}),r("hGI9q",function(t,e){t.exports=function(t){return t.points.reverse(),t}}),r("baGGN",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cwr8X");i.Area=s("k1h63"),i.Ceil=s("6HNnG"),i.CeilAll=s("6IJon"),i.CenterOn=s("ilLbF"),i.Clone=s("821hF"),i.Contains=s("6pEze"),i.ContainsPoint=s("he3Ny"),i.ContainsRect=s("k97Zg"),i.CopyFrom=s("kprrJ"),i.Decompose=s("l25cG"),i.Equals=s("5psDG"),i.FitInside=s("cA82z"),i.FitOutside=s("hOFs2"),i.Floor=s("ibcM5"),i.FloorAll=s("bFZ6X"),i.FromPoints=s("1zoJ0"),i.FromXY=s("gS9Ff"),i.GetAspectRatio=s("1aJpj"),i.GetCenter=s("7YZzP"),i.GetPoint=s("cu9YH"),i.GetPoints=s("c3WbB"),i.GetSize=s("1WZTG"),i.Inflate=s("lGviC"),i.Intersection=s("dYbpw"),i.MarchingAnts=s("ktcgp"),i.MergePoints=s("53j7I"),i.MergeRect=s("hmvqd"),i.MergeXY=s("8vRzF"),i.Offset=s("wqr9Z"),i.OffsetPoint=s("1CVoT"),i.Overlaps=s("8sRjR"),i.Perimeter=s("ltSp2"),i.PerimeterPoint=s("d071K"),i.Random=s("xap54"),i.RandomOutside=s("dQwMQ"),i.SameDimensions=s("hz0l4"),i.Scale=s("XreVq"),i.Union=s("dDbeb"),t.exports=i}),r("k1h63",function(t,e){t.exports=function(t){return t.width*t.height}}),r("6HNnG",function(t,e){t.exports=function(t){return t.x=Math.ceil(t.x),t.y=Math.ceil(t.y),t}}),r("6IJon",function(t,e){t.exports=function(t){return t.x=Math.ceil(t.x),t.y=Math.ceil(t.y),t.width=Math.ceil(t.width),t.height=Math.ceil(t.height),t}}),r("821hF",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cwr8X");t.exports=function(t){return new i(t.x,t.y,t.width,t.height)}}),r("he3Ny",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6pEze");t.exports=function(t,e){return i(t,e.x,e.y)}}),r("k97Zg",function(t,e){t.exports=function(t,e){return(//  Volume check (if rectB volume > rectA then rectA cannot contain it)
!(e.width*e.height>t.width*t.height)&&e.x>t.x&&e.x<t.right&&e.right>t.x&&e.right<t.right&&e.y>t.y&&e.y<t.bottom&&e.bottom>t.y&&e.bottom<t.bottom)}}),r("kprrJ",function(t,e){t.exports=function(t,e){return e.setTo(t.x,t.y,t.width,t.height)}}),r("5psDG",function(t,e){t.exports=function(t,e){return t.x===e.x&&t.y===e.y&&t.width===e.width&&t.height===e.height}}),r("cA82z",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1aJpj");t.exports=function(t,e){var n=i(t);return n<i(e)?t.setSize(e.height*n,e.height):t.setSize(e.width,e.width/n),t.setPosition(e.centerX-t.width/2,e.centerY-t.height/2)}}),r("1aJpj",function(t,e){t.exports=function(t){return 0===t.height?NaN:t.width/t.height}}),r("hOFs2",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1aJpj");t.exports=function(t,e){var n=i(t);return n>i(e)?t.setSize(e.height*n,e.height):t.setSize(e.width,e.width/n),t.setPosition(e.centerX-t.width/2,e.centerY-t.height/2)}}),r("ibcM5",function(t,e){t.exports=function(t){return t.x=Math.floor(t.x),t.y=Math.floor(t.y),t}}),r("bFZ6X",function(t,e){t.exports=function(t){return t.x=Math.floor(t.x),t.y=Math.floor(t.y),t.width=Math.floor(t.width),t.height=Math.floor(t.height),t}}),r("gS9Ff",function(t,e){/**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cwr8X");t.exports=function(t,e,n,s,r){return void 0===r&&(r=new i),r.setTo(Math.min(t,n),Math.min(e,s),Math.abs(t-n),Math.abs(e-s))}}),r("7YZzP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e){return void 0===e&&(e=new i),e.x=t.centerX,e.y=t.centerY,e}}),r("1WZTG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e){return void 0===e&&(e=new i),e.x=t.width,e.y=t.height,e}}),r("lGviC",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ilLbF");t.exports=function(t,e,n){var s=t.centerX,r=t.centerY;return t.setSize(t.width+2*e,t.height+2*n),i(t,s,r)}}),r("dYbpw",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cwr8X"),n=s("dTOqt");t.exports=function(t,e,s){return void 0===s&&(s=new i),n(t,e)?(s.x=Math.max(t.x,e.x),s.y=Math.max(t.y,e.y),s.width=Math.min(t.right,e.right)-s.x,s.height=Math.min(t.bottom,e.bottom)-s.y):s.setEmpty(),s}}),r("53j7I",function(t,e){t.exports=function(t,e){for(var i=t.x,n=t.right,s=t.y,r=t.bottom,o=0;o<e.length;o++)i=Math.min(i,e[o].x),n=Math.max(n,e[o].x),s=Math.min(s,e[o].y),r=Math.max(r,e[o].y);return t.x=i,t.y=s,t.width=n-i,t.height=r-s,t}}),r("hmvqd",function(t,e){t.exports=function(t,e){var i=Math.min(t.x,e.x),n=Math.max(t.right,e.right);t.x=i,t.width=n-i;var s=Math.min(t.y,e.y),r=Math.max(t.bottom,e.bottom);return t.y=s,t.height=r-s,t}}),r("8vRzF",function(t,e){t.exports=function(t,e,i){var n=Math.min(t.x,e),s=Math.max(t.right,e);t.x=n,t.width=s-n;var r=Math.min(t.y,i),o=Math.max(t.bottom,i);return t.y=r,t.height=o-r,t}}),r("wqr9Z",function(t,e){t.exports=function(t,e,i){return t.x+=e,t.y+=i,t}}),r("1CVoT",function(t,e){t.exports=function(t,e){return t.x+=e.x,t.y+=e.y,t}}),r("8sRjR",function(t,e){t.exports=function(t,e){return t.x<e.right&&t.right>e.x&&t.y<e.bottom&&t.bottom>e.y}}),r("d071K",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9"),n=s("2zqSA");t.exports=function(t,e,s){void 0===s&&(s=new i);var r=Math.sin(e=n(e)),o=Math.cos(e),a=o>0?t.width/2:-(t.width/2),h=r>0?t.height/2:-(t.height/2);return Math.abs(a*r)<Math.abs(h*o)?h=a*r/o:a=h*o/r,s.x=a+t.centerX,s.y=h+t.centerY,s}}),r("dQwMQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2EBZh"),n=s("k97Zg"),r=s("cSEB9");t.exports=function(t,e,s){if(void 0===s&&(s=new r),n(t,e))//
//  The quadrants don't extend the full widths / heights of the outer rect to give
//  us a better uniformed distribution, otherwise you get clumping in the corners where
//  the 4 quads would overlap
switch(i(0,3)){case 0:s.x=t.x+Math.random()*(e.right-t.x),s.y=t.y+Math.random()*(e.top-t.y);break;case 1:s.x=e.x+Math.random()*(t.right-e.x),s.y=e.bottom+Math.random()*(t.bottom-e.bottom);break;case 2:s.x=t.x+Math.random()*(e.x-t.x),s.y=e.y+Math.random()*(t.bottom-e.y);break;case 3:s.x=e.right+Math.random()*(t.right-e.right),s.y=t.y+Math.random()*(e.bottom-t.y)}return s}}),r("hz0l4",function(t,e){t.exports=function(t,e){return t.width===e.width&&t.height===e.height}}),r("XreVq",function(t,e){t.exports=function(t,e,i){return void 0===i&&(i=e),t.width*=e,t.height*=i,t}}),r("iq5jH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1TF8x");i.Area=s("3I0ab"),i.BuildEquilateral=s("jJKjT"),i.BuildFromPolygon=s("hYBAU"),i.BuildRight=s("VtnnF"),i.CenterOn=s("4lWfh"),i.Centroid=s("h9LPH"),i.CircumCenter=s("9kYeH"),i.CircumCircle=s("aBhG3"),i.Clone=s("bPApw"),i.Contains=s("7e4Vb"),i.ContainsArray=s("2ummv"),i.ContainsPoint=s("hGkQI"),i.CopyFrom=s("hq0U4"),i.Decompose=s("21YsO"),i.Equals=s("1VS9a"),i.GetPoint=s("dzuyF"),i.GetPoints=s("50jzU"),i.InCenter=s("4K7d6"),i.Perimeter=s("azTcC"),i.Offset=s("iHM3K"),i.Random=s("2MADn"),i.Rotate=s("jPvqq"),i.RotateAroundPoint=s("5PnUG"),i.RotateAroundXY=s("9xiU6"),t.exports=i}),r("3I0ab",function(t,e){t.exports=function(t){var e=t.x1,i=t.y1,n=t.x2,s=t.y2;return Math.abs(((t.x3-e)*(s-i)-(n-e)*(t.y3-i))/2)}}),r("jJKjT",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1TF8x");t.exports=function(t,e,n){var s=n*(Math.sqrt(3)/2),r=t+n/2,o=e+s,a=t-n/2,h=e+s;return new i(t,e,r,o,a,h)}}),r("hYBAU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hjbjS"),n=s("1TF8x");t.exports=function(t,e,s,r,o){void 0===e&&(e=null),void 0===s&&(s=1),void 0===r&&(r=1),void 0===o&&(o=[]);for(var a,h,l,u,c,d,f,p,g,v=i(t,e),m=0;m<v.length;m+=3)a=v[m],h=v[m+1],l=v[m+2],u=t[2*a]*s,c=t[2*a+1]*r,d=t[2*h]*s,f=t[2*h+1]*r,p=t[2*l]*s,g=t[2*l+1]*r,o.push(new n(u,c,d,f,p,g));return o}}),r("VtnnF",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1TF8x");t.exports=function(t,e,n,s){void 0===s&&(s=n);var r=e-s,o=t+n;return new i(t,e,t,r,o,e)}}),r("4lWfh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("h9LPH"),n=s("iHM3K");t.exports=function(t,e,s,r){void 0===r&&(r=i);//  Get the center of the triangle
var o=r(t);return n(t,e-o.x,s-o.y)}}),r("h9LPH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");t.exports=function(t,e){return void 0===e&&(e=new i),e.x=(t.x1+t.x2+t.x3)/3,e.y=(t.y1+t.y2+t.y3)/3,e}}),r("iHM3K",function(t,e){t.exports=function(t,e,i){return t.x1+=e,t.y1+=i,t.x2+=e,t.y2+=i,t.x3+=e,t.y3+=i,t}}),r("9kYeH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7SBSk");t.exports=function(t,e){void 0===e&&(e=new i);var n=t.x3,s=t.y3,r=t.x1-n,o=t.y1-s,a=t.x2-n,h=t.y2-s,l=2*(r*h-o*a);return e.x=n-(o*(a*a+h*h)-(r*r+o*o)*h)/l,e.y=s+(r*(a*a+h*h)-(r*r+o*o)*a)/l,e}}),r("aBhG3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eQ4tZ");t.exports=function(t,e){void 0===e&&(e=new i);//  A
var n,s,r=t.x1,o=t.y1,a=t.x2,h=t.y2,l=t.x3,u=t.y3,c=a-r,d=h-o,f=l-r,p=u-o,g=c*(r+a)+d*(o+h),v=f*(r+l)+p*(o+u),m=2*(c*(u-h)-d*(l-a));//  If the points of the triangle are collinear, then just find the
//  extremes and use the midpoint as the center of the circumcircle.
if(1e-6>Math.abs(m)){var y=Math.min(r,a,l),x=Math.min(o,h,u);n=(Math.max(r,a,l)-y)*.5,s=(Math.max(o,h,u)-x)*.5,e.x=y+n,e.y=x+s,e.radius=Math.sqrt(n*n+s*s)}else e.x=(p*g-d*v)/m,e.y=(c*v-f*g)/m,n=e.x-r,s=e.y-o,e.radius=Math.sqrt(n*n+s*s);return e}}),r("bPApw",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1TF8x");t.exports=function(t){return new i(t.x1,t.y1,t.x2,t.y2,t.x3,t.y3)}}),r("hGkQI",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7e4Vb");t.exports=function(t,e){return i(t,e.x,e.y)}}),r("hq0U4",function(t,e){t.exports=function(t,e){return e.setTo(t.x1,t.y1,t.x2,t.y2,t.x3,t.y3)}}),r("1VS9a",function(t,e){t.exports=function(t,e){return t.x1===e.x1&&t.y1===e.y1&&t.x2===e.x2&&t.y2===e.y2&&t.x3===e.x3&&t.y3===e.y3}}),r("4K7d6",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("cSEB9");// The three angle bisectors of a triangle meet in one point called the incenter.
// It is the center of the incircle, the circle inscribed in the triangle.
function n(t,e,i,n){var s=t-i,r=e-n;return Math.sqrt(s*s+r*r)}t.exports=function(t,e){void 0===e&&(e=new i);var s=t.x1,r=t.y1,o=t.x2,a=t.y2,h=t.x3,l=t.y3,u=n(h,l,o,a),c=n(s,r,h,l),d=n(o,a,s,r),f=u+c+d;return e.x=(s*u+o*c+h*d)/f,e.y=(r*u+a*c+l*d)/f,e}}),r("azTcC",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7Smss");t.exports=function(t){var e=t.getLineA(),n=t.getLineB(),s=t.getLineC();return i(e)+i(n)+i(s)}}),r("jPvqq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("9xiU6"),n=s("4K7d6");t.exports=function(t,e){var s=n(t);return i(t,s.x,s.y,e)}}),r("9xiU6",function(t,e){t.exports=function(t,e,i,n){var s=Math.cos(n),r=Math.sin(n),o=t.x1-e,a=t.y1-i;return t.x1=o*s-a*r+e,t.y1=o*r+a*s+i,o=t.x2-e,a=t.y2-i,t.x2=o*s-a*r+e,t.y2=o*r+a*s+i,o=t.x3-e,a=t.y3-i,t.x3=o*s-a*r+e,t.y3=o*r+a*s+i,t}}),r("5PnUG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("9xiU6");t.exports=function(t,e,n){return i(t,e.x,e.y,n)}}),r("lKFyN",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1BSIy"),n=s("hVk4C"),r={CreateInteractiveObject:s("elGGb"),Events:s("2nOjn"),Gamepad:s("a3re3"),InputManager:s("5ZH3f"),InputPlugin:s("2aowr"),InputPluginCache:s("cdMQz"),Keyboard:s("5em2R"),Mouse:s("iTK5J"),Pointer:s("1Oao7"),Touch:s("egEbB")};//   Merge in the consts
r=n(!1,r,i),t.exports=r}),r("elGGb",function(t,e){t.exports=function(t,e,i){return{gameObject:t,enabled:!0,alwaysEnabled:!1,draggable:!1,dropZone:!1,cursor:!1,target:null,camera:null,hitArea:e,hitAreaCallback:i,hitAreaDebug:null,//  Has the dev specified their own shape, or is this bound to the texture size?
customHitArea:!1,localX:0,localY:0,//  0 = Not being dragged
//  1 = Being checked for dragging
//  2 = Being dragged
dragState:0,dragStartX:0,dragStartY:0,dragStartXGlobal:0,dragStartYGlobal:0,dragX:0,dragY:0}}}),r("a3re3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Input.Gamepad
 */t.exports={Axis:s("6cpol"),Button:s("iOFFc"),Events:s("c97mn"),Gamepad:s("b4EQR"),GamepadPlugin:s("kgHTd"),Configs:s("1nW7X")}}),r("6cpol",function(t,e){/**
 * @classdesc
 * Contains information about a specific Gamepad Axis.
 * Axis objects are created automatically by the Gamepad as they are needed.
 *
 * @class Axis
 * @memberof Phaser.Input.Gamepad
 * @constructor
 * @since 3.0.0
 *
 * @param {Phaser.Input.Gamepad.Gamepad} pad - A reference to the Gamepad that this Axis belongs to.
 * @param {integer} index - The index of this Axis.
 */var i=new(s("jwj1g"))({initialize:function(t,e){/**
         * A reference to the Gamepad that this Axis belongs to.
         *
         * @name Phaser.Input.Gamepad.Axis#pad
         * @type {Phaser.Input.Gamepad.Gamepad}
         * @since 3.0.0
         */this.pad=t,/**
         * An event emitter to use to emit the axis events.
         *
         * @name Phaser.Input.Gamepad.Axis#events
         * @type {Phaser.Events.EventEmitter}
         * @since 3.0.0
         */this.events=t.events,/**
         * The index of this Axis.
         *
         * @name Phaser.Input.Gamepad.Axis#index
         * @type {integer}
         * @since 3.0.0
         */this.index=e,/**
         * The raw axis value, between -1 and 1 with 0 being dead center.
         * Use the method `getValue` to get a normalized value with the threshold applied.
         *
         * @name Phaser.Input.Gamepad.Axis#value
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.value=0,/**
         * Movement tolerance threshold below which axis values are ignored in `getValue`.
         *
         * @name Phaser.Input.Gamepad.Axis#threshold
         * @type {number}
         * @default 0.1
         * @since 3.0.0
         */this.threshold=.1},/**
     * Internal update handler for this Axis.
     * Called automatically by the Gamepad as part of its update.
     *
     * @method Phaser.Input.Gamepad.Axis#update
     * @private
     * @since 3.0.0
     *
     * @param {number} value - The value of the axis movement.
     */update:function(t){this.value=t},/**
     * Applies the `threshold` value to the axis and returns it.
     *
     * @method Phaser.Input.Gamepad.Axis#getValue
     * @since 3.0.0
     *
     * @return {number} The axis value, adjusted for the movement threshold.
     */getValue:function(){return Math.abs(this.value)<this.threshold?0:this.value},/**
     * Destroys this Axis instance and releases external references it holds.
     *
     * @method Phaser.Input.Gamepad.Axis#destroy
     * @since 3.10.0
     */destroy:function(){this.pad=null,this.events=null}});t.exports=i}),r("iOFFc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("c97mn"),r=new i({initialize:function(t,e){/**
         * A reference to the Gamepad that this Button belongs to.
         *
         * @name Phaser.Input.Gamepad.Button#pad
         * @type {Phaser.Input.Gamepad.Gamepad}
         * @since 3.0.0
         */this.pad=t,/**
         * An event emitter to use to emit the button events.
         *
         * @name Phaser.Input.Gamepad.Button#events
         * @type {Phaser.Events.EventEmitter}
         * @since 3.0.0
         */this.events=t.manager,/**
         * The index of this Button.
         *
         * @name Phaser.Input.Gamepad.Button#index
         * @type {integer}
         * @since 3.0.0
         */this.index=e,/**
         * Between 0 and 1.
         *
         * @name Phaser.Input.Gamepad.Button#value
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.value=0,/**
         * Can be set for analogue buttons to enable a 'pressure' threshold,
         * before a button is considered as being 'pressed'.
         *
         * @name Phaser.Input.Gamepad.Button#threshold
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.threshold=1,/**
         * Is the Button being pressed down or not?
         *
         * @name Phaser.Input.Gamepad.Button#pressed
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.pressed=!1},/**
     * Internal update handler for this Button.
     * Called automatically by the Gamepad as part of its update.
     *
     * @method Phaser.Input.Gamepad.Button#update
     * @fires Phaser.Input.Gamepad.Events#BUTTON_DOWN
     * @fires Phaser.Input.Gamepad.Events#BUTTON_UP
     * @fires Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_DOWN
     * @fires Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_UP
     * @private
     * @since 3.0.0
     *
     * @param {number} value - The value of the button. Between 0 and 1.
     */update:function(t){this.value=t;var e=this.pad,i=this.index;t>=this.threshold?this.pressed||(this.pressed=!0,this.events.emit(n.BUTTON_DOWN,e,this,t),this.pad.emit(n.GAMEPAD_BUTTON_DOWN,i,t,this)):this.pressed&&(this.pressed=!1,this.events.emit(n.BUTTON_UP,e,this,t),this.pad.emit(n.GAMEPAD_BUTTON_UP,i,t,this))},/**
     * Destroys this Button instance and releases external references it holds.
     *
     * @method Phaser.Input.Gamepad.Button#destroy
     * @since 3.10.0
     */destroy:function(){this.pad=null,this.events=null}});t.exports=r}),r("c97mn",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Input.Gamepad.Events
 */t.exports={BUTTON_DOWN:s("atuUr"),BUTTON_UP:s("hYB5C"),CONNECTED:s("8teRQ"),DISCONNECTED:s("4niBo"),GAMEPAD_BUTTON_DOWN:s("emeVh"),GAMEPAD_BUTTON_UP:s("bygAz")}}),r("atuUr",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Gamepad Button Down Event.
 * 
 * This event is dispatched by the Gamepad Plugin when a button has been pressed on any active Gamepad.
 * 
 * Listen to this event from within a Scene using: `this.input.gamepad.on('down', listener)`.
 * 
 * You can also listen for a DOWN event from a Gamepad instance. See the [GAMEPAD_BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_DOWN} event for details.
 *
 * @event Phaser.Input.Gamepad.Events#BUTTON_DOWN
 * @since 3.10.0
 * 
 * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad on which the button was pressed.
 * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was pressed.
 * @param {number} value - The value of the button at the time it was pressed. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.
 */t.exports="down"}),r("hYB5C",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Gamepad Button Up Event.
 * 
 * This event is dispatched by the Gamepad Plugin when a button has been released on any active Gamepad.
 * 
 * Listen to this event from within a Scene using: `this.input.gamepad.on('up', listener)`.
 * 
 * You can also listen for an UP event from a Gamepad instance. See the [GAMEPAD_BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_UP} event for details.
 *
 * @event Phaser.Input.Gamepad.Events#BUTTON_UP
 * @since 3.10.0
 * 
 * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad on which the button was released.
 * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was released.
 * @param {number} value - The value of the button at the time it was released. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.
 */t.exports="up"}),r("8teRQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Gamepad Connected Event.
 * 
 * This event is dispatched by the Gamepad Plugin when a Gamepad has been connected.
 * 
 * Listen to this event from within a Scene using: `this.input.gamepad.once('connected', listener)`.
 * 
 * Note that the browser may require you to press a button on a gamepad before it will allow you to access it,
 * this is for security reasons. However, it may also trust the page already, in which case you won't get the
 * 'connected' event and instead should check `GamepadPlugin.total` to see if it thinks there are any gamepads
 * already connected.
 *
 * @event Phaser.Input.Gamepad.Events#CONNECTED
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad which was connected.
 * @param {Event} event - The native DOM Event that triggered the connection.
 */t.exports="connected"}),r("4niBo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Gamepad Disconnected Event.
 * 
 * This event is dispatched by the Gamepad Plugin when a Gamepad has been disconnected.
 * 
 * Listen to this event from within a Scene using: `this.input.gamepad.once('disconnected', listener)`.
 *
 * @event Phaser.Input.Gamepad.Events#DISCONNECTED
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad which was disconnected.
 * @param {Event} event - The native DOM Event that triggered the disconnection.
 */t.exports="disconnected"}),r("emeVh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Gamepad Button Down Event.
 * 
 * This event is dispatched by a Gamepad instance when a button has been pressed on it.
 * 
 * Listen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:
 * `this.input.gamepad.pad1.on('down', listener)`.
 * 
 * Note that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.
 * 
 * You can also listen for a DOWN event from the Gamepad Plugin. See the [BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_DOWN} event for details.
 *
 * @event Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_DOWN
 * @since 3.10.0
 * 
 * @param {integer} index - The index of the button that was pressed.
 * @param {number} value - The value of the button at the time it was pressed. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.
 * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was pressed.
 */t.exports="down"}),r("bygAz",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Gamepad Button Up Event.
 * 
 * This event is dispatched by a Gamepad instance when a button has been released on it.
 * 
 * Listen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:
 * `this.input.gamepad.pad1.on('up', listener)`.
 * 
 * Note that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.
 * 
 * You can also listen for an UP event from the Gamepad Plugin. See the [BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_UP} event for details.
 *
 * @event Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_UP
 * @since 3.10.0
 * 
 * @param {integer} index - The index of the button that was released.
 * @param {number} value - The value of the button at the time it was released. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.
 * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was released.
 */t.exports="up"}),r("b4EQR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6cpol"),n=s("iOFFc"),r=s("jwj1g"),o=s("3vRz3"),a=s("7SBSk"),h=new r({Extends:o,initialize:function(t,e){o.call(this),/**
         * A reference to the Gamepad Plugin.
         *
         * @name Phaser.Input.Gamepad.Gamepad#manager
         * @type {Phaser.Input.Gamepad.GamepadPlugin}
         * @since 3.0.0
         */this.manager=t,/**
         * A reference to the native Gamepad object that is connected to the browser.
         *
         * @name Phaser.Input.Gamepad.Gamepad#pad
         * @type {any}
         * @since 3.10.0
         */this.pad=e,/**
         * A string containing some information about the controller.
         *
         * This is not strictly specified, but in Firefox it will contain three pieces of information
         * separated by dashes (-): two 4-digit hexadecimal strings containing the USB vendor and
         * product id of the controller, and the name of the controller as provided by the driver.
         * In Chrome it will contain the name of the controller as provided by the driver,
         * followed by vendor and product 4-digit hexadecimal strings.
         *
         * @name Phaser.Input.Gamepad.Gamepad#id
         * @type {string}
         * @since 3.0.0
         */this.id=e.id,/**
         * An integer that is unique for each Gamepad currently connected to the system.
         * This can be used to distinguish multiple controllers.
         * Note that disconnecting a device and then connecting a new device may reuse the previous index.
         *
         * @name Phaser.Input.Gamepad.Gamepad#index
         * @type {number}
         * @since 3.0.0
         */this.index=e.index;for(var s=[],r=0;r<e.buttons.length;r++)s.push(new n(this,r));/**
         * An array of Gamepad Button objects, corresponding to the different buttons available on the Gamepad.
         *
         * @name Phaser.Input.Gamepad.Gamepad#buttons
         * @type {Phaser.Input.Gamepad.Button[]}
         * @since 3.0.0
         */this.buttons=s;var h=[];for(r=0;r<e.axes.length;r++)h.push(new i(this,r));/**
         * An array of Gamepad Axis objects, corresponding to the different axes available on the Gamepad, if any.
         *
         * @name Phaser.Input.Gamepad.Gamepad#axes
         * @type {Phaser.Input.Gamepad.Axis[]}
         * @since 3.0.0
         */this.axes=h,/**
         * The Gamepad's Haptic Actuator (Vibration / Rumble support).
         * This is highly experimental and only set if both present on the device,
         * and exposed by both the hardware and browser.
         *
         * @name Phaser.Input.Gamepad.Gamepad#vibration
         * @type {GamepadHapticActuator}
         * @since 3.10.0
         */this.vibration=e.vibrationActuator;// https://w3c.github.io/gamepad/#remapping
var l={value:0,pressed:!1};/**
         * A reference to the Left Button in the Left Cluster.
         *
         * @name Phaser.Input.Gamepad.Gamepad#_LCLeft
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._LCLeft=s[14]?s[14]:l,/**
         * A reference to the Right Button in the Left Cluster.
         *
         * @name Phaser.Input.Gamepad.Gamepad#_LCRight
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._LCRight=s[15]?s[15]:l,/**
         * A reference to the Top Button in the Left Cluster.
         *
         * @name Phaser.Input.Gamepad.Gamepad#_LCTop
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._LCTop=s[12]?s[12]:l,/**
         * A reference to the Bottom Button in the Left Cluster.
         *
         * @name Phaser.Input.Gamepad.Gamepad#_LCBottom
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._LCBottom=s[13]?s[13]:l,/**
         * A reference to the Left Button in the Right Cluster.
         *
         * @name Phaser.Input.Gamepad.Gamepad#_RCLeft
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._RCLeft=s[2]?s[2]:l,/**
         * A reference to the Right Button in the Right Cluster.
         *
         * @name Phaser.Input.Gamepad.Gamepad#_RCRight
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._RCRight=s[1]?s[1]:l,/**
         * A reference to the Top Button in the Right Cluster.
         *
         * @name Phaser.Input.Gamepad.Gamepad#_RCTop
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._RCTop=s[3]?s[3]:l,/**
         * A reference to the Bottom Button in the Right Cluster.
         *
         * @name Phaser.Input.Gamepad.Gamepad#_RCBottom
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._RCBottom=s[0]?s[0]:l,/**
         * A reference to the Top Left Front Button (L1 Shoulder Button)
         *
         * @name Phaser.Input.Gamepad.Gamepad#_FBLeftTop
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._FBLeftTop=s[4]?s[4]:l,/**
         * A reference to the Bottom Left Front Button (L2 Shoulder Button)
         *
         * @name Phaser.Input.Gamepad.Gamepad#_FBLeftBottom
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._FBLeftBottom=s[6]?s[6]:l,/**
         * A reference to the Top Right Front Button (R1 Shoulder Button)
         *
         * @name Phaser.Input.Gamepad.Gamepad#_FBRightTop
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._FBRightTop=s[5]?s[5]:l,/**
         * A reference to the Bottom Right Front Button (R2 Shoulder Button)
         *
         * @name Phaser.Input.Gamepad.Gamepad#_FBRightBottom
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._FBRightBottom=s[7]?s[7]:l;var u={value:0};/**
         * A reference to the Horizontal Axis for the Left Stick.
         *
         * @name Phaser.Input.Gamepad.Gamepad#_HAxisLeft
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._HAxisLeft=h[0]?h[0]:u,/**
         * A reference to the Vertical Axis for the Left Stick.
         *
         * @name Phaser.Input.Gamepad.Gamepad#_VAxisLeft
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._VAxisLeft=h[1]?h[1]:u,/**
         * A reference to the Horizontal Axis for the Right Stick.
         *
         * @name Phaser.Input.Gamepad.Gamepad#_HAxisRight
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._HAxisRight=h[2]?h[2]:u,/**
         * A reference to the Vertical Axis for the Right Stick.
         *
         * @name Phaser.Input.Gamepad.Gamepad#_VAxisRight
         * @type {Phaser.Input.Gamepad.Button}
         * @private
         * @since 3.10.0
         */this._VAxisRight=h[3]?h[3]:u,/**
         * A Vector2 containing the most recent values from the Gamepad's left axis stick.
         * This is updated automatically as part of the Gamepad.update cycle.
         * The H Axis is mapped to the `Vector2.x` property, and the V Axis to the `Vector2.y` property.
         * The values are based on the Axis thresholds.
         * If the Gamepad does not have a left axis stick, the values will always be zero.
         *
         * @name Phaser.Input.Gamepad.Gamepad#leftStick
         * @type {Phaser.Math.Vector2}
         * @since 3.10.0
         */this.leftStick=new a,/**
         * A Vector2 containing the most recent values from the Gamepad's right axis stick.
         * This is updated automatically as part of the Gamepad.update cycle.
         * The H Axis is mapped to the `Vector2.x` property, and the V Axis to the `Vector2.y` property.
         * The values are based on the Axis thresholds.
         * If the Gamepad does not have a right axis stick, the values will always be zero.
         *
         * @name Phaser.Input.Gamepad.Gamepad#rightStick
         * @type {Phaser.Math.Vector2}
         * @since 3.10.0
         */this.rightStick=new a},/**
     * Gets the total number of axis this Gamepad claims to support.
     *
     * @method Phaser.Input.Gamepad.Gamepad#getAxisTotal
     * @since 3.10.0
     *
     * @return {integer} The total number of axes this Gamepad claims to support.
     */getAxisTotal:function(){return this.axes.length},/**
     * Gets the value of an axis based on the given index.
     * The index must be valid within the range of axes supported by this Gamepad.
     * The return value will be a float between 0 and 1.
     *
     * @method Phaser.Input.Gamepad.Gamepad#getAxisValue
     * @since 3.10.0
     *
     * @param {integer} index - The index of the axes to get the value for.
     *
     * @return {number} The value of the axis, between 0 and 1.
     */getAxisValue:function(t){return this.axes[t].getValue()},/**
     * Sets the threshold value of all axis on this Gamepad.
     * The value is a float between 0 and 1 and is the amount below which the axis is considered as not having been moved.
     *
     * @method Phaser.Input.Gamepad.Gamepad#setAxisThreshold
     * @since 3.10.0
     *
     * @param {number} value - A value between 0 and 1.
     */setAxisThreshold:function(t){for(var e=0;e<this.axes.length;e++)this.axes[e].threshold=t},/**
     * Gets the total number of buttons this Gamepad claims to have.
     *
     * @method Phaser.Input.Gamepad.Gamepad#getButtonTotal
     * @since 3.10.0
     *
     * @return {integer} The total number of buttons this Gamepad claims to have.
     */getButtonTotal:function(){return this.buttons.length},/**
     * Gets the value of a button based on the given index.
     * The index must be valid within the range of buttons supported by this Gamepad.
     *
     * The return value will be either 0 or 1 for an analogue button, or a float between 0 and 1
     * for a pressure-sensitive digital button, such as the shoulder buttons on a Dual Shock.
     *
     * @method Phaser.Input.Gamepad.Gamepad#getButtonValue
     * @since 3.10.0
     *
     * @param {integer} index - The index of the button to get the value for.
     *
     * @return {number} The value of the button, between 0 and 1.
     */getButtonValue:function(t){return this.buttons[t].value},/**
     * Returns if the button is pressed down or not.
     * The index must be valid within the range of buttons supported by this Gamepad.
     *
     * @method Phaser.Input.Gamepad.Gamepad#isButtonDown
     * @since 3.10.0
     *
     * @param {integer} index - The index of the button to get the value for.
     *
     * @return {boolean} `true` if the button is considered as being pressed down, otherwise `false`.
     */isButtonDown:function(t){return this.buttons[t].pressed},/**
     * Internal update handler for this Gamepad.
     * Called automatically by the Gamepad Manager as part of its update.
     *
     * @method Phaser.Input.Gamepad.Gamepad#update
     * @private
     * @since 3.0.0
     */update:function(t){//  Sync the button values
var e,i=this.buttons,n=t.buttons,s=i.length;for(e=0;e<s;e++)i[e].update(n[e].value);//  Sync the axis values
var r=this.axes,o=t.axes;for(e=0,s=r.length;e<s;e++)r[e].update(o[e]);s>=2&&(this.leftStick.set(r[0].getValue(),r[1].getValue()),s>=4&&this.rightStick.set(r[2].getValue(),r[3].getValue()))},/**
     * Destroys this Gamepad instance, its buttons and axes, and releases external references it holds.
     *
     * @method Phaser.Input.Gamepad.Gamepad#destroy
     * @since 3.10.0
     */destroy:function(){var t;for(this.removeAllListeners(),this.manager=null,this.pad=null,t=0;t<this.buttons.length;t++)this.buttons[t].destroy();for(t=0;t<this.axes.length;t++)this.axes[t].destroy();this.buttons=[],this.axes=[]},/**
     * Is this Gamepad currently connected or not?
     *
     * @name Phaser.Input.Gamepad.Gamepad#connected
     * @type {boolean}
     * @default true
     * @since 3.0.0
     */connected:{get:function(){return this.pad.connected}},/**
     * A timestamp containing the most recent time this Gamepad was updated.
     *
     * @name Phaser.Input.Gamepad.Gamepad#timestamp
     * @type {number}
     * @since 3.0.0
     */timestamp:{get:function(){return this.pad.timestamp}},/**
     * Is the Gamepad's Left button being pressed?
     * If the Gamepad doesn't have this button it will always return false.
     * This is the d-pad left button under standard Gamepad mapping.
     *
     * @name Phaser.Input.Gamepad.Gamepad#left
     * @type {boolean}
     * @since 3.10.0
     */left:{get:function(){return this._LCLeft.pressed}},/**
     * Is the Gamepad's Right button being pressed?
     * If the Gamepad doesn't have this button it will always return false.
     * This is the d-pad right button under standard Gamepad mapping.
     *
     * @name Phaser.Input.Gamepad.Gamepad#right
     * @type {boolean}
     * @since 3.10.0
     */right:{get:function(){return this._LCRight.pressed}},/**
     * Is the Gamepad's Up button being pressed?
     * If the Gamepad doesn't have this button it will always return false.
     * This is the d-pad up button under standard Gamepad mapping.
     *
     * @name Phaser.Input.Gamepad.Gamepad#up
     * @type {boolean}
     * @since 3.10.0
     */up:{get:function(){return this._LCTop.pressed}},/**
     * Is the Gamepad's Down button being pressed?
     * If the Gamepad doesn't have this button it will always return false.
     * This is the d-pad down button under standard Gamepad mapping.
     *
     * @name Phaser.Input.Gamepad.Gamepad#down
     * @type {boolean}
     * @since 3.10.0
     */down:{get:function(){return this._LCBottom.pressed}},/**
     * Is the Gamepad's bottom button in the right button cluster being pressed?
     * If the Gamepad doesn't have this button it will always return false.
     * On a Dual Shock controller it's the X button.
     * On an XBox controller it's the A button.
     *
     * @name Phaser.Input.Gamepad.Gamepad#A
     * @type {boolean}
     * @since 3.10.0
     */A:{get:function(){return this._RCBottom.pressed}},/**
     * Is the Gamepad's top button in the right button cluster being pressed?
     * If the Gamepad doesn't have this button it will always return false.
     * On a Dual Shock controller it's the Triangle button.
     * On an XBox controller it's the Y button.
     *
     * @name Phaser.Input.Gamepad.Gamepad#Y
     * @type {boolean}
     * @since 3.10.0
     */Y:{get:function(){return this._RCTop.pressed}},/**
     * Is the Gamepad's left button in the right button cluster being pressed?
     * If the Gamepad doesn't have this button it will always return false.
     * On a Dual Shock controller it's the Square button.
     * On an XBox controller it's the X button.
     *
     * @name Phaser.Input.Gamepad.Gamepad#X
     * @type {boolean}
     * @since 3.10.0
     */X:{get:function(){return this._RCLeft.pressed}},/**
     * Is the Gamepad's right button in the right button cluster being pressed?
     * If the Gamepad doesn't have this button it will always return false.
     * On a Dual Shock controller it's the Circle button.
     * On an XBox controller it's the B button.
     *
     * @name Phaser.Input.Gamepad.Gamepad#B
     * @type {boolean}
     * @since 3.10.0
     */B:{get:function(){return this._RCRight.pressed}},/**
     * Returns the value of the Gamepad's top left shoulder button.
     * If the Gamepad doesn't have this button it will always return zero.
     * The value is a float between 0 and 1, corresponding to how depressed the button is.
     * On a Dual Shock controller it's the L1 button.
     * On an XBox controller it's the LB button.
     *
     * @name Phaser.Input.Gamepad.Gamepad#L1
     * @type {number}
     * @since 3.10.0
     */L1:{get:function(){return this._FBLeftTop.value}},/**
     * Returns the value of the Gamepad's bottom left shoulder button.
     * If the Gamepad doesn't have this button it will always return zero.
     * The value is a float between 0 and 1, corresponding to how depressed the button is.
     * On a Dual Shock controller it's the L2 button.
     * On an XBox controller it's the LT button.
     *
     * @name Phaser.Input.Gamepad.Gamepad#L2
     * @type {number}
     * @since 3.10.0
     */L2:{get:function(){return this._FBLeftBottom.value}},/**
     * Returns the value of the Gamepad's top right shoulder button.
     * If the Gamepad doesn't have this button it will always return zero.
     * The value is a float between 0 and 1, corresponding to how depressed the button is.
     * On a Dual Shock controller it's the R1 button.
     * On an XBox controller it's the RB button.
     *
     * @name Phaser.Input.Gamepad.Gamepad#R1
     * @type {number}
     * @since 3.10.0
     */R1:{get:function(){return this._FBRightTop.value}},/**
     * Returns the value of the Gamepad's bottom right shoulder button.
     * If the Gamepad doesn't have this button it will always return zero.
     * The value is a float between 0 and 1, corresponding to how depressed the button is.
     * On a Dual Shock controller it's the R2 button.
     * On an XBox controller it's the RT button.
     *
     * @name Phaser.Input.Gamepad.Gamepad#R2
     * @type {number}
     * @since 3.10.0
     */R2:{get:function(){return this._FBRightBottom.value}}});t.exports=h}),r("kgHTd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("3vRz3"),r=s("c97mn"),o=s("b4EQR"),a=s("5pMDk"),h=s("cdMQz"),l=s("2nOjn"),u=new i({Extends:n,initialize:function(t){n.call(this),/**
         * A reference to the Scene that this Input Plugin is responsible for.
         *
         * @name Phaser.Input.Gamepad.GamepadPlugin#scene
         * @type {Phaser.Scene}
         * @since 3.10.0
         */this.scene=t.scene,/**
         * A reference to the Scene Systems Settings.
         *
         * @name Phaser.Input.Gamepad.GamepadPlugin#settings
         * @type {Phaser.Types.Scenes.SettingsObject}
         * @since 3.10.0
         */this.settings=this.scene.sys.settings,/**
         * A reference to the Scene Input Plugin that created this Keyboard Plugin.
         *
         * @name Phaser.Input.Gamepad.GamepadPlugin#sceneInputPlugin
         * @type {Phaser.Input.InputPlugin}
         * @since 3.10.0
         */this.sceneInputPlugin=t,/**
         * A boolean that controls if the Gamepad Manager is enabled or not.
         * Can be toggled on the fly.
         *
         * @name Phaser.Input.Gamepad.GamepadPlugin#enabled
         * @type {boolean}
         * @default true
         * @since 3.10.0
         */this.enabled=!0,/**
         * The Gamepad Event target, as defined in the Game Config.
         * Typically the browser window, but can be any interactive DOM element.
         *
         * @name Phaser.Input.Gamepad.GamepadPlugin#target
         * @type {any}
         * @since 3.10.0
         */this.target,/**
         * An array of the connected Gamepads.
         *
         * @name Phaser.Input.Gamepad.GamepadPlugin#gamepads
         * @type {Phaser.Input.Gamepad.Gamepad[]}
         * @default []
         * @since 3.10.0
         */this.gamepads=[],/**
         * An internal event queue.
         *
         * @name Phaser.Input.Gamepad.GamepadPlugin#queue
         * @type {GamepadEvent[]}
         * @private
         * @since 3.10.0
         */this.queue=[],/**
         * Internal event handler.
         *
         * @name Phaser.Input.Gamepad.GamepadPlugin#onGamepadHandler
         * @type {function}
         * @private
         * @since 3.10.0
         */this.onGamepadHandler,/**
         * Internal Gamepad reference.
         *
         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad1
         * @type {Phaser.Input.Gamepad.Gamepad}
         * @private
         * @since 3.10.0
         */this._pad1,/**
         * Internal Gamepad reference.
         *
         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad2
         * @type {Phaser.Input.Gamepad.Gamepad}
         * @private
         * @since 3.10.0
         */this._pad2,/**
         * Internal Gamepad reference.
         *
         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad3
         * @type {Phaser.Input.Gamepad.Gamepad}
         * @private
         * @since 3.10.0
         */this._pad3,/**
         * Internal Gamepad reference.
         *
         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad4
         * @type {Phaser.Input.Gamepad.Gamepad}
         * @private
         * @since 3.10.0
         */this._pad4,t.pluginEvents.once(l.BOOT,this.boot,this),t.pluginEvents.on(l.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.Input.Gamepad.GamepadPlugin#boot
     * @private
     * @since 3.10.0
     */boot:function(){var t=this.scene.sys.game,e=this.settings.input,i=t.config;this.enabled=a(e,"gamepad",i.inputGamepad)&&t.device.input.gamepads,this.target=a(e,"gamepad.target",i.inputGamepadEventTarget),this.sceneInputPlugin.pluginEvents.once(l.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.Input.Gamepad.GamepadPlugin#start
     * @private
     * @since 3.10.0
     */start:function(){this.enabled&&this.startListeners(),this.sceneInputPlugin.pluginEvents.once(l.SHUTDOWN,this.shutdown,this)},/**
     * Checks to see if both this plugin and the Scene to which it belongs is active.
     *
     * @method Phaser.Input.Gamepad.GamepadPlugin#isActive
     * @since 3.10.0
     *
     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.
     */isActive:function(){return this.enabled&&this.scene.sys.isActive()},/**
     * Starts the Gamepad Event listeners running.
     * This is called automatically and does not need to be manually invoked.
     *
     * @method Phaser.Input.Gamepad.GamepadPlugin#startListeners
     * @private
     * @since 3.10.0
     */startListeners:function(){var t=this,e=this.target,i=function(e){!e.defaultPrevented&&t.isActive()&&(t.refreshPads(),t.queue.push(e))};this.onGamepadHandler=i,e.addEventListener("gamepadconnected",i,!1),e.addEventListener("gamepaddisconnected",i,!1),//  FF also supports gamepadbuttondown, gamepadbuttonup and gamepadaxismove but
//  nothing else does, and we can get those values via the gamepads anyway, so we will
//  until more browsers support this
//  Finally, listen for an update event from the Input Plugin
this.sceneInputPlugin.pluginEvents.on(l.UPDATE,this.update,this)},/**
     * Stops the Gamepad Event listeners.
     * This is called automatically and does not need to be manually invoked.
     *
     * @method Phaser.Input.Gamepad.GamepadPlugin#stopListeners
     * @private
     * @since 3.10.0
     */stopListeners:function(){this.target.removeEventListener("gamepadconnected",this.onGamepadHandler),this.target.removeEventListener("gamepaddisconnected",this.onGamepadHandler),this.sceneInputPlugin.pluginEvents.off(l.UPDATE,this.update)},/**
     * Disconnects all current Gamepads.
     *
     * @method Phaser.Input.Gamepad.GamepadPlugin#disconnectAll
     * @since 3.10.0
     */disconnectAll:function(){for(var t=0;t<this.gamepads.length;t++)this.gamepads.connected=!1},/**
     * Refreshes the list of connected Gamepads.
     *
     * This is called automatically when a gamepad is connected or disconnected,
     * and during the update loop.
     *
     * @method Phaser.Input.Gamepad.GamepadPlugin#refreshPads
     * @private
     * @since 3.10.0
     */refreshPads:function(){var t=navigator.getGamepads();if(t)for(var e=this.gamepads,i=0;i<t.length;i++){var n=t[i];//  Because sometimes they're null (yes, really)
if(n){var s=n.id,r=n.index,a=e[r];if(a)a.id!==s?(//  A new Gamepad with a different vendor string, but it has got the same index as an old one
a.destroy(),e[r]=new o(this,n)):a.update(n);else{//  A new Gamepad, not currently stored locally
var h=new o(this,n);e[r]=h,this._pad1?this._pad2?this._pad3?this._pad4||(this._pad4=h):this._pad3=h:this._pad2=h:this._pad1=h}}}else this.disconnectAll()},/**
     * Returns an array of all currently connected Gamepads.
     *
     * @method Phaser.Input.Gamepad.GamepadPlugin#getAll
     * @since 3.10.0
     *
     * @return {Phaser.Input.Gamepad.Gamepad[]} An array of all currently connected Gamepads.
     */getAll:function(){for(var t=[],e=this.gamepads,i=0;i<e.length;i++)e[i]&&t.push(e[i]);return t},/**
     * Looks-up a single Gamepad based on the given index value.
     *
     * @method Phaser.Input.Gamepad.GamepadPlugin#getPad
     * @since 3.10.0
     *
     * @param {number} index - The index of the Gamepad to get.
     *
     * @return {Phaser.Input.Gamepad.Gamepad} The Gamepad matching the given index, or undefined if none were found.
     */getPad:function(t){for(var e=this.gamepads,i=0;i<e.length;i++)if(e[i]&&e[i].index===t)return e[i]},/**
     * The internal update loop. Refreshes all connected gamepads and processes their events.
     *
     * Called automatically by the Input Manager, invoked from the Game step.
     *
     * @method Phaser.Input.Gamepad.GamepadPlugin#update
     * @private
     * @fires Phaser.Input.Gamepad.Events#CONNECTED
     * @fires Phaser.Input.Gamepad.Events#DISCONNECTED
     * @since 3.10.0
     */update:function(){if(this.enabled){this.refreshPads();var t=this.queue.length;if(0!==t)//  Process the event queue, dispatching all of the events that have stored up
for(var e=this.queue.splice(0,t),i=0;i<t;i++){var n=e[i],s=this.getPad(n.gamepad.index);"gamepadconnected"===n.type?this.emit(r.CONNECTED,s,n):"gamepaddisconnected"===n.type&&this.emit(r.DISCONNECTED,s,n)}}},/**
     * Shuts the Gamepad Plugin down.
     * All this does is remove any listeners bound to it.
     *
     * @method Phaser.Input.Gamepad.GamepadPlugin#shutdown
     * @private
     * @since 3.10.0
     */shutdown:function(){this.stopListeners(),this.disconnectAll(),this.removeAllListeners()},/**
     * Destroys this Gamepad Plugin, disconnecting all Gamepads and releasing internal references.
     *
     * @method Phaser.Input.Gamepad.GamepadPlugin#destroy
     * @private
     * @since 3.10.0
     */destroy:function(){this.shutdown();for(var t=0;t<this.gamepads.length;t++)this.gamepads[t]&&this.gamepads[t].destroy();this.gamepads=[],this.scene=null,this.settings=null,this.sceneInputPlugin=null,this.target=null},/**
     * The total number of connected game pads.
     *
     * @name Phaser.Input.Gamepad.GamepadPlugin#total
     * @type {integer}
     * @since 3.10.0
     */total:{get:function(){return this.gamepads.length}},/**
     * A reference to the first connected Gamepad.
     *
     * This will be undefined if either no pads are connected, or the browser
     * has not yet issued a gamepadconnect, which can happen even if a Gamepad
     * is plugged in, but hasn't yet had any buttons pressed on it.
     *
     * @name Phaser.Input.Gamepad.GamepadPlugin#pad1
     * @type {Phaser.Input.Gamepad.Gamepad}
     * @since 3.10.0
     */pad1:{get:function(){return this._pad1}},/**
     * A reference to the second connected Gamepad.
     *
     * This will be undefined if either no pads are connected, or the browser
     * has not yet issued a gamepadconnect, which can happen even if a Gamepad
     * is plugged in, but hasn't yet had any buttons pressed on it.
     *
     * @name Phaser.Input.Gamepad.GamepadPlugin#pad2
     * @type {Phaser.Input.Gamepad.Gamepad}
     * @since 3.10.0
     */pad2:{get:function(){return this._pad2}},/**
     * A reference to the third connected Gamepad.
     *
     * This will be undefined if either no pads are connected, or the browser
     * has not yet issued a gamepadconnect, which can happen even if a Gamepad
     * is plugged in, but hasn't yet had any buttons pressed on it.
     *
     * @name Phaser.Input.Gamepad.GamepadPlugin#pad3
     * @type {Phaser.Input.Gamepad.Gamepad}
     * @since 3.10.0
     */pad3:{get:function(){return this._pad3}},/**
     * A reference to the fourth connected Gamepad.
     *
     * This will be undefined if either no pads are connected, or the browser
     * has not yet issued a gamepadconnect, which can happen even if a Gamepad
     * is plugged in, but hasn't yet had any buttons pressed on it.
     *
     * @name Phaser.Input.Gamepad.GamepadPlugin#pad4
     * @type {Phaser.Input.Gamepad.Gamepad}
     * @since 3.10.0
     */pad4:{get:function(){return this._pad4}}});/**
 * An instance of the Gamepad Plugin class, if enabled via the `input.gamepad` Scene or Game Config property.
 * Use this to create access Gamepads connected to the browser and respond to gamepad buttons.
 *
 * @name Phaser.Input.InputPlugin#gamepad
 * @type {?Phaser.Input.Gamepad.GamepadPlugin}
 * @since 3.10.0
 */h.register("GamepadPlugin",u,"gamepad","gamepad","inputGamepad"),t.exports=u}),r("cdMQz",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5pMDk"),n={},r={};/**
 * Static method called directly by the Core internal Plugins.
 * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)
 * Plugin is the object to instantiate to create the plugin
 * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)
 *
 * @function Phaser.Input.InputPluginCache.register
 * @static
 * @since 3.10.0
 *
 * @param {string} key - A reference used to get this plugin from the plugin cache.
 * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.
 * @param {string} mapping - If this plugin is to be injected into the Input Plugin, this is the property key used.
 * @param {string} settingsKey - The key in the Scene Settings to check to see if this plugin should install or not.
 * @param {string} configKey - The key in the Game Config to check to see if this plugin should install or not.
 */r.register=function(t,e,i,s,r){n[t]={plugin:e,mapping:i,settingsKey:s,configKey:r}},/**
 * Returns the input plugin object from the cache based on the given key.
 *
 * @function Phaser.Input.InputPluginCache.getCore
 * @static
 * @since 3.10.0
 *
 * @param {string} key - The key of the input plugin to get.
 *
 * @return {Phaser.Types.Input.InputPluginContainer} The input plugin object.
 */r.getPlugin=function(t){return n[t]},/**
 * Installs all of the registered Input Plugins into the given target.
 *
 * @function Phaser.Input.InputPluginCache.install
 * @static
 * @since 3.10.0
 *
 * @param {Phaser.Input.InputPlugin} target - The target InputPlugin to install the plugins into.
 */r.install=function(t){var e=t.scene.sys,s=e.settings.input,r=e.game.config;for(var o in n){var a=n[o].plugin,h=n[o].mapping;i(s,n[o].settingsKey,r[n[o].configKey])&&(t[h]=new a(t))}},/**
 * Removes an input plugin based on the given key.
 *
 * @function Phaser.Input.InputPluginCache.remove
 * @static
 * @since 3.10.0
 *
 * @param {string} key - The key of the input plugin to remove.
 */r.remove=function(t){n.hasOwnProperty(t)&&delete n[t]},t.exports=r}),r("1nW7X",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Input.Gamepad.Configs
 */t.exports={DUALSHOCK_4:s("j437e"),SNES_USB:s("8CAiJ"),XBOX_360:s("rMsWs")}}),r("j437e",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * PlayStation DualShock 4 Gamepad Configuration.
 * Sony PlayStation DualShock 4 (v2) wireless controller
 *
 * @name Phaser.Input.Gamepad.Configs.DUALSHOCK_4
 * @type {object}
 * @since 3.0.0
 */t.exports={UP:12,DOWN:13,LEFT:14,RIGHT:15,SHARE:8,OPTIONS:9,PS:16,TOUCHBAR:17,X:0,CIRCLE:1,SQUARE:2,TRIANGLE:3,L1:4,R1:5,L2:6,R2:7,L3:10,R3:11,LEFT_STICK_H:0,LEFT_STICK_V:1,RIGHT_STICK_H:2,RIGHT_STICK_V:3}}),r("8CAiJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * Tatar SNES USB Controller Gamepad Configuration.
 * USB Gamepad  (STANDARD GAMEPAD Vendor: 0079 Product: 0011)
 *
 * @name Phaser.Input.Gamepad.Configs.SNES_USB
 * @type {object}
 * @since 3.0.0
 */t.exports={UP:12,DOWN:13,LEFT:14,RIGHT:15,SELECT:8,START:9,B:0,A:1,Y:2,X:3,LEFT_SHOULDER:4,RIGHT_SHOULDER:5}}),r("rMsWs",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * XBox 360 Gamepad Configuration.
 *
 * @name Phaser.Input.Gamepad.Configs.XBOX_360
 * @type {object}
 * @since 3.0.0
 */t.exports={UP:12,DOWN:13,LEFT:14,RIGHT:15,MENU:16,A:0,B:1,X:2,Y:3,LB:4,RB:5,LT:6,RT:7,BACK:8,START:9,LS:10,RS:11,LEFT_STICK_H:0,LEFT_STICK_V:1,RIGHT_STICK_H:2,RIGHT_STICK_V:3}}),r("2aowr",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eQ4tZ"),n=s("6hp2k"),r=s("jwj1g"),o=s("1BSIy"),a=s("elGGb"),h=s("aFvH8"),l=s("bwLQh"),u=s("eaZcG"),c=s("dsAkp"),d=s("2nOjn"),f=s("3vRz3"),p=s("7BSWl"),g=s("gZ2BZ"),v=s("cdMQz"),m=s("jC9MQ"),y=s("7AzQW"),x=s("cwr8X"),w=s("6pEze"),T=s("4rtgc"),b=s("1TF8x"),S=s("7e4Vb"),A=new r({Extends:f,initialize:function(t){f.call(this),/**
         * A reference to the Scene that this Input Plugin is responsible for.
         *
         * @name Phaser.Input.InputPlugin#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * A reference to the Scene Systems class.
         *
         * @name Phaser.Input.InputPlugin#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,/**
         * A reference to the Scene Systems Settings.
         *
         * @name Phaser.Input.InputPlugin#settings
         * @type {Phaser.Types.Scenes.SettingsObject}
         * @since 3.5.0
         */this.settings=t.sys.settings,/**
         * A reference to the Game Input Manager.
         *
         * @name Phaser.Input.InputPlugin#manager
         * @type {Phaser.Input.InputManager}
         * @since 3.0.0
         */this.manager=t.sys.game.input,/**
         * Internal event queue used for plugins only.
         *
         * @name Phaser.Input.InputPlugin#pluginEvents
         * @type {Phaser.Events.EventEmitter}
         * @private
         * @since 3.10.0
         */this.pluginEvents=new f,/**
         * If `true` this Input Plugin will process DOM input events.
         *
         * @name Phaser.Input.InputPlugin#enabled
         * @type {boolean}
         * @default true
         * @since 3.5.0
         */this.enabled=!0,/**
         * A reference to the Scene Display List. This property is set during the `boot` method.
         *
         * @name Phaser.Input.InputPlugin#displayList
         * @type {Phaser.GameObjects.DisplayList}
         * @since 3.0.0
         */this.displayList,/**
         * A reference to the Scene Cameras Manager. This property is set during the `boot` method.
         *
         * @name Phaser.Input.InputPlugin#cameras
         * @type {Phaser.Cameras.Scene2D.CameraManager}
         * @since 3.0.0
         */this.cameras,//  Inject the available input plugins into this class
v.install(this),/**
         * A reference to the Mouse Manager.
         *
         * This property is only set if Mouse support has been enabled in your Game Configuration file.
         *
         * If you just wish to get access to the mouse pointer, use the `mousePointer` property instead.
         *
         * @name Phaser.Input.InputPlugin#mouse
         * @type {?Phaser.Input.Mouse.MouseManager}
         * @since 3.0.0
         */this.mouse=this.manager.mouse,/**
         * When set to `true` (the default) the Input Plugin will emulate DOM behavior by only emitting events from
         * the top-most Game Objects in the Display List.
         *
         * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.
         *
         * @name Phaser.Input.InputPlugin#topOnly
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.topOnly=!0,/**
         * How often should the Pointers be checked?
         *
         * The value is a time, given in ms, and is the time that must have elapsed between game steps before
         * the Pointers will be polled again. When a pointer is polled it runs a hit test to see which Game
         * Objects are currently below it, or being interacted with it.
         *
         * Pointers will *always* be checked if they have been moved by the user, or press or released.
         *
         * This property only controls how often they will be polled if they have not been updated.
         * You should set this if you want to have Game Objects constantly check against the pointers, even
         * if the pointer didn't itself move.
         *
         * Set to 0 to poll constantly. Set to -1 to only poll on user movement.
         *
         * @name Phaser.Input.InputPlugin#pollRate
         * @type {integer}
         * @default -1
         * @since 3.0.0
         */this.pollRate=-1,/**
         * Internal poll timer value.
         *
         * @name Phaser.Input.InputPlugin#_pollTimer
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._pollTimer=0;var e={cancelled:!1};/**
         * Internal event propagation callback container.
         *
         * @name Phaser.Input.InputPlugin#_eventContainer
         * @type {Phaser.Types.Input.EventData}
         * @private
         * @since 3.13.0
         */this._eventContainer={stopPropagation:function(){e.cancelled=!0}},/**
         * Internal event propagation data object.
         *
         * @name Phaser.Input.InputPlugin#_eventData
         * @type {object}
         * @private
         * @since 3.13.0
         */this._eventData=e,/**
         * The distance, in pixels, a pointer has to move while being held down, before it thinks it is being dragged.
         *
         * @name Phaser.Input.InputPlugin#dragDistanceThreshold
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.dragDistanceThreshold=0,/**
         * The amount of time, in ms, a pointer has to be held down before it thinks it is dragging.
         *
         * The default polling rate is to poll only on move so once the time threshold is reached the
         * drag event will not start until you move the mouse. If you want it to start immediately
         * when the time threshold is reached, you must increase the polling rate by calling
         * [setPollAlways]{@linkcode Phaser.Input.InputPlugin#setPollAlways} or
         * [setPollRate]{@linkcode Phaser.Input.InputPlugin#setPollRate}.
         *
         * @name Phaser.Input.InputPlugin#dragTimeThreshold
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.dragTimeThreshold=0,/**
         * Used to temporarily store the results of the Hit Test
         *
         * @name Phaser.Input.InputPlugin#_temp
         * @type {array}
         * @private
         * @default []
         * @since 3.0.0
         */this._temp=[],/**
         * Used to temporarily store the results of the Hit Test dropZones
         *
         * @name Phaser.Input.InputPlugin#_tempZones
         * @type {array}
         * @private
         * @default []
         * @since 3.0.0
         */this._tempZones=[],/**
         * A list of all Game Objects that have been set to be interactive in the Scene this Input Plugin is managing.
         *
         * @name Phaser.Input.InputPlugin#_list
         * @type {Phaser.GameObjects.GameObject[]}
         * @private
         * @default []
         * @since 3.0.0
         */this._list=[],/**
         * Objects waiting to be inserted to the list on the next call to 'begin'.
         *
         * @name Phaser.Input.InputPlugin#_pendingInsertion
         * @type {Phaser.GameObjects.GameObject[]}
         * @private
         * @default []
         * @since 3.0.0
         */this._pendingInsertion=[],/**
         * Objects waiting to be removed from the list on the next call to 'begin'.
         *
         * @name Phaser.Input.InputPlugin#_pendingRemoval
         * @type {Phaser.GameObjects.GameObject[]}
         * @private
         * @default []
         * @since 3.0.0
         */this._pendingRemoval=[],/**
         * A list of all Game Objects that have been enabled for dragging.
         *
         * @name Phaser.Input.InputPlugin#_draggable
         * @type {Phaser.GameObjects.GameObject[]}
         * @private
         * @default []
         * @since 3.0.0
         */this._draggable=[],/**
         * A list of all Interactive Objects currently considered as being 'draggable' by any pointer, indexed by pointer ID.
         *
         * @name Phaser.Input.InputPlugin#_drag
         * @type {{0:Array,1:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array,10:Array}}
         * @private
         * @since 3.0.0
         */this._drag={0:[],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[]},/**
         * A array containing the dragStates, for this Scene, index by the Pointer ID.
         *
         * @name Phaser.Input.InputPlugin#_dragState
         * @type {integer[]}
         * @private
         * @since 3.16.0
         */this._dragState=[],/**
         * A list of all Interactive Objects currently considered as being 'over' by any pointer, indexed by pointer ID.
         *
         * @name Phaser.Input.InputPlugin#_over
         * @type {{0:Array,1:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array,10:Array}}
         * @private
         * @since 3.0.0
         */this._over={0:[],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[],10:[]},/**
         * A list of valid DOM event types.
         *
         * @name Phaser.Input.InputPlugin#_validTypes
         * @type {string[]}
         * @private
         * @since 3.0.0
         */this._validTypes=["onDown","onUp","onOver","onOut","onMove","onDragStart","onDrag","onDragEnd","onDragEnter","onDragLeave","onDragOver","onDrop"],/**
         * Internal property that tracks frame event state.
         *
         * @name Phaser.Input.InputPlugin#_updatedThisFrame
         * @type {boolean}
         * @private
         * @since 3.18.0
         */this._updatedThisFrame=!1,t.sys.events.once(T.BOOT,this.boot,this),t.sys.events.on(T.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.Input.InputPlugin#boot
     * @fires Phaser.Input.Events#BOOT
     * @private
     * @since 3.5.1
     */boot:function(){this.cameras=this.systems.cameras,this.displayList=this.systems.displayList,this.systems.events.once(T.DESTROY,this.destroy,this),//  Registered input plugins listen for this
this.pluginEvents.emit(d.BOOT)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.Input.InputPlugin#start
     * @fires Phaser.Input.Events#START
     * @private
     * @since 3.5.0
     */start:function(){var t=this.systems.events;t.on(T.TRANSITION_START,this.transitionIn,this),t.on(T.TRANSITION_OUT,this.transitionOut,this),t.on(T.TRANSITION_COMPLETE,this.transitionComplete,this),t.on(T.PRE_UPDATE,this.preUpdate,this),t.once(T.SHUTDOWN,this.shutdown,this),this.manager.events.on(d.GAME_OUT,this.onGameOut,this),this.manager.events.on(d.GAME_OVER,this.onGameOver,this),this.enabled=!0,//  Populate the pointer drag states
this._dragState=[0,0,0,0,0,0,0,0,0,0],//  Registered input plugins listen for this
this.pluginEvents.emit(d.START)},/**
     * Game Over handler.
     *
     * @method Phaser.Input.InputPlugin#onGameOver
     * @fires Phaser.Input.Events#GAME_OVER
     * @private
     * @since 3.16.2
     */onGameOver:function(t){this.isActive()&&this.emit(d.GAME_OVER,t.timeStamp,t)},/**
     * Game Out handler.
     *
     * @method Phaser.Input.InputPlugin#onGameOut
     * @fires Phaser.Input.Events#GAME_OUT
     * @private
     * @since 3.16.2
     */onGameOut:function(t){this.isActive()&&this.emit(d.GAME_OUT,t.timeStamp,t)},/**
     * The pre-update handler is responsible for checking the pending removal and insertion lists and
     * deleting old Game Objects.
     *
     * @method Phaser.Input.InputPlugin#preUpdate
     * @private
     * @fires Phaser.Input.Events#PRE_UPDATE
     * @since 3.0.0
     */preUpdate:function(){//  Registered input plugins listen for this
this.pluginEvents.emit(d.PRE_UPDATE);var t=this._pendingRemoval,e=this._pendingInsertion,i=t.length,n=e.length;if(0!==i||0!==n){//  Delete old gameObjects
for(var s=this._list,r=0;r<i;r++){var o=t[r],a=s.indexOf(o);a>-1&&(s.splice(a,1),this.clear(o,!0))}//  Clear the removal list
t.length=0,this._pendingRemoval.length=0,//  Move pendingInsertion to list (also clears pendingInsertion at the same time)
this._list=s.concat(e.splice(0))}},/**
     * Checks to see if both this plugin and the Scene to which it belongs is active.
     *
     * @method Phaser.Input.InputPlugin#isActive
     * @since 3.10.0
     *
     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.
     */isActive:function(){return this.enabled&&this.scene.sys.isActive()},/**
     * This is called automatically by the Input Manager.
     * It emits events for plugins to listen to and also handles polling updates, if enabled.
     *
     * @method Phaser.Input.InputPlugin#updatePoll
     * @since 3.18.0
     *
     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     *
     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.
     */updatePoll:function(t,e){if(!this.isActive())return!1;//  We can leave now if we've already updated once this frame via the immediate DOM event handlers
if(//  The plugins should update every frame, regardless if there has been
//  any DOM input events or not (such as the Gamepad and Keyboard)
this.pluginEvents.emit(d.UPDATE,t,e),this._updatedThisFrame)return this._updatedThisFrame=!1,!1;var i,n=this.manager,s=n.pointers,r=n.pointersTotal;for(i=0;i<r;i++)s[i].updateMotion();//  No point going any further if there aren't any interactive objects
if(0===this._list.length)return!1;var o=this.pollRate;if(-1===o)return!1;if(o>0){if(this._pollTimer-=e,!(this._pollTimer<0))return!1;this._pollTimer=this.pollRate}//  We got this far? Then we should poll for movement
var a=!1;for(i=0;i<r;i++){var h=0,l=s[i];//  Always reset this array
this._tempZones=[],//  _temp contains a hit tested and camera culled list of IO objects
this._temp=this.hitTestPointer(l),this.sortGameObjects(this._temp),this.sortGameObjects(this._tempZones),this.topOnly&&(this._temp.length&&this._temp.splice(1),this._tempZones.length&&this._tempZones.splice(1)),h+=this.processOverOutEvents(l),2===this.getDragState(l)&&this.processDragThresholdEvent(l,t),h>0&&(a=!0)}return a},/**
     * This method is called when a DOM Event is received by the Input Manager. It handles dispatching the events
     * to relevant input enabled Game Objects in this scene.
     *
     * @method Phaser.Input.InputPlugin#update
     * @private
     * @fires Phaser.Input.Events#UPDATE
     * @since 3.0.0
     *
     * @param {integer} type - The type of event to process.
     * @param {Phaser.Input.Pointer[]} pointers - An array of Pointers on which the event occurred.
     *
     * @return {boolean} `true` if this Scene has captured the input events from all other Scenes, otherwise `false`.
     */update:function(t,e){if(!this.isActive())return!1;for(var i=e.length,n=!1,s=0;s<i;s++){var r=0,a=e[s];switch(//  Always reset this array
this._tempZones=[],//  _temp contains a hit tested and camera culled list of IO objects
this._temp=this.hitTestPointer(a),this.sortGameObjects(this._temp),this.sortGameObjects(this._tempZones),this.topOnly&&(this._temp.length&&this._temp.splice(1),this._tempZones.length&&this._tempZones.splice(1)),t){case o.MOUSE_DOWN:r+=this.processDragDownEvent(a)+this.processDownEvents(a)+this.processOverOutEvents(a);break;case o.MOUSE_UP:r+=this.processDragUpEvent(a)+this.processUpEvents(a)+this.processOverOutEvents(a);break;case o.TOUCH_START:r+=this.processDragDownEvent(a)+this.processDownEvents(a)+this.processOverEvents(a);break;case o.TOUCH_END:case o.TOUCH_CANCEL:r+=this.processDragUpEvent(a)+this.processUpEvents(a)+this.processOutEvents(a);break;case o.MOUSE_MOVE:case o.TOUCH_MOVE:r+=this.processDragMoveEvent(a)+this.processMoveEvents(a)+this.processOverOutEvents(a);break;case o.MOUSE_WHEEL:r+=this.processWheelEvent(a)}r>0&&(n=!0)}return this._updatedThisFrame=!0,n},/**
     * Clears a Game Object so it no longer has an Interactive Object associated with it.
     * The Game Object is then queued for removal from the Input Plugin on the next update.
     *
     * @method Phaser.Input.InputPlugin#clear
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will have its Interactive Object removed.
     * @param {boolean} [skipQueue=false] - Skip adding this Game Object into the removal queue?
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that had its Interactive Object removed.
     */clear:function(t,e){void 0===e&&(e=!1);var i=t.input;// If GameObject.input already cleared from higher class
if(i){e||this.queueForRemoval(t),i.gameObject=void 0,i.target=void 0,i.hitArea=void 0,i.hitAreaCallback=void 0,i.callbackContext=void 0,this.manager.resetCursor(i),t.input=null;//  Clear from _draggable, _drag and _over
var n=this._draggable.indexOf(t);return n>-1&&this._draggable.splice(n,1),(n=this._drag[0].indexOf(t))>-1&&this._drag[0].splice(n,1),(n=this._over[0].indexOf(t))>-1&&this._over[0].splice(n,1),t}},/**
     * Disables Input on a single Game Object.
     *
     * An input disabled Game Object still retains its Interactive Object component and can be re-enabled
     * at any time, by passing it to `InputPlugin.enable`.
     *
     * @method Phaser.Input.InputPlugin#disable
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to have its input system disabled.
     */disable:function(t){t.input.enabled=!1},/**
     * Enable a Game Object for interaction.
     *
     * If the Game Object already has an Interactive Object component, it is enabled and returned.
     *
     * Otherwise, a new Interactive Object component is created and assigned to the Game Object's `input` property.
     *
     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area
     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced
     * input detection.
     *
     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If
     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific
     * shape for it to use.
     *
     * You can also provide an Input Configuration Object as the only argument to this method.
     *
     * @method Phaser.Input.InputPlugin#enable
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to be enabled for input.
     * @param {(Phaser.Types.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.
     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The 'contains' function to invoke to check if the pointer is within the hit area.
     * @param {boolean} [dropZone=false] - Is this Game Object a drop zone or not?
     *
     * @return {this} This Input Plugin.
     */enable:function(t,e,i,n){return void 0===n&&(n=!1),t.input?t.input.enabled=!0:this.setHitArea(t,e,i),t.input&&n&&!t.input.dropZone&&(t.input.dropZone=n),this},/**
     * Takes the given Pointer and performs a hit test against it, to see which interactive Game Objects
     * it is currently above.
     *
     * The hit test is performed against which-ever Camera the Pointer is over. If it is over multiple
     * cameras, it starts checking the camera at the top of the camera list, and if nothing is found, iterates down the list.
     *
     * @method Phaser.Input.InputPlugin#hitTestPointer
     * @since 3.0.0
     *
     * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.
     *
     * @return {Phaser.GameObjects.GameObject[]} An array of all the interactive Game Objects the Pointer was above.
     */hitTestPointer:function(t){for(var e=this.cameras.getCamerasBelowPointer(t),i=0;i<e.length;i++){//  Filter out the drop zones
for(var n=e[i],s=this.manager.hitTest(t,this._list,n),r=0;r<s.length;r++){var o=s[r];o.input.dropZone&&this._tempZones.push(o)}if(s.length>0)return t.camera=n,s}return(//  If we got this far then there were no Game Objects below the pointer, but it was still over
//  a camera, so set that the top-most one into the pointer
t.camera=e[0],[])},/**
     * An internal method that handles the Pointer down event.
     *
     * @method Phaser.Input.InputPlugin#processDownEvents
     * @private
     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_DOWN
     * @fires Phaser.Input.Events#GAMEOBJECT_DOWN
     * @fires Phaser.Input.Events#POINTER_DOWN
     * @fires Phaser.Input.Events#POINTER_DOWN_OUTSIDE
     * @since 3.0.0
     *
     * @param {Phaser.Input.Pointer} pointer - The Pointer being tested.
     *
     * @return {integer} The total number of objects interacted with.
     */processDownEvents:function(t){var e=0,i=this._temp,n=this._eventData,s=this._eventContainer;n.cancelled=!1;//  Go through all objects the pointer was over and fire their events / callbacks
for(var r=!1,o=0;o<i.length;o++){var a=i[o];if(a.input&&(e++,a.emit(d.GAMEOBJECT_POINTER_DOWN,t,a.input.localX,a.input.localY,s),n.cancelled||!a.input||(this.emit(d.GAMEOBJECT_DOWN,t,a,s),n.cancelled||!a.input))){r=!0;break}}return!r&&this.manager&&(t.downElement===this.manager.game.canvas?this.emit(d.POINTER_DOWN,t,i):this.emit(d.POINTER_DOWN_OUTSIDE,t)),e},/**
     * Returns the drag state of the given Pointer for this Input Plugin.
     *
     * The state will be one of the following:
     *
     * 0 = Not dragging anything
     * 1 = Primary button down and objects below, so collect a draglist
     * 2 = Pointer being checked if meets drag criteria
     * 3 = Pointer meets criteria, notify the draglist
     * 4 = Pointer actively dragging the draglist and has moved
     * 5 = Pointer actively dragging but has been released, notify draglist
     *
     * @method Phaser.Input.InputPlugin#getDragState
     * @since 3.16.0
     *
     * @param {Phaser.Input.Pointer} pointer - The Pointer to get the drag state for.
     *
     * @return {integer} The drag state of the given Pointer.
     */getDragState:function(t){return this._dragState[t.id]},/**
     * Sets the drag state of the given Pointer for this Input Plugin.
     *
     * The state must be one of the following values:
     *
     * 0 = Not dragging anything
     * 1 = Primary button down and objects below, so collect a draglist
     * 2 = Pointer being checked if meets drag criteria
     * 3 = Pointer meets criteria, notify the draglist
     * 4 = Pointer actively dragging the draglist and has moved
     * 5 = Pointer actively dragging but has been released, notify draglist
     *
     * @method Phaser.Input.InputPlugin#setDragState
     * @since 3.16.0
     *
     * @param {Phaser.Input.Pointer} pointer - The Pointer to set the drag state for.
     * @param {integer} state - The drag state value. An integer between 0 and 5.
     */setDragState:function(t,e){this._dragState[t.id]=e},/**
     * Checks to see if a Pointer is ready to drag the objects below it, based on either a distance
     * or time threshold.
     *
     * @method Phaser.Input.InputPlugin#processDragThresholdEvent
     * @private
     * @since 3.18.0
     *
     * @param {Phaser.Input.Pointer} pointer - The Pointer to check the drag thresholds on.
     * @param {number} time - The current time.
     */processDragThresholdEvent:function(t,e){var i=!1,n=this.dragTimeThreshold,s=this.dragDistanceThreshold;if(s>0&&l(t.x,t.y,t.downX,t.downY)>=s?i=!0:n>0&&e>=t.downTime+n&&(i=!0),i)return this.setDragState(t,3),this.processDragStartList(t)},/**
     * Processes the drag list for the given pointer and dispatches the start events for each object on it.
     *
     * @method Phaser.Input.InputPlugin#processDragStartList
     * @private
     * @fires Phaser.Input.Events#DRAG_START
     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_START
     * @since 3.18.0
     *
     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.
     *
     * @return {integer} The number of items that DRAG_START was called on.
     */processDragStartList:function(t){//  3 = Pointer meets criteria and is freshly down, notify the draglist
if(3!==this.getDragState(t))return 0;for(var e=this._drag[t.id],i=0;i<e.length;i++){var n=e[i],s=n.input;s.dragState=2,s.dragStartX=n.x,s.dragStartY=n.y,s.dragStartXGlobal=t.x,s.dragStartYGlobal=t.y,s.dragX=s.dragStartXGlobal-s.dragStartX,s.dragY=s.dragStartYGlobal-s.dragStartY,n.emit(d.GAMEOBJECT_DRAG_START,t,s.dragX,s.dragY),this.emit(d.DRAG_START,t,n)}return this.setDragState(t,4),e.length},/**
     * Processes a 'drag down' event for the given pointer. Checks the pointer state, builds-up the drag list
     * and prepares them all for interaction.
     *
     * @method Phaser.Input.InputPlugin#processDragDownEvent
     * @private
     * @since 3.18.0
     *
     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.
     *
     * @return {integer} The number of items that were collected on the drag list.
     */processDragDownEvent:function(t){var e=this._temp;if(0===this._draggable.length||0===e.length||!t.primaryDown||0!==this.getDragState(t))return 0;//  1 = Primary button down and objects below, so collect a draglist
this.setDragState(t,1);for(var i=[],n=0;n<e.length;n++){var s=e[n];s.input.draggable&&0===s.input.dragState&&i.push(s)}return 0===i.length?(this.setDragState(t,0),0):(i.length>1&&(this.sortGameObjects(i),this.topOnly&&i.splice(1)),//  draglist now contains all potential candidates for dragging
this._drag[t.id]=i,0===this.dragDistanceThreshold&&0===this.dragTimeThreshold)?(//  No drag criteria, so snap immediately to mode 3
this.setDragState(t,3),this.processDragStartList(t)):(//  Check the distance / time on the next event
this.setDragState(t,2),0)},/**
     * Processes a 'drag move' event for the given pointer.
     *
     * @method Phaser.Input.InputPlugin#processDragMoveEvent
     * @private
     * @fires Phaser.Input.Events#DRAG_ENTER
     * @fires Phaser.Input.Events#DRAG
     * @fires Phaser.Input.Events#DRAG_LEAVE
     * @fires Phaser.Input.Events#DRAG_OVER
     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_ENTER
     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG
     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_LEAVE
     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_OVER
     * @since 3.18.0
     *
     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.
     *
     * @return {integer} The number of items that were updated by this drag event.
     */processDragMoveEvent:function(t){if(2===this.getDragState(t)&&this.processDragThresholdEvent(t,this.manager.game.loop.now),4!==this.getDragState(t))return 0;for(var e=this._tempZones,i=this._drag[t.id],n=0;n<i.length;n++){var s,r,o=i[n],a=o.input,h=a.target;//  If this GO has a target then let's check it
if(h){var l=e.indexOf(h);//  Got a target, are we still over it?
0===l?(//  We're still over it, and it's still the top of the display list, phew ...
o.emit(d.GAMEOBJECT_DRAG_OVER,t,h),this.emit(d.DRAG_OVER,t,o,h)):l>0?(//  Still over it but it's no longer top of the display list (targets must always be at the top)
o.emit(d.GAMEOBJECT_DRAG_LEAVE,t,h),this.emit(d.DRAG_LEAVE,t,o,h),a.target=e[0],h=a.target,o.emit(d.GAMEOBJECT_DRAG_ENTER,t,h),this.emit(d.DRAG_ENTER,t,o,h)):(//  Nope, we've moved on (or the target has!), leave the old target
o.emit(d.GAMEOBJECT_DRAG_LEAVE,t,h),this.emit(d.DRAG_LEAVE,t,o,h),e[0]?(a.target=e[0],h=a.target,o.emit(d.GAMEOBJECT_DRAG_ENTER,t,h),this.emit(d.DRAG_ENTER,t,o,h)):a.target=null)}else!h&&e[0]&&(a.target=e[0],h=a.target,o.emit(d.GAMEOBJECT_DRAG_ENTER,t,h),this.emit(d.DRAG_ENTER,t,o,h));if(o.parentContainer){var u=t.x-a.dragStartXGlobal,c=t.y-a.dragStartYGlobal,f=o.getParentRotation(),p=u*Math.cos(f)+c*Math.sin(f),g=c*Math.cos(f)-u*Math.sin(f);p*=1/o.parentContainer.scaleX,g*=1/o.parentContainer.scaleY,s=p+a.dragStartX,r=g+a.dragStartY}else s=t.x-a.dragX,r=t.y-a.dragY;o.emit(d.GAMEOBJECT_DRAG,t,s,r),this.emit(d.DRAG,t,o,s,r)}return i.length},/**
     * Processes a 'drag down' event for the given pointer. Checks the pointer state, builds-up the drag list
     * and prepares them all for interaction.
     *
     * @method Phaser.Input.InputPlugin#processDragUpEvent
     * @fires Phaser.Input.Events#DRAG_END
     * @fires Phaser.Input.Events#DROP
     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_END
     * @fires Phaser.Input.Events#GAMEOBJECT_DROP
     * @private
     * @since 3.18.0
     *
     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.
     *
     * @return {integer} The number of items that were updated by this drag event.
     */processDragUpEvent:function(t){for(var e=this._drag[t.id],i=0;i<e.length;i++){var n=e[i],s=n.input;if(s&&2===s.dragState){s.dragState=0,s.dragX=s.localX-n.displayOriginX,s.dragY=s.localY-n.displayOriginY;var r=!1,o=s.target;o&&(n.emit(d.GAMEOBJECT_DROP,t,o),this.emit(d.DROP,t,n,o),s.target=null,r=!0),n.input&&(n.emit(d.GAMEOBJECT_DRAG_END,t,s.dragX,s.dragY,r),this.emit(d.DRAG_END,t,n,r))}}return this.setDragState(t,0),e.splice(0),0},/**
     * An internal method that handles the Pointer movement event.
     *
     * @method Phaser.Input.InputPlugin#processMoveEvents
     * @private
     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_MOVE
     * @fires Phaser.Input.Events#GAMEOBJECT_MOVE
     * @fires Phaser.Input.Events#POINTER_MOVE
     * @since 3.0.0
     *
     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.
     *
     * @return {integer} The total number of objects interacted with.
     */processMoveEvents:function(t){var e=0,i=this._temp,n=this._eventData,s=this._eventContainer;n.cancelled=!1;//  Go through all objects the pointer was over and fire their events / callbacks
for(var r=!1,o=0;o<i.length;o++){var a=i[o];if(a.input){if(e++,a.emit(d.GAMEOBJECT_POINTER_MOVE,t,a.input.localX,a.input.localY,s),n.cancelled||!a.input||(this.emit(d.GAMEOBJECT_MOVE,t,a,s),n.cancelled||!a.input)){r=!0;break}if(this.topOnly)break}}return r||this.emit(d.POINTER_MOVE,t,i),e},/**
     * An internal method that handles a mouse wheel event.
     *
     * @method Phaser.Input.InputPlugin#processWheelEvent
     * @private
     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_WHEEL
     * @fires Phaser.Input.Events#GAMEOBJECT_WHEEL
     * @fires Phaser.Input.Events#POINTER_WHEEL
     * @since 3.18.0
     *
     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.
     *
     * @return {integer} The total number of objects interacted with.
     */processWheelEvent:function(t){var e=0,i=this._temp,n=this._eventData,s=this._eventContainer;n.cancelled=!1;//  Go through all objects the pointer was over and fire their events / callbacks
for(var r=!1,o=t.deltaX,a=t.deltaY,h=t.deltaZ,l=0;l<i.length;l++){var u=i[l];if(u.input&&(e++,u.emit(d.GAMEOBJECT_POINTER_WHEEL,t,o,a,h,s),n.cancelled||!u.input||(this.emit(d.GAMEOBJECT_WHEEL,t,u,o,a,h,s),n.cancelled||!u.input))){r=!0;break}}return r||this.emit(d.POINTER_WHEEL,t,i,o,a,h),e},/**
     * An internal method that handles the Pointer over events.
     * This is called when a touch input hits the canvas, having previously been off of it.
     *
     * @method Phaser.Input.InputPlugin#processOverEvents
     * @private
     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER
     * @fires Phaser.Input.Events#GAMEOBJECT_OVER
     * @fires Phaser.Input.Events#POINTER_OVER
     * @since 3.18.0
     *
     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.
     *
     * @return {integer} The total number of objects interacted with.
     */processOverEvents:function(t){var e=this._temp,i=0,n=e.length,s=[];if(n>0){var r=this.manager,o=this._eventData,a=this._eventContainer;o.cancelled=!1;for(var h=!1,l=0;l<n;l++){var u=e[l];if(u.input&&(s.push(u),r.setCursor(u.input),u.emit(d.GAMEOBJECT_POINTER_OVER,t,u.input.localX,u.input.localY,a),i++,o.cancelled||!u.input||(this.emit(d.GAMEOBJECT_OVER,t,u,a),o.cancelled||!u.input))){h=!0;break}}h||this.emit(d.POINTER_OVER,t,s)}return(//  Then sort it into display list order
this._over[t.id]=s,i)},/**
     * An internal method that handles the Pointer out events.
     * This is called when a touch input leaves the canvas, as it can never be 'over' in this case.
     *
     * @method Phaser.Input.InputPlugin#processOutEvents
     * @private
     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT
     * @fires Phaser.Input.Events#GAMEOBJECT_OUT
     * @fires Phaser.Input.Events#POINTER_OUT
     * @since 3.18.0
     *
     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.
     *
     * @return {integer} The total number of objects interacted with.
     */processOutEvents:function(t){var e=this._over[t.id],i=0,n=e.length;if(n>0){var s=this.manager,r=this._eventData,o=this._eventContainer;r.cancelled=!1;var a=!1;this.sortGameObjects(e);for(var h=0;h<n;h++){var l=e[h];//  Call onOut for everything in the previouslyOver array
for(h=0;h<n;h++)if((l=e[h]).input&&(s.resetCursor(l.input),l.emit(d.GAMEOBJECT_POINTER_OUT,t,o),i++,r.cancelled||!l.input||(this.emit(d.GAMEOBJECT_OUT,t,l,o),r.cancelled||!l.input))){a=!0;break}a||this.emit(d.POINTER_OUT,t,e)}this._over[t.id]=[]}return i},/**
     * An internal method that handles the Pointer over and out events.
     *
     * @method Phaser.Input.InputPlugin#processOverOutEvents
     * @private
     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER
     * @fires Phaser.Input.Events#GAMEOBJECT_OVER
     * @fires Phaser.Input.Events#POINTER_OVER
     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT
     * @fires Phaser.Input.Events#GAMEOBJECT_OUT
     * @fires Phaser.Input.Events#POINTER_OUT
     * @since 3.0.0
     *
     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.
     *
     * @return {integer} The total number of objects interacted with.
     */processOverOutEvents:function(t){var e,i,n=this._temp,s=[],r=[],o=[],a=this._over[t.id],h=this._drag[t.id],l=this.manager;//  Go through all objects the pointer was previously over, and see if it still is.
//  Splits the previouslyOver array into two parts: justOut and stillOver
for(e=0;e<a.length;e++)i=a[e],-1===n.indexOf(i)&&-1===h.indexOf(i)?s.push(i):o.push(i);//  Go through all objects the pointer is currently over (the hit test results)
//  and if not in the previouslyOver array we know it's a new entry, so add to justOver
for(e=0;e<n.length;e++)i=n[e],-1===a.indexOf(i)&&r.push(i);//  By this point the arrays are filled, so now we can process what happened...
//  Process the Just Out objects
var u=s.length,c=0,f=this._eventData,p=this._eventContainer;f.cancelled=!1;var g=!1;if(u>0){//  Call onOut for everything in the justOut array
for(this.sortGameObjects(s),e=0;e<u;e++)if((i=s[e]).input&&(//  Reset cursor before we emit the event, in case they want to change it during the event
l.resetCursor(i.input),i.emit(d.GAMEOBJECT_POINTER_OUT,t,p),c++,f.cancelled||!i.input||(this.emit(d.GAMEOBJECT_OUT,t,i,p),f.cancelled||!i.input))){g=!0;break}g||this.emit(d.POINTER_OUT,t,s)}if(//  Process the Just Over objects
u=r.length,f.cancelled=!1,g=!1,u>0){//  Call onOver for everything in the justOver array
for(this.sortGameObjects(r),e=0;e<u;e++)if((i=r[e]).input&&(//  Set cursor before we emit the event, in case they want to change it during the event
l.setCursor(i.input),i.emit(d.GAMEOBJECT_POINTER_OVER,t,i.input.localX,i.input.localY,p),c++,f.cancelled||!i.input||(this.emit(d.GAMEOBJECT_OVER,t,i,p),f.cancelled||!i.input))){g=!0;break}g||this.emit(d.POINTER_OVER,t,r)}return(//  Add the contents of justOver to the previously over array
a=o.concat(r),//  Then sort it into display list order
this._over[t.id]=this.sortGameObjects(a),c)},/**
     * An internal method that handles the Pointer up events.
     *
     * @method Phaser.Input.InputPlugin#processUpEvents
     * @private
     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_UP
     * @fires Phaser.Input.Events#GAMEOBJECT_UP
     * @fires Phaser.Input.Events#POINTER_UP
     * @fires Phaser.Input.Events#POINTER_UP_OUTSIDE
     * @since 3.0.0
     *
     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.
     *
     * @return {integer} The total number of objects interacted with.
     */processUpEvents:function(t){var e=this._temp,i=this._eventData,n=this._eventContainer;i.cancelled=!1;//  Go through all objects the pointer was over and fire their events / callbacks
for(var s=!1,r=0;r<e.length;r++){var o=e[r];if(o.input&&(o.emit(d.GAMEOBJECT_POINTER_UP,t,o.input.localX,o.input.localY,n),i.cancelled||!o.input||(this.emit(d.GAMEOBJECT_UP,t,o,n),i.cancelled||!o.input))){s=!0;break}}return!s&&this.manager&&(t.upElement===this.manager.game.canvas?this.emit(d.POINTER_UP,t,e):this.emit(d.POINTER_UP_OUTSIDE,t)),e.length},/**
     * Queues a Game Object for insertion into this Input Plugin on the next update.
     *
     * @method Phaser.Input.InputPlugin#queueForInsertion
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.
     *
     * @return {this} This InputPlugin object.
     */queueForInsertion:function(t){return -1===this._pendingInsertion.indexOf(t)&&-1===this._list.indexOf(t)&&this._pendingInsertion.push(t),this},/**
     * Queues a Game Object for removal from this Input Plugin on the next update.
     *
     * @method Phaser.Input.InputPlugin#queueForRemoval
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.
     *
     * @return {this} This InputPlugin object.
     */queueForRemoval:function(t){return this._pendingRemoval.push(t),this},/**
     * Sets the draggable state of the given array of Game Objects.
     *
     * They can either be set to be draggable, or can have their draggable state removed by passing `false`.
     *
     * A Game Object will not fire drag events unless it has been specifically enabled for drag.
     *
     * @method Phaser.Input.InputPlugin#setDraggable
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to change the draggable state on.
     * @param {boolean} [value=true] - Set to `true` if the Game Objects should be made draggable, `false` if they should be unset.
     *
     * @return {this} This InputPlugin object.
     */setDraggable:function(t,e){void 0===e&&(e=!0),Array.isArray(t)||(t=[t]);for(var i=0;i<t.length;i++){var n=t[i];n.input.draggable=e;var s=this._draggable.indexOf(n);e&&-1===s?this._draggable.push(n):!e&&s>-1&&this._draggable.splice(s,1)}return this},/**
     * Creates a function that can be passed to `setInteractive`, `enable` or `setHitArea` that will handle
     * pixel-perfect input detection on an Image or Sprite based Game Object, or any custom class that extends them.
     *
     * The following will create a sprite that is clickable on any pixel that has an alpha value >= 1.
     *
     * ```javascript
     * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect());
     * ```
     *
     * The following will create a sprite that is clickable on any pixel that has an alpha value >= 150.
     *
     * ```javascript
     * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect(150));
     * ```
     *
     * Once you have made an Interactive Object pixel perfect it impacts all input related events for it: down, up,
     * dragstart, drag, etc.
     *
     * As a pointer interacts with the Game Object it will constantly poll the texture, extracting a single pixel from
     * the given coordinates and checking its color values. This is an expensive process, so should only be enabled on
     * Game Objects that really need it.
     *
     * You cannot make non-texture based Game Objects pixel perfect. So this will not work on Graphics, BitmapText,
     * Render Textures, Text, Tilemaps, Containers or Particles.
     *
     * @method Phaser.Input.InputPlugin#makePixelPerfect
     * @since 3.10.0
     *
     * @param {integer} [alphaTolerance=1] - The alpha level that the pixel should be above to be included as a successful interaction.
     *
     * @return {function} A Pixel Perfect Handler for use as a hitArea shape callback.
     */makePixelPerfect:function(t){return void 0===t&&(t=1),h(this.systems.textures,t)},/**
     * Sets the hit area for the given array of Game Objects.
     *
     * A hit area is typically one of the geometric shapes Phaser provides, such as a `Phaser.Geom.Rectangle`
     * or `Phaser.Geom.Circle`. However, it can be any object as long as it works with the provided callback.
     *
     * If no hit area is provided a Rectangle is created based on the size of the Game Object, if possible
     * to calculate.
     *
     * The hit area callback is the function that takes an `x` and `y` coordinate and returns a boolean if
     * those values fall within the area of the shape or not. All of the Phaser geometry objects provide this,
     * such as `Phaser.Geom.Rectangle.Contains`.
     *
     * @method Phaser.Input.InputPlugin#setHitArea
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set the hit area on.
     * @param {(Phaser.Types.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.
     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The 'contains' function to invoke to check if the pointer is within the hit area.
     *
     * @return {this} This InputPlugin object.
     */setHitArea:function(t,e,i){if(void 0===e)return this.setHitAreaFromTexture(t);Array.isArray(t)||(t=[t]);var n=!1,s=!1,r=!1,o=!1,h=!1,l=!0;//  Config object?
if(m(e)){var u=e;e=p(u,"hitArea",null),i=p(u,"hitAreaCallback",null),n=p(u,"draggable",!1),s=p(u,"dropZone",!1),r=p(u,"cursor",!1),o=p(u,"useHandCursor",!1),h=p(u,"pixelPerfect",!1);var c=p(u,"alphaTolerance",1);h&&(e={},i=this.makePixelPerfect(c)),e&&i||(this.setHitAreaFromTexture(t),l=!1)}else"function"!=typeof e||i||(i=e,e={});for(var d=0;d<t.length;d++){var f=t[d];if(h&&"Container"===f.type){console.warn("Cannot pixelPerfect test a Container. Use a custom callback.");continue}var g=f.input?f.input:a(f,e,i);g.customHitArea=l,g.dropZone=s,g.cursor=o?"pointer":r,f.input=g,n&&this.setDraggable(f),this.queueForInsertion(f)}return this},/**
     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Circle` shape, using
     * the given coordinates and radius to control its position and size.
     *
     * @method Phaser.Input.InputPlugin#setHitAreaCircle
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a circle hit area.
     * @param {number} x - The center of the circle.
     * @param {number} y - The center of the circle.
     * @param {number} radius - The radius of the circle.
     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Circle.Contains.
     *
     * @return {this} This InputPlugin object.
     */setHitAreaCircle:function(t,e,s,r,o){void 0===o&&(o=n);var a=new i(e,s,r);return this.setHitArea(t,a,o)},/**
     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Ellipse` shape, using
     * the given coordinates and dimensions to control its position and size.
     *
     * @method Phaser.Input.InputPlugin#setHitAreaEllipse
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.
     * @param {number} x - The center of the ellipse.
     * @param {number} y - The center of the ellipse.
     * @param {number} width - The width of the ellipse.
     * @param {number} height - The height of the ellipse.
     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Ellipse.Contains.
     *
     * @return {this} This InputPlugin object.
     */setHitAreaEllipse:function(t,e,i,n,s,r){void 0===r&&(r=c);var o=new u(e,i,n,s);return this.setHitArea(t,o,r)},/**
     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using
     * the Game Objects texture frame to define the position and size of the hit area.
     *
     * @method Phaser.Input.InputPlugin#setHitAreaFromTexture
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.
     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.
     *
     * @return {this} This InputPlugin object.
     */setHitAreaFromTexture:function(t,e){void 0===e&&(e=w),Array.isArray(t)||(t=[t]);for(var i=0;i<t.length;i++){var n=t[i],s=n.frame,r=0,o=0;if(n.width?(r=n.width,o=n.height):s&&(r=s.realWidth,o=s.realHeight),"Container"===n.type&&(0===r||0===o)){console.warn("Container.setInteractive must specify a Shape or call setSize() first");continue}0!==r&&0!==o&&(n.input=a(n,new x(0,0,r,o),e),this.queueForInsertion(n))}return this},/**
     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using
     * the given coordinates and dimensions to control its position and size.
     *
     * @method Phaser.Input.InputPlugin#setHitAreaRectangle
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a rectangular hit area.
     * @param {number} x - The top-left of the rectangle.
     * @param {number} y - The top-left of the rectangle.
     * @param {number} width - The width of the rectangle.
     * @param {number} height - The height of the rectangle.
     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.
     *
     * @return {this} This InputPlugin object.
     */setHitAreaRectangle:function(t,e,i,n,s,r){void 0===r&&(r=w);var o=new x(e,i,n,s);return this.setHitArea(t,o,r)},/**
     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Triangle` shape, using
     * the given coordinates to control the position of its points.
     *
     * @method Phaser.Input.InputPlugin#setHitAreaTriangle
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a  triangular hit area.
     * @param {number} x1 - The x coordinate of the first point of the triangle.
     * @param {number} y1 - The y coordinate of the first point of the triangle.
     * @param {number} x2 - The x coordinate of the second point of the triangle.
     * @param {number} y2 - The y coordinate of the second point of the triangle.
     * @param {number} x3 - The x coordinate of the third point of the triangle.
     * @param {number} y3 - The y coordinate of the third point of the triangle.
     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Triangle.Contains.
     *
     * @return {this} This InputPlugin object.
     */setHitAreaTriangle:function(t,e,i,n,s,r,o,a){void 0===a&&(a=S);var h=new b(e,i,n,s,r,o);return this.setHitArea(t,h,a)},/**
     * Creates an Input Debug Shape for the given Game Object.
     *
     * The Game Object must have _already_ been enabled for input prior to calling this method.
     *
     * This is intended to assist you during development and debugging.
     *
     * Debug Shapes can only be created for Game Objects that are using standard Phaser Geometry for input,
     * including: Circle, Ellipse, Line, Polygon, Rectangle and Triangle.
     *
     * Game Objects that are using their automatic hit areas are using Rectangles by default, so will also work.
     *
     * The Debug Shape is created and added to the display list and is then kept in sync with the Game Object
     * it is connected with. Should you need to modify it yourself, such as to hide it, you can access it via
     * the Game Object property: `GameObject.input.hitAreaDebug`.
     *
     * Calling this method on a Game Object that already has a Debug Shape will first destroy the old shape,
     * before creating a new one. If you wish to remove the Debug Shape entirely, you should call the
     * method `InputPlugin.removeDebug`.
     *
     * Note that the debug shape will only show the outline of the input area. If the input test is using a
     * pixel perfect check, for example, then this is not displayed. If you are using a custom shape, that
     * doesn't extend one of the base Phaser Geometry objects, as your hit area, then this method will not
     * work.
     *
     * @method Phaser.Input.InputPlugin#enableDebug
     * @since 3.19.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to create the input debug shape for.
     * @param {number} [color=0x00ff00] - The outline color of the debug shape.
     *
     * @return {this} This Input Plugin.
     */enableDebug:function(t,e){void 0===e&&(e=65280);var i=t.input;if(!i||!i.hitArea)return this;var n=i.hitArea,s=n.type,r=i.hitAreaDebug,o=this.systems.add,a=this.systems.updateList;r&&(a.remove(r),r.destroy(),r=null);var h=0,l=0;switch(s){case g.CIRCLE:r=o.arc(0,0,n.radius),h=n.x-n.radius,l=n.y-n.radius;break;case g.ELLIPSE:r=o.ellipse(0,0,n.width,n.height),h=n.x-n.width/2,l=n.y-n.height/2;break;case g.LINE:r=o.line(0,0,n.x1,n.y1,n.x2,n.y2);break;case g.POLYGON:r=o.polygon(0,0,n.points);break;case g.RECTANGLE:r=o.rectangle(0,0,n.width,n.height),h=n.x,l=n.y;break;case g.TRIANGLE:r=o.triangle(0,0,n.x1,n.y1,n.x2,n.y2,n.x3,n.y3)}return r&&(r.isFilled=!1,r.preUpdate=function(){r.setStrokeStyle(1/t.scale,e),r.setDisplayOrigin(t.displayOriginX,t.displayOriginY);var i=t.x,n=t.y,s=t.rotation,o=t.scaleX,a=t.scaleY;if(t.parentContainer){var u=t.getWorldTransformMatrix();i=u.tx,n=u.ty,s=u.rotation,o=u.scaleX,a=u.scaleY}r.setRotation(s),r.setScale(o,a),r.setPosition(i+h,n+l),r.setScrollFactor(t.scrollFactorX,t.scrollFactorY),r.setDepth(t.depth)},a.add(r),i.hitAreaDebug=r),this},/**
     * Removes an Input Debug Shape from the given Game Object.
     *
     * The shape is destroyed immediately and the `hitAreaDebug` property is set to `null`.
     *
     * @method Phaser.Input.InputPlugin#removeDebug
     * @since 3.19.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to remove the input debug shape from.
     *
     * @return {this} This Input Plugin.
     */removeDebug:function(t){var e=t.input;if(e&&e.hitAreaDebug){var i=e.hitAreaDebug;this.systems.updateList.remove(i),i.destroy(),e.hitAreaDebug=null}return this},/**
     * Sets the Pointers to always poll.
     *
     * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,
     * or being interacted with it, regardless if the Pointer has actually moved or not.
     *
     * You should enable this if you want objects in your game to fire over / out events, and the objects
     * are constantly moving, but the pointer may not have. Polling every frame has additional computation
     * costs, especially if there are a large number of interactive objects in your game.
     *
     * @method Phaser.Input.InputPlugin#setPollAlways
     * @since 3.0.0
     *
     * @return {this} This InputPlugin object.
     */setPollAlways:function(){return this.setPollRate(0)},/**
     * Sets the Pointers to only poll when they are moved or updated.
     *
     * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,
     * or being interacted with it.
     *
     * @method Phaser.Input.InputPlugin#setPollOnMove
     * @since 3.0.0
     *
     * @return {this} This InputPlugin object.
     */setPollOnMove:function(){return this.setPollRate(-1)},/**
     * Sets the poll rate value. This is the amount of time that should have elapsed before a pointer
     * will be polled again. See the `setPollAlways` and `setPollOnMove` methods.
     *
     * @method Phaser.Input.InputPlugin#setPollRate
     * @since 3.0.0
     *
     * @param {number} value - The amount of time, in ms, that should elapsed before re-polling the pointers.
     *
     * @return {this} This InputPlugin object.
     */setPollRate:function(t){return this.pollRate=t,this._pollTimer=0,this},/**
     * When set to `true` the global Input Manager will emulate DOM behavior by only emitting events from
     * the top-most Scene in the Scene List. By default, if a Scene receives an input event it will then stop the event
     * from flowing down to any Scenes below it in the Scene list. To disable this behavior call this method with `false`.
     *
     * @method Phaser.Input.InputPlugin#setGlobalTopOnly
     * @since 3.0.0
     *
     * @param {boolean} value - Set to `true` to stop processing input events on the Scene that receives it, or `false` to let the event continue down the Scene list.
     *
     * @return {this} This InputPlugin object.
     */setGlobalTopOnly:function(t){return this.manager.globalTopOnly=t,this},/**
     * When set to `true` this Input Plugin will emulate DOM behavior by only emitting events from
     * the top-most Game Objects in the Display List.
     *
     * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.
     *
     * @method Phaser.Input.InputPlugin#setTopOnly
     * @since 3.0.0
     *
     * @param {boolean} value - `true` to only include the top-most Game Object, or `false` to include all Game Objects in a hit test.
     *
     * @return {this} This InputPlugin object.
     */setTopOnly:function(t){return this.topOnly=t,this},/**
     * Given an array of Game Objects, sort the array and return it, so that the objects are in depth index order
     * with the lowest at the bottom.
     *
     * @method Phaser.Input.InputPlugin#sortGameObjects
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject[]} gameObjects - An array of Game Objects to be sorted.
     *
     * @return {Phaser.GameObjects.GameObject[]} The sorted array of Game Objects.
     */sortGameObjects:function(t){return t.length<2?t:(this.scene.sys.depthSort(),t.sort(this.sortHandlerGO.bind(this)))},/**
     * Return the child lowest down the display list (with the smallest index)
     * Will iterate through all parent containers, if present.
     *
     * @method Phaser.Input.InputPlugin#sortHandlerGO
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} childA - The first Game Object to compare.
     * @param {Phaser.GameObjects.GameObject} childB - The second Game Object to compare.
     *
     * @return {integer} Returns either a negative or positive integer, or zero if they match.
     */sortHandlerGO:function(t,e){if(!t.parentContainer&&!e.parentContainer)return this.displayList.getIndex(e)-this.displayList.getIndex(t);if(t.parentContainer===e.parentContainer)return e.parentContainer.getIndex(e)-t.parentContainer.getIndex(t);if(t.parentContainer===e)return -1;if(e.parentContainer===t)return 1;for(var i=t.getIndexList(),n=e.getIndexList(),s=Math.min(i.length,n.length),r=0;r<s;r++){var o=i[r],a=n[r];if(o!==a)return a-o}return n.length-i.length},/**
     * This method should be called from within an input event handler, such as `pointerdown`.
     *
     * When called, it stops the Input Manager from allowing _this specific event_ to be processed by any other Scene
     * not yet handled in the scene list.
     *
     * @method Phaser.Input.InputPlugin#stopPropagation
     * @since 3.0.0
     *
     * @return {this} This InputPlugin object.
     */stopPropagation:function(){return this.manager._tempSkip=!0,this},/**
     * Adds new Pointer objects to the Input Manager.
     *
     * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.
     *
     * You can create more either by calling this method, or by setting the `input.activePointers` property
     * in the Game Config, up to a maximum of 10 pointers.
     *
     * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added
     * via this method.
     *
     * @method Phaser.Input.InputPlugin#addPointer
     * @since 3.10.0
     *
     * @param {integer} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.
     *
     * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.
     */addPointer:function(t){return this.manager.addPointer(t)},/**
     * Tells the Input system to set a custom cursor.
     *
     * This cursor will be the default cursor used when interacting with the game canvas.
     *
     * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.
     *
     * Any valid CSS cursor value is allowed, including paths to image files, i.e.:
     *
     * ```javascript
     * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');
     * ```
     *
     * Please read about the differences between browsers when it comes to the file formats and sizes they support:
     *
     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property
     *
     * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.
     *
     * @method Phaser.Input.InputPlugin#setDefaultCursor
     * @since 3.10.0
     *
     * @param {string} cursor - The CSS to be used when setting the default cursor.
     *
     * @return {this} This Input instance.
     */setDefaultCursor:function(t){return this.manager.setDefaultCursor(t),this},/**
     * The Scene that owns this plugin is transitioning in.
     *
     * @method Phaser.Input.InputPlugin#transitionIn
     * @private
     * @since 3.5.0
     */transitionIn:function(){this.enabled=this.settings.transitionAllowInput},/**
     * The Scene that owns this plugin has finished transitioning in.
     *
     * @method Phaser.Input.InputPlugin#transitionComplete
     * @private
     * @since 3.5.0
     */transitionComplete:function(){this.settings.transitionAllowInput||(this.enabled=!0)},/**
     * The Scene that owns this plugin is transitioning out.
     *
     * @method Phaser.Input.InputPlugin#transitionOut
     * @private
     * @since 3.5.0
     */transitionOut:function(){this.enabled=this.settings.transitionAllowInput},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.Input.InputPlugin#shutdown
     * @fires Phaser.Input.Events#SHUTDOWN
     * @private
     * @since 3.0.0
     */shutdown:function(){//  Registered input plugins listen for this
this.pluginEvents.emit(d.SHUTDOWN),this._temp.length=0,this._list.length=0,this._draggable.length=0,this._pendingRemoval.length=0,this._pendingInsertion.length=0,this._dragState.length=0;for(var t=0;t<10;t++)this._drag[t]=[],this._over[t]=[];this.removeAllListeners();var e=this.systems.events;e.off(T.TRANSITION_START,this.transitionIn,this),e.off(T.TRANSITION_OUT,this.transitionOut,this),e.off(T.TRANSITION_COMPLETE,this.transitionComplete,this),e.off(T.PRE_UPDATE,this.preUpdate,this),this.manager.events.off(d.GAME_OUT,this.onGameOut,this),this.manager.events.off(d.GAME_OVER,this.onGameOver,this),e.off(T.SHUTDOWN,this.shutdown,this)},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.Input.InputPlugin#destroy
     * @fires Phaser.Input.Events#DESTROY
     * @private
     * @since 3.0.0
     */destroy:function(){this.shutdown(),//  Registered input plugins listen for this
this.pluginEvents.emit(d.DESTROY),this.pluginEvents.removeAllListeners(),this.scene.sys.events.off(T.START,this.start,this),this.scene=null,this.cameras=null,this.manager=null,this.events=null,this.mouse=null},/**
     * The x coordinates of the ActivePointer based on the first camera in the camera list.
     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.
     *
     * @name Phaser.Input.InputPlugin#x
     * @type {number}
     * @readonly
     * @since 3.0.0
     */x:{get:function(){return this.manager.activePointer.x}},/**
     * The y coordinates of the ActivePointer based on the first camera in the camera list.
     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.
     *
     * @name Phaser.Input.InputPlugin#y
     * @type {number}
     * @readonly
     * @since 3.0.0
     */y:{get:function(){return this.manager.activePointer.y}},/**
     * Are any mouse or touch pointers currently over the game canvas?
     *
     * @name Phaser.Input.InputPlugin#isOver
     * @type {boolean}
     * @readonly
     * @since 3.16.0
     */isOver:{get:function(){return this.manager.isOver}},/**
     * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.
     * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`
     * which will always map to the most recently interacted pointer.
     *
     * @name Phaser.Input.InputPlugin#mousePointer
     * @type {Phaser.Input.Pointer}
     * @readonly
     * @since 3.10.0
     */mousePointer:{get:function(){return this.manager.mousePointer}},/**
     * The current active input Pointer.
     *
     * @name Phaser.Input.InputPlugin#activePointer
     * @type {Phaser.Input.Pointer}
     * @readonly
     * @since 3.0.0
     */activePointer:{get:function(){return this.manager.activePointer}},/**
     * A touch-based Pointer object.
     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
     *
     * @name Phaser.Input.InputPlugin#pointer1
     * @type {Phaser.Input.Pointer}
     * @readonly
     * @since 3.10.0
     */pointer1:{get:function(){return this.manager.pointers[1]}},/**
     * A touch-based Pointer object.
     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
     *
     * @name Phaser.Input.InputPlugin#pointer2
     * @type {Phaser.Input.Pointer}
     * @readonly
     * @since 3.10.0
     */pointer2:{get:function(){return this.manager.pointers[2]}},/**
     * A touch-based Pointer object.
     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
     *
     * @name Phaser.Input.InputPlugin#pointer3
     * @type {Phaser.Input.Pointer}
     * @readonly
     * @since 3.10.0
     */pointer3:{get:function(){return this.manager.pointers[3]}},/**
     * A touch-based Pointer object.
     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
     *
     * @name Phaser.Input.InputPlugin#pointer4
     * @type {Phaser.Input.Pointer}
     * @readonly
     * @since 3.10.0
     */pointer4:{get:function(){return this.manager.pointers[4]}},/**
     * A touch-based Pointer object.
     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
     *
     * @name Phaser.Input.InputPlugin#pointer5
     * @type {Phaser.Input.Pointer}
     * @readonly
     * @since 3.10.0
     */pointer5:{get:function(){return this.manager.pointers[5]}},/**
     * A touch-based Pointer object.
     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
     *
     * @name Phaser.Input.InputPlugin#pointer6
     * @type {Phaser.Input.Pointer}
     * @readonly
     * @since 3.10.0
     */pointer6:{get:function(){return this.manager.pointers[6]}},/**
     * A touch-based Pointer object.
     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
     *
     * @name Phaser.Input.InputPlugin#pointer7
     * @type {Phaser.Input.Pointer}
     * @readonly
     * @since 3.10.0
     */pointer7:{get:function(){return this.manager.pointers[7]}},/**
     * A touch-based Pointer object.
     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
     *
     * @name Phaser.Input.InputPlugin#pointer8
     * @type {Phaser.Input.Pointer}
     * @readonly
     * @since 3.10.0
     */pointer8:{get:function(){return this.manager.pointers[8]}},/**
     * A touch-based Pointer object.
     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
     *
     * @name Phaser.Input.InputPlugin#pointer9
     * @type {Phaser.Input.Pointer}
     * @readonly
     * @since 3.10.0
     */pointer9:{get:function(){return this.manager.pointers[9]}},/**
     * A touch-based Pointer object.
     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
     *
     * @name Phaser.Input.InputPlugin#pointer10
     * @type {Phaser.Input.Pointer}
     * @readonly
     * @since 3.10.0
     */pointer10:{get:function(){return this.manager.pointers[10]}}});y.register("InputPlugin",A,"input"),t.exports=A}),r("aFvH8",function(t,e){t.exports=function(t,e){return function(i,n,s,r){var o=t.getPixelAlpha(n,s,r.texture.key,r.frame.name);return o&&o>=e}}}),r("5em2R",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Input.Keyboard
 */t.exports={Events:s("ktuRg"),KeyboardManager:s("c0CF7"),KeyboardPlugin:s("c6rYT"),Key:s("dhUOR"),KeyCodes:s("hmrEO"),KeyCombo:s("9nAMT"),JustDown:s("4qXaU"),JustUp:s("69Yg3"),DownDuration:s("4fsjq"),UpDuration:s("7tfD5")}}),r("ktuRg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Input.Keyboard.Events
 */t.exports={ANY_KEY_DOWN:s("2bTcJ"),ANY_KEY_UP:s("ghfPO"),COMBO_MATCH:s("gYulO"),DOWN:s("1wYhT"),KEY_DOWN:s("8OSRB"),KEY_UP:s("dkiky"),UP:s("1ZtSU")}}),r("2bTcJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Global Key Down Event.
 * 
 * This event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.
 * 
 * Listen to this event from within a Scene using: `this.input.keyboard.on('keydown', listener)`.
 * 
 * You can also listen for a specific key being pressed. See [Keyboard.Events.KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_DOWN} for details.
 * 
 * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.
 * 
 * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.
 * Read [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.
 *
 * Also, please be aware that some browser extensions can disable or override Phaser keyboard handling.
 * For example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.
 * There are others. So, please check your extensions if you find you have specific keys that don't work.
 *
 * @event Phaser.Input.Keyboard.Events#ANY_KEY_DOWN
 * @since 3.0.0
 * 
 * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was pressed, any modifiers, etc.
 */t.exports="keydown"}),r("ghfPO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Global Key Up Event.
 * 
 * This event is dispatched by the Keyboard Plugin when any key on the keyboard is released.
 * 
 * Listen to this event from within a Scene using: `this.input.keyboard.on('keyup', listener)`.
 * 
 * You can also listen for a specific key being released. See [Keyboard.Events.KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_UP} for details.
 * 
 * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.
 *
 * @event Phaser.Input.Keyboard.Events#ANY_KEY_UP
 * @since 3.0.0
 * 
 * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was released, any modifiers, etc.
 */t.exports="keyup"}),r("gYulO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Key Combo Match Event.
 * 
 * This event is dispatched by the Keyboard Plugin when a [Key Combo]{@link Phaser.Input.Keyboard.KeyCombo} is matched.
 * 
 * Listen for this event from the Key Plugin after a combo has been created:
 * 
 * ```javascript
 * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });
 *
 * this.input.keyboard.on('keycombomatch', function (event) {
 *     console.log('Konami Code entered!');
 * });
 * ```
 *
 * @event Phaser.Input.Keyboard.Events#COMBO_MATCH
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Keyboard.KeyCombo} keycombo - The Key Combo object that was matched.
 * @param {KeyboardEvent} event - The native DOM Keyboard Event of the final key in the combo. You can inspect this to learn more about any modifiers, etc.
 */t.exports="keycombomatch"}),r("1wYhT",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Key Down Event.
 * 
 * This event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is pressed.
 * 
 * Listen for this event from the Key object instance directly:
 * 
 * ```javascript
 * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
 * 
 * spaceBar.on('down', listener)
 * ```
 * 
 * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.
 *
 * @event Phaser.Input.Keyboard.Events#DOWN
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Keyboard.Key} key - The Key object that was pressed.
 * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about any modifiers, etc.
 */t.exports="down"}),r("8OSRB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Key Down Event.
 * 
 * This event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.
 * 
 * Unlike the `ANY_KEY_DOWN` event, this one has a special dynamic event name. For example, to listen for the `A` key being pressed
 * use the following from within a Scene: `this.input.keyboard.on('keydown-A', listener)`. You can replace the `-A` part of the event
 * name with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar: 
 * `this.input.keyboard.on('keydown-SPACE', listener)`.
 * 
 * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.
 * 
 * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.
 * 
 * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.
 * Read [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.
 *
 * Also, please be aware that some browser extensions can disable or override Phaser keyboard handling.
 * For example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.
 * There are others. So, please check your extensions if you find you have specific keys that don't work.
 *
 * @event Phaser.Input.Keyboard.Events#KEY_DOWN
 * @since 3.0.0
 * 
 * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was pressed, any modifiers, etc.
 */t.exports="keydown-"}),r("dkiky",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Key Up Event.
 * 
 * This event is dispatched by the Keyboard Plugin when any key on the keyboard is released.
 * 
 * Unlike the `ANY_KEY_UP` event, this one has a special dynamic event name. For example, to listen for the `A` key being released
 * use the following from within a Scene: `this.input.keyboard.on('keyup-A', listener)`. You can replace the `-A` part of the event
 * name with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar: 
 * `this.input.keyboard.on('keyup-SPACE', listener)`.
 * 
 * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.
 * 
 * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.
 *
 * @event Phaser.Input.Keyboard.Events#KEY_UP
 * @since 3.0.0
 * 
 * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was released, any modifiers, etc.
 */t.exports="keyup-"}),r("1ZtSU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Key Up Event.
 * 
 * This event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is released.
 * 
 * Listen for this event from the Key object instance directly:
 * 
 * ```javascript
 * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
 * 
 * spaceBar.on('up', listener)
 * ```
 * 
 * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.
 *
 * @event Phaser.Input.Keyboard.Events#UP
 * @since 3.0.0
 * 
 * @param {Phaser.Input.Keyboard.Key} key - The Key object that was released.
 * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about any modifiers, etc.
 */t.exports="up"}),r("c6rYT",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("3vRz3"),r=s("ktuRg"),o=s("aqcI1"),a=s("5pMDk"),h=s("2nOjn"),l=s("cdMQz"),u=s("dhUOR"),c=s("hmrEO"),d=s("9nAMT"),f=s("7nRqR"),p=s("jcIaO"),g=new i({Extends:n,initialize:function(t){n.call(this),/**
         * A reference to the core game, so we can listen for visibility events.
         *
         * @name Phaser.Input.Keyboard.KeyboardPlugin#game
         * @type {Phaser.Game}
         * @since 3.16.0
         */this.game=t.systems.game,/**
         * A reference to the Scene that this Input Plugin is responsible for.
         *
         * @name Phaser.Input.Keyboard.KeyboardPlugin#scene
         * @type {Phaser.Scene}
         * @since 3.10.0
         */this.scene=t.scene,/**
         * A reference to the Scene Systems Settings.
         *
         * @name Phaser.Input.Keyboard.KeyboardPlugin#settings
         * @type {Phaser.Types.Scenes.SettingsObject}
         * @since 3.10.0
         */this.settings=this.scene.sys.settings,/**
         * A reference to the Scene Input Plugin that created this Keyboard Plugin.
         *
         * @name Phaser.Input.Keyboard.KeyboardPlugin#sceneInputPlugin
         * @type {Phaser.Input.InputPlugin}
         * @since 3.10.0
         */this.sceneInputPlugin=t,/**
         * A reference to the global Keyboard Manager.
         *
         * @name Phaser.Input.Keyboard.KeyboardPlugin#manager
         * @type {Phaser.Input.InputPlugin}
         * @since 3.16.0
         */this.manager=t.manager.keyboard,/**
         * A boolean that controls if this Keyboard Plugin is enabled or not.
         * Can be toggled on the fly.
         *
         * @name Phaser.Input.Keyboard.KeyboardPlugin#enabled
         * @type {boolean}
         * @default true
         * @since 3.10.0
         */this.enabled=!0,/**
         * An array of Key objects to process.
         *
         * @name Phaser.Input.Keyboard.KeyboardPlugin#keys
         * @type {Phaser.Input.Keyboard.Key[]}
         * @since 3.10.0
         */this.keys=[],/**
         * An array of KeyCombo objects to process.
         *
         * @name Phaser.Input.Keyboard.KeyboardPlugin#combos
         * @type {Phaser.Input.Keyboard.KeyCombo[]}
         * @since 3.10.0
         */this.combos=[],t.pluginEvents.once(h.BOOT,this.boot,this),t.pluginEvents.on(h.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#boot
     * @private
     * @since 3.10.0
     */boot:function(){var t=this.settings.input;this.enabled=a(t,"keyboard",!0);var e=a(t,"keyboard.capture",null);e&&this.addCaptures(e),this.sceneInputPlugin.pluginEvents.once(h.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#start
     * @private
     * @since 3.10.0
     */start:function(){this.sceneInputPlugin.manager.useQueue?this.sceneInputPlugin.pluginEvents.on(h.UPDATE,this.update,this):this.sceneInputPlugin.manager.events.on(h.MANAGER_PROCESS,this.update,this),this.sceneInputPlugin.pluginEvents.once(h.SHUTDOWN,this.shutdown,this),this.game.events.on(o.BLUR,this.resetKeys,this)},/**
     * Checks to see if both this plugin and the Scene to which it belongs is active.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#isActive
     * @since 3.10.0
     *
     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.
     */isActive:function(){return this.enabled&&this.scene.sys.isActive()},/**
     * By default when a key is pressed Phaser will not stop the event from propagating up to the browser.
     * There are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.
     *
     * This `addCapture` method enables consuming keyboard events for specific keys, so they don't bubble up the browser
     * and cause the default behaviors.
     * 
     * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to say prevent
     * the SPACE BAR from triggering a page scroll, then it will prevent it for any Scene in your game, not just the calling one.
     * 
     * You can pass a single key code value:
     * 
     * ```javascript
     * this.input.keyboard.addCapture(62);
     * ```
     * 
     * An array of key codes:
     * 
     * ```javascript
     * this.input.keyboard.addCapture([ 62, 63, 64 ]);
     * ```
     * 
     * Or, a comma-delimited string:
     * 
     * ```javascript
     * this.input.keyboard.addCapture('W,S,A,D');
     * ```
     * 
     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.
     * 
     * You can also provide an array mixing both strings and key code integers.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#addCapture
     * @since 3.16.0
     * 
     * @param {(string|integer|integer[]|any[])} keycode - The Key Codes to enable event capture for.
     *
     * @return {this} This KeyboardPlugin object.
     */addCapture:function(t){return this.manager.addCapture(t),this},/**
     * Removes an existing key capture.
     * 
     * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to remove
     * the capture of a key, then it will remove it for any Scene in your game, not just the calling one.
     * 
     * You can pass a single key code value:
     * 
     * ```javascript
     * this.input.keyboard.removeCapture(62);
     * ```
     * 
     * An array of key codes:
     * 
     * ```javascript
     * this.input.keyboard.removeCapture([ 62, 63, 64 ]);
     * ```
     * 
     * Or, a comma-delimited string:
     * 
     * ```javascript
     * this.input.keyboard.removeCapture('W,S,A,D');
     * ```
     * 
     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.
     * 
     * You can also provide an array mixing both strings and key code integers.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeCapture
     * @since 3.16.0
     * 
     * @param {(string|integer|integer[]|any[])} keycode - The Key Codes to disable event capture for.
     *
     * @return {this} This KeyboardPlugin object.
     */removeCapture:function(t){return this.manager.removeCapture(t),this},/**
     * Returns an array that contains all of the keyboard captures currently enabled.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#getCaptures
     * @since 3.16.0
     * 
     * @return {integer[]} An array of all the currently capturing key codes.
     */getCaptures:function(){return this.manager.captures},/**
     * Allows Phaser to prevent any key captures you may have defined from bubbling up the browser.
     * You can use this to re-enable event capturing if you had paused it via `disableGlobalCapture`.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#enableGlobalCapture
     * @since 3.16.0
     *
     * @return {this} This KeyboardPlugin object.
     */enableGlobalCapture:function(){return this.manager.preventDefault=!0,this},/**
     * Disables Phaser from preventing any key captures you may have defined, without actually removing them.
     * You can use this to temporarily disable event capturing if, for example, you swap to a DOM element.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#disableGlobalCapture
     * @since 3.16.0
     *
     * @return {this} This KeyboardPlugin object.
     */disableGlobalCapture:function(){return this.manager.preventDefault=!1,this},/**
     * Removes all keyboard captures.
     * 
     * Note that this is a global change. It will clear all event captures across your game, not just for this specific Scene.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#clearCaptures
     * @since 3.16.0
     *
     * @return {this} This KeyboardPlugin object.
     */clearCaptures:function(){return this.manager.clearCaptures(),this},/**
     * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right, and also Space Bar and shift.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#createCursorKeys
     * @since 3.10.0
     *
     * @return {Phaser.Types.Input.Keyboard.CursorKeys} An object containing the properties: `up`, `down`, `left`, `right`, `space` and `shift`.
     */createCursorKeys:function(){return this.addKeys({up:c.UP,down:c.DOWN,left:c.LEFT,right:c.RIGHT,space:c.SPACE,shift:c.SHIFT})},/**
     * A practical way to create an object containing user selected hotkeys.
     *
     * For example:
     *
     * ```javascript
     * this.input.keyboard.addKeys({ 'up': Phaser.Input.Keyboard.KeyCodes.W, 'down': Phaser.Input.Keyboard.KeyCodes.S });
     * ```
     * 
     * would return an object containing the properties (`up` and `down`) mapped to W and S {@link Phaser.Input.Keyboard.Key} objects.
     *
     * You can also pass in a comma-separated string:
     * 
     * ```javascript
     * this.input.keyboard.addKeys('W,S,A,D');
     * ```
     *
     * Which will return an object with the properties W, S, A and D mapped to the relevant Key objects.
     *
     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#addKeys
     * @since 3.10.0
     *
     * @param {(object|string)} keys - An object containing Key Codes, or a comma-separated string.
     * @param {boolean} [enableCapture=true] - Automatically call `preventDefault` on the native DOM browser event for the key codes being added.
     * @param {boolean} [emitOnRepeat=false] - Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default).
     *
     * @return {object} An object containing Key objects mapped to the input properties.
     */addKeys:function(t,e,i){void 0===e&&(e=!0),void 0===i&&(i=!1);var n={};if("string"==typeof t){t=t.split(",");for(var s=0;s<t.length;s++){var r=t[s].trim();r&&(n[r]=this.addKey(r,e,i))}}else for(var o in t)n[o]=this.addKey(t[o],e,i);return n},/**
     * Adds a Key object to this Keyboard Plugin.
     *
     * The given argument can be either an existing Key object, a string, such as `A` or `SPACE`, or a key code value.
     *
     * If a Key object is given, and one already exists matching the same key code, the existing one is replaced with the new one.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#addKey
     * @since 3.10.0
     *
     * @param {(Phaser.Input.Keyboard.Key|string|integer)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.
     * @param {boolean} [enableCapture=true] - Automatically call `preventDefault` on the native DOM browser event for the key codes being added.
     * @param {boolean} [emitOnRepeat=false] - Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default).
     *
     * @return {Phaser.Input.Keyboard.Key} The newly created Key object, or a reference to it if it already existed in the keys array.
     */addKey:function(t,e,i){void 0===e&&(e=!0),void 0===i&&(i=!1);var n=this.keys;if(t instanceof u){var s=n.indexOf(t);return s>-1?n[s]=t:n[t.keyCode]=t,e&&this.addCapture(t.keyCode),t.setEmitOnRepeat(i),t}return"string"==typeof t&&(t=c[t.toUpperCase()]),n[t]||(n[t]=new u(this,t),e&&this.addCapture(t),n[t].setEmitOnRepeat(i)),n[t]},/**
     * Removes a Key object from this Keyboard Plugin.
     *
     * The given argument can be either a Key object, a string, such as `A` or `SPACE`, or a key code value.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeKey
     * @since 3.10.0
     *
     * @param {(Phaser.Input.Keyboard.Key|string|integer)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.
     * @param {boolean} [destroy=false] - Call `Key.destroy` on the removed Key object?
     *
     * @return {this} This KeyboardPlugin object.
     */removeKey:function(t,e){void 0===e&&(e=!1);var i,n=this.keys;if(t instanceof u){var s=n.indexOf(t);s>-1&&(i=this.keys[s],this.keys[s]=void 0)}else"string"==typeof t&&(t=c[t.toUpperCase()]);return n[t]&&(i=n[t],n[t]=void 0),i&&(i.plugin=null,e&&i.destroy()),this},/**
     * Creates a new KeyCombo.
     * 
     * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them
     * it will emit a `keycombomatch` event from this Keyboard Plugin.
     *
     * The keys to be listened for can be defined as:
     *
     * A string (i.e. 'ATARI')
     * An array of either integers (key codes) or strings, or a mixture of both
     * An array of objects (such as Key objects) with a public 'keyCode' property
     *
     * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)
     * you could pass the following array of key codes:
     *
     * ```javascript
     * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });
     *
     * this.input.keyboard.on('keycombomatch', function (event) {
     *     console.log('Konami Code entered!');
     * });
     * ```
     *
     * Or, to listen for the user entering the word PHASER:
     *
     * ```javascript
     * this.input.keyboard.createCombo('PHASER');
     * ```
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#createCombo
     * @since 3.10.0
     *
     * @param {(string|integer[]|object[])} keys - The keys that comprise this combo.
     * @param {Phaser.Types.Input.Keyboard.KeyComboConfig} [config] - A Key Combo configuration object.
     *
     * @return {Phaser.Input.Keyboard.KeyCombo} The new KeyCombo object.
     */createCombo:function(t,e){return new d(this,t,e)},/**
     * Checks if the given Key object is currently being held down.
     * 
     * The difference between this method and checking the `Key.isDown` property directly is that you can provide
     * a duration to this method. For example, if you wanted a key press to fire a bullet, but you only wanted
     * it to be able to fire every 100ms, then you can call this method with a `duration` of 100 and it
     * will only return `true` every 100ms.
     * 
     * If the Keyboard Plugin has been disabled, this method will always return `false`.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#checkDown
     * @since 3.11.0
     *
     * @param {Phaser.Input.Keyboard.Key} key - A Key object.
     * @param {number} [duration=0] - The duration which must have elapsed before this Key is considered as being down.
     * 
     * @return {boolean} `true` if the Key is down within the duration specified, otherwise `false`.
     */checkDown:function(t,e){if(this.enabled&&t.isDown){var i=p(this.time-t.timeDown,e);if(i>t._tick)return t._tick=i,!0}return!1},/**
     * Internal update handler called by the Input Plugin, which is in turn invoked by the Game step.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#update
     * @private
     * @since 3.10.0
     */update:function(){var t=this.manager.queue,e=t.length;if(this.isActive()&&0!==e)//  Process the event queue, dispatching all of the events that have stored up
for(var i=this.keys,n=0;n<e;n++){var s=t[n],o=s.keyCode,a=i[o],h=!1;void 0===s.cancelled&&(//  Event allowed to flow across all handlers in this Scene, and any other Scene in the Scene list
s.cancelled=0,//  Won't reach any more local (Scene level) handlers
s.stopImmediatePropagation=function(){s.cancelled=1},//  Won't reach any more handlers in any Scene further down the Scene list
s.stopPropagation=function(){s.cancelled=-1}),-1!==s.cancelled&&("keydown"===s.type?(a&&(h=a.isDown,a.onDown(s)),s.cancelled||a&&h||(f[o]&&(this.emit(r.KEY_DOWN+f[o],s),//  Deprecated, kept in for compatibility with 3.15
//  To be removed by 3.20.
this.emit("keydown_"+f[o],s)),s.cancelled||this.emit(r.ANY_KEY_DOWN,s))):(a&&a.onUp(s),s.cancelled||(f[o]&&(this.emit(r.KEY_UP+f[o],s),//  Deprecated, kept in for compatibility with 3.15
//  To be removed by 3.20.
this.emit("keyup_"+f[o],s)),s.cancelled||this.emit(r.ANY_KEY_UP,s))),1===s.cancelled&&(s.cancelled=0))}},/**
     * Resets all Key objects created by _this_ Keyboard Plugin back to their default un-pressed states.
     * This can only reset keys created via the `addKey`, `addKeys` or `createCursorKeys` methods.
     * If you have created a Key object directly you'll need to reset it yourself.
     * 
     * This method is called automatically when the Keyboard Plugin shuts down, but can be
     * invoked directly at any time you require.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#resetKeys
     * @since 3.15.0
     *
     * @return {this} This KeyboardPlugin object.
     */resetKeys:function(){for(var t=this.keys,e=0;e<t.length;e++)t[e]&&t[e].reset();return this},/**
     * Shuts this Keyboard Plugin down. This performs the following tasks:
     * 
     * 1 - Resets all keys created by this Keyboard plugin.
     * 2 - Stops and removes the keyboard event listeners.
     * 3 - Clears out any pending requests in the queue, without processing them.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#shutdown
     * @private
     * @since 3.10.0
     */shutdown:function(){this.resetKeys(),this.sceneInputPlugin.manager.useQueue?this.sceneInputPlugin.pluginEvents.off(h.UPDATE,this.update,this):this.sceneInputPlugin.manager.events.off(h.MANAGER_PROCESS,this.update,this),this.game.events.off(o.BLUR,this.resetKeys),this.removeAllListeners(),this.queue=[]},/**
     * Destroys this Keyboard Plugin instance and all references it holds, plus clears out local arrays.
     *
     * @method Phaser.Input.Keyboard.KeyboardPlugin#destroy
     * @private
     * @since 3.10.0
     */destroy:function(){this.shutdown();for(var t=this.keys,e=0;e<t.length;e++)t[e]&&t[e].destroy();this.keys=[],this.combos=[],this.queue=[],this.scene=null,this.settings=null,this.sceneInputPlugin=null,this.manager=null},/**
     * Internal time value.
     *
     * @name Phaser.Input.Keyboard.KeyboardPlugin#time
     * @type {number}
     * @private
     * @since 3.11.0
     */time:{get:function(){return this.sceneInputPlugin.manager.time}}});/**
 * An instance of the Keyboard Plugin class, if enabled via the `input.keyboard` Scene or Game Config property.
 * Use this to create Key objects and listen for keyboard specific events.
 *
 * @name Phaser.Input.InputPlugin#keyboard
 * @type {?Phaser.Input.Keyboard.KeyboardPlugin}
 * @since 3.10.0
 */l.register("KeyboardPlugin",g,"keyboard","keyboard","inputKeyboard"),t.exports=g}),r("dhUOR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("3vRz3"),r=s("ktuRg"),o=new i({Extends:n,initialize:function(t,e){n.call(this),/**
         * The Keyboard Plugin instance that owns this Key object.
         *
         * @name Phaser.Input.Keyboard.Key#plugin
         * @type {Phaser.Input.Keyboard.KeyboardPlugin}
         * @since 3.17.0
         */this.plugin=t,/**
         * The keycode of this key.
         *
         * @name Phaser.Input.Keyboard.Key#keyCode
         * @type {integer}
         * @since 3.0.0
         */this.keyCode=e,/**
         * The original DOM event.
         *
         * @name Phaser.Input.Keyboard.Key#originalEvent
         * @type {KeyboardEvent}
         * @since 3.0.0
         */this.originalEvent=void 0,/**
         * Can this Key be processed?
         *
         * @name Phaser.Input.Keyboard.Key#enabled
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.enabled=!0,/**
         * The "down" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.
         *
         * @name Phaser.Input.Keyboard.Key#isDown
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.isDown=!1,/**
         * The "up" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.
         *
         * @name Phaser.Input.Keyboard.Key#isUp
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.isUp=!0,/**
         * The down state of the ALT key, if pressed at the same time as this key.
         *
         * @name Phaser.Input.Keyboard.Key#altKey
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.altKey=!1,/**
         * The down state of the CTRL key, if pressed at the same time as this key.
         *
         * @name Phaser.Input.Keyboard.Key#ctrlKey
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.ctrlKey=!1,/**
         * The down state of the SHIFT key, if pressed at the same time as this key.
         *
         * @name Phaser.Input.Keyboard.Key#shiftKey
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.shiftKey=!1,/**
         * The down state of the Meta key, if pressed at the same time as this key.
         * On a Mac the Meta Key is the Command key. On Windows keyboards, it's the Windows key.
         *
         * @name Phaser.Input.Keyboard.Key#metaKey
         * @type {boolean}
         * @default false
         * @since 3.16.0
         */this.metaKey=!1,/**
         * The location of the modifier key. 0 for standard (or unknown), 1 for left, 2 for right, 3 for numpad.
         *
         * @name Phaser.Input.Keyboard.Key#location
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.location=0,/**
         * The timestamp when the key was last pressed down.
         *
         * @name Phaser.Input.Keyboard.Key#timeDown
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.timeDown=0,/**
         * The number of milliseconds this key was held down for in the previous down - up sequence.
         * This value isn't updated every game step, only when the Key changes state.
         * To get the current duration use the `getDuration` method.
         *
         * @name Phaser.Input.Keyboard.Key#duration
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.duration=0,/**
         * The timestamp when the key was last released.
         *
         * @name Phaser.Input.Keyboard.Key#timeUp
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.timeUp=0,/**
         * When a key is held down should it continuously fire the `down` event each time it repeats?
         * 
         * By default it will emit the `down` event just once, but if you wish to receive the event
         * for each repeat as well, enable this property.
         *
         * @name Phaser.Input.Keyboard.Key#emitOnRepeat
         * @type {boolean}
         * @default false
         * @since 3.16.0
         */this.emitOnRepeat=!1,/**
         * If a key is held down this holds down the number of times the key has 'repeated'.
         *
         * @name Phaser.Input.Keyboard.Key#repeats
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.repeats=0,/**
         * True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
         *
         * @name Phaser.Input.Keyboard.Key#_justDown
         * @type {boolean}
         * @private
         * @default false
         * @since 3.0.0
         */this._justDown=!1,/**
         * True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
         *
         * @name Phaser.Input.Keyboard.Key#_justUp
         * @type {boolean}
         * @private
         * @default false
         * @since 3.0.0
         */this._justUp=!1,/**
         * Internal tick counter.
         *
         * @name Phaser.Input.Keyboard.Key#_tick
         * @type {number}
         * @private
         * @since 3.11.0
         */this._tick=-1},/**
     * Controls if this Key will continuously emit a `down` event while being held down (true),
     * or emit the event just once, on first press, and then skip future events (false).
     *
     * @method Phaser.Input.Keyboard.Key#setEmitOnRepeat
     * @since 3.16.0
     * 
     * @param {boolean} value - Emit `down` events on repeated key down actions, or just once?
     * 
     * @return {this} This Key instance.
     */setEmitOnRepeat:function(t){return this.emitOnRepeat=t,this},/**
     * Processes the Key Down action for this Key.
     * Called automatically by the Keyboard Plugin.
     *
     * @method Phaser.Input.Keyboard.Key#onDown
     * @fires Phaser.Input.Keyboard.Events#DOWN
     * @since 3.16.0
     * 
     * @param {KeyboardEvent} event - The native DOM Keyboard event.
     */onDown:function(t){this.originalEvent=t,this.enabled&&(this.altKey=t.altKey,this.ctrlKey=t.ctrlKey,this.shiftKey=t.shiftKey,this.metaKey=t.metaKey,this.location=t.location,this.repeats++,this.isDown?this.emitOnRepeat&&this.emit(r.DOWN,this,t):(this.isDown=!0,this.isUp=!1,this.timeDown=t.timeStamp,this.duration=0,this._justDown=!0,this._justUp=!1,this.emit(r.DOWN,this,t)))},/**
     * Processes the Key Up action for this Key.
     * Called automatically by the Keyboard Plugin.
     *
     * @method Phaser.Input.Keyboard.Key#onUp
     * @fires Phaser.Input.Keyboard.Events#UP
     * @since 3.16.0
     * 
     * @param {KeyboardEvent} event - The native DOM Keyboard event.
     */onUp:function(t){this.originalEvent=t,this.enabled&&(this.isDown=!1,this.isUp=!0,this.timeUp=t.timeStamp,this.duration=this.timeUp-this.timeDown,this.repeats=0,this._justDown=!1,this._justUp=!0,this._tick=-1,this.emit(r.UP,this,t))},/**
     * Resets this Key object back to its default un-pressed state.
     *
     * @method Phaser.Input.Keyboard.Key#reset
     * @since 3.6.0
     * 
     * @return {this} This Key instance.
     */reset:function(){return this.preventDefault=!0,this.enabled=!0,this.isDown=!1,this.isUp=!0,this.altKey=!1,this.ctrlKey=!1,this.shiftKey=!1,this.metaKey=!1,this.timeDown=0,this.duration=0,this.timeUp=0,this.repeats=0,this._justDown=!1,this._justUp=!1,this._tick=-1,this},/**
     * Returns the duration, in ms, that the Key has been held down for.
     * 
     * If the key is not currently down it will return zero.
     * 
     * The get the duration the Key was held down for in the previous up-down cycle,
     * use the `Key.duration` property value instead.
     *
     * @method Phaser.Input.Keyboard.Key#getDuration
     * @since 3.17.0
     * 
     * @return {number} The duration, in ms, that the Key has been held down for if currently down.
     */getDuration:function(){return this.isDown?this.plugin.game.loop.time-this.timeDown:0},/**
     * Removes any bound event handlers and removes local references.
     *
     * @method Phaser.Input.Keyboard.Key#destroy
     * @since 3.16.0
     */destroy:function(){this.removeAllListeners(),this.originalEvent=null,this.plugin=null}});t.exports=o}),r("9nAMT",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("ktuRg"),r=s("7BSWl"),o=s("lz3li"),a=s("15qzb"),h=new i({initialize:function(t,e,i){//  Can't have a zero or single length combo (string or array based)
if(void 0===i&&(i={}),e.length<2)return!1;/**
         * A reference to the Keyboard Manager
         *
         * @name Phaser.Input.Keyboard.KeyCombo#manager
         * @type {Phaser.Input.Keyboard.KeyboardPlugin}
         * @since 3.0.0
         */this.manager=t,/**
         * A flag that controls if this Key Combo is actively processing keys or not.
         *
         * @name Phaser.Input.Keyboard.KeyCombo#enabled
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.enabled=!0,/**
         * An array of the keycodes that comprise this combo.
         *
         * @name Phaser.Input.Keyboard.KeyCombo#keyCodes
         * @type {array}
         * @default []
         * @since 3.0.0
         */this.keyCodes=[];//  if 'keys' is a string we need to get the keycode of each character in it
for(var s=0;s<e.length;s++){var h=e[s];"string"==typeof h?this.keyCodes.push(h.toUpperCase().charCodeAt(0)):"number"==typeof h?this.keyCodes.push(h):h.hasOwnProperty("keyCode")&&this.keyCodes.push(h.keyCode)}/**
         * The current keyCode the combo is waiting for.
         *
         * @name Phaser.Input.Keyboard.KeyCombo#current
         * @type {integer}
         * @since 3.0.0
         */this.current=this.keyCodes[0],/**
         * The current index of the key being waited for in the 'keys' string.
         *
         * @name Phaser.Input.Keyboard.KeyCombo#index
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.index=0,/**
         * The length of this combo (in keycodes)
         *
         * @name Phaser.Input.Keyboard.KeyCombo#size
         * @type {number}
         * @since 3.0.0
         */this.size=this.keyCodes.length,/**
         * The time the previous key in the combo was matched.
         *
         * @name Phaser.Input.Keyboard.KeyCombo#timeLastMatched
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.timeLastMatched=0,/**
         * Has this Key Combo been matched yet?
         *
         * @name Phaser.Input.Keyboard.KeyCombo#matched
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.matched=!1,/**
         * The time the entire combo was matched.
         *
         * @name Phaser.Input.Keyboard.KeyCombo#timeMatched
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.timeMatched=0,/**
         * If they press the wrong key do we reset the combo?
         *
         * @name Phaser.Input.Keyboard.KeyCombo#resetOnWrongKey
         * @type {boolean}
         * @default 0
         * @since 3.0.0
         */this.resetOnWrongKey=r(i,"resetOnWrongKey",!0),/**
         * The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.
         *
         * @name Phaser.Input.Keyboard.KeyCombo#maxKeyDelay
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.maxKeyDelay=r(i,"maxKeyDelay",0),/**
         * If previously matched and they press the first key of the combo again, will it reset?
         *
         * @name Phaser.Input.Keyboard.KeyCombo#resetOnMatch
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.resetOnMatch=r(i,"resetOnMatch",!1),/**
         * If the combo matches, will it delete itself?
         *
         * @name Phaser.Input.Keyboard.KeyCombo#deleteOnMatch
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.deleteOnMatch=r(i,"deleteOnMatch",!1);var l=this;/**
         * The internal Key Down handler.
         *
         * @name Phaser.Input.Keyboard.KeyCombo#onKeyDown
         * @private
         * @type {KeyboardKeydownCallback}
         * @fires Phaser.Input.Keyboard.Events#COMBO_MATCH
         * @since 3.0.0
         */this.onKeyDown=function(t){!l.matched&&l.enabled&&o(t,l)&&(l.manager.emit(n.COMBO_MATCH,l,t),l.resetOnMatch?a(l):l.deleteOnMatch&&l.destroy())},this.manager.on(n.ANY_KEY_DOWN,this.onKeyDown)},/**
     * How far complete is this combo? A value between 0 and 1.
     *
     * @name Phaser.Input.Keyboard.KeyCombo#progress
     * @type {number}
     * @readonly
     * @since 3.0.0
     */progress:{get:function(){return this.index/this.size}},/**
     * Destroys this Key Combo and all of its references.
     *
     * @method Phaser.Input.Keyboard.KeyCombo#destroy
     * @since 3.0.0
     */destroy:function(){this.enabled=!1,this.keyCodes=[],this.manager.off(n.ANY_KEY_DOWN,this.onKeyDown),this.manager=null}});t.exports=h}),r("lz3li",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gdeyH");t.exports=function(t,e){if(e.matched)return!0;var n=!1,s=!1;if(t.keyCode===e.current){//  Key was correct
if(e.index>0&&e.maxKeyDelay>0){//  We have to check to see if the delay between
//  the new key and the old one was too long (if enabled)
var r=e.timeLastMatched+e.maxKeyDelay;//  Check if they pressed it in time or not
t.timeStamp<=r&&(s=!0,n=i(t,e))}else s=!0,//  We don't check the time for the first key pressed, so just advance it
n=i(t,e)}return!s&&e.resetOnWrongKey&&(//  Wrong key was pressed
e.index=0,e.current=e.keyCodes[0]),n&&(e.timeLastMatched=t.timeStamp,e.matched=!0,e.timeMatched=t.timeStamp),n}}),r("gdeyH",function(t,e){t.exports=function(t,e){return e.timeLastMatched=t.timeStamp,e.index++,e.index===e.size||(e.current=e.keyCodes[e.index],!1)}}),r("15qzb",function(t,e){t.exports=function(t){return t.current=t.keyCodes[0],t.index=0,t.timeLastMatched=0,t.matched=!1,t.timeMatched=0,t}}),r("7nRqR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hmrEO"),n={};for(var r in i)n[i[r]]=r;t.exports=n}),r("4qXaU",function(t,e){t.exports=function(t){return!!t._justDown&&(t._justDown=!1,!0)}}),r("69Yg3",function(t,e){t.exports=function(t){return!!t._justUp&&(t._justUp=!1,!0)}}),r("4fsjq",function(t,e){t.exports=function(t,e){void 0===e&&(e=50);var i=t.plugin.game.loop.time-t.timeDown;return t.isDown&&i<e}}),r("7tfD5",function(t,e){t.exports=function(t,e){void 0===e&&(e=50);var i=t.plugin.game.loop.time-t.timeUp;return t.isUp&&i<e}}),r("iTK5J",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Input.Mouse
 *//* eslint-disable */t.exports={MouseManager:s("jy9yA")};/* eslint-enable */}),r("egEbB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Input.Touch
 *//* eslint-disable */t.exports={TouchManager:s("d3PYD")};/* eslint-enable */}),r("89Da5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jOz8I"),n=s("hVk4C"),r={Events:s("ls69h"),FileTypes:s("10loJ"),File:s("8Aww1"),FileTypesManager:s("9csvT"),GetURL:s("6MxE8"),LoaderPlugin:s("5eeE2"),MergeXHRSettings:s("gAlTf"),MultiFile:s("B7Zxi"),XHRLoader:s("eohDK"),XHRSettings:s("kTh8x")};//   Merge in the consts
r=n(!1,r,i),t.exports=r}),r("jOz8I",function(t,e){t.exports={/**
     * The Loader is idle.
     * 
     * @name Phaser.Loader.LOADER_IDLE
     * @type {integer}
     * @since 3.0.0
     */LOADER_IDLE:0,/**
     * The Loader is actively loading.
     * 
     * @name Phaser.Loader.LOADER_LOADING
     * @type {integer}
     * @since 3.0.0
     */LOADER_LOADING:1,/**
     * The Loader is processing files is has loaded.
     * 
     * @name Phaser.Loader.LOADER_PROCESSING
     * @type {integer}
     * @since 3.0.0
     */LOADER_PROCESSING:2,/**
     * The Loader has completed loading and processing.
     * 
     * @name Phaser.Loader.LOADER_COMPLETE
     * @type {integer}
     * @since 3.0.0
     */LOADER_COMPLETE:3,/**
     * The Loader is shutting down.
     * 
     * @name Phaser.Loader.LOADER_SHUTDOWN
     * @type {integer}
     * @since 3.0.0
     */LOADER_SHUTDOWN:4,/**
     * The Loader has been destroyed.
     * 
     * @name Phaser.Loader.LOADER_DESTROYED
     * @type {integer}
     * @since 3.0.0
     */LOADER_DESTROYED:5,/**
     * File is in the load queue but not yet started
     * 
     * @name Phaser.Loader.FILE_PENDING
     * @type {integer}
     * @since 3.0.0
     */FILE_PENDING:10,/**
     * File has been started to load by the loader (onLoad called)
     * 
     * @name Phaser.Loader.FILE_LOADING
     * @type {integer}
     * @since 3.0.0
     */FILE_LOADING:11,/**
     * File has loaded successfully, awaiting processing    
     * 
     * @name Phaser.Loader.FILE_LOADED
     * @type {integer}
     * @since 3.0.0
     */FILE_LOADED:12,/**
     * File failed to load
     * 
     * @name Phaser.Loader.FILE_FAILED
     * @type {integer}
     * @since 3.0.0
     */FILE_FAILED:13,/**
     * File is being processed (onProcess callback)
     * 
     * @name Phaser.Loader.FILE_PROCESSING
     * @type {integer}
     * @since 3.0.0
     */FILE_PROCESSING:14,/**
     * The File has errored somehow during processing.
     * 
     * @name Phaser.Loader.FILE_ERRORED
     * @type {integer}
     * @since 3.0.0
     */FILE_ERRORED:16,/**
     * File has finished processing.
     * 
     * @name Phaser.Loader.FILE_COMPLETE
     * @type {integer}
     * @since 3.0.0
     */FILE_COMPLETE:17,/**
     * File has been destroyed
     * 
     * @name Phaser.Loader.FILE_DESTROYED
     * @type {integer}
     * @since 3.0.0
     */FILE_DESTROYED:18,/**
     * File was populated from local data and doesn't need an HTTP request
     * 
     * @name Phaser.Loader.FILE_POPULATED
     * @type {integer}
     * @since 3.0.0
     */FILE_POPULATED:19}}),r("10loJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Loader.FileTypes
 */t.exports={AnimationJSONFile:s("bFniC"),AtlasJSONFile:s("jWhe0"),AtlasXMLFile:s("e6x5K"),AudioFile:s("5fnRj"),AudioSpriteFile:s("2PFPJ"),BinaryFile:s("htyZ3"),BitmapFontFile:s("eqnR1"),CSSFile:s("456Xt"),GLSLFile:s("cfaNt"),HTML5AudioFile:s("cBw3Y"),HTMLFile:s("fky3L"),HTMLTextureFile:s("hC7gq"),ImageFile:s("gT96E"),JSONFile:s("j0zmu"),MultiAtlasFile:s("3NA92"),MultiScriptFile:s("8g88p"),PackFile:s("9i0hf"),PluginFile:s("lpnsI"),SceneFile:s("8nYaJ"),ScenePluginFile:s("4FmI6"),ScriptFile:s("fh7OQ"),SpriteSheetFile:s("7z6bR"),SVGFile:s("763ZX"),TextFile:s("xcajA"),TilemapCSVFile:s("5xR0u"),TilemapImpactFile:s("k8GdB"),TilemapJSONFile:s("jtcSd"),UnityAtlasFile:s("luwkr"),VideoFile:s("aEsfq"),XMLFile:s("wRXCw")}}),r("bFniC",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("9csvT"),r=s("j0zmu"),o=s("ls69h"),a=new i({Extends:r,initialize://  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing
function(t,e,i,n,s){r.call(this,t,e,i,n,s),this.type="animationJSON"},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.AnimationJSONFile#onProcess
     * @since 3.7.0
     */onProcess:function(){//  We need to hook into this event:
this.loader.once(o.POST_PROCESS,this.onLoadComplete,this),//  But the rest is the same as a normal JSON file
r.prototype.onProcess.call(this)},/**
     * Called at the end of the load process, after the Loader has finished all files in its queue.
     *
     * @method Phaser.Loader.FileTypes.AnimationJSONFile#onLoadComplete
     * @since 3.7.0
     */onLoadComplete:function(){this.loader.systems.anims.fromJSON(this.data)}});/**
 * Adds an Animation JSON Data file, or array of Animation JSON files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.animation('baddieAnims', 'files/BaddieAnims.json');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
 * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
 *
 * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the JSON Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.animation({
 *     key: 'baddieAnims',
 *     url: 'files/BaddieAnims.json'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.JSONFileConfig` for more details.
 *
 * Once the file has finished loading it will automatically be passed to the global Animation Managers `fromJSON` method.
 * This will parse all of the JSON data and create animation data from it. This process happens at the very end
 * of the Loader, once every other file in the load queue has finished. The reason for this is to allow you to load
 * both animation data and the images it relies upon in the same load call.
 *
 * Once the animation data has been parsed you will be able to play animations using that data.
 * Please see the Animation Manager `fromJSON` method for more details about the format and playback.
 *
 * You can also access the raw animation data from its Cache using its key:
 *
 * ```javascript
 * this.load.animation('baddieAnims', 'files/BaddieAnims.json');
 * // and later in your game ...
 * var data = this.cache.json.get('baddieAnims');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and
 * this is what you would use to retrieve the text from the JSON Cache.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "data"
 * and no URL is given then the Loader will set the URL to be "data.json". It will always add `.json` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,
 * rather than the whole file. For example, if your JSON data had a structure like this:
 *
 * ```json
 * {
 *     "level1": {
 *         "baddies": {
 *             "aliens": {},
 *             "boss": {}
 *         }
 *     },
 *     "level2": {},
 *     "level3": {}
 * }
 * ```
 *
 * And if you only wanted to create animations from the `boss` data, then you could pass `level1.baddies.boss`as the `dataKey`.
 *
 * Note: The ability to load this type of file will only be available if the JSON File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#animation
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
 * @param {string} [dataKey] - When the Animation JSON file loads only this property will be stored in the Cache and used to create animation data.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */n.register("animation",function(t,e,i,n){//  Supports an Object file definition in the key argument
//  Or an array of objects in the key argument
//  Or a single entry where all arguments have been defined
if(Array.isArray(t))for(var s=0;s<t.length;s++)this.addFile(new a(this,t[s]));else this.addFile(new a(this,t,e,n,i));return this}),t.exports=a}),r("j0zmu",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("5pMDk"),l=s("jC9MQ"),u=new i({Extends:r,initialize://  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing
function(t,e,i,s,o){var u="json";if(l(e)){var c=e;e=a(c,"key"),i=a(c,"url"),s=a(c,"xhrSettings"),u=a(c,"extension",u),o=a(c,"dataKey",o)}var d={type:"json",cache:t.cacheManager.json,extension:u,responseType:"text",key:e,url:i,xhrSettings:s,config:o};r.call(this,t,d),l(i)&&(o?this.data=h(i,o):this.data=i,this.state=n.FILE_POPULATED)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.JSONFile#onProcess
     * @since 3.7.0
     */onProcess:function(){if(this.state!==n.FILE_POPULATED){this.state=n.FILE_PROCESSING;var t=JSON.parse(this.xhrLoader.responseText),e=this.config;"string"==typeof e?this.data=h(t,e,t):this.data=t}this.onProcessComplete()}});/**
 * Adds a JSON file, or array of JSON files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.json('wavedata', 'files/AlienWaveData.json');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the JSON Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.json({
 *     key: 'wavedata',
 *     url: 'files/AlienWaveData.json'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.JSONFileConfig` for more details.
 *
 * Once the file has finished loading you can access it from its Cache using its key:
 *
 * ```javascript
 * this.load.json('wavedata', 'files/AlienWaveData.json');
 * // and later in your game ...
 * var data = this.cache.json.get('wavedata');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and
 * this is what you would use to retrieve the text from the JSON Cache.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "data"
 * and no URL is given then the Loader will set the URL to be "data.json". It will always add `.json` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,
 * rather than the whole file. For example, if your JSON data had a structure like this:
 *
 * ```json
 * {
 *     "level1": {
 *         "baddies": {
 *             "aliens": {},
 *             "boss": {}
 *         }
 *     },
 *     "level2": {},
 *     "level3": {}
 * }
 * ```
 *
 * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.
 *
 * Note: The ability to load this type of file will only be available if the JSON File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#json
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
 * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("json",function(t,e,i,n){if(Array.isArray(t))for(var s=0;s<t.length;s++)this.addFile(new u(this,t[s]));else this.addFile(new u(this,t,e,n,i));return this}),t.exports=u}),r("8Aww1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("ls69h"),o=s("7BSWl"),a=s("6MxE8"),h=s("gAlTf"),l=s("eohDK"),u=s("kTh8x"),c=new i({initialize:function(t,e){/**
         * A reference to the Loader that is going to load this file.
         *
         * @name Phaser.Loader.File#loader
         * @type {Phaser.Loader.LoaderPlugin}
         * @since 3.0.0
         */this.loader=t,/**
         * A reference to the Cache, or Texture Manager, that is going to store this file if it loads.
         *
         * @name Phaser.Loader.File#cache
         * @type {(Phaser.Cache.BaseCache|Phaser.Textures.TextureManager)}
         * @since 3.7.0
         */this.cache=o(e,"cache",!1),/**
         * The file type string (image, json, etc) for sorting within the Loader.
         *
         * @name Phaser.Loader.File#type
         * @type {string}
         * @since 3.0.0
         */this.type=o(e,"type",!1),/**
         * Unique cache key (unique within its file type)
         *
         * @name Phaser.Loader.File#key
         * @type {string}
         * @since 3.0.0
         */this.key=o(e,"key",!1);var i=this.key;if(t.prefix&&""!==t.prefix&&(this.key=t.prefix+i),!this.type||!this.key)throw Error("Error calling 'Loader."+this.type+"' invalid key provided.");/**
         * The URL of the file, not including baseURL.
         * Automatically has Loader.path prepended to it.
         *
         * @name Phaser.Loader.File#url
         * @type {string}
         * @since 3.0.0
         */this.url=o(e,"url"),void 0===this.url?this.url=t.path+i+"."+o(e,"extension",""):"function"!=typeof this.url&&0!==this.url.indexOf("blob:")&&0!==this.url.indexOf("data:")&&(this.url=t.path+this.url),/**
         * The final URL this file will load from, including baseURL and path.
         * Set automatically when the Loader calls 'load' on this file.
         *
         * @name Phaser.Loader.File#src
         * @type {string}
         * @since 3.0.0
         */this.src="",/**
         * The merged XHRSettings for this file.
         *
         * @name Phaser.Loader.File#xhrSettings
         * @type {Phaser.Types.Loader.XHRSettingsObject}
         * @since 3.0.0
         */this.xhrSettings=u(o(e,"responseType",void 0)),o(e,"xhrSettings",!1)&&(this.xhrSettings=h(this.xhrSettings,o(e,"xhrSettings",{}))),/**
         * The XMLHttpRequest instance (as created by XHR Loader) that is loading this File.
         *
         * @name Phaser.Loader.File#xhrLoader
         * @type {?XMLHttpRequest}
         * @since 3.0.0
         */this.xhrLoader=null,/**
         * The current state of the file. One of the FILE_CONST values.
         *
         * @name Phaser.Loader.File#state
         * @type {integer}
         * @since 3.0.0
         */this.state="function"==typeof this.url?n.FILE_POPULATED:n.FILE_PENDING,/**
         * The total size of this file.
         * Set by onProgress and only if loading via XHR.
         *
         * @name Phaser.Loader.File#bytesTotal
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.bytesTotal=0,/**
         * Updated as the file loads.
         * Only set if loading via XHR.
         *
         * @name Phaser.Loader.File#bytesLoaded
         * @type {number}
         * @default -1
         * @since 3.0.0
         */this.bytesLoaded=-1,/**
         * A percentage value between 0 and 1 indicating how much of this file has loaded.
         * Only set if loading via XHR.
         *
         * @name Phaser.Loader.File#percentComplete
         * @type {number}
         * @default -1
         * @since 3.0.0
         */this.percentComplete=-1,/**
         * For CORs based loading.
         * If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)
         *
         * @name Phaser.Loader.File#crossOrigin
         * @type {(string|undefined)}
         * @since 3.0.0
         */this.crossOrigin=void 0,/**
         * The processed file data, stored here after the file has loaded.
         *
         * @name Phaser.Loader.File#data
         * @type {*}
         * @since 3.0.0
         */this.data=void 0,/**
         * A config object that can be used by file types to store transitional data.
         *
         * @name Phaser.Loader.File#config
         * @type {*}
         * @since 3.0.0
         */this.config=o(e,"config",{}),/**
         * If this is a multipart file, i.e. an atlas and its json together, then this is a reference
         * to the parent MultiFile. Set and used internally by the Loader or specific file types.
         *
         * @name Phaser.Loader.File#multiFile
         * @type {?Phaser.Loader.MultiFile}
         * @since 3.7.0
         */this.multiFile,/**
         * Does this file have an associated linked file? Such as an image and a normal map.
         * Atlases and Bitmap Fonts use the multiFile, because those files need loading together but aren't
         * actually bound by data, where-as a linkFile is.
         *
         * @name Phaser.Loader.File#linkFile
         * @type {?Phaser.Loader.File}
         * @since 3.7.0
         */this.linkFile},/**
     * Links this File with another, so they depend upon each other for loading and processing.
     *
     * @method Phaser.Loader.File#setLink
     * @since 3.7.0
     *
     * @param {Phaser.Loader.File} fileB - The file to link to this one.
     */setLink:function(t){this.linkFile=t,t.linkFile=this},/**
     * Resets the XHRLoader instance this file is using.
     *
     * @method Phaser.Loader.File#resetXHR
     * @since 3.0.0
     */resetXHR:function(){this.xhrLoader&&(this.xhrLoader.onload=void 0,this.xhrLoader.onerror=void 0,this.xhrLoader.onprogress=void 0)},/**
     * Called by the Loader, starts the actual file downloading.
     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.
     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.
     *
     * @method Phaser.Loader.File#load
     * @since 3.0.0
     */load:function(){this.state===n.FILE_POPULATED?this.loader.nextFile(this,!0):(this.src=a(this,this.loader.baseURL),0===this.src.indexOf("data:")?console.warn("Local data URIs are not supported: "+this.key)://  It will automatically call the following, based on the load outcome:
//  
// xhr.onload = this.onLoad
// xhr.onerror = this.onError
// xhr.onprogress = this.onProgress
this.xhrLoader=l(this,this.loader.xhr))},/**
     * Called when the file finishes loading, is sent a DOM ProgressEvent.
     *
     * @method Phaser.Loader.File#onLoad
     * @since 3.0.0
     *
     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.
     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.
     */onLoad:function(t,e){var i=t.responseURL&&0===t.responseURL.indexOf("file://")&&0===e.target.status,n=!(e.target&&200!==e.target.status)||i;4===t.readyState&&t.status>=400&&t.status<=599&&(n=!1),this.resetXHR(),this.loader.nextFile(this,n)},/**
     * Called if the file errors while loading, is sent a DOM ProgressEvent.
     *
     * @method Phaser.Loader.File#onError
     * @since 3.0.0
     *
     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.
     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this error.
     */onError:function(){this.resetXHR(),this.loader.nextFile(this,!1)},/**
     * Called during the file load progress. Is sent a DOM ProgressEvent.
     *
     * @method Phaser.Loader.File#onProgress
     * @fires Phaser.Loader.Events#FILE_PROGRESS
     * @since 3.0.0
     *
     * @param {ProgressEvent} event - The DOM ProgressEvent.
     */onProgress:function(t){t.lengthComputable&&(this.bytesLoaded=t.loaded,this.bytesTotal=t.total,this.percentComplete=Math.min(this.bytesLoaded/this.bytesTotal,1),this.loader.emit(r.FILE_PROGRESS,this,this.percentComplete))},/**
     * Usually overridden by the FileTypes and is called by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data, for example a JSON file will parse itself during this stage.
     *
     * @method Phaser.Loader.File#onProcess
     * @since 3.0.0
     */onProcess:function(){this.state=n.FILE_PROCESSING,this.onProcessComplete()},/**
     * Called when the File has completed processing.
     * Checks on the state of its multifile, if set.
     *
     * @method Phaser.Loader.File#onProcessComplete
     * @since 3.7.0
     */onProcessComplete:function(){this.state=n.FILE_COMPLETE,this.multiFile&&this.multiFile.onFileComplete(this),this.loader.fileProcessComplete(this)},/**
     * Called when the File has completed processing but it generated an error.
     * Checks on the state of its multifile, if set.
     *
     * @method Phaser.Loader.File#onProcessError
     * @since 3.7.0
     */onProcessError:function(){this.state=n.FILE_ERRORED,this.multiFile&&this.multiFile.onFileFailed(this),this.loader.fileProcessComplete(this)},/**
     * Checks if a key matching the one used by this file exists in the target Cache or not.
     * This is called automatically by the LoaderPlugin to decide if the file can be safely
     * loaded or will conflict.
     *
     * @method Phaser.Loader.File#hasCacheConflict
     * @since 3.7.0
     *
     * @return {boolean} `true` if adding this file will cause a conflict, otherwise `false`.
     */hasCacheConflict:function(){return this.cache&&this.cache.exists(this.key)},/**
     * Adds this file to its target cache upon successful loading and processing.
     * This method is often overridden by specific file types.
     *
     * @method Phaser.Loader.File#addToCache
     * @since 3.7.0
     */addToCache:function(){this.cache&&this.cache.add(this.key,this.data),this.pendingDestroy()},/**
     * Called once the file has been added to its cache and is now ready for deletion from the Loader.
     * It will emit a `filecomplete` event from the LoaderPlugin.
     *
     * @method Phaser.Loader.File#pendingDestroy
     * @fires Phaser.Loader.Events#FILE_COMPLETE
     * @fires Phaser.Loader.Events#FILE_KEY_COMPLETE
     * @since 3.7.0
     */pendingDestroy:function(t){void 0===t&&(t=this.data);var e=this.key,i=this.type;this.loader.emit(r.FILE_COMPLETE,e,i,t),this.loader.emit(r.FILE_KEY_COMPLETE+i+"-"+e,e,i,t),this.loader.flagForRemoval(this)},/**
     * Destroy this File and any references it holds.
     *
     * @method Phaser.Loader.File#destroy
     * @since 3.7.0
     */destroy:function(){this.loader=null,this.cache=null,this.xhrSettings=null,this.multiFile=null,this.linkFile=null,this.data=null}});/**
 * Static method for creating object URL using URL API and setting it as image 'src' attribute.
 * If URL API is not supported (usually on old browsers) it falls back to creating Base64 encoded url using FileReader.
 *
 * @method Phaser.Loader.File.createObjectURL
 * @static
 * @since 3.7.0
 * 
 * @param {HTMLImageElement} image - Image object which 'src' attribute should be set to object URL.
 * @param {Blob} blob - A Blob object to create an object URL for.
 * @param {string} defaultType - Default mime type used if blob type is not available.
 */c.createObjectURL=function(t,e,i){if("function"==typeof URL)t.src=URL.createObjectURL(e);else{var n=new FileReader;n.onload=function(){t.removeAttribute("crossOrigin"),t.src="data:"+(e.type||i)+";base64,"+n.result.split(",")[1]},n.onerror=t.onerror,n.readAsDataURL(e)}},/**
 * Static method for releasing an existing object URL which was previously created
 * by calling {@link File#createObjectURL} method.
 *
 * @method Phaser.Loader.File.revokeObjectURL
 * @static
 * @since 3.7.0
 * 
 * @param {HTMLImageElement} image - Image object which 'src' attribute should be revoked.
 */c.revokeObjectURL=function(t){"function"==typeof URL&&URL.revokeObjectURL(t.src)},t.exports=c}),r("6MxE8",function(t,e){t.exports=function(t,e){return!!t.url&&(t.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)?t.url:e+t.url)}}),r("gAlTf",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hVk4C"),n=s("kTh8x");t.exports=function(t,e){var s=void 0===t?n():i({},t);if(e)for(var r in e)void 0!==e[r]&&(s[r]=e[r]);return s}}),r("kTh8x",function(t,e){t.exports=function(t,e,i,n,s,r){// Before sending a request, set the xhr.responseType to "text",
// "arraybuffer", "blob", or "document", depending on your data needs.
// Note, setting xhr.responseType = '' (or omitting) will default the response to "text".
return void 0===t&&(t=""),void 0===e&&(e=!0),void 0===i&&(i=""),void 0===n&&(n=""),void 0===s&&(s=0),void 0===r&&(r=!1),{//  Ignored by the Loader, only used by File.
responseType:t,async:e,//  credentials
user:i,password:n,//  timeout in ms (0 = no timeout)
timeout:s,//  setRequestHeader
headers:void 0,header:void 0,headerValue:void 0,requestedWith:!1,//  overrideMimeType
overrideMimeType:void 0,//  withCredentials
withCredentials:r}}}),r("eohDK",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gAlTf");t.exports=function(t,e){var n=i(e,t.xhrSettings),s=new XMLHttpRequest;if(s.open("GET",t.src,n.async,n.user,n.password),s.responseType=t.xhrSettings.responseType,s.timeout=n.timeout,n.headers)for(var r in n.headers)s.setRequestHeader(r,n.headers[r]);return n.header&&n.headerValue&&s.setRequestHeader(n.header,n.headerValue),n.requestedWith&&s.setRequestHeader("X-Requested-With",n.requestedWith),n.overrideMimeType&&s.overrideMimeType(n.overrideMimeType),n.withCredentials&&(s.withCredentials=!0),// After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)
s.onload=t.onLoad.bind(t,s),s.onerror=t.onError.bind(t,s),s.onprogress=t.onProgress.bind(t),//  This is the only standard method, the ones above are browser additions (maybe not universal?)
// xhr.onreadystatechange
s.send(),s}}),r("jWhe0",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("9csvT"),r=s("7BSWl"),o=s("gT96E"),a=s("jC9MQ"),h=s("j0zmu"),l=s("B7Zxi"),u=new i({Extends:l,initialize:function(t,e,i,n,s,u){if(a(e)){var c,d,f=e;e=r(f,"key"),c=new o(t,{key:e,url:r(f,"textureURL"),extension:r(f,"textureExtension","png"),normalMap:r(f,"normalMap"),xhrSettings:r(f,"textureXhrSettings")}),d=new h(t,{key:e,url:r(f,"atlasURL"),extension:r(f,"atlasExtension","json"),xhrSettings:r(f,"atlasXhrSettings")})}else c=new o(t,e,i,s),d=new h(t,e,n,u);c.linkFile?l.call(this,t,"atlasjson",e,[c,d,c.linkFile]):l.call(this,t,"atlasjson",e,[c,d])},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.AtlasJSONFile#addToCache
     * @since 3.7.0
     */addToCache:function(){if(this.isReadyToProcess()){var t=this.files[0],e=this.files[1],i=this.files[2]?this.files[2].data:null;this.loader.textureManager.addAtlas(t.key,t.data,e.data,i),e.addToCache(),this.complete=!0}}});/**
 * Adds a JSON based Texture Atlas, or array of atlases, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.atlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
 * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
 *
 * Phaser expects the atlas data to be provided in a JSON file, using either the JSON Hash or JSON Array format.
 * These files are created by software such as Texture Packer, Shoebox and Adobe Flash / Animate.
 * If you are using Texture Packer and have enabled multi-atlas support, then please use the Phaser Multi Atlas loader
 * instead of this one.
 *
 * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
 *
 * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Texture Manager first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.atlas({
 *     key: 'mainmenu',
 *     textureURL: 'images/MainMenu.png',
 *     atlasURL: 'images/MainMenu.json'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig` for more details.
 *
 * Instead of passing a URL for the atlas JSON data you can also pass in a well formed JSON object instead.
 *
 * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:
 *
 * ```javascript
 * this.load.atlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');
 * // and later in your game ...
 * this.add.image(x, y, 'mainmenu', 'background');
 * ```
 *
 * To get a list of all available frames within an atlas please consult your Texture Atlas software.
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
 * this is what you would use to retrieve the image from the Texture Manager.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,
 * then you can specify it by providing an array as the `url` where the second element is the normal map:
 *
 * ```javascript
 * this.load.atlas('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.json');
 * ```
 *
 * Or, if you are using a config object use the `normalMap` property:
 *
 * ```javascript
 * this.load.atlas({
 *     key: 'mainmenu',
 *     textureURL: 'images/MainMenu.png',
 *     normalMap: 'images/MainMenu-n.png',
 *     atlasURL: 'images/MainMenu.json'
 * });
 * ```
 *
 * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.
 * Normal maps are a WebGL only feature.
 *
 * Note: The ability to load this type of file will only be available if the Atlas JSON File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#atlas
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig|Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
 * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */n.register("atlas",function(t,e,i,n,s){var r;//  Supports an Object file definition in the key argument
//  Or an array of objects in the key argument
//  Or a single entry where all arguments have been defined
if(Array.isArray(t))for(var o=0;o<t.length;o++)r=new u(this,t[o]),this.addFile(r.files);else r=new u(this,t,e,i,n,s),this.addFile(r.files);return this}),t.exports=u}),r("gT96E",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=new i({Extends:r,initialize:function t(e,i,n,s,o){var l,u="png";if(h(i)){var c=i;i=a(c,"key"),n=a(c,"url"),l=a(c,"normalMap"),s=a(c,"xhrSettings"),u=a(c,"extension",u),o=a(c,"frameConfig")}Array.isArray(n)&&(l=n[1],n=n[0]);var d={type:"image",cache:e.textureManager,extension:u,responseType:"blob",key:i,url:n,xhrSettings:s,config:o};//  Do we have a normal map to load as well?
if(r.call(this,e,d),l){var f=new t(e,this.key,l,s,o);f.type="normalMap",this.setLink(f),e.addFile(f)}},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.ImageFile#onProcess
     * @since 3.7.0
     */onProcess:function(){this.state=n.FILE_PROCESSING,this.data=new Image,this.data.crossOrigin=this.crossOrigin;var t=this;this.data.onload=function(){r.revokeObjectURL(t.data),t.onProcessComplete()},this.data.onerror=function(){r.revokeObjectURL(t.data),t.onProcessError()},r.createObjectURL(this.data,this.xhrLoader.response,"image/png")},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.ImageFile#addToCache
     * @since 3.7.0
     */addToCache:function(){var t,e=this.linkFile;e&&e.state===n.FILE_COMPLETE?(t="image"===this.type?this.cache.addImage(this.key,this.data,e.data):this.cache.addImage(e.key,e.data,this.data),this.pendingDestroy(t),e.pendingDestroy(t)):e||(t=this.cache.addImage(this.key,this.data),this.pendingDestroy(t))}});/**
 * Adds an Image, or array of Images, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.image('logo', 'images/phaserLogo.png');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
 * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback
 * of animated gifs to Canvas elements.
 *
 * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Texture Manager first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.image({
 *     key: 'logo',
 *     url: 'images/AtariLogo.png'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.ImageFileConfig` for more details.
 *
 * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:
 *
 * ```javascript
 * this.load.image('logo', 'images/AtariLogo.png');
 * // and later in your game ...
 * this.add.image(x, y, 'logo');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
 * this is what you would use to retrieve the image from the Texture Manager.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,
 * then you can specify it by providing an array as the `url` where the second element is the normal map:
 *
 * ```javascript
 * this.load.image('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ]);
 * ```
 *
 * Or, if you are using a config object use the `normalMap` property:
 *
 * ```javascript
 * this.load.image({
 *     key: 'logo',
 *     url: 'images/AtariLogo.png',
 *     normalMap: 'images/AtariLogo-n.png'
 * });
 * ```
 *
 * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.
 * Normal maps are a WebGL only feature.
 *
 * Note: The ability to load this type of file will only be available if the Image File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#image
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig|Phaser.Types.Loader.FileTypes.ImageFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("image",function(t,e,i){if(Array.isArray(t))for(var n=0;n<t.length;n++)this.addFile(new l(this,t[n]));else this.addFile(new l(this,t,e,i));return this}),t.exports=l}),r("B7Zxi",function(t,e){/**
 * @classdesc
 * A MultiFile is a special kind of parent that contains two, or more, Files as children and looks after
 * the loading and processing of them all. It is commonly extended and used as a base class for file types such as AtlasJSON or BitmapFont.
 * 
 * You shouldn't create an instance of a MultiFile directly, but should extend it with your own class, setting a custom type and processing methods.
 *
 * @class MultiFile
 * @memberof Phaser.Loader
 * @constructor
 * @since 3.7.0
 *
 * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.
 * @param {string} type - The file type string for sorting within the Loader.
 * @param {string} key - The key of the file within the loader.
 * @param {Phaser.Loader.File[]} files - An array of Files that make-up this MultiFile.
 */var i=new(s("jwj1g"))({initialize:function(t,e,i,n){/**
         * A reference to the Loader that is going to load this file.
         *
         * @name Phaser.Loader.MultiFile#loader
         * @type {Phaser.Loader.LoaderPlugin}
         * @since 3.7.0
         */this.loader=t,/**
         * The file type string for sorting within the Loader.
         *
         * @name Phaser.Loader.MultiFile#type
         * @type {string}
         * @since 3.7.0
         */this.type=e,/**
         * Unique cache key (unique within its file type)
         *
         * @name Phaser.Loader.MultiFile#key
         * @type {string}
         * @since 3.7.0
         */this.key=i,/**
         * The current index being used by multi-file loaders to avoid key clashes.
         *
         * @name Phaser.Loader.MultiFile#multiKeyIndex
         * @type {integer}
         * @private
         * @since 3.20.0
         */this.multiKeyIndex=t.multiKeyIndex++,/**
         * Array of files that make up this MultiFile.
         *
         * @name Phaser.Loader.MultiFile#files
         * @type {Phaser.Loader.File[]}
         * @since 3.7.0
         */this.files=n,/**
         * The completion status of this MultiFile.
         *
         * @name Phaser.Loader.MultiFile#complete
         * @type {boolean}
         * @default false
         * @since 3.7.0
         */this.complete=!1,/**
         * The number of files to load.
         *
         * @name Phaser.Loader.MultiFile#pending
         * @type {integer}
         * @since 3.7.0
         */this.pending=n.length,/**
         * The number of files that failed to load.
         *
         * @name Phaser.Loader.MultiFile#failed
         * @type {integer}
         * @default 0
         * @since 3.7.0
         */this.failed=0,/**
         * A storage container for transient data that the loading files need.
         *
         * @name Phaser.Loader.MultiFile#config
         * @type {any}
         * @since 3.7.0
         */this.config={},/**
         * A reference to the Loaders baseURL at the time this MultiFile was created.
         * Used to populate child-files.
         *
         * @name Phaser.Loader.MultiFile#baseURL
         * @type {string}
         * @since 3.20.0
         */this.baseURL=t.baseURL,/**
         * A reference to the Loaders path at the time this MultiFile was created.
         * Used to populate child-files.
         *
         * @name Phaser.Loader.MultiFile#path
         * @type {string}
         * @since 3.20.0
         */this.path=t.path,/**
         * A reference to the Loaders prefix at the time this MultiFile was created.
         * Used to populate child-files.
         *
         * @name Phaser.Loader.MultiFile#prefix
         * @type {string}
         * @since 3.20.0
         */this.prefix=t.prefix;//  Link the files
for(var s=0;s<n.length;s++)n[s].multiFile=this},/**
     * Checks if this MultiFile is ready to process its children or not.
     *
     * @method Phaser.Loader.MultiFile#isReadyToProcess
     * @since 3.7.0
     *
     * @return {boolean} `true` if all children of this MultiFile have loaded, otherwise `false`.
     */isReadyToProcess:function(){return 0===this.pending&&0===this.failed&&!this.complete},/**
     * Adds another child to this MultiFile, increases the pending count and resets the completion status.
     *
     * @method Phaser.Loader.MultiFile#addToMultiFile
     * @since 3.7.0
     *
     * @param {Phaser.Loader.File} files - The File to add to this MultiFile.
     *
     * @return {Phaser.Loader.MultiFile} This MultiFile instance.
     */addToMultiFile:function(t){return this.files.push(t),t.multiFile=this,this.pending++,this.complete=!1,this},/**
     * Called by each File when it finishes loading.
     *
     * @method Phaser.Loader.MultiFile#onFileComplete
     * @since 3.7.0
     *
     * @param {Phaser.Loader.File} file - The File that has completed processing.
     */onFileComplete:function(t){-1!==this.files.indexOf(t)&&this.pending--},/**
     * Called by each File that fails to load.
     *
     * @method Phaser.Loader.MultiFile#onFileFailed
     * @since 3.7.0
     *
     * @param {Phaser.Loader.File} file - The File that has failed to load.
     */onFileFailed:function(t){-1!==this.files.indexOf(t)&&this.failed++}});t.exports=i}),r("e6x5K",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("9csvT"),r=s("7BSWl"),o=s("gT96E"),a=s("jC9MQ"),h=s("B7Zxi"),l=s("wRXCw"),u=new i({Extends:h,initialize:function(t,e,i,n,s,u){if(a(e)){var c,d,f=e;e=r(f,"key"),c=new o(t,{key:e,url:r(f,"textureURL"),extension:r(f,"textureExtension","png"),normalMap:r(f,"normalMap"),xhrSettings:r(f,"textureXhrSettings")}),d=new l(t,{key:e,url:r(f,"atlasURL"),extension:r(f,"atlasExtension","xml"),xhrSettings:r(f,"atlasXhrSettings")})}else c=new o(t,e,i,s),d=new l(t,e,n,u);c.linkFile?h.call(this,t,"atlasxml",e,[c,d,c.linkFile]):h.call(this,t,"atlasxml",e,[c,d])},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.AtlasXMLFile#addToCache
     * @since 3.7.0
     */addToCache:function(){if(this.isReadyToProcess()){var t=this.files[0],e=this.files[1],i=this.files[2]?this.files[2].data:null;this.loader.textureManager.addAtlasXML(t.key,t.data,e.data,i),e.addToCache(),this.complete=!0}}});/**
 * Adds an XML based Texture Atlas, or array of atlases, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.atlasXML('mainmenu', 'images/MainMenu.png', 'images/MainMenu.xml');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
 * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
 *
 * Phaser expects the atlas data to be provided in an XML file format.
 * These files are created by software such as Shoebox and Adobe Flash / Animate.
 *
 * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
 *
 * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Texture Manager first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.atlasXML({
 *     key: 'mainmenu',
 *     textureURL: 'images/MainMenu.png',
 *     atlasURL: 'images/MainMenu.xml'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig` for more details.
 *
 * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:
 *
 * ```javascript
 * this.load.atlasXML('mainmenu', 'images/MainMenu.png', 'images/MainMenu.xml');
 * // and later in your game ...
 * this.add.image(x, y, 'mainmenu', 'background');
 * ```
 *
 * To get a list of all available frames within an atlas please consult your Texture Atlas software.
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
 * this is what you would use to retrieve the image from the Texture Manager.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,
 * then you can specify it by providing an array as the `url` where the second element is the normal map:
 *
 * ```javascript
 * this.load.atlasXML('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.xml');
 * ```
 *
 * Or, if you are using a config object use the `normalMap` property:
 *
 * ```javascript
 * this.load.atlasXML({
 *     key: 'mainmenu',
 *     textureURL: 'images/MainMenu.png',
 *     normalMap: 'images/MainMenu-n.png',
 *     atlasURL: 'images/MainMenu.xml'
 * });
 * ```
 *
 * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.
 * Normal maps are a WebGL only feature.
 *
 * Note: The ability to load this type of file will only be available if the Atlas XML File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#atlasXML
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.7.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig|Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
 * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was "alien" then the URL will be "alien.xml".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas xml file. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */n.register("atlasXML",function(t,e,i,n,s){var r;//  Supports an Object file definition in the key argument
//  Or an array of objects in the key argument
//  Or a single entry where all arguments have been defined
if(Array.isArray(t))for(var o=0;o<t.length;o++)r=new u(this,t[o]),this.addFile(r.files);else r=new u(this,t,e,i,n,s),this.addFile(r.files);return this}),t.exports=u}),r("wRXCw",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=s("1zOUS"),u=new i({Extends:r,initialize:function(t,e,i,n){var s="xml";if(h(e)){var o=e;e=a(o,"key"),i=a(o,"url"),n=a(o,"xhrSettings"),s=a(o,"extension",s)}var l={type:"xml",cache:t.cacheManager.xml,extension:s,responseType:"text",key:e,url:i,xhrSettings:n};r.call(this,t,l)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.XMLFile#onProcess
     * @since 3.7.0
     */onProcess:function(){this.state=n.FILE_PROCESSING,this.data=l(this.xhrLoader.responseText),this.data?this.onProcessComplete():(console.warn("Invalid XMLFile: "+this.key),this.onProcessError())}});/**
 * Adds an XML file, or array of XML files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 * 
 * ```javascript
 * function preload ()
 * {
 *     this.load.xml('wavedata', 'files/AlienWaveData.xml');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 * 
 * The key must be a unique String. It is used to add the file to the global XML Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the XML Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the XML Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 * 
 * ```javascript
 * this.load.xml({
 *     key: 'wavedata',
 *     url: 'files/AlienWaveData.xml'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.XMLFileConfig` for more details.
 *
 * Once the file has finished loading you can access it from its Cache using its key:
 * 
 * ```javascript
 * this.load.xml('wavedata', 'files/AlienWaveData.xml');
 * // and later in your game ...
 * var data = this.cache.xml.get('wavedata');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and
 * this is what you would use to retrieve the text from the XML Cache.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "data"
 * and no URL is given then the Loader will set the URL to be "data.xml". It will always add `.xml` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the XML File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#xml
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.XMLFileConfig|Phaser.Types.Loader.FileTypes.XMLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was "alien" then the URL will be "alien.xml".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("xml",function(t,e,i){if(Array.isArray(t))for(var n=0;n<t.length;n++)this.addFile(new u(this,t[n]));else this.addFile(new u(this,t,e,i));return this}),t.exports=u}),r("5fnRj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("cBw3Y"),l=s("jC9MQ"),u=new i({Extends:r,initialize:function(t,e,i,n,s){if(l(e)){var o=e;e=a(o,"key"),n=a(o,"xhrSettings"),s=a(o,"context",s)}var h={type:"audio",cache:t.cacheManager.audio,extension:i.type,responseType:"arraybuffer",key:e,url:i.url,xhrSettings:n,config:{context:s}};r.call(this,t,h)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.AudioFile#onProcess
     * @since 3.0.0
     */onProcess:function(){this.state=n.FILE_PROCESSING;var t=this;// interesting read https://github.com/WebAudio/web-audio-api/issues/1305
this.config.context.decodeAudioData(this.xhrLoader.response,function(e){t.data=e,t.onProcessComplete()},function(e){// eslint-disable-next-line no-console
console.error("Error decoding audio: "+this.key+" - ",e?e.message:null),t.onProcessError()}),this.config.context=null}});u.create=function(t,e,i,n,s){var r=t.systems.game,o=r.config.audio,c=r.device.audio;//  url may be inside key, which may be an object
l(e)&&(i=a(e,"url",[]),n=a(e,"config",{}));var d=u.getAudioURL(r,i);return d?c.webAudio&&!(o&&o.disableWebAudio)?new u(t,e,d,s,r.sound.context):new h(t,e,d,n):null},u.getAudioURL=function(t,e){Array.isArray(e)||(e=[e]);for(var i=0;i<e.length;i++){var n=a(e[i],"url",e[i]);if(0===n.indexOf("blob:")||0===n.indexOf("data:"))return{url:n,type:""};var s=n.match(/\.([a-zA-Z0-9]+)($|\?)/);if(s=a(e[i],"type",s?s[1]:"").toLowerCase(),t.device.audio[s])return{url:n,type:s}}return null},/**
 * Adds an Audio or HTML5Audio file, or array of audio files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.audio('title', [ 'music/Title.ogg', 'music/Title.mp3', 'music/Title.m4a' ]);
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global Audio Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Audio Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Audio Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.audio({
 *     key: 'title',
 *     url: [ 'music/Title.ogg', 'music/Title.mp3', 'music/Title.m4a' ]
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.AudioFileConfig` for more details.
 *
 * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.
 *
 * Due to different browsers supporting different audio file types you should usually provide your audio files in a variety of formats.
 * ogg, mp3 and m4a are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on
 * browser support.
 *
 * If audio has been disabled in your game, either via the game config, or lack of support from the device, then no audio will be loaded.
 *
 * Note: The ability to load this type of file will only be available if the Audio File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#audio
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.AudioFileConfig|Phaser.Types.Loader.FileTypes.AudioFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {(string|string[])} [urls] - The absolute or relative URL to load the audio files from.
 * @param {any} [config] - An object containing an `instances` property for HTML5Audio. Defaults to 1.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("audio",function(t,e,i,n){var s,r=this.systems.game,o=r.config.audio,a=r.device.audio;if(o&&o.noAudio||!a.webAudio&&!a.audioData)return this;if(Array.isArray(t))for(var h=0;h<t.length;h++)//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
(s=u.create(this,t[h]))&&this.addFile(s);else(s=u.create(this,t,e,i,n))&&this.addFile(s);return this}),t.exports=u}),r("cBw3Y",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("ls69h"),r=s("8Aww1"),o=s("7BSWl"),a=s("6MxE8"),h=s("jC9MQ"),l=new i({Extends:r,initialize:function(t,e,i,n){if(h(e)){var s=e;e=o(s,"key"),n=o(s,"config",n)}var a={type:"audio",cache:t.cacheManager.audio,extension:i.type,key:e,url:i.url,config:n};r.call(this,t,a),//  New properties specific to this class
this.locked="ontouchstart"in window,this.loaded=!1,this.filesLoaded=0,this.filesTotal=0},/**
     * Called when the file finishes loading.
     *
     * @method Phaser.Loader.FileTypes.HTML5AudioFile#onLoad
     * @since 3.0.0
     */onLoad:function(){this.loaded||(this.loaded=!0,this.loader.nextFile(this,!0))},/**
     * Called if the file errors while loading.
     *
     * @method Phaser.Loader.FileTypes.HTML5AudioFile#onError
     * @since 3.0.0
     */onError:function(){for(var t=0;t<this.data.length;t++){var e=this.data[t];e.oncanplaythrough=null,e.onerror=null}this.loader.nextFile(this,!1)},/**
     * Called during the file load progress. Is sent a DOM ProgressEvent.
     *
     * @method Phaser.Loader.FileTypes.HTML5AudioFile#onProgress
     * @fires Phaser.Loader.Events#FILE_PROGRESS
     * @since 3.0.0
     */onProgress:function(t){var e=t.target;e.oncanplaythrough=null,e.onerror=null,this.filesLoaded++,this.percentComplete=Math.min(this.filesLoaded/this.filesTotal,1),this.loader.emit(n.FILE_PROGRESS,this,this.percentComplete),this.filesLoaded===this.filesTotal&&this.onLoad()},/**
     * Called by the Loader, starts the actual file downloading.
     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.
     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.
     *
     * @method Phaser.Loader.FileTypes.HTML5AudioFile#load
     * @since 3.0.0
     */load:function(){this.data=[];var t=this.config&&this.config.instances||1;this.filesTotal=t,this.filesLoaded=0,this.percentComplete=0;for(var e=0;e<t;e++){var i=new Audio;i.dataset||(i.dataset={}),i.dataset.name=this.key+("0"+e).slice(-2),i.dataset.used="false",this.locked?i.dataset.locked="true":(i.dataset.locked="false",i.preload="auto",i.oncanplaythrough=this.onProgress.bind(this),i.onerror=this.onError.bind(this)),this.data.push(i)}for(e=0;e<this.data.length;e++)(i=this.data[e]).src=a(this,this.loader.baseURL),this.locked||i.load();this.locked&&//  Is there another way?
setTimeout(this.onLoad.bind(this))}});t.exports=l}),r("2PFPJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5fnRj"),n=s("jwj1g"),r=s("9csvT"),o=s("7BSWl"),a=s("jC9MQ"),h=s("j0zmu"),l=s("B7Zxi"),u=new n({Extends:l,initialize:function(t,e,n,s,r,u,c){if(a(e)){var d,f=e;e=o(f,"key"),n=o(f,"jsonURL"),s=o(f,"audioURL"),r=o(f,"audioConfig"),u=o(f,"audioXhrSettings"),c=o(f,"jsonXhrSettings")}//  No url? then we're going to do a json load and parse it from that
if(s){var p=i.create(t,e,s,r,u);p&&(d=new h(t,e,n,c),l.call(this,t,"audiosprite",e,[p,d]),this.config.resourceLoad=!1)}else d=new h(t,e,n,c),l.call(this,t,"audiosprite",e,[d]),this.config.resourceLoad=!0,this.config.audioConfig=r,this.config.audioXhrSettings=u},/**
     * Called by each File when it finishes loading.
     *
     * @method Phaser.Loader.FileTypes.AudioSpriteFile#onFileComplete
     * @since 3.7.0
     *
     * @param {Phaser.Loader.File} file - The File that has completed processing.
     */onFileComplete:function(t){if(-1!==this.files.indexOf(t)&&(this.pending--,this.config.resourceLoad&&"json"===t.type&&t.data.hasOwnProperty("resources"))){//  Inspect the data for the files to now load
var e=t.data.resources,n=o(this.config,"audioConfig"),s=o(this.config,"audioXhrSettings"),r=i.create(this.loader,t.key,e,n,s);r&&(this.addToMultiFile(r),this.loader.addFile(r))}},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.AudioSpriteFile#addToCache
     * @since 3.7.0
     */addToCache:function(){if(this.isReadyToProcess()){var t=this.files[0],e=this.files[1];t.addToCache(),e.addToCache(),this.complete=!0}}});/**
 * Adds a JSON based Audio Sprite, or array of audio sprites, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.audioSprite('kyobi', 'kyobi.json', [
 *         'kyobi.ogg',
 *         'kyobi.mp3',
 *         'kyobi.m4a'
 *     ]);
 * }
 * ```
 *
 * Audio Sprites are a combination of audio files and a JSON configuration.
 * The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite
 *
 * If the JSON file includes a 'resource' object then you can let Phaser parse it and load the audio
 * files automatically based on its content. To do this exclude the audio URLs from the load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.audioSprite('kyobi', 'kyobi.json');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
 * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
 *
 * The key must be a unique String. It is used to add the file to the global Audio Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Audio Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Audio Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.audioSprite({
 *     key: 'kyobi',
 *     jsonURL: 'audio/Kyobi.json',
 *     audioURL: [
 *         'audio/Kyobi.ogg',
 *         'audio/Kyobi.mp3',
 *         'audio/Kyobi.m4a'
 *     ]
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig` for more details.
 *
 * Instead of passing a URL for the audio JSON data you can also pass in a well formed JSON object instead.
 *
 * Once the audio has finished loading you can use it create an Audio Sprite by referencing its key:
 *
 * ```javascript
 * this.load.audioSprite('kyobi', 'kyobi.json');
 * // and later in your game ...
 * var music = this.sound.addAudioSprite('kyobi');
 * music.play('title');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
 * this is what you would use to retrieve the image from the Texture Manager.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * Due to different browsers supporting different audio file types you should usually provide your audio files in a variety of formats.
 * ogg, mp3 and m4a are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on
 * browser support.
 *
 * If audio has been disabled in your game, either via the game config, or lack of support from the device, then no audio will be loaded.
 *
 * Note: The ability to load this type of file will only be available if the Audio Sprite File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#audioSprite
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig|Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig[])} key - The key to use for this file, or a file configuration object, or an array of objects.
 * @param {string} jsonURL - The absolute or relative URL to load the json file from. Or a well formed JSON object to use instead.
 * @param {(string|string[])} [audioURL] - The absolute or relative URL to load the audio file from. If empty it will be obtained by parsing the JSON file.
 * @param {any} [audioConfig] - The audio configuration options.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [audioXhrSettings] - An XHR Settings configuration object for the audio file. Used in replacement of the Loaders default XHR Settings.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [jsonXhrSettings] - An XHR Settings configuration object for the json file. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader.
 */r.register("audioSprite",function(t,e,i,n,s,r){var o,a=this.systems.game,h=a.config.audio,l=a.device.audio;if(h&&h.noAudio||!l.webAudio&&!l.audioData)return this;//  Supports an Object file definition in the key argument
//  Or an array of objects in the key argument
//  Or a single entry where all arguments have been defined
if(Array.isArray(t))for(var c=0;c<t.length;c++)(o=new u(this,t[c])).files&&this.addFile(o.files);else(o=new u(this,t,e,i,n,s,r)).files&&this.addFile(o.files);return this})}),r("htyZ3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=new i({Extends:r,initialize:function(t,e,i,n,s){var o="bin";if(h(e)){var l=e;e=a(l,"key"),i=a(l,"url"),n=a(l,"xhrSettings"),o=a(l,"extension",o),s=a(l,"dataType",s)}var u={type:"binary",cache:t.cacheManager.binary,extension:o,responseType:"arraybuffer",key:e,url:i,xhrSettings:n,config:{dataType:s}};r.call(this,t,u)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.BinaryFile#onProcess
     * @since 3.7.0
     */onProcess:function(){this.state=n.FILE_PROCESSING;var t=this.config.dataType;this.data=t?new t(this.xhrLoader.response):this.xhrLoader.response,this.onProcessComplete()}});/**
 * Adds a Binary file, or array of Binary files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.binary('doom', 'files/Doom.wad');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global Binary Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Binary Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Binary Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.binary({
 *     key: 'doom',
 *     url: 'files/Doom.wad',
 *     dataType: Uint8Array
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.BinaryFileConfig` for more details.
 *
 * Once the file has finished loading you can access it from its Cache using its key:
 *
 * ```javascript
 * this.load.binary('doom', 'files/Doom.wad');
 * // and later in your game ...
 * var data = this.cache.binary.get('doom');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `LEVEL1.` and the key was `Data` the final key will be `LEVEL1.Data` and
 * this is what you would use to retrieve the text from the Binary Cache.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "doom"
 * and no URL is given then the Loader will set the URL to be "doom.bin". It will always add `.bin` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the Binary File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#binary
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.BinaryFileConfig|Phaser.Types.Loader.FileTypes.BinaryFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.bin`, i.e. if `key` was "alien" then the URL will be "alien.bin".
 * @param {any} [dataType] - Optional type to cast the binary file to once loaded. For example, `Uint8Array`.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("binary",function(t,e,i,n){if(Array.isArray(t))for(var s=0;s<t.length;s++)this.addFile(new l(this,t[s]));else this.addFile(new l(this,t,e,n,i));return this}),t.exports=l}),r("eqnR1",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("9csvT"),r=s("7BSWl"),o=s("gT96E"),a=s("jC9MQ"),h=s("B7Zxi"),l=s("5t9GW"),u=s("wRXCw"),c=new i({Extends:h,initialize:function(t,e,i,n,s,l){if(a(e)){var c,d,f=e;e=r(f,"key"),c=new o(t,{key:e,url:r(f,"textureURL"),extension:r(f,"textureExtension","png"),normalMap:r(f,"normalMap"),xhrSettings:r(f,"textureXhrSettings")}),d=new u(t,{key:e,url:r(f,"fontDataURL"),extension:r(f,"fontDataExtension","xml"),xhrSettings:r(f,"fontDataXhrSettings")})}else c=new o(t,e,i,s),d=new u(t,e,n,l);c.linkFile?h.call(this,t,"bitmapfont",e,[c,d,c.linkFile]):h.call(this,t,"bitmapfont",e,[c,d])},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.BitmapFontFile#addToCache
     * @since 3.7.0
     */addToCache:function(){if(this.isReadyToProcess()){var t=this.files[0],e=this.files[1];t.addToCache(),e.addToCache(),this.loader.cacheManager.bitmapFont.add(t.key,{data:l(e.data),texture:t.key,frame:null}),this.complete=!0}}});/**
 * Adds an XML based Bitmap Font, or array of fonts, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:

 * ```javascript
 * function preload ()
 * {
 *     this.load.bitmapFont('goldenFont', 'images/GoldFont.png', 'images/GoldFont.xml');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
 * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
 *
 * Phaser expects the font data to be provided in an XML file format.
 * These files are created by software such as the [Angelcode Bitmap Font Generator](http://www.angelcode.com/products/bmfont/),
 * [Littera](http://kvazars.com/littera/) or [Glyph Designer](https://71squared.com/glyphdesigner)
 *
 * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
 *
 * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Texture Manager first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.bitmapFont({
 *     key: 'goldenFont',
 *     textureURL: 'images/GoldFont.png',
 *     fontDataURL: 'images/GoldFont.xml'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.BitmapFontFileConfig` for more details.
 *
 * Once the atlas has finished loading you can use key of it when creating a Bitmap Text Game Object:
 *
 * ```javascript
 * this.load.bitmapFont('goldenFont', 'images/GoldFont.png', 'images/GoldFont.xml');
 * // and later in your game ...
 * this.add.bitmapText(x, y, 'goldenFont', 'Hello World');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
 * this is what you would use when creating a Bitmap Text object.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,
 * then you can specify it by providing an array as the `url` where the second element is the normal map:
 *
 * ```javascript
 * this.load.bitmapFont('goldenFont', [ 'images/GoldFont.png', 'images/GoldFont-n.png' ], 'images/GoldFont.xml');
 * ```
 *
 * Or, if you are using a config object use the `normalMap` property:
 *
 * ```javascript
 * this.load.bitmapFont({
 *     key: 'goldenFont',
 *     textureURL: 'images/GoldFont.png',
 *     normalMap: 'images/GoldFont-n.png',
 *     fontDataURL: 'images/GoldFont.xml'
 * });
 * ```
 *
 * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.
 * Normal maps are a WebGL only feature.
 *
 * Note: The ability to load this type of file will only be available if the Bitmap Font File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#bitmapFont
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.BitmapFontFileConfig|Phaser.Types.Loader.FileTypes.BitmapFontFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string|string[]} [textureURL] - The absolute or relative URL to load the font image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
 * @param {string} [fontDataURL] - The absolute or relative URL to load the font xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was "alien" then the URL will be "alien.xml".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the font image file. Used in replacement of the Loaders default XHR Settings.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [fontDataXhrSettings] - An XHR Settings configuration object for the font data xml file. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */n.register("bitmapFont",function(t,e,i,n,s){var r;//  Supports an Object file definition in the key argument
//  Or an array of objects in the key argument
//  Or a single entry where all arguments have been defined
if(Array.isArray(t))for(var o=0;o<t.length;o++)r=new c(this,t[o]),this.addFile(r.files);else r=new c(this,t,e,i,n,s),this.addFile(r.files);return this}),t.exports=c}),r("456Xt",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=new i({Extends:r,initialize:function(t,e,i,n){var s="css";if(h(e)){var o=e;e=a(o,"key"),i=a(o,"url"),n=a(o,"xhrSettings"),s=a(o,"extension",s)}var l={type:"script",cache:!1,extension:s,responseType:"text",key:e,url:i,xhrSettings:n};r.call(this,t,l)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.CSSFile#onProcess
     * @since 3.17.0
     */onProcess:function(){this.state=n.FILE_PROCESSING,this.data=document.createElement("style"),this.data.defer=!1,this.data.innerHTML=this.xhrLoader.responseText,document.head.appendChild(this.data),this.onProcessComplete()}});/**
 * Adds a CSS file, or array of CSS files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.css('headers', 'styles/headers.css');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String and not already in-use by another file in the Loader.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.css({
 *     key: 'headers',
 *     url: 'styles/headers.css'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.CSSFileConfig` for more details.
 *
 * Once the file has finished loading it will automatically be converted into a style DOM element
 * via `document.createElement('style')`. It will have its `defer` property set to false and then the
 * resulting element will be appended to `document.head`. The CSS styles are then applied to the current document.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.css". It will always add `.css` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the CSS File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#css
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.17.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.CSSFileConfig|Phaser.Types.Loader.FileTypes.CSSFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.css`, i.e. if `key` was "alien" then the URL will be "alien.css".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("css",function(t,e,i){if(Array.isArray(t))for(var n=0;n<t.length;n++)this.addFile(new l(this,t[n]));else this.addFile(new l(this,t,e,i));return this}),t.exports=l}),r("cfaNt",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=s("dtVn6"),u=new i({Extends:r,initialize:function(t,e,i,n,s){var o="glsl";if(h(e)){var l=e;e=a(l,"key"),i=a(l,"url"),n=a(l,"shaderType","fragment"),s=a(l,"xhrSettings"),o=a(l,"extension",o)}else void 0===n&&(n="fragment");var u={type:"glsl",cache:t.cacheManager.shader,extension:o,responseType:"text",key:e,url:i,config:{shaderType:n},xhrSettings:s};r.call(this,t,u)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.GLSLFile#onProcess
     * @since 3.7.0
     */onProcess:function(){this.state=n.FILE_PROCESSING,this.data=this.xhrLoader.responseText,this.onProcessComplete()},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.GLSLFile#addToCache
     * @since 3.17.0
     */addToCache:function(){var t=this.data.split("\n"),e=this.extractBlock(t,0);if(e)for(;e;){var i=this.getShaderName(e.header),n=this.getShaderType(e.header),s=this.getShaderUniforms(e.header),r=e.shader;if(this.cache.has(i)){var o=this.cache.get(i);"fragment"===n?o.fragmentSrc=r:o.vertexSrc=r,o.uniforms||(o.uniforms=s)}else"fragment"===n?this.cache.add(i,new l(i,r,"",s)):this.cache.add(i,new l(i,"",r,s));e=this.extractBlock(t,e.offset)}else"fragment"===this.config.shaderType?this.cache.add(this.key,new l(this.key,this.data)):this.cache.add(this.key,new l(this.key,"",this.data));this.pendingDestroy()},/**
     * Returns the name of the shader from the header block.
     *
     * @method Phaser.Loader.FileTypes.GLSLFile#getShaderName
     * @since 3.17.0
     *
     * @param {string[]} headerSource - The header data.
     *
     * @return {string} The shader name.
     */getShaderName:function(t){for(var e=0;e<t.length;e++){var i=t[e].trim();if("name:"===i.substring(0,5))return i.substring(5).trim()}return this.key},/**
     * Returns the type of the shader from the header block.
     *
     * @method Phaser.Loader.FileTypes.GLSLFile#getShaderType
     * @since 3.17.0
     *
     * @param {string[]} headerSource - The header data.
     *
     * @return {string} The shader type. Either 'fragment' or 'vertex'.
     */getShaderType:function(t){for(var e=0;e<t.length;e++){var i=t[e].trim();if("type:"===i.substring(0,5))return i.substring(5).trim()}return this.config.shaderType},/**
     * Returns the shader uniforms from the header block.
     *
     * @method Phaser.Loader.FileTypes.GLSLFile#getShaderUniforms
     * @since 3.17.0
     *
     * @param {string[]} headerSource - The header data.
     *
     * @return {any} The shader uniforms object.
     */getShaderUniforms:function(t){for(var e={},i=0;i<t.length;i++){var n=t[i].trim();if("uniform."===n.substring(0,8)){var s=n.indexOf(":");if(s){var r=n.substring(8,s);try{e[r]=JSON.parse(n.substring(s+1))}catch(t){console.warn("Invalid uniform JSON: "+r)}}}}return e},/**
     * Processes the shader file and extracts the relevant data.
     *
     * @method Phaser.Loader.FileTypes.GLSLFile#extractBlock
     * @private
     * @since 3.17.0
     *
     * @param {string[]} data - The array of shader data to process.
     * @param {integer} offset - The offset to start processing from.
     *
     * @return {any} The processed shader block, or null.
     */extractBlock:function(t,e){for(var i=-1,n=-1,s=-1,r=!1,o=!1,a=[],h=[],l=e;l<t.length;l++){var u=t[l].trim();if("---"===u){if(-1===i)i=l,r=!0;else if(r)n=l,r=!1,o=!0;else{//  We've hit another --- delimiter, break out
o=!1;break}}else r?a.push(u):o&&(h.push(u),s=l)}return r||-1===n?null:{header:a,shader:h.join("\n"),offset:s}}});/**
 * Adds a GLSL file, or array of GLSL files, to the current load queue.
 * In Phaser 3 GLSL files are just plain Text files at the current moment in time.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.glsl('plasma', 'shaders/Plasma.glsl');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global Shader Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Shader Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Shader Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.glsl({
 *     key: 'plasma',
 *     shaderType: 'fragment',
 *     url: 'shaders/Plasma.glsl'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.GLSLFileConfig` for more details.
 *
 * Once the file has finished loading you can access it from its Cache using its key:
 *
 * ```javascript
 * this.load.glsl('plasma', 'shaders/Plasma.glsl');
 * // and later in your game ...
 * var data = this.cache.shader.get('plasma');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `FX.` and the key was `Plasma` the final key will be `FX.Plasma` and
 * this is what you would use to retrieve the text from the Shader Cache.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "plasma"
 * and no URL is given then the Loader will set the URL to be "plasma.glsl". It will always add `.glsl` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the GLSL File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#glsl
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.GLSLFileConfig|Phaser.Types.Loader.FileTypes.GLSLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.glsl`, i.e. if `key` was "alien" then the URL will be "alien.glsl".
 * @param {string} [shaderType='fragment'] - The type of shader. Either `fragment` for a fragment shader, or `vertex` for a vertex shader. This is ignored if you load a shader bundle.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("glsl",function(t,e,i,n){if(Array.isArray(t))for(var s=0;s<t.length;s++)this.addFile(new u(this,t[s]));else this.addFile(new u(this,t,e,i,n));return this}),t.exports=u}),r("fky3L",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=new i({Extends:r,initialize:function(t,e,i,n){var s="html";if(h(e)){var o=e;e=a(o,"key"),i=a(o,"url"),n=a(o,"xhrSettings"),s=a(o,"extension",s)}var l={type:"text",cache:t.cacheManager.html,extension:s,responseType:"text",key:e,url:i,xhrSettings:n};r.call(this,t,l)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.HTMLFile#onProcess
     * @since 3.7.0
     */onProcess:function(){this.state=n.FILE_PROCESSING,this.data=this.xhrLoader.responseText,this.onProcessComplete()}});/**
 * Adds an HTML file, or array of HTML files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.html('story', 'files/LoginForm.html');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global HTML Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the HTML Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the HTML Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.html({
 *     key: 'login',
 *     url: 'files/LoginForm.html'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.HTMLFileConfig` for more details.
 *
 * Once the file has finished loading you can access it from its Cache using its key:
 *
 * ```javascript
 * this.load.html('login', 'files/LoginForm.html');
 * // and later in your game ...
 * var data = this.cache.html.get('login');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and
 * this is what you would use to retrieve the html from the HTML Cache.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "story"
 * and no URL is given then the Loader will set the URL to be "story.html". It will always add `.html` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the HTML File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#html
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.12.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.HTMLFileConfig|Phaser.Types.Loader.FileTypes.HTMLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was "alien" then the URL will be "alien.html".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("html",function(t,e,i){if(Array.isArray(t))for(var n=0;n<t.length;n++)this.addFile(new l(this,t[n]));else this.addFile(new l(this,t,e,i));return this}),t.exports=l}),r("hC7gq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=new i({Extends:r,initialize:function(t,e,i,n,s,o){void 0===n&&(n=512),void 0===s&&(s=512);var l="html";if(h(e)){var u=e;e=a(u,"key"),i=a(u,"url"),o=a(u,"xhrSettings"),l=a(u,"extension",l),n=a(u,"width",n),s=a(u,"height",s)}var c={type:"html",cache:t.textureManager,extension:l,responseType:"text",key:e,url:i,xhrSettings:o,config:{width:n,height:s}};r.call(this,t,c)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.HTMLTextureFile#onProcess
     * @since 3.7.0
     */onProcess:function(){this.state=n.FILE_PROCESSING;var t=this.config.width,e=this.config.height,i=[];i.push('<svg width="'+t+'px" height="'+e+'px" viewBox="0 0 '+t+" "+e+'" xmlns="http://www.w3.org/2000/svg">'),i.push('<foreignObject width="100%" height="100%">'),i.push('<body xmlns="http://www.w3.org/1999/xhtml">'),i.push(this.xhrLoader.responseText),i.push("</body>"),i.push("</foreignObject>"),i.push("</svg>");var s=[i.join("\n")],o=this;try{var a=new window.Blob(s,{type:"image/svg+xml;charset=utf-8"})}catch(t){o.state=n.FILE_ERRORED,o.onProcessComplete();return}this.data=new Image,this.data.crossOrigin=this.crossOrigin,this.data.onload=function(){r.revokeObjectURL(o.data),o.onProcessComplete()},this.data.onerror=function(){r.revokeObjectURL(o.data),o.onProcessError()},r.createObjectURL(this.data,a,"image/svg+xml")},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.HTMLTextureFile#addToCache
     * @since 3.7.0
     */addToCache:function(){var t=this.cache.addImage(this.key,this.data);this.pendingDestroy(t)}});/**
 * Adds an HTML File, or array of HTML Files, to the current load queue. When the files are loaded they
 * will be rendered to textures and stored in the Texture Manager.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.htmlTexture('instructions', 'content/intro.html', 256, 512);
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Texture Manager first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.htmlTexture({
 *     key: 'instructions',
 *     url: 'content/intro.html',
 *     width: 256,
 *     height: 512
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig` for more details.
 *
 * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:
 *
 * ```javascript
 * this.load.htmlTexture('instructions', 'content/intro.html', 256, 512);
 * // and later in your game ...
 * this.add.image(x, y, 'instructions');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
 * this is what you would use to retrieve the image from the Texture Manager.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.html". It will always add `.html` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * The width and height are the size of the texture to which the HTML will be rendered. It's not possible to determine these
 * automatically, so you will need to provide them, either as arguments or in the file config object.
 * When the HTML file has loaded a new SVG element is created with a size and viewbox set to the width and height given.
 * The SVG file has a body tag added to it, with the HTML file contents included. It then calls `window.Blob` on the SVG,
 * and if successful is added to the Texture Manager, otherwise it fails processing. The overall quality of the rendered
 * HTML depends on your browser, and some of them may not even support the svg / blob process used. Be aware that there are
 * limitations on what HTML can be inside an SVG. You can find out more details in this
 * [Mozilla MDN entry](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Drawing_DOM_objects_into_a_canvas).
 *
 * Note: The ability to load this type of file will only be available if the HTMLTextureFile File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#htmlTexture
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.12.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig|Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was "alien" then the URL will be "alien.html".
 * @param {integer} [width=512] - The width of the texture the HTML will be rendered to.
 * @param {integer} [height=512] - The height of the texture the HTML will be rendered to.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("htmlTexture",function(t,e,i,n,s){if(Array.isArray(t))for(var r=0;r<t.length;r++)this.addFile(new l(this,t[r]));else this.addFile(new l(this,t,e,i,n,s));return this}),t.exports=l}),r("3NA92",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("9csvT"),r=s("7BSWl"),o=s("gT96E"),a=s("jC9MQ"),h=s("j0zmu"),l=s("B7Zxi"),u=new i({Extends:l,initialize:function(t,e,i,n,s,o,u){if(a(e)){var c=e;e=r(c,"key"),i=r(c,"url",!1)?r(c,"url"):r(c,"atlasURL"),o=r(c,"xhrSettings"),n=r(c,"path"),s=r(c,"baseURL"),u=r(c,"textureXhrSettings")}var d=new h(t,e,i,o);l.call(this,t,"multiatlas",e,[d]),this.config.path=n,this.config.baseURL=s,this.config.textureXhrSettings=u},/**
     * Called by each File when it finishes loading.
     *
     * @method Phaser.Loader.FileTypes.MultiAtlasFile#onFileComplete
     * @since 3.7.0
     *
     * @param {Phaser.Loader.File} file - The File that has completed processing.
     */onFileComplete:function(t){if(-1!==this.files.indexOf(t)&&(this.pending--,"json"===t.type&&t.data.hasOwnProperty("textures"))){//  Inspect the data for the files to now load
var e=t.data.textures,i=this.config,n=this.loader,s=n.baseURL,a=n.path,h=n.prefix,l=r(i,"baseURL",this.baseURL),u=r(i,"path",this.path),c=r(i,"prefix",this.prefix),d=r(i,"textureXhrSettings");n.setBaseURL(l),n.setPath(u),n.setPrefix(c);for(var f=0;f<e.length;f++){//  "image": "texture-packer-multi-atlas-0.png",
var p=e[f].image,g="MA"+this.multiKeyIndex+"_"+p,v=new o(n,g,p,d);//  "normalMap": "texture-packer-multi-atlas-0_n.png",
if(this.addToMultiFile(v),n.addFile(v),e[f].normalMap){var m=new o(n,g,e[f].normalMap,d);m.type="normalMap",v.setLink(m),this.addToMultiFile(m),n.addFile(m)}}//  Reset the loader settings
n.setBaseURL(s),n.setPath(a),n.setPrefix(h)}},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.MultiAtlasFile#addToCache
     * @since 3.7.0
     */addToCache:function(){if(this.isReadyToProcess()){for(var t=this.files[0],e=[],i=[],n=[],s=1;s<this.files.length;s++){var r=this.files[s];if("normalMap"!==r.type)//  Now we need to find out which json entry this mapped to
for(var o=r.key.indexOf("_"),a=r.key.substr(o+1),h=r.data,l=0;l<t.data.textures.length;l++){var u=t.data.textures[l];if(u.image===a){i.push(h),e.push(u),r.linkFile&&n.push(r.linkFile.data);break}}}for(0===n.length&&(n=void 0),this.loader.textureManager.addAtlasJSONArray(this.key,i,e,n),this.complete=!0,s=0;s<this.files.length;s++)this.files[s].pendingDestroy()}}});/**
 * Adds a Multi Texture Atlas, or array of multi atlases, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.multiatlas('level1', 'images/Level1.json');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
 * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
 *
 * Phaser expects the atlas data to be provided in a JSON file as exported from the application Texture Packer,
 * version 4.6.3 or above, where you have made sure to use the Phaser 3 Export option.
 *
 * The way it works internally is that you provide a URL to the JSON file. Phaser then loads this JSON, parses it and
 * extracts which texture files it also needs to load to complete the process. If the JSON also defines normal maps,
 * Phaser will load those as well.
 *
 * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Texture Manager first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.multiatlas({
 *     key: 'level1',
 *     atlasURL: 'images/Level1.json'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig` for more details.
 *
 * Instead of passing a URL for the atlas JSON data you can also pass in a well formed JSON object instead.
 *
 * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:
 *
 * ```javascript
 * this.load.multiatlas('level1', 'images/Level1.json');
 * // and later in your game ...
 * this.add.image(x, y, 'level1', 'background');
 * ```
 *
 * To get a list of all available frames within an atlas please consult your Texture Atlas software.
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
 * this is what you would use to retrieve the image from the Texture Manager.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the Multi Atlas File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#multiatlas
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.7.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig|Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
 * @param {string} [path] - Optional path to use when loading the textures defined in the atlas data.
 * @param {string} [baseURL] - Optional Base URL to use when loading the textures defined in the atlas data.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */n.register("multiatlas",function(t,e,i,n,s){var r;//  Supports an Object file definition in the key argument
//  Or an array of objects in the key argument
//  Or a single entry where all arguments have been defined
if(Array.isArray(t))for(var o=0;o<t.length;o++)r=new u(this,t[o]),this.addFile(r.files);else r=new u(this,t,e,i,n,s),this.addFile(r.files);return this}),t.exports=u}),r("8g88p",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("9csvT"),r=s("7BSWl"),o=s("jC9MQ"),a=s("B7Zxi"),h=s("fh7OQ"),l=new i({Extends:a,initialize:function(t,e,i,n){var s="js",l=[];if(o(e)){var u=e;e=r(u,"key"),i=r(u,"url"),n=r(u,"xhrSettings"),s=r(u,"extension",s)}Array.isArray(i)||(i=[i]);for(var c=0;c<i.length;c++){var d=new h(t,{key:e+"_"+c.toString(),url:i[c],extension:s,xhrSettings:n});//  Override the default onProcess function
d.onProcess=function(){this.onProcessComplete()},l.push(d)}a.call(this,t,"scripts",e,l)},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.MultiScriptFile#addToCache
     * @since 3.17.0
     */addToCache:function(){if(this.isReadyToProcess()){for(var t=0;t<this.files.length;t++){var e=this.files[t];e.data=document.createElement("script"),e.data.language="javascript",e.data.type="text/javascript",e.data.defer=!1,e.data.text=e.xhrLoader.responseText,document.head.appendChild(e.data)}this.complete=!0}}});/**
 * Adds an array of Script files to the current load queue.
 *
 * The difference between this and the `ScriptFile` file type is that you give an array of scripts to this method,
 * and the scripts are then processed _exactly_ in that order. This allows you to load a bunch of scripts that
 * may have dependencies on each other without worrying about the async nature of traditional script loading.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.scripts('PostProcess', [
 *         'libs/shaders/CopyShader.js',
 *         'libs/postprocessing/EffectComposer.js',
 *         'libs/postprocessing/RenderPass.js',
 *         'libs/postprocessing/MaskPass.js',
 *         'libs/postprocessing/ShaderPass.js',
 *         'libs/postprocessing/AfterimagePass.js'
 *    ]);
 * }
 * ```
 *
 * In the code above the script files will all be loaded in parallel but only processed (i.e. invoked) in the exact
 * order given in the array.
 *
 * The files are **not** loaded right away. They are added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the files are queued
 * it means you cannot use the files immediately after calling this method, but must wait for the files to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String and not already in-use by another file in the Loader.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.scripts({
 *     key: 'PostProcess',
 *     url: [
 *         'libs/shaders/CopyShader.js',
 *         'libs/postprocessing/EffectComposer.js',
 *         'libs/postprocessing/RenderPass.js',
 *         'libs/postprocessing/MaskPass.js',
 *         'libs/postprocessing/ShaderPass.js',
 *         'libs/postprocessing/AfterimagePass.js'
 *        ]
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.MultiScriptFileConfig` for more details.
 *
 * Once all the files have finished loading they will automatically be converted into a script element
 * via `document.createElement('script')`. They will have their language set to JavaScript, `defer` set to
 * false and then the resulting element will be appended to `document.head`. Any code then in the
 * script will be executed. This is done in the exact order the files are specified in the url array.
 *
 * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.
 *
 * Note: The ability to load this type of file will only be available if the MultiScript File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#scripts
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.17.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.MultiScriptFileConfig|Phaser.Types.Loader.FileTypes.MultiScriptFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string[]} [url] - An array of absolute or relative URLs to load the script files from. They are processed in the order given in the array.
 * @param {string} [extension='js'] - The default file extension to use if no url is provided.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for these files.
 *
 * @return {this} The Loader instance.
 */n.register("scripts",function(t,e,i){var n;//  Supports an Object file definition in the key argument
//  Or an array of objects in the key argument
//  Or a single entry where all arguments have been defined
if(Array.isArray(t))for(var s=0;s<t.length;s++)n=new l(this,t[s]),this.addFile(n.files);else n=new l(this,t,e,i),this.addFile(n.files);return this}),t.exports=l}),r("fh7OQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=new i({Extends:r,initialize:function(t,e,i,n){var s="js";if(h(e)){var o=e;e=a(o,"key"),i=a(o,"url"),n=a(o,"xhrSettings"),s=a(o,"extension",s)}var l={type:"script",cache:!1,extension:s,responseType:"text",key:e,url:i,xhrSettings:n};r.call(this,t,l)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.ScriptFile#onProcess
     * @since 3.7.0
     */onProcess:function(){this.state=n.FILE_PROCESSING,this.data=document.createElement("script"),this.data.language="javascript",this.data.type="text/javascript",this.data.defer=!1,this.data.text=this.xhrLoader.responseText,document.head.appendChild(this.data),this.onProcessComplete()}});/**
 * Adds a Script file, or array of Script files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.script('aliens', 'lib/aliens.js');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String and not already in-use by another file in the Loader.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.script({
 *     key: 'aliens',
 *     url: 'lib/aliens.js'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.ScriptFileConfig` for more details.
 *
 * Once the file has finished loading it will automatically be converted into a script element
 * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to
 * false and then the resulting element will be appended to `document.head`. Any code then in the
 * script will be executed.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.js". It will always add `.js` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the Script File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#script
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.ScriptFileConfig|Phaser.Types.Loader.FileTypes.ScriptFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was "alien" then the URL will be "alien.js".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("script",function(t,e,i){if(Array.isArray(t))for(var n=0;n<t.length;n++)this.addFile(new l(this,t[n]));else this.addFile(new l(this,t,e,i));return this}),t.exports=l}),r("9i0hf",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("9csvT"),o=s("j0zmu"),a=new i({Extends:o,initialize://  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing
function(t,e,i,n,s){o.call(this,t,e,i,n,s),this.type="packfile"},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.PackFile#onProcess
     * @since 3.7.0
     */onProcess:function(){this.state!==n.FILE_POPULATED&&(this.state=n.FILE_PROCESSING,this.data=JSON.parse(this.xhrLoader.responseText)),//  Let's pass the pack file data over to the Loader ...
this.loader.addPack(this.data,this.config),this.onProcessComplete()}});/**
 * Adds a JSON File Pack, or array of packs, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.pack('level1', 'data/Level1Files.json');
 * }
 * ```
 *
 * A File Pack is a JSON file (or object) that contains details about other files that should be added into the Loader.
 * Here is a small example:
 *
 * ```json
 * {
 *    "test1": {
 *        "files": [
 *            {
 *                "type": "image",
 *                "key": "taikodrummaster",
 *                "url": "assets/pics/taikodrummaster.jpg"
 *            },
 *            {
 *                "type": "image",
 *                "key": "sukasuka-chtholly",
 *                "url": "assets/pics/sukasuka-chtholly.png"
 *            }
 *        ]
 *    },
 *    "meta": {
 *        "generated": "1401380327373",
 *        "app": "Phaser 3 Asset Packer",
 *        "url": "https://phaser.io",
 *        "version": "1.0",
 *        "copyright": "Photon Storm Ltd. 2018"
 *    }
 * }
 * ```
 *
 * The pack can be split into sections. In the example above you'll see a section called `test1. You can tell
 * the `load.pack` method to parse only a particular section of a pack. The pack is stored in the JSON Cache,
 * so you can pass it to the Loader to process additional sections as needed in your game, or you can just load
 * them all at once without specifying anything.
 *
 * The pack file can contain an entry for any type of file that Phaser can load. The object structures exactly
 * match that of the file type configs, and all properties available within the file type configs can be used
 * in the pack file too.
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
 * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
 *
 * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the JSON Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.pack({
 *     key: 'level1',
 *     url: 'data/Level1Files.json'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.PackFileConfig` for more details.
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and
 * this is what you would use to retrieve the text from the JSON Cache.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "data"
 * and no URL is given then the Loader will set the URL to be "data.json". It will always add `.json` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,
 * rather than the whole file. For example, if your JSON data had a structure like this:
 *
 * ```json
 * {
 *     "level1": {
 *         "baddies": {
 *             "aliens": {},
 *             "boss": {}
 *         }
 *     },
 *     "level2": {},
 *     "level3": {}
 * }
 * ```
 *
 * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.
 *
 * Note: The ability to load this type of file will only be available if the Pack File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#pack
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.7.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.PackFileConfig|Phaser.Types.Loader.FileTypes.PackFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
 * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */r.register("pack",function(t,e,i,n){//  Supports an Object file definition in the key argument
//  Or an array of objects in the key argument
//  Or a single entry where all arguments have been defined
if(Array.isArray(t))for(var s=0;s<t.length;s++)this.addFile(new a(this,t[s]));else this.addFile(new a(this,t,e,n,i));return this}),t.exports=a}),r("lpnsI",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=new i({Extends:r,initialize:function(t,e,i,s,o,l){var u="js";if(h(e)){var c=e;e=a(c,"key"),i=a(c,"url"),l=a(c,"xhrSettings"),u=a(c,"extension",u),s=a(c,"start"),o=a(c,"mapping")}var d={type:"plugin",cache:!1,extension:u,responseType:"text",key:e,url:i,xhrSettings:l,config:{start:s,mapping:o}};r.call(this,t,d),"function"==typeof i&&(this.data=i,this.state=n.FILE_POPULATED)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.PluginFile#onProcess
     * @since 3.7.0
     */onProcess:function(){var t=this.loader.systems.plugins,e=this.config,i=a(e,"start",!1),s=a(e,"mapping",null);if(this.state===n.FILE_POPULATED)t.install(this.key,this.data,i,s);else{//  Plugin added via a js file
this.state=n.FILE_PROCESSING,this.data=document.createElement("script"),this.data.language="javascript",this.data.type="text/javascript",this.data.defer=!1,this.data.text=this.xhrLoader.responseText,document.head.appendChild(this.data);var r=t.install(this.key,window[this.key],i,s);(i||s)&&(//  Install into the current Scene Systems and Scene
this.loader.systems[s]=r,this.loader.scene[s]=r)}this.onProcessComplete()}});/**
 * Adds a Plugin Script file, or array of plugin files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.plugin('modplayer', 'plugins/ModPlayer.js');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String and not already in-use by another file in the Loader.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.plugin({
 *     key: 'modplayer',
 *     url: 'plugins/ModPlayer.js'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.PluginFileConfig` for more details.
 *
 * Once the file has finished loading it will automatically be converted into a script element
 * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to
 * false and then the resulting element will be appended to `document.head`. Any code then in the
 * script will be executed. It will then be passed to the Phaser PluginCache.register method.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.js". It will always add `.js` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the Plugin File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#plugin
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.PluginFileConfig|Phaser.Types.Loader.FileTypes.PluginFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {(string|function)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was "alien" then the URL will be "alien.js". Or, a plugin function.
 * @param {boolean} [start] - Automatically start the plugin after loading?
 * @param {string} [mapping] - If this plugin is to be injected into the Scene, this is the property key used.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("plugin",function(t,e,i,n,s){if(Array.isArray(t))for(var r=0;r<t.length;r++)this.addFile(new l(this,t[r]));else this.addFile(new l(this,t,e,i,n,s));return this}),t.exports=l}),r("8nYaJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=new i({Extends:r,initialize:function(t,e,i,n){var s="js";if(h(e)){var o=e;e=a(o,"key"),i=a(o,"url"),n=a(o,"xhrSettings"),s=a(o,"extension",s)}var l={type:"text",cache:t.cacheManager.text,extension:s,responseType:"text",key:e,url:i,xhrSettings:n};r.call(this,t,l)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.SceneFile#onProcess
     * @since 3.16.0
     */onProcess:function(){this.state=n.FILE_PROCESSING,this.data=this.xhrLoader.responseText,this.onProcessComplete()},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.SceneFile#addToCache
     * @since 3.16.0
     */addToCache:function(){var t=this.data.concat("(function(){\nreturn new "+this.key+"();\n}).call(this);"),e=eval;this.loader.sceneManager.add(this.key,e(t)),this.complete=!0}});/**
 * Adds an external Scene file, or array of Scene files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.sceneFile('Level1', 'src/Level1.js');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global Scene Manager upon a successful load.
 *
 * For a Scene File it's vitally important that the key matches the class name in the JavaScript file.
 *
 * For example here is the source file:
 *
 * ```javascript
 * class ExternalScene extends Phaser.Scene {
 *
 *     constructor ()
 *     {
 *         super('myScene');
 *     }
 *
 * }
 * ```
 *
 * Because the class is called `ExternalScene` that is the exact same key you must use when loading it:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.sceneFile('ExternalScene', 'src/yourScene.js');
 * }
 * ```
 *
 * The key that is used within the Scene Manager can either be set to the same, or you can override it in the Scene
 * constructor, as we've done in the example above, where the Scene key was changed to `myScene`.
 *
 * The key should be unique both in terms of files being loaded and Scenes already present in the Scene Manager.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Scene Manager first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.sceneFile({
 *     key: 'Level1',
 *     url: 'src/Level1.js'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.SceneFileConfig` for more details.
 *
 * Once the file has finished loading it will be added to the Scene Manager.
 *
 * ```javascript
 * this.load.sceneFile('Level1', 'src/Level1.js');
 * // and later in your game ...
 * this.scene.start('Level1');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `WORLD1.` and the key was `Story` the final key will be `WORLD1.Story` and
 * this is what you would use to retrieve the text from the Scene Manager.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "story"
 * and no URL is given then the Loader will set the URL to be "story.js". It will always add `.js` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the Scene File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#sceneFile
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.16.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.SceneFileConfig|Phaser.Types.Loader.FileTypes.SceneFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was "alien" then the URL will be "alien.js".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("sceneFile",function(t,e,i){if(Array.isArray(t))for(var n=0;n<t.length;n++)this.addFile(new l(this,t[n]));else this.addFile(new l(this,t,e,i));return this}),t.exports=l}),r("4FmI6",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=new i({Extends:r,initialize:function(t,e,i,s,o,l){var u="js";if(h(e)){var c=e;e=a(c,"key"),i=a(c,"url"),l=a(c,"xhrSettings"),u=a(c,"extension",u),s=a(c,"systemKey"),o=a(c,"sceneKey")}var d={type:"scenePlugin",cache:!1,extension:u,responseType:"text",key:e,url:i,xhrSettings:l,config:{systemKey:s,sceneKey:o}};r.call(this,t,d),"function"==typeof i&&(this.data=i,this.state=n.FILE_POPULATED)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.ScenePluginFile#onProcess
     * @since 3.8.0
     */onProcess:function(){var t=this.loader.systems.plugins,e=this.config,i=this.key,s=a(e,"systemKey",i),r=a(e,"sceneKey",i);this.state===n.FILE_POPULATED?t.installScenePlugin(s,this.data,r,this.loader.scene,!0):(//  Plugin added via a js file
this.state=n.FILE_PROCESSING,this.data=document.createElement("script"),this.data.language="javascript",this.data.type="text/javascript",this.data.defer=!1,this.data.text=this.xhrLoader.responseText,document.head.appendChild(this.data),t.installScenePlugin(s,window[this.key],r,this.loader.scene,!0)),this.onProcessComplete()}});/**
 * Adds a Scene Plugin Script file, or array of plugin files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.scenePlugin('ModPlayer', 'plugins/ModPlayer.js', 'modPlayer', 'mods');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String and not already in-use by another file in the Loader.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.scenePlugin({
 *     key: 'modplayer',
 *     url: 'plugins/ModPlayer.js'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.ScenePluginFileConfig` for more details.
 *
 * Once the file has finished loading it will automatically be converted into a script element
 * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to
 * false and then the resulting element will be appended to `document.head`. Any code then in the
 * script will be executed. It will then be passed to the Phaser PluginCache.register method.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.js". It will always add `.js` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the Script File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#scenePlugin
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.8.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.ScenePluginFileConfig|Phaser.Types.Loader.FileTypes.ScenePluginFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {(string|function)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was "alien" then the URL will be "alien.js". Or, set to a plugin function.
 * @param {string} [systemKey] - If this plugin is to be added to Scene.Systems, this is the property key for it.
 * @param {string} [sceneKey] - If this plugin is to be added to the Scene, this is the property key for it.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("scenePlugin",function(t,e,i,n,s){if(Array.isArray(t))for(var r=0;r<t.length;r++)this.addFile(new l(this,t[r]));else this.addFile(new l(this,t,e,i,n,s));return this}),t.exports=l}),r("7z6bR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("9csvT"),r=s("gT96E"),o=new i({Extends:r,initialize:function(t,e,i,n,s){r.call(this,t,e,i,s,n),this.type="spritesheet"},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.SpriteSheetFile#addToCache
     * @since 3.7.0
     */addToCache:function(){var t=this.cache.addSpriteSheet(this.key,this.data,this.config);this.pendingDestroy(t)}});/**
 * Adds a Sprite Sheet Image, or array of Sprite Sheet Images, to the current load queue.
 *
 * The term 'Sprite Sheet' in Phaser means a fixed-size sheet. Where every frame in the sheet is the exact same size,
 * and you reference those frames using numbers, not frame names. This is not the same thing as a Texture Atlas, where
 * the frames are packed in a way where they take up the least amount of space, and are referenced by their names,
 * not numbers. Some articles and software use the term 'Sprite Sheet' to mean Texture Atlas, so please be aware of
 * what sort of file you're actually trying to load.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 * 
 * ```javascript
 * function preload ()
 * {
 *     this.load.spritesheet('bot', 'images/robot.png', { frameWidth: 32, frameHeight: 38 });
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 * 
 * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
 * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback
 * of animated gifs to Canvas elements.
 *
 * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Texture Manager first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 * 
 * ```javascript
 * this.load.spritesheet({
 *     key: 'bot',
 *     url: 'images/robot.png',
 *     frameConfig: {
 *         frameWidth: 32,
 *         frameHeight: 38,
 *         startFrame: 0,
 *         endFrame: 8
 *     }
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig` for more details.
 *
 * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:
 * 
 * ```javascript
 * this.load.spritesheet('bot', 'images/robot.png', { frameWidth: 32, frameHeight: 38 });
 * // and later in your game ...
 * this.add.image(x, y, 'bot', 0);
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `PLAYER.` and the key was `Running` the final key will be `PLAYER.Running` and
 * this is what you would use to retrieve the image from the Texture Manager.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,
 * then you can specify it by providing an array as the `url` where the second element is the normal map:
 * 
 * ```javascript
 * this.load.spritesheet('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ], { frameWidth: 256, frameHeight: 80 });
 * ```
 *
 * Or, if you are using a config object use the `normalMap` property:
 * 
 * ```javascript
 * this.load.spritesheet({
 *     key: 'logo',
 *     url: 'images/AtariLogo.png',
 *     normalMap: 'images/AtariLogo-n.png',
 *     frameConfig: {
 *         frameWidth: 256,
 *         frameHeight: 80
 *     }
 * });
 * ```
 *
 * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.
 * Normal maps are a WebGL only feature.
 * 
 * Note: The ability to load this type of file will only be available if the Sprite Sheet File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#spritesheet
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig|Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
 * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object. At a minimum it should have a `frameWidth` property.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */n.register("spritesheet",function(t,e,i,n){if(Array.isArray(t))for(var s=0;s<t.length;s++)this.addFile(new o(this,t[s]));else this.addFile(new o(this,t,e,i,n));return this}),t.exports=o}),r("763ZX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=new i({Extends:r,initialize:function(t,e,i,n,s){var o="svg";if(h(e)){var l=e;e=a(l,"key"),i=a(l,"url"),n=a(l,"svgConfig",{}),s=a(l,"xhrSettings"),o=a(l,"extension",o)}var u={type:"svg",cache:t.textureManager,extension:o,responseType:"text",key:e,url:i,xhrSettings:s,config:{width:a(n,"width"),height:a(n,"height"),scale:a(n,"scale")}};r.call(this,t,u)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.SVGFile#onProcess
     * @since 3.7.0
     */onProcess:function(){this.state=n.FILE_PROCESSING;var t=this.xhrLoader.responseText,e=[t],i=this.config.width,s=this.config.height,o=this.config.scale;t:if(i&&s||o){var a=new DOMParser().parseFromString(t,"text/xml").getElementsByTagName("svg")[0],h=a.hasAttribute("viewBox"),l=parseFloat(a.getAttribute("width")),u=parseFloat(a.getAttribute("height"));if(!h&&l&&u)a.setAttribute("viewBox","0  0 "+l+" "+u);else if(h&&!l&&!u){//  Get the w/h from the viewbox
var c=a.getAttribute("viewBox").split(/\s+|,/);l=c[2],u=c[3]}if(o){if(l&&u)i=l*o,s=u*o;else break t}a.setAttribute("width",i.toString()+"px"),a.setAttribute("height",s.toString()+"px"),e=[new XMLSerializer().serializeToString(a)]}try{var d=new window.Blob(e,{type:"image/svg+xml;charset=utf-8"})}catch(t){this.onProcessError();return}this.data=new Image,this.data.crossOrigin=this.crossOrigin;var f=this,p=!1;this.data.onload=function(){p||r.revokeObjectURL(f.data),f.onProcessComplete()},this.data.onerror=function(){//  Safari 8 re-try
p?f.onProcessError():(p=!0,r.revokeObjectURL(f.data),f.data.src="data:image/svg+xml,"+encodeURIComponent(e.join("")))},r.createObjectURL(this.data,d,"image/svg+xml")},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.SVGFile#addToCache
     * @since 3.7.0
     */addToCache:function(){var t=this.cache.addImage(this.key,this.data);this.pendingDestroy(t)}});/**
 * Adds an SVG File, or array of SVG Files, to the current load queue. When the files are loaded they
 * will be rendered to bitmap textures and stored in the Texture Manager.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.svg('morty', 'images/Morty.svg');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Texture Manager first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.svg({
 *     key: 'morty',
 *     url: 'images/Morty.svg'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.SVGFileConfig` for more details.
 *
 * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:
 *
 * ```javascript
 * this.load.svg('morty', 'images/Morty.svg');
 * // and later in your game ...
 * this.add.image(x, y, 'morty');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
 * this is what you would use to retrieve the image from the Texture Manager.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.html". It will always add `.html` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * You can optionally pass an SVG Resize Configuration object when you load an SVG file. By default the SVG will be rendered to a texture
 * at the same size defined in the SVG file attributes. However, this isn't always desirable. You may wish to resize the SVG (either down
 * or up) to improve texture clarity, or reduce texture memory consumption. You can either specify an exact width and height to resize
 * the SVG to:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.svg('morty', 'images/Morty.svg', { width: 300, height: 600 });
 * }
 * ```
 *
 * Or when using a configuration object:
 *
 * ```javascript
 * this.load.svg({
 *     key: 'morty',
 *     url: 'images/Morty.svg',
 *     svgConfig: {
 *         width: 300,
 *         height: 600
 *     }
 * });
 * ```
 *
 * Alternatively, you can just provide a scale factor instead:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.svg('morty', 'images/Morty.svg', { scale: 2.5 });
 * }
 * ```
 *
 * Or when using a configuration object:
 *
 * ```javascript
 * this.load.svg({
 *     key: 'morty',
 *     url: 'images/Morty.svg',
 *     svgConfig: {
 *         scale: 2.5
 *     }
 * });
 * ```
 *
 * If scale, width and height values are all given, the scale has priority and the width and height values are ignored.
 *
 * Note: The ability to load this type of file will only be available if the SVG File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#svg
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.SVGFileConfig|Phaser.Types.Loader.FileTypes.SVGFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.svg`, i.e. if `key` was "alien" then the URL will be "alien.svg".
 * @param {Phaser.Types.Loader.FileTypes.SVGSizeConfig} [svgConfig] - The svg size configuration object.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("svg",function(t,e,i,n){if(Array.isArray(t))for(var s=0;s<t.length;s++)this.addFile(new l(this,t[s]));else this.addFile(new l(this,t,e,i,n));return this}),t.exports=l}),r("xcajA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=new i({Extends:r,initialize:function(t,e,i,n){var s="txt";if(h(e)){var o=e;e=a(o,"key"),i=a(o,"url"),n=a(o,"xhrSettings"),s=a(o,"extension",s)}var l={type:"text",cache:t.cacheManager.text,extension:s,responseType:"text",key:e,url:i,xhrSettings:n};r.call(this,t,l)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.TextFile#onProcess
     * @since 3.7.0
     */onProcess:function(){this.state=n.FILE_PROCESSING,this.data=this.xhrLoader.responseText,this.onProcessComplete()}});/**
 * Adds a Text file, or array of Text files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.text('story', 'files/IntroStory.txt');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global Text Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Text Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Text Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.text({
 *     key: 'story',
 *     url: 'files/IntroStory.txt'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.TextFileConfig` for more details.
 *
 * Once the file has finished loading you can access it from its Cache using its key:
 *
 * ```javascript
 * this.load.text('story', 'files/IntroStory.txt');
 * // and later in your game ...
 * var data = this.cache.text.get('story');
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and
 * this is what you would use to retrieve the text from the Text Cache.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "story"
 * and no URL is given then the Loader will set the URL to be "story.txt". It will always add `.txt` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the Text File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#text
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig|Phaser.Types.Loader.FileTypes.TextFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was "alien" then the URL will be "alien.txt".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("text",function(t,e,i){if(Array.isArray(t))for(var n=0;n<t.length;n++)this.addFile(new l(this,t[n]));else this.addFile(new l(this,t,e,i));return this}),t.exports=l}),r("5xR0u",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("7BSWl"),h=s("jC9MQ"),l=s("au4z0"),u=new i({Extends:r,initialize:function(t,e,i,n){var s="csv";if(h(e)){var o=e;e=a(o,"key"),i=a(o,"url"),n=a(o,"xhrSettings"),s=a(o,"extension",s)}var u={type:"tilemapCSV",cache:t.cacheManager.tilemap,extension:s,responseType:"text",key:e,url:i,xhrSettings:n};r.call(this,t,u),this.tilemapFormat=l.CSV},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.TilemapCSVFile#onProcess
     * @since 3.7.0
     */onProcess:function(){this.state=n.FILE_PROCESSING,this.data=this.xhrLoader.responseText,this.onProcessComplete()},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.TilemapCSVFile#addToCache
     * @since 3.7.0
     */addToCache:function(){var t={format:this.tilemapFormat,data:this.data};this.cache.add(this.key,t),this.pendingDestroy(t)}});/**
 * Adds a CSV Tilemap file, or array of CSV files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.tilemapCSV('level1', 'maps/Level1.csv');
 * }
 * ```
 *
 * Tilemap CSV data can be created in a text editor, or a 3rd party app that exports as CSV.
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Text Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.tilemapCSV({
 *     key: 'level1',
 *     url: 'maps/Level1.csv'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig` for more details.
 *
 * Once the file has finished loading you can access it from its Cache using its key:
 *
 * ```javascript
 * this.load.tilemapCSV('level1', 'maps/Level1.csv');
 * // and later in your game ...
 * var map = this.make.tilemap({ key: 'level1' });
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and
 * this is what you would use to retrieve the text from the Tilemap Cache.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "level"
 * and no URL is given then the Loader will set the URL to be "level.csv". It will always add `.csv` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the Tilemap CSV File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#tilemapCSV
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig|Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.csv`, i.e. if `key` was "alien" then the URL will be "alien.csv".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("tilemapCSV",function(t,e,i){if(Array.isArray(t))for(var n=0;n<t.length;n++)this.addFile(new u(this,t[n]));else this.addFile(new u(this,t,e,i));return this}),t.exports=u}),r("au4z0",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Tilemaps.Formats
 */t.exports={/**
     * CSV Map Type
     * 
     * @name Phaser.Tilemaps.Formats.CSV
     * @type {number}
     * @since 3.0.0
     */CSV:0,/**
     * Tiled JSON Map Type
     * 
     * @name Phaser.Tilemaps.Formats.TILED_JSON
     * @type {number}
     * @since 3.0.0
     */TILED_JSON:1,/**
     * 2D Array Map Type
     * 
     * @name Phaser.Tilemaps.Formats.ARRAY_2D
     * @type {number}
     * @since 3.0.0
     */ARRAY_2D:2,/**
     * Weltmeister (Impact.js) Map Type
     * 
     * @name Phaser.Tilemaps.Formats.WELTMEISTER
     * @type {number}
     * @since 3.0.0
     */WELTMEISTER:3}}),r("k8GdB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("9csvT"),r=s("j0zmu"),o=s("au4z0"),a=new i({Extends:r,initialize:function(t,e,i,n){r.call(this,t,e,i,n),this.type="tilemapJSON",this.cache=t.cacheManager.tilemap},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.TilemapImpactFile#addToCache
     * @since 3.7.0
     */addToCache:function(){var t={format:o.WELTMEISTER,data:this.data};this.cache.add(this.key,t),this.pendingDestroy(t)}});/**
 * Adds an Impact.js Tilemap file, or array of map files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.tilemapImpact('level1', 'maps/Level1.json');
 * }
 * ```
 *
 * Impact Tilemap data is created the Impact.js Map Editor called Weltmeister.
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Text Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.tilemapImpact({
 *     key: 'level1',
 *     url: 'maps/Level1.json'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig` for more details.
 *
 * Once the file has finished loading you can access it from its Cache using its key:
 *
 * ```javascript
 * this.load.tilemapImpact('level1', 'maps/Level1.json');
 * // and later in your game ...
 * var map = this.make.tilemap({ key: 'level1' });
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and
 * this is what you would use to retrieve the text from the Tilemap Cache.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "level"
 * and no URL is given then the Loader will set the URL to be "level.json". It will always add `.json` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the Tilemap Impact File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#tilemapImpact
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.7.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig|Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */n.register("tilemapImpact",function(t,e,i){if(Array.isArray(t))for(var n=0;n<t.length;n++)this.addFile(new a(this,t[n]));else this.addFile(new a(this,t,e,i));return this}),t.exports=a}),r("jtcSd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("9csvT"),r=s("j0zmu"),o=s("au4z0"),a=new i({Extends:r,initialize:function(t,e,i,n){r.call(this,t,e,i,n),this.type="tilemapJSON",this.cache=t.cacheManager.tilemap},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.TilemapJSONFile#addToCache
     * @since 3.7.0
     */addToCache:function(){var t={format:o.TILED_JSON,data:this.data};this.cache.add(this.key,t),this.pendingDestroy(t)}});/**
 * Adds a Tiled JSON Tilemap file, or array of map files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.tilemapTiledJSON('level1', 'maps/Level1.json');
 * }
 * ```
 *
 * The Tilemap data is created using the Tiled Map Editor and selecting JSON as the export format.
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Text Cache first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.tilemapTiledJSON({
 *     key: 'level1',
 *     url: 'maps/Level1.json'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig` for more details.
 *
 * Once the file has finished loading you can access it from its Cache using its key:
 *
 * ```javascript
 * this.load.tilemapTiledJSON('level1', 'maps/Level1.json');
 * // and later in your game ...
 * var map = this.make.tilemap({ key: 'level1' });
 * ```
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and
 * this is what you would use to retrieve the text from the Tilemap Cache.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "level"
 * and no URL is given then the Loader will set the URL to be "level.json". It will always add `.json` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Note: The ability to load this type of file will only be available if the Tilemap JSON File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#tilemapTiledJSON
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig|Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */n.register("tilemapTiledJSON",function(t,e,i){if(Array.isArray(t))for(var n=0;n<t.length;n++)this.addFile(new a(this,t[n]));else this.addFile(new a(this,t,e,i));return this}),t.exports=a}),r("luwkr",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("9csvT"),r=s("7BSWl"),o=s("gT96E"),a=s("jC9MQ"),h=s("B7Zxi"),l=s("xcajA"),u=new i({Extends:h,initialize:function(t,e,i,n,s,u){if(a(e)){var c,d,f=e;e=r(f,"key"),c=new o(t,{key:e,url:r(f,"textureURL"),extension:r(f,"textureExtension","png"),normalMap:r(f,"normalMap"),xhrSettings:r(f,"textureXhrSettings")}),d=new l(t,{key:e,url:r(f,"atlasURL"),extension:r(f,"atlasExtension","txt"),xhrSettings:r(f,"atlasXhrSettings")})}else c=new o(t,e,i,s),d=new l(t,e,n,u);c.linkFile?h.call(this,t,"unityatlas",e,[c,d,c.linkFile]):h.call(this,t,"unityatlas",e,[c,d])},/**
     * Adds this file to its target cache upon successful loading and processing.
     *
     * @method Phaser.Loader.FileTypes.UnityAtlasFile#addToCache
     * @since 3.7.0
     */addToCache:function(){if(this.isReadyToProcess()){var t=this.files[0],e=this.files[1],i=this.files[2]?this.files[2].data:null;this.loader.textureManager.addUnityAtlas(t.key,t.data,e.data,i),e.addToCache(),this.complete=!0}}});/**
 * Adds a Unity YAML based Texture Atlas, or array of atlases, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.unityAtlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.txt');
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
 * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
 *
 * Phaser expects the atlas data to be provided in a YAML formatted text file as exported from Unity.
 *
 * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
 *
 * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Texture Manager first, before loading a new one.
 *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.unityAtlas({
 *     key: 'mainmenu',
 *     textureURL: 'images/MainMenu.png',
 *     atlasURL: 'images/MainMenu.txt'
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig` for more details.
 *
 * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:
 *
 * ```javascript
 * this.load.unityAtlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');
 * // and later in your game ...
 * this.add.image(x, y, 'mainmenu', 'background');
 * ```
 *
 * To get a list of all available frames within an atlas please consult your Texture Atlas software.
 *
 * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
 * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
 * this is what you would use to retrieve the image from the Texture Manager.
 *
 * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
 *
 * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
 * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
 * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
 *
 * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,
 * then you can specify it by providing an array as the `url` where the second element is the normal map:
 *
 * ```javascript
 * this.load.unityAtlas('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.txt');
 * ```
 *
 * Or, if you are using a config object use the `normalMap` property:
 *
 * ```javascript
 * this.load.unityAtlas({
 *     key: 'mainmenu',
 *     textureURL: 'images/MainMenu.png',
 *     normalMap: 'images/MainMenu-n.png',
 *     atlasURL: 'images/MainMenu.txt'
 * });
 * ```
 *
 * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.
 * Normal maps are a WebGL only feature.
 *
 * Note: The ability to load this type of file will only be available if the Unity Atlas File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#unityAtlas
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.0.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig|Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
 * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was "alien" then the URL will be "alien.txt".
 * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */n.register("unityAtlas",function(t,e,i,n,s){var r;//  Supports an Object file definition in the key argument
//  Or an array of objects in the key argument
//  Or a single entry where all arguments have been defined
if(Array.isArray(t))for(var o=0;o<t.length;o++)r=new u(this,t[o]),this.addFile(r.files);else r=new u(this,t,e,i,n,s),this.addFile(r.files);return this}),t.exports=u}),r("aEsfq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("8Aww1"),o=s("9csvT"),a=s("6MxE8"),h=s("7BSWl"),l=s("jC9MQ"),u=new i({Extends:r,initialize:function(t,e,i,n,s,o,a){void 0===n&&(n="loadeddata"),void 0===s&&(s=!1),void 0===o&&(o=!1),"loadeddata"!==n&&"canplay"!==n&&"canplaythrough"!==n&&(n="loadeddata");var h={type:"video",cache:t.cacheManager.video,extension:i.type,responseType:"blob",key:e,url:i.url,xhrSettings:a,config:{loadEvent:n,asBlob:s,noAudio:o}};this.onLoadCallback=this.onVideoLoadHandler.bind(this),this.onErrorCallback=this.onVideoErrorHandler.bind(this),r.call(this,t,h)},/**
     * Called automatically by Loader.nextFile.
     * This method controls what extra work this File does with its loaded data.
     *
     * @method Phaser.Loader.FileTypes.VideoFile#onProcess
     * @since 3.20.0
     */onProcess:function(){if(this.state=n.FILE_PROCESSING,!this.config.asBlob){this.onProcessComplete();return}//  Load Video as blob
var t=this.createVideoElement();this.data=t;var e=this;this.data.onloadeddata=function(){e.onProcessComplete()},this.data.onerror=function(){r.revokeObjectURL(e.data),e.onProcessError()},r.createObjectURL(t,this.xhrLoader.response,""),t.load()},/**
     * Creates a Video Element within the DOM.
     *
     * @method Phaser.Loader.FileTypes.VideoFile#createVideoElement
     * @private
     * @since 3.20.0
     *
     * @return {HTMLVideoElement} The newly created Video element.
     */createVideoElement:function(){var t=document.createElement("video");return t.controls=!1,t.crossOrigin=this.loader.crossOrigin,this.config.noAudio&&(t.muted=!0,t.defaultMuted=!0,t.setAttribute("autoplay","autoplay")),t.setAttribute("playsinline","playsinline"),t.setAttribute("preload","auto"),t},/**
     * Internal load event callback.
     *
     * @method Phaser.Loader.FileTypes.VideoFile#onVideoLoadHandler
     * @private
     * @since 3.20.0
     *
     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.
     */onVideoLoadHandler:function(t){var e=t.target;e.removeEventListener(this.config.loadEvent,this.onLoadCallback,!0),e.removeEventListener("error",this.onErrorCallback,!0),this.data=e,this.resetXHR(),this.loader.nextFile(this,!0)},/**
     * Internal load error event callback.
     *
     * @method Phaser.Loader.FileTypes.VideoFile#onVideoErrorHandler
     * @private
     * @since 3.20.0
     *
     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.
     */onVideoErrorHandler:function(t){var e=t.target;e&&(e.removeEventListener(this.config.loadEvent,this.onLoadCallback,!0),e.removeEventListener("error",this.onErrorCallback,!0)),this.resetXHR(),this.loader.nextFile(this,!1)},/**
     * Called by the Loader, starts the actual file downloading.
     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.
     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.
     *
     * @method Phaser.Loader.FileTypes.VideoFile#load
     * @since 3.20.0
     */load:function(){var t=this.config.loadEvent;if(this.config.asBlob)r.prototype.load.call(this);else{this.percentComplete=0;var e=this.createVideoElement();e.addEventListener(t,this.onLoadCallback,!0),e.addEventListener("error",this.onErrorCallback,!0),e.src=a(this,this.loader.baseURL),e.load()}}});u.create=function(t,e,i,n,s,r,o){var a=t.systems.game;//  url may be inside key, which may be an object
l(e)&&(i=h(e,"url",[]),n=h(e,"loadEvent","loadeddata"),s=h(e,"asBlob",!1),r=h(e,"noAudio",!1),o=h(e,"xhrSettings"));var c=u.getVideoURL(a,i);if(c)return new u(t,e,c,n,s,r,o)},u.getVideoURL=function(t,e){Array.isArray(e)||(e=[e]);for(var i=0;i<e.length;i++){var n,s=h(e[i],"url",e[i]);if(0===s.indexOf("blob:"))return{url:s,type:""};if(n=0===s.indexOf("data:")?s.split(",")[0].match(/\/(.*?);/):s.match(/\.([a-zA-Z0-9]+)($|\?)/),n=h(e[i],"type",n?n[1]:"").toLowerCase(),t.device.video[n])return{url:s,type:n}}return null},/**
 * Adds a Video file, or array of video files, to the current load queue.
 *
 * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
 *
 * ```javascript
 * function preload ()
 * {
 *     this.load.video('intro', [ 'video/level1.mp4', 'video/level1.webm', 'video/level1.mov' ]);
 * }
 * ```
 *
 * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
 * or if it's already running, when the next free load slot becomes available. This happens automatically if you
 * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
 * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
 * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
 * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
 * loaded.
 *
 * The key must be a unique String. It is used to add the file to the global Video Cache upon a successful load.
 * The key should be unique both in terms of files being loaded and files already present in the Video Cache.
 * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
 * then remove it from the Video Cache first, before loading a new one.
  *
 * Instead of passing arguments you can pass a configuration object, such as:
 *
 * ```javascript
 * this.load.video({
 *     key: 'intro',
 *     url: [ 'video/level1.mp4', 'video/level1.webm', 'video/level1.mov' ],
 *     asBlob: false,
 *     noAudio: true
 * });
 * ```
 *
 * See the documentation for `Phaser.Types.Loader.FileTypes.VideoFileConfig` for more details.
 *
 * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.
 *
 * Due to different browsers supporting different video file types you should usually provide your video files in a variety of formats.
 * mp4, mov and webm are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on
 * browser support, starting with the first in the array and progressing to the end.
 *
 * Unlike most asset-types, videos do not _need_ to be preloaded. You can create a Video Game Object and then call its `loadURL` method,
 * to load a video at run-time, rather than in advance.
 *
 * Note: The ability to load this type of file will only be available if the Video File type has been built into Phaser.
 * It is available in the default build but can be excluded from custom builds.
 *
 * @method Phaser.Loader.LoaderPlugin#video
 * @fires Phaser.Loader.LoaderPlugin#ADD
 * @since 3.20.0
 *
 * @param {(string|Phaser.Types.Loader.FileTypes.VideoFileConfig|Phaser.Types.Loader.FileTypes.VideoFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.
 * @param {(string|string[])} [urls] - The absolute or relative URL to load the video files from.
 * @param {string} [loadEvent='loadeddata'] - The load event to listen for when _not_ loading as a blob. Either `loadeddata`, `canplay` or `canplaythrough`.
 * @param {boolean} [asBlob=false] - Load the video as a data blob, or stream it via the Video element?
 * @param {boolean} [noAudio=false] - Does the video have an audio track? If not you can enable auto-playing on it.
 * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
 *
 * @return {this} The Loader instance.
 */o.register("video",function(t,e,i,n,s,r){var o;if(Array.isArray(t))for(var a=0;a<t.length;a++)//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
(o=u.create(this,t[a]))&&this.addFile(o);else(o=u.create(this,t,e,i,n,s,r))&&this.addFile(o);return this}),t.exports=u}),r("5eeE2",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("jOz8I"),r=s("lxxnL"),o=s("3vRz3"),a=s("ls69h"),h=s("9csvT"),l=s("7BSWl"),u=s("7AzQW"),c=s("4rtgc"),d=s("kTh8x"),f=new i({Extends:o,initialize:function(t){o.call(this);var e=t.sys.game.config,i=t.sys.settings.loader;/**
         * The Scene which owns this Loader instance.
         *
         * @name Phaser.Loader.LoaderPlugin#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * A reference to the Scene Systems.
         *
         * @name Phaser.Loader.LoaderPlugin#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,/**
         * A reference to the global Cache Manager.
         *
         * @name Phaser.Loader.LoaderPlugin#cacheManager
         * @type {Phaser.Cache.CacheManager}
         * @since 3.7.0
         */this.cacheManager=t.sys.cache,/**
         * A reference to the global Texture Manager.
         *
         * @name Phaser.Loader.LoaderPlugin#textureManager
         * @type {Phaser.Textures.TextureManager}
         * @since 3.7.0
         */this.textureManager=t.sys.textures,/**
         * A reference to the global Scene Manager.
         *
         * @name Phaser.Loader.LoaderPlugin#sceneManager
         * @type {Phaser.Scenes.SceneManager}
         * @protected
         * @since 3.16.0
         */this.sceneManager=t.sys.game.scene,//  Inject the available filetypes into the Loader
h.install(this),/**
         * An optional prefix that is automatically prepended to the start of every file key.
         * If prefix was `MENU.` and you load an image with the key 'Background' the resulting key would be `MENU.Background`.
         * You can set this directly, or call `Loader.setPrefix()`. It will then affect every file added to the Loader
         * from that point on. It does _not_ change any file already in the load queue.
         *
         * @name Phaser.Loader.LoaderPlugin#prefix
         * @type {string}
         * @default ''
         * @since 3.7.0
         */this.prefix="",/**
         * The value of `path`, if set, is placed before any _relative_ file path given. For example:
         *
         * ```javascript
         * this.load.path = "images/sprites/";
         * this.load.image("ball", "ball.png");
         * this.load.image("tree", "level1/oaktree.png");
         * this.load.image("boom", "http://server.com/explode.png");
         * ```
         *
         * Would load the `ball` file from `images/sprites/ball.png` and the tree from
         * `images/sprites/level1/oaktree.png` but the file `boom` would load from the URL
         * given as it's an absolute URL.
         *
         * Please note that the path is added before the filename but *after* the baseURL (if set.)
         *
         * If you set this property directly then it _must_ end with a "/". Alternatively, call `setPath()` and it'll do it for you.
         *
         * @name Phaser.Loader.LoaderPlugin#path
         * @type {string}
         * @default ''
         * @since 3.0.0
         */this.path="",/**
         * If you want to append a URL before the path of any asset you can set this here.
         *
         * Useful if allowing the asset base url to be configured outside of the game code.
         *
         * If you set this property directly then it _must_ end with a "/". Alternatively, call `setBaseURL()` and it'll do it for you.
         *
         * @name Phaser.Loader.LoaderPlugin#baseURL
         * @type {string}
         * @default ''
         * @since 3.0.0
         */this.baseURL="",this.setBaseURL(l(i,"baseURL",e.loaderBaseURL)),this.setPath(l(i,"path",e.loaderPath)),this.setPrefix(l(i,"prefix",e.loaderPrefix)),/**
         * The number of concurrent / parallel resources to try and fetch at once.
         *
         * Old browsers limit 6 requests per domain; modern ones, especially those with HTTP/2 don't limit it at all.
         *
         * The default is 32 but you can change this in your Game Config, or by changing this property before the Loader starts.
         *
         * @name Phaser.Loader.LoaderPlugin#maxParallelDownloads
         * @type {integer}
         * @since 3.0.0
         */this.maxParallelDownloads=l(i,"maxParallelDownloads",e.loaderMaxParallelDownloads),/**
         * xhr specific global settings (can be overridden on a per-file basis)
         *
         * @name Phaser.Loader.LoaderPlugin#xhr
         * @type {Phaser.Types.Loader.XHRSettingsObject}
         * @since 3.0.0
         */this.xhr=d(l(i,"responseType",e.loaderResponseType),l(i,"async",e.loaderAsync),l(i,"user",e.loaderUser),l(i,"password",e.loaderPassword),l(i,"timeout",e.loaderTimeout),l(i,"withCredentials",e.loaderWithCredentials)),/**
         * The crossOrigin value applied to loaded images. Very often this needs to be set to 'anonymous'.
         *
         * @name Phaser.Loader.LoaderPlugin#crossOrigin
         * @type {string}
         * @since 3.0.0
         */this.crossOrigin=l(i,"crossOrigin",e.loaderCrossOrigin),/**
         * The total number of files to load. It may not always be accurate because you may add to the Loader during the process
         * of loading, especially if you load a Pack File. Therefore this value can change, but in most cases remains static.
         *
         * @name Phaser.Loader.LoaderPlugin#totalToLoad
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.totalToLoad=0,/**
         * The progress of the current load queue, as a float value between 0 and 1.
         * This is updated automatically as files complete loading.
         * Note that it is possible for this value to go down again if you add content to the current load queue during a load.
         *
         * @name Phaser.Loader.LoaderPlugin#progress
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.progress=0,/**
         * Files are placed in this Set when they're added to the Loader via `addFile`.
         *
         * They are moved to the `inflight` Set when they start loading, and assuming a successful
         * load, to the `queue` Set for further processing.
         *
         * By the end of the load process this Set will be empty.
         *
         * @name Phaser.Loader.LoaderPlugin#list
         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}
         * @since 3.0.0
         */this.list=new r,/**
         * Files are stored in this Set while they're in the process of being loaded.
         *
         * Upon a successful load they are moved to the `queue` Set.
         *
         * By the end of the load process this Set will be empty.
         *
         * @name Phaser.Loader.LoaderPlugin#inflight
         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}
         * @since 3.0.0
         */this.inflight=new r,/**
         * Files are stored in this Set while they're being processed.
         *
         * If the process is successful they are moved to their final destination, which could be
         * a Cache or the Texture Manager.
         *
         * At the end of the load process this Set will be empty.
         *
         * @name Phaser.Loader.LoaderPlugin#queue
         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}
         * @since 3.0.0
         */this.queue=new r,/**
         * A temporary Set in which files are stored after processing,
         * awaiting destruction at the end of the load process.
         *
         * @name Phaser.Loader.LoaderPlugin#_deleteQueue
         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}
         * @private
         * @since 3.7.0
         */this._deleteQueue=new r,/**
         * The total number of files that failed to load during the most recent load.
         * This value is reset when you call `Loader.start`.
         *
         * @name Phaser.Loader.LoaderPlugin#totalFailed
         * @type {integer}
         * @default 0
         * @since 3.7.0
         */this.totalFailed=0,/**
         * The total number of files that successfully loaded during the most recent load.
         * This value is reset when you call `Loader.start`.
         *
         * @name Phaser.Loader.LoaderPlugin#totalComplete
         * @type {integer}
         * @default 0
         * @since 3.7.0
         */this.totalComplete=0,/**
         * The current state of the Loader.
         *
         * @name Phaser.Loader.LoaderPlugin#state
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.state=n.LOADER_IDLE,/**
         * The current index being used by multi-file loaders to avoid key clashes.
         *
         * @name Phaser.Loader.LoaderPlugin#multiKeyIndex
         * @type {integer}
         * @private
         * @since 3.20.0
         */this.multiKeyIndex=0,t.sys.events.once(c.BOOT,this.boot,this),t.sys.events.on(c.START,this.pluginStart,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.Loader.LoaderPlugin#boot
     * @private
     * @since 3.5.1
     */boot:function(){this.systems.events.once(c.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.Loader.LoaderPlugin#pluginStart
     * @private
     * @since 3.5.1
     */pluginStart:function(){this.systems.events.once(c.SHUTDOWN,this.shutdown,this)},/**
     * If you want to append a URL before the path of any asset you can set this here.
     *
     * Useful if allowing the asset base url to be configured outside of the game code.
     *
     * Once a base URL is set it will affect every file loaded by the Loader from that point on. It does _not_ change any
     * file _already_ being loaded. To reset it, call this method with no arguments.
     *
     * @method Phaser.Loader.LoaderPlugin#setBaseURL
     * @since 3.0.0
     *
     * @param {string} [url] - The URL to use. Leave empty to reset.
     *
     * @return {this} This Loader object.
     */setBaseURL:function(t){return void 0===t&&(t=""),""!==t&&"/"!==t.substr(-1)&&(t=t.concat("/")),this.baseURL=t,this},/**
     * The value of `path`, if set, is placed before any _relative_ file path given. For example:
     *
     * ```javascript
     * this.load.setPath("images/sprites/");
     * this.load.image("ball", "ball.png");
     * this.load.image("tree", "level1/oaktree.png");
     * this.load.image("boom", "http://server.com/explode.png");
     * ```
     *
     * Would load the `ball` file from `images/sprites/ball.png` and the tree from
     * `images/sprites/level1/oaktree.png` but the file `boom` would load from the URL
     * given as it's an absolute URL.
     *
     * Please note that the path is added before the filename but *after* the baseURL (if set.)
     *
     * Once a path is set it will then affect every file added to the Loader from that point on. It does _not_ change any
     * file _already_ in the load queue. To reset it, call this method with no arguments.
     *
     * @method Phaser.Loader.LoaderPlugin#setPath
     * @since 3.0.0
     *
     * @param {string} [path] - The path to use. Leave empty to reset.
     *
     * @return {this} This Loader object.
     */setPath:function(t){return void 0===t&&(t=""),""!==t&&"/"!==t.substr(-1)&&(t=t.concat("/")),this.path=t,this},/**
     * An optional prefix that is automatically prepended to the start of every file key.
     *
     * If prefix was `MENU.` and you load an image with the key 'Background' the resulting key would be `MENU.Background`.
     *
     * Once a prefix is set it will then affect every file added to the Loader from that point on. It does _not_ change any
     * file _already_ in the load queue. To reset it, call this method with no arguments.
     *
     * @method Phaser.Loader.LoaderPlugin#setPrefix
     * @since 3.7.0
     *
     * @param {string} [prefix] - The prefix to use. Leave empty to reset.
     *
     * @return {this} This Loader object.
     */setPrefix:function(t){return void 0===t&&(t=""),this.prefix=t,this},/**
     * Sets the Cross Origin Resource Sharing value used when loading files.
     *
     * Files can override this value on a per-file basis by specifying an alternative `crossOrigin` value in their file config.
     *
     * Once CORs is set it will then affect every file loaded by the Loader from that point on, as long as they don't have
     * their own CORs setting. To reset it, call this method with no arguments.
     *
     * For more details about CORs see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
     *
     * @method Phaser.Loader.LoaderPlugin#setCORS
     * @since 3.0.0
     *
     * @param {string} [crossOrigin] - The value to use for the `crossOrigin` property in the load request.
     *
     * @return {this} This Loader object.
     */setCORS:function(t){return this.crossOrigin=t,this},/**
     * Adds a file, or array of files, into the load queue.
     *
     * The file must be an instance of `Phaser.Loader.File`, or a class that extends it. The Loader will check that the key
     * used by the file won't conflict with any other key either in the loader, the inflight queue or the target cache.
     * If allowed it will then add the file into the pending list, read for the load to start. Or, if the load has already
     * started, ready for the next batch of files to be pulled from the list to the inflight queue.
     *
     * You should not normally call this method directly, but rather use one of the Loader methods like `image` or `atlas`,
     * however you can call this as long as the file given to it is well formed.
     *
     * @method Phaser.Loader.LoaderPlugin#addFile
     * @fires Phaser.Loader.Events#ADD
     * @since 3.0.0
     *
     * @param {(Phaser.Loader.File|Phaser.Loader.File[])} file - The file, or array of files, to be added to the load queue.
     */addFile:function(t){Array.isArray(t)||(t=[t]);for(var e=0;e<t.length;e++){var i=t[e];//  Does the file already exist in the cache or texture manager?
//  Or will it conflict with a file already in the queue or inflight?
!this.keyExists(i)&&(this.list.set(i),this.emit(a.ADD,i.key,i.type,this,i),this.isLoading()&&(this.totalToLoad++,this.updateProgress()))}},/**
     * Checks the key and type of the given file to see if it will conflict with anything already
     * in a Cache, the Texture Manager, or the list or inflight queues.
     *
     * @method Phaser.Loader.LoaderPlugin#keyExists
     * @since 3.7.0
     *
     * @param {Phaser.Loader.File} file - The file to check the key of.
     *
     * @return {boolean} `true` if adding this file will cause a cache or queue conflict, otherwise `false`.
     */keyExists:function(t){var e=t.hasCacheConflict();return e||this.list.iterate(function(i){if(i.type===t.type&&i.key===t.key)return e=!0,!1}),!e&&this.isLoading()&&(this.inflight.iterate(function(i){if(i.type===t.type&&i.key===t.key)return e=!0,!1}),this.queue.iterate(function(i){if(i.type===t.type&&i.key===t.key)return e=!0,!1})),e},/**
     * Takes a well formed, fully parsed pack file object and adds its entries into the load queue. Usually you do not call
     * this method directly, but instead use `Loader.pack` and supply a path to a JSON file that holds the
     * pack data. However, if you've got the data prepared you can pass it to this method.
     *
     * You can also provide an optional key. If you do then it will only add the entries from that part of the pack into
     * to the load queue. If not specified it will add all entries it finds. For more details about the pack file format
     * see the `LoaderPlugin.pack` method.
     *
     * @method Phaser.Loader.LoaderPlugin#addPack
     * @since 3.7.0
     *
     * @param {any} pack - The Pack File data to be parsed and each entry of it to added to the load queue.
     * @param {string} [packKey] - An optional key to use from the pack file data.
     *
     * @return {boolean} `true` if any files were added to the queue, otherwise `false`.
     */addPack:function(t,e){e&&t.hasOwnProperty(e)&&(t={packKey:t[e]});var i=0,n=this.baseURL,s=this.path,r=this.prefix;//  Here we go ...
for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var a=t[o],h=l(a,"baseURL",n),u=l(a,"path",s),c=l(a,"prefix",r),d=l(a,"files",null),f=l(a,"defaultType","void");if(Array.isArray(d)){this.setBaseURL(h),this.setPath(u),this.setPrefix(c);for(var p=0;p<d.length;p++){var g=d[p],v=g.hasOwnProperty("type")?g.type:f;this[v]&&(this[v](g),i++)}}}return(//  Reset the loader settings
this.setBaseURL(n),this.setPath(s),this.setPrefix(r),i>0)},/**
     * Is the Loader actively loading, or processing loaded files?
     *
     * @method Phaser.Loader.LoaderPlugin#isLoading
     * @since 3.0.0
     *
     * @return {boolean} `true` if the Loader is busy loading or processing, otherwise `false`.
     */isLoading:function(){return this.state===n.LOADER_LOADING||this.state===n.LOADER_PROCESSING},/**
     * Is the Loader ready to start a new load?
     *
     * @method Phaser.Loader.LoaderPlugin#isReady
     * @since 3.0.0
     *
     * @return {boolean} `true` if the Loader is ready to start a new load, otherwise `false`.
     */isReady:function(){return this.state===n.LOADER_IDLE||this.state===n.LOADER_COMPLETE},/**
     * Starts the Loader running. This will reset the progress and totals and then emit a `start` event.
     * If there is nothing in the queue the Loader will immediately complete, otherwise it will start
     * loading the first batch of files.
     *
     * The Loader is started automatically if the queue is populated within your Scenes `preload` method.
     *
     * However, outside of this, you need to call this method to start it.
     *
     * If the Loader is already running this method will simply return.
     *
     * @method Phaser.Loader.LoaderPlugin#start
     * @fires Phaser.Loader.Events#START
     * @since 3.0.0
     */start:function(){this.isReady()&&(this.progress=0,this.totalFailed=0,this.totalComplete=0,this.totalToLoad=this.list.size,this.emit(a.START,this),0===this.list.size?this.loadComplete():(this.state=n.LOADER_LOADING,this.inflight.clear(),this.queue.clear(),this.updateProgress(),this.checkLoadQueue(),this.systems.events.on(c.UPDATE,this.update,this)))},/**
     * Called automatically during the load process.
     * It updates the `progress` value and then emits a progress event, which you can use to
     * display a loading bar in your game.
     *
     * @method Phaser.Loader.LoaderPlugin#updateProgress
     * @fires Phaser.Loader.Events#PROGRESS
     * @since 3.0.0
     */updateProgress:function(){this.progress=1-(this.list.size+this.inflight.size)/this.totalToLoad,this.emit(a.PROGRESS,this.progress)},/**
     * Called automatically during the load process.
     *
     * @method Phaser.Loader.LoaderPlugin#update
     * @since 3.10.0
     */update:function(){this.state===n.LOADER_LOADING&&this.list.size>0&&this.inflight.size<this.maxParallelDownloads&&this.checkLoadQueue()},/**
     * An internal method called by the Loader.
     *
     * It will check to see if there are any more files in the pending list that need loading, and if so it will move
     * them from the list Set into the inflight Set, set their CORs flag and start them loading.
     *
     * It will carrying on doing this for each file in the pending list until it runs out, or hits the max allowed parallel downloads.
     *
     * @method Phaser.Loader.LoaderPlugin#checkLoadQueue
     * @private
     * @since 3.7.0
     */checkLoadQueue:function(){this.list.each(function(t){if((t.state===n.FILE_POPULATED||t.state===n.FILE_PENDING&&this.inflight.size<this.maxParallelDownloads)&&(this.inflight.set(t),this.list.delete(t),t.crossOrigin||(t.crossOrigin=this.crossOrigin),t.load()),this.inflight.size===this.maxParallelDownloads)return!1},this)},/**
     * An internal method called automatically by the XHRLoader belong to a File.
     *
     * This method will remove the given file from the inflight Set and update the load progress.
     * If the file was successful its `onProcess` method is called, otherwise it is added to the delete queue.
     *
     * @method Phaser.Loader.LoaderPlugin#nextFile
     * @fires Phaser.Loader.Events#FILE_LOAD
     * @fires Phaser.Loader.Events#FILE_LOAD_ERROR
     * @since 3.0.0
     *
     * @param {Phaser.Loader.File} file - The File that just finished loading, or errored during load.
     * @param {boolean} success - `true` if the file loaded successfully, otherwise `false`.
     */nextFile:function(t,e){//  Has the game been destroyed during load? If so, bail out now.
this.inflight&&(this.inflight.delete(t),this.updateProgress(),e?(this.totalComplete++,this.queue.set(t),this.emit(a.FILE_LOAD,t),t.onProcess()):(this.totalFailed++,this._deleteQueue.set(t),this.emit(a.FILE_LOAD_ERROR,t),this.fileProcessComplete(t)))},/**
     * An internal method that is called automatically by the File when it has finished processing.
     *
     * If the process was successful, and the File isn't part of a MultiFile, its `addToCache` method is called.
     *
     * It this then removed from the queue. If there are no more files to load `loadComplete` is called.
     *
     * @method Phaser.Loader.LoaderPlugin#fileProcessComplete
     * @since 3.7.0
     *
     * @param {Phaser.Loader.File} file - The file that has finished processing.
     */fileProcessComplete:function(t){//  Has the game been destroyed during load? If so, bail out now.
this.scene&&this.systems&&this.systems.game&&!this.systems.game.pendingDestroy&&(t.state===n.FILE_ERRORED?t.multiFile&&t.multiFile.onFileFailed(t):t.state===n.FILE_COMPLETE&&(t.multiFile?t.multiFile.isReadyToProcess()&&t.multiFile.addToCache():t.addToCache()),//  Remove it from the queue
this.queue.delete(t),0===this.list.size&&0===this.inflight.size&&0===this.queue.size&&this.loadComplete())},/**
     * Called at the end when the load queue is exhausted and all files have either loaded or errored.
     * By this point every loaded file will now be in its associated cache and ready for use.
     *
     * Also clears down the Sets, puts progress to 1 and clears the deletion queue.
     *
     * @method Phaser.Loader.LoaderPlugin#loadComplete
     * @fires Phaser.Loader.Events#COMPLETE
     * @fires Phaser.Loader.Events#POST_PROCESS
     * @since 3.7.0
     */loadComplete:function(){this.emit(a.POST_PROCESS,this),this.list.clear(),this.inflight.clear(),this.queue.clear(),this.progress=1,this.state=n.LOADER_COMPLETE,this.systems.events.off(c.UPDATE,this.update,this),//  Call 'destroy' on each file ready for deletion
this._deleteQueue.iterateLocal("destroy"),this._deleteQueue.clear(),this.emit(a.COMPLETE,this,this.totalComplete,this.totalFailed)},/**
     * Adds a File into the pending-deletion queue.
     *
     * @method Phaser.Loader.LoaderPlugin#flagForRemoval
     * @since 3.7.0
     *
     * @param {Phaser.Loader.File} file - The File to be queued for deletion when the Loader completes.
     */flagForRemoval:function(t){this._deleteQueue.set(t)},/**
     * Converts the given JSON data into a file that the browser then prompts you to download so you can save it locally.
     *
     * The data must be well formed JSON and ready-parsed, not a JavaScript object.
     *
     * @method Phaser.Loader.LoaderPlugin#saveJSON
     * @since 3.0.0
     *
     * @param {*} data - The JSON data, ready parsed.
     * @param {string} [filename=file.json] - The name to save the JSON file as.
     *
     * @return {this} This Loader plugin.
     */saveJSON:function(t,e){return this.save(JSON.stringify(t),e)},/**
     * Causes the browser to save the given data as a file to its default Downloads folder.
     *
     * Creates a DOM level anchor link, assigns it as being a `download` anchor, sets the href
     * to be an ObjectURL based on the given data, and then invokes a click event.
     *
     * @method Phaser.Loader.LoaderPlugin#save
     * @since 3.0.0
     *
     * @param {*} data - The data to be saved. Will be passed through URL.createObjectURL.
     * @param {string} [filename=file.json] - The filename to save the file as.
     * @param {string} [filetype=application/json] - The file type to use when saving the file. Defaults to JSON.
     *
     * @return {this} This Loader plugin.
     */save:function(t,e,i){void 0===e&&(e="file.json"),void 0===i&&(i="application/json");var n=new Blob([t],{type:i}),s=URL.createObjectURL(n),r=document.createElement("a");return r.download=e,r.textContent="Download "+e,r.href=s,r.click(),this},/**
     * Resets the Loader.
     *
     * This will clear all lists and reset the base URL, path and prefix.
     *
     * Warning: If the Loader is currently downloading files, or has files in its queue, they will be aborted.
     *
     * @method Phaser.Loader.LoaderPlugin#reset
     * @since 3.0.0
     */reset:function(){this.list.clear(),this.inflight.clear(),this.queue.clear();var t=this.systems.game.config,e=this.systems.settings.loader;this.setBaseURL(l(e,"baseURL",t.loaderBaseURL)),this.setPath(l(e,"path",t.loaderPath)),this.setPrefix(l(e,"prefix",t.loaderPrefix)),this.state=n.LOADER_IDLE},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.Loader.LoaderPlugin#shutdown
     * @private
     * @since 3.0.0
     */shutdown:function(){this.reset(),this.state=n.LOADER_SHUTDOWN,this.systems.events.off(c.UPDATE,this.update,this),this.systems.events.off(c.SHUTDOWN,this.shutdown,this)},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.Loader.LoaderPlugin#destroy
     * @private
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.state=n.LOADER_DESTROYED,this.systems.events.off(c.UPDATE,this.update,this),this.systems.events.off(c.START,this.pluginStart,this),this.list=null,this.inflight=null,this.queue=null,this.scene=null,this.systems=null,this.textureManager=null,this.cacheManager=null,this.sceneManager=null}});u.register("Loader",f,"load"),t.exports=f}),r("kZqOf",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Physics
 *//**
 * @namespace Phaser.Types.Physics
 */t.exports={Arcade:s("2tjvS"),Matter:s("6xUMs")}}),r("2tjvS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ilZSx"),n=s("hVk4C"),r={ArcadePhysics:s("fLgwd"),Body:s("eJKdR"),Collider:s("egqqo"),Components:s("3SfZs"),Events:s("cPwjQ"),Factory:s("5kYTK"),Group:s("ciOQq"),Image:s("6FypI"),Sprite:s("bLNEY"),StaticBody:s("k8alZ"),StaticGroup:s("gpJfs"),World:s("dokZz")};//   Merge in the consts
r=n(!1,r,i),t.exports=r}),r("ilZSx",function(t,e){t.exports={/**
     * Dynamic Body.
     *
     * @name Phaser.Physics.Arcade.DYNAMIC_BODY
     * @readonly
     * @type {number}
     * @since 3.0.0
     *
     * @see Phaser.Physics.Arcade.Body#physicsType
     * @see Phaser.Physics.Arcade.Group#physicsType
     */DYNAMIC_BODY:0,/**
     * Static Body.
     *
     * @name Phaser.Physics.Arcade.STATIC_BODY
     * @readonly
     * @type {number}
     * @since 3.0.0
     *
     * @see Phaser.Physics.Arcade.Body#physicsType
     * @see Phaser.Physics.Arcade.StaticBody#physicsType
     */STATIC_BODY:1,/**
     * Arcade Physics Group containing Dynamic Bodies.
     *
     * @name Phaser.Physics.Arcade.GROUP
     * @readonly
     * @type {number}
     * @since 3.0.0
     */GROUP:2,/**
     * A Tilemap Layer.
     *
     * @name Phaser.Physics.Arcade.TILEMAPLAYER
     * @readonly
     * @type {number}
     * @since 3.0.0
     */TILEMAPLAYER:3,/**
     * Facing no direction (initial value).
     *
     * @name Phaser.Physics.Arcade.FACING_NONE
     * @readonly
     * @type {number}
     * @since 3.0.0
     *
     * @see Phaser.Physics.Arcade.Body#facing
     */FACING_NONE:10,/**
     * Facing up.
     *
     * @name Phaser.Physics.Arcade.FACING_UP
     * @readonly
     * @type {number}
     * @since 3.0.0
     *
     * @see Phaser.Physics.Arcade.Body#facing
     */FACING_UP:11,/**
     * Facing down.
     *
     * @name Phaser.Physics.Arcade.FACING_DOWN
     * @readonly
     * @type {number}
     * @since 3.0.0
     *
     * @see Phaser.Physics.Arcade.Body#facing
     */FACING_DOWN:12,/**
     * Facing left.
     *
     * @name Phaser.Physics.Arcade.FACING_LEFT
     * @readonly
     * @type {number}
     * @since 3.0.0
     *
     * @see Phaser.Physics.Arcade.Body#facing
     */FACING_LEFT:13,/**
     * Facing right.
     *
     * @name Phaser.Physics.Arcade.FACING_RIGHT
     * @readonly
     * @type {number}
     * @since 3.0.0
     *
     * @see Phaser.Physics.Arcade.Body#facing
     */FACING_RIGHT:14}}),r("fLgwd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("2zqSA"),r=s("bwLQh"),o=s("gMODW"),a=s("5kYTK"),h=s("7BSWl"),l=s("awyQk"),u=s("egXG9"),c=s("9rlFn"),d=s("7AzQW"),f=s("4rtgc"),p=s("7SBSk"),g=s("dokZz"),v=new i({initialize:function(t){/**
         * The Scene that this Plugin belongs to.
         *
         * @name Phaser.Physics.Arcade.ArcadePhysics#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * The Scene's Systems.
         *
         * @name Phaser.Physics.Arcade.ArcadePhysics#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,/**
         * A configuration object. Union of the `physics.arcade.*` properties of the GameConfig and SceneConfig objects.
         *
         * @name Phaser.Physics.Arcade.ArcadePhysics#config
         * @type {object}
         * @since 3.0.0
         */this.config=this.getConfig(),/**
         * The physics simulation.
         *
         * @name Phaser.Physics.Arcade.ArcadePhysics#world
         * @type {Phaser.Physics.Arcade.World}
         * @since 3.0.0
         */this.world,/**
         * An object holding the Arcade Physics factory methods.
         *
         * @name Phaser.Physics.Arcade.ArcadePhysics#add
         * @type {Phaser.Physics.Arcade.Factory}
         * @since 3.0.0
         */this.add,t.sys.events.once(f.BOOT,this.boot,this),t.sys.events.on(f.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#boot
     * @private
     * @since 3.5.1
     */boot:function(){this.world=new g(this.scene,this.config),this.add=new a(this.world),this.systems.events.once(f.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#start
     * @private
     * @since 3.5.0
     */start:function(){this.world||(this.world=new g(this.scene,this.config),this.add=new a(this.world));var t=this.systems.events;t.on(f.UPDATE,this.world.update,this.world),t.on(f.POST_UPDATE,this.world.postUpdate,this.world),t.once(f.SHUTDOWN,this.shutdown,this)},/**
     * Creates the physics configuration for the current Scene.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#getConfig
     * @since 3.0.0
     *
     * @return {object} The physics configuration.
     */getConfig:function(){var t=this.systems.game.config.physics;return l(h(this.systems.settings.physics,"arcade",{}),h(t,"arcade",{}))},/**
     * Tests if Game Objects overlap. See {@link Phaser.Physics.Arcade.World#overlap}
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#overlap
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.
     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {*} [callbackContext] - The context in which to run the callbacks.
     *
     * @return {boolean} True if at least one Game Object overlaps another.
     *
     * @see Phaser.Physics.Arcade.World#overlap
     */overlap:function(t,e,i,n,s){return void 0===i&&(i=null),void 0===n&&(n=null),void 0===s&&(s=i),this.world.collideObjects(t,e,i,n,s,!0)},/**
     * Performs a collision check and separation between the two physics enabled objects given, which can be single
     * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.
     *
     * If you don't require separation then use {@link #overlap} instead.
     *
     * If two Groups or arrays are passed, each member of one will be tested against each member of the other.
     *
     * If **only** one Group is passed (as `object1`), each member of the Group will be collided against the other members.
     *
     * If **only** one Array is passed, the array is iterated and every element in it is tested against the others.
     *
     * Two callbacks can be provided. The `collideCallback` is invoked if a collision occurs and the two colliding
     * objects are passed to it.
     *
     * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable
     * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.
     * The separation that stops two objects penetrating may create a new penetration against a different object. If you
     * require a high level of stability please consider using an alternative physics system, such as Matter.js.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#collide
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.
     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {*} [callbackContext] - The context in which to run the callbacks.
     *
     * @return {boolean} True if any overlapping Game Objects were separated, otherwise false.
     *
     * @see Phaser.Physics.Arcade.World#collide
     */collide:function(t,e,i,n,s){return void 0===i&&(i=null),void 0===n&&(n=null),void 0===s&&(s=i),this.world.collideObjects(t,e,i,n,s,!1)},/**
     * This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects.
     *
     * You should generally use the `collide` method instead, with a Sprite vs. a Tilemap Layer, as that will perform
     * tile filtering and culling for you, as well as handle the interesting face collision automatically.
     *
     * This method is offered for those who would like to check for collision with specific Tiles in a layer, without
     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions
     * on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,
     * you should filter them before passing them to this method.
     *
     * Important: Use of this method skips the `interesting faces` system that Tilemap Layers use. This means if you have
     * say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the
     * tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on
     * dynamic maps, this method can prove very useful.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#collideTiles
     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE
     * @since 3.17.0
     *
     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.
     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.
     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {any} [callbackContext] - The context in which to run the callbacks.
     *
     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.
     */collideTiles:function(t,e,i,n,s){return this.world.collideTiles(t,e,i,n,s)},/**
     * This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects.
     *
     * You should generally use the `overlap` method instead, with a Sprite vs. a Tilemap Layer, as that will perform
     * tile filtering and culling for you, as well as handle the interesting face collision automatically.
     *
     * This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without
     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap
     * tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,
     * you should filter them before passing them to this method.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapTiles
     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP
     * @since 3.17.0
     *
     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.
     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.
     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects overlap.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {any} [callbackContext] - The context in which to run the callbacks.
     *
     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.
     */overlapTiles:function(t,e,i,n,s){return this.world.overlapTiles(t,e,i,n,s)},/**
     * Pauses the simulation.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#pause
     * @since 3.0.0
     *
     * @return {Phaser.Physics.Arcade.World} The simulation.
     */pause:function(){return this.world.pause()},/**
     * Resumes the simulation (if paused).
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#resume
     * @since 3.0.0
     *
     * @return {Phaser.Physics.Arcade.World} The simulation.
     */resume:function(){return this.world.resume()},/**
     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)
     *
     * You must give a maximum speed value, beyond which the game object won't go any faster.
     *
     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.
     * Note: The game object doesn't stop moving once it reaches the destination coordinates.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateTo
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.
     * @param {number} x - The x coordinate to accelerate towards.
     * @param {number} y - The y coordinate to accelerate towards.
     * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.
     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.
     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.
     *
     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.
     */accelerateTo:function(t,e,i,n,s,r){void 0===n&&(n=60);var o=Math.atan2(i-t.y,e-t.x);return t.body.acceleration.setToPolar(o,n),void 0!==s&&void 0!==r&&t.body.maxVelocity.set(s,r),o},/**
     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)
     *
     * You must give a maximum speed value, beyond which the game object won't go any faster.
     *
     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.
     * Note: The game object doesn't stop moving once it reaches the destination coordinates.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateToObject
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.
     * @param {Phaser.GameObjects.GameObject} destination - The Game Object to move towards. Can be any object but must have visible x/y properties.
     * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.
     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.
     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.
     *
     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.
     */accelerateToObject:function(t,e,i,n,s){return this.accelerateTo(t,e.x,e.y,i,n,s)},/**
     * Finds the Body or Game Object closest to a source point or object.
     *
     * If a `targets` argument is passed, this method finds the closest of those.
     * The targets can be Arcade Physics Game Objects, Dynamic Bodies, or Static Bodies.
     *
     * If no `targets` argument is passed, this method finds the closest Dynamic Body.
     *
     * If two or more targets are the exact same distance from the source point, only the first target
     * is returned.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#closest
     * @since 3.0.0
     *
     * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.
     * @param {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[]|Phaser.GameObjects.GameObject[])} [targets] - The targets.
     *
     * @return {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|Phaser.GameObjects.GameObject)} The target closest to the given source point.
     */closest:function(t,e){e||(e=this.world.bodies.entries);for(var i=Number.MAX_VALUE,n=null,s=t.x,r=t.y,a=e.length,h=0;h<a;h++){var l=e[h],u=l.body||l;if(t!==l&&t!==u&&t!==u.gameObject&&t!==u.center){var c=o(s,r,u.center.x,u.center.y);c<i&&(n=l,i=c)}}return n},/**
     * Finds the Body or Game Object farthest from a source point or object.
     *
     * If a `targets` argument is passed, this method finds the farthest of those.
     * The targets can be Arcade Physics Game Objects, Dynamic Bodies, or Static Bodies.
     *
     * If no `targets` argument is passed, this method finds the farthest Dynamic Body.
     *
     * If two or more targets are the exact same distance from the source point, only the first target
     * is returned.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#furthest
     * @since 3.0.0
     *
     * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.
     * @param {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[]|Phaser.GameObjects.GameObject[])} [targets] - The targets.
     *
     * @return {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|Phaser.GameObjects.GameObject)} The target farthest from the given source point.
     */furthest:function(t,e){e||(e=this.world.bodies.entries);for(var i=-1,n=null,s=t.x,r=t.y,a=e.length,h=0;h<a;h++){var l=e[h],u=l.body||l;if(t!==l&&t!==u&&t!==u.gameObject&&t!==u.center){var c=o(s,r,u.center.x,u.center.y);c>i&&(n=l,i=c)}}return n},/**
     * Move the given display object towards the x/y coordinates at a steady velocity.
     * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.
     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
     * Note: The display object doesn't stop moving once it reaches the destination coordinates.
     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#moveTo
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.
     * @param {number} x - The x coordinate to move towards.
     * @param {number} y - The y coordinate to move towards.
     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)
     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.
     *
     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.
     */moveTo:function(t,e,i,n,s){void 0===n&&(n=60),void 0===s&&(s=0);var o=Math.atan2(i-t.y,e-t.x);return s>0&&(n=r(t.x,t.y,e,i)/(s/1e3)),t.body.velocity.setToPolar(o,n),o},/**
     * Move the given display object towards the destination object at a steady velocity.
     * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.
     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.
     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
     * Note: The display object doesn't stop moving once it reaches the destination coordinates.
     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#moveToObject
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.
     * @param {object} destination - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.
     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)
     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.
     *
     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.
     */moveToObject:function(t,e,i,n){return this.moveTo(t,e.x,e.y,i,n)},/**
     * Given the angle (in degrees) and speed calculate the velocity and return it as a vector, or set it to the given vector object.
     * One way to use this is: velocityFromAngle(angle, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromAngle
     * @since 3.0.0
     *
     * @param {number} angle - The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
     * @param {number} [speed=60] - The speed it will move, in pixels per second squared.
     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.
     *
     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.
     */velocityFromAngle:function(t,e,i){return void 0===e&&(e=60),void 0===i&&(i=new p),i.setToPolar(n(t),e)},/**
     * Given the rotation (in radians) and speed calculate the velocity and return it as a vector, or set it to the given vector object.
     * One way to use this is: velocityFromRotation(rotation, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromRotation
     * @since 3.0.0
     *
     * @param {number} rotation - The angle in radians.
     * @param {number} [speed=60] - The speed it will move, in pixels per second squared
     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.
     *
     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.
     */velocityFromRotation:function(t,e,i){return void 0===e&&(e=60),void 0===i&&(i=new p),i.setToPolar(t,e)},/**
     * This method will search the given rectangular area and return an array of all physics bodies that
     * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.
     *
     * A body only has to intersect with the search area to be considered, it doesn't have to be fully
     * contained within it.
     *
     * If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,
     * otherwise the search is O(N) for Dynamic Bodies.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapRect
     * @since 3.17.0
     *
     * @param {number} x - The top-left x coordinate of the area to search within.
     * @param {number} y - The top-left y coordinate of the area to search within.
     * @param {number} width - The width of the area to search within.
     * @param {number} height - The height of the area to search within.
     * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?
     * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?
     *
     * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.
     */overlapRect:function(t,e,i,n,s,r){return c(this.world,t,e,i,n,s,r)},/**
     * This method will search the given circular area and return an array of all physics bodies that
     * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.
     *
     * A body only has to intersect with the search area to be considered, it doesn't have to be fully
     * contained within it.
     *
     * If Arcade Physics is set to use the RTree (which it is by default) then the search is rather fast,
     * otherwise the search is O(N) for Dynamic Bodies.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapCirc
     * @since 3.21.0
     *
     * @param {number} x - The x coordinate of the center of the area to search within.
     * @param {number} y - The y coordinate of the center of the area to search within.
     * @param {number} radius - The radius of the area to search within.
     * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?
     * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?
     *
     * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.
     */overlapCirc:function(t,e,i,n,s){return u(this.world,t,e,i,n,s)},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#shutdown
     * @since 3.0.0
     */shutdown:function(){if(this.world){var t=this.systems.events;t.off(f.UPDATE,this.world.update,this.world),t.off(f.POST_UPDATE,this.world.postUpdate,this.world),t.off(f.SHUTDOWN,this.shutdown,this),this.add.destroy(),this.world.destroy(),this.add=null,this.world=null}},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.Physics.Arcade.ArcadePhysics#destroy
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.scene.sys.events.off(f.START,this.start,this),this.scene=null,this.systems=null}});d.register("ArcadePhysics",v,"arcadePhysics"),t.exports=v}),r("5kYTK",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6FypI"),n=s("bLNEY"),r=s("jwj1g"),o=s("ilZSx"),a=s("ciOQq"),h=s("gpJfs"),l=new r({initialize:function(t){/**
         * A reference to the Arcade Physics World.
         *
         * @name Phaser.Physics.Arcade.Factory#world
         * @type {Phaser.Physics.Arcade.World}
         * @since 3.0.0
         */this.world=t,/**
         * A reference to the Scene this Arcade Physics instance belongs to.
         *
         * @name Phaser.Physics.Arcade.Factory#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t.scene,/**
         * A reference to the Scene.Systems this Arcade Physics instance belongs to.
         *
         * @name Phaser.Physics.Arcade.Factory#sys
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.sys=t.scene.sys},/**
     * Creates a new Arcade Physics Collider object.
     *
     * @method Phaser.Physics.Arcade.Factory#collider
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object1 - The first object to check for collision.
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object2 - The second object to check for collision.
     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.
     * @param {*} [callbackContext] - The scope in which to call the callbacks.
     *
     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.
     */collider:function(t,e,i,n,s){return this.world.addCollider(t,e,i,n,s)},/**
     * Creates a new Arcade Physics Collider Overlap object.
     *
     * @method Phaser.Physics.Arcade.Factory#overlap
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object1 - The first object to check for overlap.
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object2 - The second object to check for overlap.
     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.
     * @param {*} [callbackContext] - The scope in which to call the callbacks.
     *
     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.
     */overlap:function(t,e,i,n,s){return this.world.addOverlap(t,e,i,n,s)},/**
     * Adds an Arcade Physics Body to the given Game Object.
     *
     * @method Phaser.Physics.Arcade.Factory#existing
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - A Game Object.
     * @param {boolean} [isStatic=false] - Create a Static body (true) or Dynamic body (false).
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object.
     */existing:function(t,e){var i=e?o.STATIC_BODY:o.DYNAMIC_BODY;return this.world.enableBody(t,i),t},/**
     * Creates a new Arcade Image object with a Static body.
     *
     * @method Phaser.Physics.Arcade.Factory#staticImage
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of this Game Object in the world.
     * @param {number} y - The vertical position of this Game Object in the world.
     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.
     *
     * @return {Phaser.Physics.Arcade.Image} The Image object that was created.
     */staticImage:function(t,e,n,s){var r=new i(this.scene,t,e,n,s);return this.sys.displayList.add(r),this.world.enableBody(r,o.STATIC_BODY),r},/**
     * Creates a new Arcade Image object with a Dynamic body.
     *
     * @method Phaser.Physics.Arcade.Factory#image
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of this Game Object in the world.
     * @param {number} y - The vertical position of this Game Object in the world.
     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.
     *
     * @return {Phaser.Physics.Arcade.Image} The Image object that was created.
     */image:function(t,e,n,s){var r=new i(this.scene,t,e,n,s);return this.sys.displayList.add(r),this.world.enableBody(r,o.DYNAMIC_BODY),r},/**
     * Creates a new Arcade Sprite object with a Static body.
     *
     * @method Phaser.Physics.Arcade.Factory#staticSprite
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of this Game Object in the world.
     * @param {number} y - The vertical position of this Game Object in the world.
     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.
     *
     * @return {Phaser.Physics.Arcade.Sprite} The Sprite object that was created.
     */staticSprite:function(t,e,i,s){var r=new n(this.scene,t,e,i,s);return this.sys.displayList.add(r),this.sys.updateList.add(r),this.world.enableBody(r,o.STATIC_BODY),r},/**
     * Creates a new Arcade Sprite object with a Dynamic body.
     *
     * @method Phaser.Physics.Arcade.Factory#sprite
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of this Game Object in the world.
     * @param {number} y - The vertical position of this Game Object in the world.
     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.
     *
     * @return {Phaser.Physics.Arcade.Sprite} The Sprite object that was created.
     */sprite:function(t,e,i,s){var r=new n(this.scene,t,e,i,s);return this.sys.displayList.add(r),this.sys.updateList.add(r),this.world.enableBody(r,o.DYNAMIC_BODY),r},/**
     * Creates a Static Physics Group object.
     * All Game Objects created by this Group will automatically be static Arcade Physics objects.
     *
     * @method Phaser.Physics.Arcade.Factory#staticGroup
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.
     * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group.
     *
     * @return {Phaser.Physics.Arcade.StaticGroup} The Static Group object that was created.
     */staticGroup:function(t,e){return this.sys.updateList.add(new h(this.world,this.world.scene,t,e))},/**
     * Creates a Physics Group object.
     * All Game Objects created by this Group will automatically be dynamic Arcade Physics objects.
     *
     * @method Phaser.Physics.Arcade.Factory#group
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.Physics.Arcade.PhysicsGroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.
     * @param {Phaser.Types.Physics.Arcade.PhysicsGroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group.
     *
     * @return {Phaser.Physics.Arcade.Group} The Group object that was created.
     */group:function(t,e){return this.sys.updateList.add(new a(this.world,this.world.scene,t,e))},/**
     * Destroys this Factory.
     *
     * @method Phaser.Physics.Arcade.Factory#destroy
     * @since 3.5.0
     */destroy:function(){this.world=null,this.scene=null,this.sys=null}});t.exports=l}),r("6FypI",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("3SfZs"),r=s("8qGvv"),o=new i({Extends:r,Mixins:[n.Acceleration,n.Angular,n.Bounce,n.Debug,n.Drag,n.Enable,n.Friction,n.Gravity,n.Immovable,n.Mass,n.Size,n.Velocity],initialize:function(t,e,i,n,s){r.call(this,t,e,i,n,s),/**
         * This Game Object's Physics Body.
         *
         * @name Phaser.Physics.Arcade.Image#body
         * @type {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)}
         * @default null
         * @since 3.0.0
         */this.body=null}});t.exports=o}),r("3SfZs",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Physics.Arcade.Components
 */t.exports={Acceleration:s("hBHFZ"),Angular:s("l6iII"),Bounce:s("3eYIA"),Debug:s("buQHl"),Drag:s("bhmqB"),Enable:s("jyrax"),Friction:s("bFAmR"),Gravity:s("bGmpy"),Immovable:s("7ruVw"),Mass:s("fR1MQ"),Size:s("gQPlW"),Velocity:s("N9vhs")}}),r("hBHFZ",function(t,e){t.exports={/**
     * Sets the body's horizontal and vertical acceleration. If the vertical acceleration value is not provided, the vertical acceleration is set to the same value as the horizontal acceleration.
     *
     * @method Phaser.Physics.Arcade.Components.Acceleration#setAcceleration
     * @since 3.0.0
     *
     * @param {number} x - The horizontal acceleration
     * @param {number} [y=x] - The vertical acceleration
     *
     * @return {this} This Game Object.
     */setAcceleration:function(t,e){return this.body.acceleration.set(t,e),this},/**
     * Sets the body's horizontal acceleration.
     *
     * @method Phaser.Physics.Arcade.Components.Acceleration#setAccelerationX
     * @since 3.0.0
     *
     * @param {number} value - The horizontal acceleration
     *
     * @return {this} This Game Object.
     */setAccelerationX:function(t){return this.body.acceleration.x=t,this},/**
     * Sets the body's vertical acceleration.
     *
     * @method Phaser.Physics.Arcade.Components.Acceleration#setAccelerationY
     * @since 3.0.0
     *
     * @param {number} value - The vertical acceleration
     *
     * @return {this} This Game Object.
     */setAccelerationY:function(t){return this.body.acceleration.y=t,this}}}),r("l6iII",function(t,e){t.exports={/**
     * Sets the angular velocity of the body.
     * 
     * In Arcade Physics, bodies cannot rotate. They are always axis-aligned.
     * However, they can have angular motion, which is passed on to the Game Object bound to the body,
     * causing them to visually rotate, even though the body remains axis-aligned.
     *
     * @method Phaser.Physics.Arcade.Components.Angular#setAngularVelocity
     * @since 3.0.0
     *
     * @param {number} value - The amount of angular velocity.
     *
     * @return {this} This Game Object.
     */setAngularVelocity:function(t){return this.body.angularVelocity=t,this},/**
     * Sets the angular acceleration of the body.
     * 
     * In Arcade Physics, bodies cannot rotate. They are always axis-aligned.
     * However, they can have angular motion, which is passed on to the Game Object bound to the body,
     * causing them to visually rotate, even though the body remains axis-aligned.
     *
     * @method Phaser.Physics.Arcade.Components.Angular#setAngularAcceleration
     * @since 3.0.0
     *
     * @param {number} value - The amount of angular acceleration.
     *
     * @return {this} This Game Object.
     */setAngularAcceleration:function(t){return this.body.angularAcceleration=t,this},/**
     * Sets the angular drag of the body. Drag is applied to the current velocity, providing a form of deceleration.
     *
     * @method Phaser.Physics.Arcade.Components.Angular#setAngularDrag
     * @since 3.0.0
     *
     * @param {number} value - The amount of drag.
     *
     * @return {this} This Game Object.
     */setAngularDrag:function(t){return this.body.angularDrag=t,this}}}),r("3eYIA",function(t,e){t.exports={/**
     * Sets the bounce values of this body.
     * 
     * Bounce is the amount of restitution, or elasticity, the body has when it collides with another object.
     * A value of 1 means that it will retain its full velocity after the rebound. A value of 0 means it will not rebound at all.
     *
     * @method Phaser.Physics.Arcade.Components.Bounce#setBounce
     * @since 3.0.0
     *
     * @param {number} x - The amount of horizontal bounce to apply on collision. A float, typically between 0 and 1.
     * @param {number} [y=x] - The amount of vertical bounce to apply on collision. A float, typically between 0 and 1.
     *
     * @return {this} This Game Object.
     */setBounce:function(t,e){return this.body.bounce.set(t,e),this},/**
     * Sets the horizontal bounce value for this body.
     *
     * @method Phaser.Physics.Arcade.Components.Bounce#setBounceX
     * @since 3.0.0
     *
     * @param {number} value - The amount of horizontal bounce to apply on collision. A float, typically between 0 and 1.
     *
     * @return {this} This Game Object.
     */setBounceX:function(t){return this.body.bounce.x=t,this},/**
     * Sets the vertical bounce value for this body.
     *
     * @method Phaser.Physics.Arcade.Components.Bounce#setBounceY
     * @since 3.0.0
     *
     * @param {number} value - The amount of vertical bounce to apply on collision. A float, typically between 0 and 1.
     *
     * @return {this} This Game Object.
     */setBounceY:function(t){return this.body.bounce.y=t,this},/**
     * Sets whether this Body collides with the world boundary.
     * 
     * Optionally also sets the World Bounce values. If the `Body.worldBounce` is null, it's set to a new Phaser.Math.Vector2 first.
     *
     * @method Phaser.Physics.Arcade.Components.Bounce#setCollideWorldBounds
     * @since 3.0.0
     *
     * @param {boolean} [value=true] - `true` if this body should collide with the world bounds, otherwise `false`.
     * @param {number} [bounceX] - If given this will be replace the `worldBounce.x` value.
     * @param {number} [bounceY] - If given this will be replace the `worldBounce.y` value.
     *
     * @return {this} This Game Object.
     */setCollideWorldBounds:function(t,e,i){return this.body.setCollideWorldBounds(t,e,i),this}}}),r("buQHl",function(t,e){t.exports={/**
     * Sets the debug values of this body.
     * 
     * Bodies will only draw their debug if debug has been enabled for Arcade Physics as a whole.
     * Note that there is a performance cost in drawing debug displays. It should never be used in production.
     *
     * @method Phaser.Physics.Arcade.Components.Debug#setDebug
     * @since 3.0.0
     *
     * @param {boolean} showBody - Set to `true` to have this body render its outline to the debug display.
     * @param {boolean} showVelocity - Set to `true` to have this body render a velocity marker to the debug display.
     * @param {number} bodyColor - The color of the body outline when rendered to the debug display.
     *
     * @return {this} This Game Object.
     */setDebug:function(t,e,i){return this.debugShowBody=t,this.debugShowVelocity=e,this.debugBodyColor=i,this},/**
     * Sets the color of the body outline when it renders to the debug display.
     *
     * @method Phaser.Physics.Arcade.Components.Debug#setDebugBodyColor
     * @since 3.0.0
     *
     * @param {number} value - The color of the body outline when rendered to the debug display.
     *
     * @return {this} This Game Object.
     */setDebugBodyColor:function(t){return this.body.debugBodyColor=t,this},/**
     * Set to `true` to have this body render its outline to the debug display.
     *
     * @name Phaser.Physics.Arcade.Components.Debug#debugShowBody
     * @type {boolean}
     * @since 3.0.0
     */debugShowBody:{get:function(){return this.body.debugShowBody},set:function(t){this.body.debugShowBody=t}},/**
     * Set to `true` to have this body render a velocity marker to the debug display.
     *
     * @name Phaser.Physics.Arcade.Components.Debug#debugShowVelocity
     * @type {boolean}
     * @since 3.0.0
     */debugShowVelocity:{get:function(){return this.body.debugShowVelocity},set:function(t){this.body.debugShowVelocity=t}},/**
     * The color of the body outline when it renders to the debug display.
     *
     * @name Phaser.Physics.Arcade.Components.Debug#debugBodyColor
     * @type {number}
     * @since 3.0.0
     */debugBodyColor:{get:function(){return this.body.debugBodyColor},set:function(t){this.body.debugBodyColor=t}}}}),r("bhmqB",function(t,e){t.exports={/**
     * Sets the body's horizontal and vertical drag. If the vertical drag value is not provided, the vertical drag is set to the same value as the horizontal drag.
     *
     * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.
     * It is the absolute loss of velocity due to movement, in pixels per second squared.
     * The x and y components are applied separately.
     *
     * When `useDamping` is true, this is 1 minus the damping factor.
     * A value of 1 means the Body loses no velocity.
     * A value of 0.95 means the Body loses 5% of its velocity per step.
     * A value of 0.5 means the Body loses 50% of its velocity per step.
     *
     * Drag is applied only when `acceleration` is zero.
     *
     * @method Phaser.Physics.Arcade.Components.Drag#setDrag
     * @since 3.0.0
     *
     * @param {number} x - The amount of horizontal drag to apply.
     * @param {number} [y=x] - The amount of vertical drag to apply.
     *
     * @return {this} This Game Object.
     */setDrag:function(t,e){return this.body.drag.set(t,e),this},/**
     * Sets the body's horizontal drag.
     *
     * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.
     * It is the absolute loss of velocity due to movement, in pixels per second squared.
     * The x and y components are applied separately.
     *
     * When `useDamping` is true, this is 1 minus the damping factor.
     * A value of 1 means the Body loses no velocity.
     * A value of 0.95 means the Body loses 5% of its velocity per step.
     * A value of 0.5 means the Body loses 50% of its velocity per step.
     *
     * Drag is applied only when `acceleration` is zero.
     *
     * @method Phaser.Physics.Arcade.Components.Drag#setDragX
     * @since 3.0.0
     *
     * @param {number} value - The amount of horizontal drag to apply.
     *
     * @return {this} This Game Object.
     */setDragX:function(t){return this.body.drag.x=t,this},/**
     * Sets the body's vertical drag.
     *
     * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.
     * It is the absolute loss of velocity due to movement, in pixels per second squared.
     * The x and y components are applied separately.
     *
     * When `useDamping` is true, this is 1 minus the damping factor.
     * A value of 1 means the Body loses no velocity.
     * A value of 0.95 means the Body loses 5% of its velocity per step.
     * A value of 0.5 means the Body loses 50% of its velocity per step.
     *
     * Drag is applied only when `acceleration` is zero.
     *
     * @method Phaser.Physics.Arcade.Components.Drag#setDragY
     * @since 3.0.0
     *
     * @param {number} value - The amount of vertical drag to apply.
     *
     * @return {this} This Game Object.
     */setDragY:function(t){return this.body.drag.y=t,this},/**
     * If this Body is using `drag` for deceleration this function controls how the drag is applied.
     * If set to `true` drag will use a damping effect rather than a linear approach. If you are
     * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in
     * the game Asteroids) then you will get a far smoother and more visually correct deceleration
     * by using damping, avoiding the axis-drift that is prone with linear deceleration.
     *
     * If you enable this property then you should use far smaller `drag` values than with linear, as
     * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow
     * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.
     *
     * @method Phaser.Physics.Arcade.Components.Drag#setDamping
     * @since 3.10.0
     *
     * @param {boolean} value - `true` to use damping for deceleration, or `false` to use linear deceleration.
     *
     * @return {this} This Game Object.
     */setDamping:function(t){return this.body.useDamping=t,this}}}),r("jyrax",function(t,e){t.exports={/**
     * Enables this Game Object's Body.
     *
     * @method Phaser.Physics.Arcade.Components.Enable#enableBody
     * @since 3.0.0
     *
     * @param {boolean} reset - Also reset the Body and place it at (x, y).
     * @param {number} x - The horizontal position to place the Game Object and Body.
     * @param {number} y - The horizontal position to place the Game Object and Body.
     * @param {boolean} enableGameObject - Also activate this Game Object.
     * @param {boolean} showGameObject - Also show this Game Object.
     *
     * @return {this} This Game Object.
     *
     * @see Phaser.Physics.Arcade.Body#enable
     * @see Phaser.Physics.Arcade.StaticBody#enable
     * @see Phaser.Physics.Arcade.Body#reset
     * @see Phaser.Physics.Arcade.StaticBody#reset
     * @see Phaser.GameObjects.GameObject#active
     * @see Phaser.GameObjects.GameObject#visible
     */enableBody:function(t,e,i,n,s){return t&&this.body.reset(e,i),n&&(this.body.gameObject.active=!0),s&&(this.body.gameObject.visible=!0),this.body.enable=!0,this},/**
     * Stops and disables this Game Object's Body.
     *
     * @method Phaser.Physics.Arcade.Components.Enable#disableBody
     * @since 3.0.0
     *
     * @param {boolean} [disableGameObject=false] - Also deactivate this Game Object.
     * @param {boolean} [hideGameObject=false] - Also hide this Game Object.
     *
     * @return {this} This Game Object.
     *
     * @see Phaser.Physics.Arcade.Body#enable
     * @see Phaser.Physics.Arcade.StaticBody#enable
     * @see Phaser.GameObjects.GameObject#active
     * @see Phaser.GameObjects.GameObject#visible
     */disableBody:function(t,e){return void 0===t&&(t=!1),void 0===e&&(e=!1),this.body.stop(),this.body.enable=!1,t&&(this.body.gameObject.active=!1),e&&(this.body.gameObject.visible=!1),this},/**
     * Syncs the Body's position and size with its parent Game Object.
     * You don't need to call this for Dynamic Bodies, as it happens automatically.
     * But for Static bodies it's a useful way of modifying the position of a Static Body
     * in the Physics World, based on its Game Object.
     *
     * @method Phaser.Physics.Arcade.Components.Enable#refreshBody
     * @since 3.1.0
     *
     * @return {this} This Game Object.
     *
     * @see Phaser.Physics.Arcade.StaticBody#updateFromGameObject
     */refreshBody:function(){return this.body.updateFromGameObject(),this}}}),r("bFAmR",function(t,e){t.exports={/**
     * Sets the friction of this game object's physics body.
     * In Arcade Physics, friction is a special case of motion transfer from an "immovable" body to a riding body.
     *
     * @method Phaser.Physics.Arcade.Components.Friction#setFriction
     * @since 3.0.0
     *
     * @param {number} x - The amount of horizontal friction to apply, [0, 1].
     * @param {number} [y=x] - The amount of vertical friction to apply, [0, 1].
     *
     * @return {this} This Game Object.
     *
     * @see Phaser.Physics.Arcade.Body#friction
     */setFriction:function(t,e){return this.body.friction.set(t,e),this},/**
     * Sets the horizontal friction of this game object's physics body.
     * This can move a riding body horizontally when it collides with this one on the vertical axis.
     *
     * @method Phaser.Physics.Arcade.Components.Friction#setFrictionX
     * @since 3.0.0
     *
     * @param {number} x - The amount of friction to apply, [0, 1].
     *
     * @return {this} This Game Object.
     *
     * @see Phaser.Physics.Arcade.Body#friction
     */setFrictionX:function(t){return this.body.friction.x=t,this},/**
     * Sets the vertical friction of this game object's physics body.
     * This can move a riding body vertically when it collides with this one on the horizontal axis.
     *
     * @method Phaser.Physics.Arcade.Components.Friction#setFrictionY
     * @since 3.0.0
     *
     * @param {number} y - The amount of friction to apply, [0, 1].
     *
     * @return {this} This Game Object.
     *
     * @see Phaser.Physics.Arcade.Body#friction
     */setFrictionY:function(t){return this.body.friction.y=t,this}}}),r("bGmpy",function(t,e){t.exports={/**
     * Set the X and Y values of the gravitational pull to act upon this Arcade Physics Game Object. Values can be positive or negative. Larger values result in a stronger effect.
     * 
     * If only one value is provided, this value will be used for both the X and Y axis.
     *
     * @method Phaser.Physics.Arcade.Components.Gravity#setGravity
     * @since 3.0.0
     *
     * @param {number} x - The gravitational force to be applied to the X-axis.
     * @param {number} [y=x] - The gravitational force to be applied to the Y-axis. If this is not specified, the X value will be used.
     *
     * @return {this} This Game Object.
     */setGravity:function(t,e){return this.body.gravity.set(t,e),this},/**
     * Set the gravitational force to be applied to the X axis. Value can be positive or negative. Larger values result in a stronger effect.
     *
     * @method Phaser.Physics.Arcade.Components.Gravity#setGravityX
     * @since 3.0.0
     *
     * @param {number} x - The gravitational force to be applied to the X-axis.
     *
     * @return {this} This Game Object.
     */setGravityX:function(t){return this.body.gravity.x=t,this},/**
     * Set the gravitational force to be applied to the Y axis. Value can be positive or negative. Larger values result in a stronger effect.
     *
     * @method Phaser.Physics.Arcade.Components.Gravity#setGravityY
     * @since 3.0.0
     *
     * @param {number} y - The gravitational force to be applied to the Y-axis.
     *
     * @return {this} This Game Object.
     */setGravityY:function(t){return this.body.gravity.y=t,this}}}),r("7ruVw",function(t,e){t.exports={/**
     * Sets Whether this Body can be moved by collisions with another Body.
     *
     * @method Phaser.Physics.Arcade.Components.Immovable#setImmovable
     * @since 3.0.0
     *
     * @param {boolean} [value=true] - Sets if this body can be moved by collisions with another Body.
     *
     * @return {this} This Game Object.
     */setImmovable:function(t){return void 0===t&&(t=!0),this.body.immovable=t,this}}}),r("fR1MQ",function(t,e){t.exports={/**
     * Sets the mass of the physics body
     *
     * @method Phaser.Physics.Arcade.Components.Mass#setMass
     * @since 3.0.0
     *
     * @param {number} value - New value for the mass of the body.
     *
     * @return {this} This Game Object.
     */setMass:function(t){return this.body.mass=t,this}}}),r("gQPlW",function(t,e){t.exports={/**
     * Sets the body offset. This allows you to adjust the difference between the center of the body
     * and the x and y coordinates of the parent Game Object.
     *
     * @method Phaser.Physics.Arcade.Components.Size#setOffset
     * @since 3.0.0
     *
     * @param {number} x - The amount to offset the body from the parent Game Object along the x-axis.
     * @param {number} [y=x] - The amount to offset the body from the parent Game Object along the y-axis. Defaults to the value given for the x-axis.
     *
     * @return {this} This Game Object.
     */setOffset:function(t,e){return this.body.setOffset(t,e),this},/**
     * Sets the size of this physics body. Setting the size does not adjust the dimensions
     * of the parent Game Object.
     *
     * @method Phaser.Physics.Arcade.Components.Size#setSize
     * @since 3.0.0
     *
     * @param {number} width - The new width of the physics body, in pixels.
     * @param {number} height - The new height of the physics body, in pixels.
     * @param {boolean} [center=true] - Should the body be re-positioned so its center aligns with the parent Game Object?
     *
     * @return {this} This Game Object.
     */setSize:function(t,e,i){return this.body.setSize(t,e,i),this},/**
     * Sets this physics body to use a circle for collision instead of a rectangle.
     *
     * @method Phaser.Physics.Arcade.Components.Size#setCircle
     * @since 3.0.0
     *
     * @param {number} radius - The radius of the physics body, in pixels.
     * @param {number} [offsetX] - The amount to offset the body from the parent Game Object along the x-axis.
     * @param {number} [offsetY] - The amount to offset the body from the parent Game Object along the y-axis.
     *
     * @return {this} This Game Object.
     */setCircle:function(t,e,i){return this.body.setCircle(t,e,i),this}}}),r("N9vhs",function(t,e){t.exports={/**
     * Sets the velocity of the Body.
     *
     * @method Phaser.Physics.Arcade.Components.Velocity#setVelocity
     * @since 3.0.0
     *
     * @param {number} x - The horizontal velocity of the body. Positive values move the body to the right, while negative values move it to the left.
     * @param {number} [y=x] - The vertical velocity of the body. Positive values move the body down, while negative values move it up.
     *
     * @return {this} This Game Object.
     */setVelocity:function(t,e){return this.body.setVelocity(t,e),this},/**
     * Sets the horizontal component of the body's velocity.
     *
     * Positive values move the body to the right, while negative values move it to the left.
     *
     * @method Phaser.Physics.Arcade.Components.Velocity#setVelocityX
     * @since 3.0.0
     *
     * @param {number} x - The new horizontal velocity.
     *
     * @return {this} This Game Object.
     */setVelocityX:function(t){return this.body.setVelocityX(t),this},/**
     * Sets the vertical component of the body's velocity.
     *
     * Positive values move the body down, while negative values move it up.
     *
     * @method Phaser.Physics.Arcade.Components.Velocity#setVelocityY
     * @since 3.0.0
     *
     * @param {number} y - The new vertical velocity of the body.
     *
     * @return {this} This Game Object.
     */setVelocityY:function(t){return this.body.setVelocityY(t),this},/**
     * Sets the maximum velocity of the body.
     *
     * @method Phaser.Physics.Arcade.Components.Velocity#setMaxVelocity
     * @since 3.0.0
     *
     * @param {number} x - The new maximum horizontal velocity.
     * @param {number} [y=x] - The new maximum vertical velocity.
     *
     * @return {this} This Game Object.
     */setMaxVelocity:function(t,e){return this.body.maxVelocity.set(t,e),this}}}),r("bLNEY",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("3SfZs"),r=s("gXuc8"),o=new i({Extends:r,Mixins:[n.Acceleration,n.Angular,n.Bounce,n.Debug,n.Drag,n.Enable,n.Friction,n.Gravity,n.Immovable,n.Mass,n.Size,n.Velocity],initialize:function(t,e,i,n,s){r.call(this,t,e,i,n,s),/**
         * This Game Object's Physics Body.
         *
         * @name Phaser.Physics.Arcade.Sprite#body
         * @type {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)}
         * @default null
         * @since 3.0.0
         */this.body=null}});t.exports=o}),r("ciOQq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bLNEY"),n=s("jwj1g"),r=s("ilZSx"),o=s("7BSWl"),a=s("hDBsd"),h=s("jC9MQ"),l=new n({Extends:a,initialize:function(t,e,n,s){if(n||s){if(h(n))//  children is a plain object, so swizzle them:
s=n,n=null,s.internalCreateCallback=this.createCallbackHandler,s.internalRemoveCallback=this.removeCallbackHandler;else if(Array.isArray(n)&&h(n[0])){//  children is an array of plain objects
s=n[0];var l=this;n.forEach(function(t){t.internalCreateCallback=l.createCallbackHandler,t.internalRemoveCallback=l.removeCallbackHandler})}else s={internalCreateCallback:this.createCallbackHandler,internalRemoveCallback:this.removeCallbackHandler}}else s={internalCreateCallback:this.createCallbackHandler,internalRemoveCallback:this.removeCallbackHandler};/**
         * The physics simulation.
         *
         * @name Phaser.Physics.Arcade.Group#world
         * @type {Phaser.Physics.Arcade.World}
         * @since 3.0.0
         */this.world=t,/**
         * The class to create new Group members from.
         *
         * This should be either `Phaser.Physics.Arcade.Image`, `Phaser.Physics.Arcade.Sprite`, or a class extending one of those.
         *
         * @name Phaser.Physics.Arcade.Group#classType
         * @type {Function}
         * @default ArcadeSprite
         * @since 3.0.0
         */s.classType=o(s,"classType",i),/**
         * The physics type of the Group's members.
         *
         * @name Phaser.Physics.Arcade.Group#physicsType
         * @type {integer}
         * @default Phaser.Physics.Arcade.DYNAMIC_BODY
         * @since 3.0.0
         */this.physicsType=r.DYNAMIC_BODY,/**
         * Default physics properties applied to Game Objects added to the Group or created by the Group. Derived from the `config` argument.
         *
         * @name Phaser.Physics.Arcade.Group#defaults
         * @type {Phaser.Types.Physics.Arcade.PhysicsGroupDefaults}
         * @since 3.0.0
         */this.defaults={setCollideWorldBounds:o(s,"collideWorldBounds",!1),setBoundsRectangle:o(s,"customBoundsRectangle",null),setAccelerationX:o(s,"accelerationX",0),setAccelerationY:o(s,"accelerationY",0),setAllowDrag:o(s,"allowDrag",!0),setAllowGravity:o(s,"allowGravity",!0),setAllowRotation:o(s,"allowRotation",!0),setBounceX:o(s,"bounceX",0),setBounceY:o(s,"bounceY",0),setDragX:o(s,"dragX",0),setDragY:o(s,"dragY",0),setEnable:o(s,"enable",!0),setGravityX:o(s,"gravityX",0),setGravityY:o(s,"gravityY",0),setFrictionX:o(s,"frictionX",0),setFrictionY:o(s,"frictionY",0),setVelocityX:o(s,"velocityX",0),setVelocityY:o(s,"velocityY",0),setAngularVelocity:o(s,"angularVelocity",0),setAngularAcceleration:o(s,"angularAcceleration",0),setAngularDrag:o(s,"angularDrag",0),setMass:o(s,"mass",1),setImmovable:o(s,"immovable",!1)},Array.isArray(n)&&(s=null),a.call(this,e,n,s),/**
         * A textual representation of this Game Object.
         * Used internally by Phaser but is available for your own custom classes to populate.
         *
         * @name Phaser.Physics.Arcade.Group#type
         * @type {string}
         * @default 'PhysicsGroup'
         * @since 3.21.0
         */this.type="PhysicsGroup"},/**
     * Enables a Game Object's Body and assigns `defaults`. Called when a Group member is added or created.
     *
     * @method Phaser.Physics.Arcade.Group#createCallbackHandler
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object being added.
     */createCallbackHandler:function(t){t.body||this.world.enableBody(t,r.DYNAMIC_BODY);var e=t.body;for(var i in this.defaults)e[i](this.defaults[i])},/**
     * Disables a Game Object's Body. Called when a Group member is removed.
     *
     * @method Phaser.Physics.Arcade.Group#removeCallbackHandler
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The Game Object being removed.
     */removeCallbackHandler:function(t){t.body&&this.world.disableBody(t)},/**
     * Sets the velocity of each Group member.
     *
     * @method Phaser.Physics.Arcade.Group#setVelocity
     * @since 3.0.0
     *
     * @param {number} x - The horizontal velocity.
     * @param {number} y - The vertical velocity.
     * @param {number} [step=0] - The velocity increment. When set, the first member receives velocity (x, y), the second (x + step, y + step), and so on.
     *
     * @return {Phaser.Physics.Arcade.Group} This Physics Group object.
     */setVelocity:function(t,e,i){void 0===i&&(i=0);for(var n=this.getChildren(),s=0;s<n.length;s++)n[s].body.velocity.set(t+s*i,e+s*i);return this},/**
     * Sets the horizontal velocity of each Group member.
     *
     * @method Phaser.Physics.Arcade.Group#setVelocityX
     * @since 3.0.0
     *
     * @param {number} value - The velocity value.
     * @param {number} [step=0] - The velocity increment. When set, the first member receives velocity (x), the second (x + step), and so on.
     *
     * @return {Phaser.Physics.Arcade.Group} This Physics Group object.
     */setVelocityX:function(t,e){void 0===e&&(e=0);for(var i=this.getChildren(),n=0;n<i.length;n++)i[n].body.velocity.x=t+n*e;return this},/**
     * Sets the vertical velocity of each Group member.
     *
     * @method Phaser.Physics.Arcade.Group#setVelocityY
     * @since 3.0.0
     *
     * @param {number} value - The velocity value.
     * @param {number} [step=0] - The velocity increment. When set, the first member receives velocity (y), the second (y + step), and so on.
     *
     * @return {Phaser.Physics.Arcade.Group} This Physics Group object.
     */setVelocityY:function(t,e){void 0===e&&(e=0);for(var i=this.getChildren(),n=0;n<i.length;n++)i[n].body.velocity.y=t+n*e;return this}});t.exports=l}),r("gpJfs",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("bLNEY"),n=s("jwj1g"),r=s("ilZSx"),o=s("7BSWl"),a=s("hDBsd"),h=s("jC9MQ"),l=new n({Extends:a,initialize:function(t,e,n,s){n||s?h(n)?(//  children is a plain object, so swizzle them:
s=n,n=null,s.internalCreateCallback=this.createCallbackHandler,s.internalRemoveCallback=this.removeCallbackHandler,s.createMultipleCallback=this.createMultipleCallbackHandler,s.classType=o(s,"classType",i)):Array.isArray(n)&&h(n[0])&&(//  children is an array of plain objects
s=n,n=null,s.forEach(function(t){t.internalCreateCallback=this.createCallbackHandler,t.internalRemoveCallback=this.removeCallbackHandler,t.createMultipleCallback=this.createMultipleCallbackHandler,t.classType=o(t,"classType",i)})):s={internalCreateCallback:this.createCallbackHandler,internalRemoveCallback:this.removeCallbackHandler,createMultipleCallback:this.createMultipleCallbackHandler,classType:i},/**
         * The physics simulation.
         *
         * @name Phaser.Physics.Arcade.StaticGroup#world
         * @type {Phaser.Physics.Arcade.World}
         * @since 3.0.0
         */this.world=t,/**
         * The scene this group belongs to.
         *
         * @name Phaser.Physics.Arcade.StaticGroup#physicsType
         * @type {integer}
         * @default Phaser.Physics.Arcade.STATIC_BODY
         * @since 3.0.0
         */this.physicsType=r.STATIC_BODY,a.call(this,e,n,s),/**
         * A textual representation of this Game Object.
         * Used internally by Phaser but is available for your own custom classes to populate.
         *
         * @name Phaser.Physics.Arcade.StaticGroup#type
         * @type {string}
         * @default 'StaticPhysicsGroup'
         * @since 3.21.0
         */this.type="StaticPhysicsGroup"},/**
     * Adds a static physics body to the new group member (if it lacks one) and adds it to the simulation.
     *
     * @method Phaser.Physics.Arcade.StaticGroup#createCallbackHandler
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The new group member.
     *
     * @see Phaser.Physics.Arcade.World#enableBody
     */createCallbackHandler:function(t){t.body||this.world.enableBody(t,r.STATIC_BODY)},/**
     * Disables the group member's physics body, removing it from the simulation.
     *
     * @method Phaser.Physics.Arcade.StaticGroup#removeCallbackHandler
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} child - The group member being removed.
     *
     * @see Phaser.Physics.Arcade.World#disableBody
     */removeCallbackHandler:function(t){t.body&&this.world.disableBody(t)},/**
     * Refreshes the group.
     *
     * @method Phaser.Physics.Arcade.StaticGroup#createMultipleCallbackHandler
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject[]} entries - The newly created group members.
     *
     * @see Phaser.Physics.Arcade.StaticGroup#refresh
     */createMultipleCallbackHandler:function(){this.refresh()},/**
     * Resets each Body to the position of its parent Game Object.
     * Body sizes aren't changed (use {@link Phaser.Physics.Arcade.Components.Enable#refreshBody} for that).
     *
     * @method Phaser.Physics.Arcade.StaticGroup#refresh
     * @since 3.0.0
     *
     * @return {Phaser.Physics.Arcade.StaticGroup} This group.
     *
     * @see Phaser.Physics.Arcade.StaticBody#reset
     */refresh:function(){for(var t=this.children.entries,e=0;e<t.length;e++)t[e].body.reset();return this}});t.exports=l}),r("egXG9",function(t,e){var i=s("9rlFn"),n=s("eQ4tZ"),r=s("1GcYB"),o=s("14KTi");t.exports=function(t,e,s,a,h,l){var u=i(t,e-a,s-a,2*a,2*a,h,l);if(0===u.length)return u;for(var c=new n(e,s,a),d=new n,f=[],p=0;p<u.length;p++){var g=u[p];g.isCircle?(d.setTo(g.center.x,g.center.y,g.halfWidth),r(c,d)&&f.push(g)):o(c,g)&&f.push(g)}return f}}),r("9rlFn",function(t,e){t.exports=function(t,e,i,n,s,r,o){void 0===r&&(r=!0),void 0===o&&(o=!1);var a=[],h=[],l=t.treeMinMax;if(l.minX=e,l.minY=i,l.maxX=e+n,l.maxY=i+s,o&&(h=t.staticTree.search(l)),r&&t.useTree)a=t.tree.search(l);else if(r){var u=t.bodies,c={position:{x:e,y:i},left:e,top:i,right:e+n,bottom:i+s,isCircle:!1},d=t.intersects;u.iterate(function(t){d(t,c)&&a.push(t)})}return h.concat(a)}}),r("dokZz",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJKdR"),n=s("iEUUO"),r=s("jwj1g"),o=s("egqqo"),a=s("ilZSx"),h=s("bwLQh"),l=s("3vRz3"),u=s("cPwjQ"),c=s("4cohD"),d=s("4wJN7"),f=s("ccP8g"),p=s("e6piX"),g=s("iBYsy"),v=s("5pMDk"),m=s("gz3ML"),y=s("7KmsS"),x=s("cwr8X"),w=s("aVlAx"),T=s("j3Ns0"),b=s("i83ko"),S=s("8u1DC"),A=s("lxxnL"),E=s("k8alZ"),_=s("eXUBz"),C=s("azs1m"),M=s("7SBSk"),P=s("8qWuA"),O=new r({Extends:l,initialize:function(t,e){l.call(this),/**
         * The Scene this simulation belongs to.
         *
         * @name Phaser.Physics.Arcade.World#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * Dynamic Bodies in this simulation.
         *
         * @name Phaser.Physics.Arcade.World#bodies
         * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.Body>}
         * @since 3.0.0
         */this.bodies=new A,/**
         * Static Bodies in this simulation.
         *
         * @name Phaser.Physics.Arcade.World#staticBodies
         * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.StaticBody>}
         * @since 3.0.0
         */this.staticBodies=new A,/**
         * Static Bodies marked for deletion.
         *
         * @name Phaser.Physics.Arcade.World#pendingDestroy
         * @type {Phaser.Structs.Set.<(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)>}
         * @since 3.1.0
         */this.pendingDestroy=new A,/**
         * This simulation's collision processors.
         *
         * @name Phaser.Physics.Arcade.World#colliders
         * @type {Phaser.Structs.ProcessQueue.<Phaser.Physics.Arcade.Collider>}
         * @since 3.0.0
         */this.colliders=new m,/**
         * Acceleration of Bodies due to gravity, in pixels per second.
         *
         * @name Phaser.Physics.Arcade.World#gravity
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.gravity=new M(v(e,"gravity.x",0),v(e,"gravity.y",0)),/**
         * A boundary constraining Bodies.
         *
         * @name Phaser.Physics.Arcade.World#bounds
         * @type {Phaser.Geom.Rectangle}
         * @since 3.0.0
         */this.bounds=new x(v(e,"x",0),v(e,"y",0),v(e,"width",t.sys.scale.width),v(e,"height",t.sys.scale.height)),/**
         * The boundary edges that Bodies can collide with.
         *
         * @name Phaser.Physics.Arcade.World#checkCollision
         * @type {Phaser.Types.Physics.Arcade.CheckCollisionObject}
         * @since 3.0.0
         */this.checkCollision={up:v(e,"checkCollision.up",!0),down:v(e,"checkCollision.down",!0),left:v(e,"checkCollision.left",!0),right:v(e,"checkCollision.right",!0)},/**
         * The number of physics steps to be taken per second.
         *
         * This property is read-only. Use the `setFPS` method to modify it at run-time.
         *
         * @name Phaser.Physics.Arcade.World#fps
         * @readonly
         * @type {number}
         * @default 60
         * @since 3.10.0
         */this.fps=v(e,"fps",60),/**
         * Should Physics use a fixed update time-step (true) or sync to the render fps (false)?. 
         * False value of this property disables fps and timeScale properties. 
         *
         * @name Phaser.Physics.Arcade.World#fixedStep
         * @type {boolean}
         * @default true
         * @since 3.23.0
         */this.fixedStep=!0,/**
         * The amount of elapsed ms since the last frame.
         *
         * @name Phaser.Physics.Arcade.World#_elapsed
         * @private
         * @type {number}
         * @since 3.10.0
         */this._elapsed=0,/**
         * Internal frame time value.
         *
         * @name Phaser.Physics.Arcade.World#_frameTime
         * @private
         * @type {number}
         * @since 3.10.0
         */this._frameTime=1/this.fps,/**
         * Internal frame time ms value.
         *
         * @name Phaser.Physics.Arcade.World#_frameTimeMS
         * @private
         * @type {number}
         * @since 3.10.0
         */this._frameTimeMS=1e3*this._frameTime,/**
         * The number of steps that took place in the last frame.
         *
         * @name Phaser.Physics.Arcade.World#stepsLastFrame
         * @readonly
         * @type {number}
         * @since 3.10.0
         */this.stepsLastFrame=0,/**
         * Scaling factor applied to the frame rate.
         *
         * - 1.0 = normal speed
         * - 2.0 = half speed
         * - 0.5 = double speed
         *
         * @name Phaser.Physics.Arcade.World#timeScale
         * @type {number}
         * @default 1
         * @since 3.10.0
         */this.timeScale=v(e,"timeScale",1),/**
         * The maximum absolute difference of a Body's per-step velocity and its overlap with another Body that will result in separation on *each axis*.
         * Larger values favor separation.
         * Smaller values favor no separation.
         *
         * @name Phaser.Physics.Arcade.World#OVERLAP_BIAS
         * @type {number}
         * @default 4
         * @since 3.0.0
         */this.OVERLAP_BIAS=v(e,"overlapBias",4),/**
         * The maximum absolute value of a Body's overlap with a tile that will result in separation on *each axis*.
         * Larger values favor separation.
         * Smaller values favor no separation.
         * The optimum value may be similar to the tile size.
         *
         * @name Phaser.Physics.Arcade.World#TILE_BIAS
         * @type {number}
         * @default 16
         * @since 3.0.0
         */this.TILE_BIAS=v(e,"tileBias",16),/**
         * Always separate overlapping Bodies horizontally before vertically.
         * False (the default) means Bodies are first separated on the axis of greater gravity, or the vertical axis if neither is greater.
         *
         * @name Phaser.Physics.Arcade.World#forceX
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.forceX=v(e,"forceX",!1),/**
         * Whether the simulation advances with the game loop.
         *
         * @name Phaser.Physics.Arcade.World#isPaused
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.isPaused=v(e,"isPaused",!1),/**
         * Temporary total of colliding Bodies.
         *
         * @name Phaser.Physics.Arcade.World#_total
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._total=0,/**
         * Enables the debug display.
         *
         * @name Phaser.Physics.Arcade.World#drawDebug
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.drawDebug=v(e,"debug",!1),/**
         * The graphics object drawing the debug display.
         *
         * @name Phaser.Physics.Arcade.World#debugGraphic
         * @type {Phaser.GameObjects.Graphics}
         * @since 3.0.0
         */this.debugGraphic,/**
         * Default debug display settings for new Bodies.
         *
         * @name Phaser.Physics.Arcade.World#defaults
         * @type {Phaser.Types.Physics.Arcade.ArcadeWorldDefaults}
         * @since 3.0.0
         */this.defaults={debugShowBody:v(e,"debugShowBody",!0),debugShowStaticBody:v(e,"debugShowStaticBody",!0),debugShowVelocity:v(e,"debugShowVelocity",!0),bodyDebugColor:v(e,"debugBodyColor",16711935),staticBodyDebugColor:v(e,"debugStaticBodyColor",255),velocityDebugColor:v(e,"debugVelocityColor",65280)},/**
         * The maximum number of items per node on the RTree.
         *
         * This is ignored if `useTree` is `false`. If you have a large number of bodies in
         * your world then you may find search performance improves by increasing this value,
         * to allow more items per node and less node division.
         *
         * @name Phaser.Physics.Arcade.World#maxEntries
         * @type {integer}
         * @default 16
         * @since 3.0.0
         */this.maxEntries=v(e,"maxEntries",16),/**
         * Should this Arcade Physics World use an RTree for Dynamic and Static Physics bodies?
         *
         * An RTree is a fast way of spatially sorting of all the bodies in the world.
         * However, at certain limits, the cost of clearing and inserting the bodies into the
         * tree every frame becomes more expensive than the search speed gains it provides.
         *
         * If you have a large number of dynamic bodies in your world then it may be best to
         * disable the use of the RTree by setting this property to `false` in the physics config.
         *
         * The number it can cope with depends on browser and device, but a conservative estimate
         * of around 5,000 bodies should be considered the max before disabling it.
         *
         * This only applies to dynamic bodies. Static bodies are always kept in an RTree,
         * because they don't have to be cleared every frame, so you benefit from the
         * massive search speeds all the time.
         *
         * @name Phaser.Physics.Arcade.World#useTree
         * @type {boolean}
         * @default true
         * @since 3.10.0
         */this.useTree=v(e,"useTree",!0),/**
         * The spatial index of Dynamic Bodies.
         *
         * @name Phaser.Physics.Arcade.World#tree
         * @type {Phaser.Structs.RTree}
         * @since 3.0.0
         */this.tree=new w(this.maxEntries),/**
         * The spatial index of Static Bodies.
         *
         * @name Phaser.Physics.Arcade.World#staticTree
         * @type {Phaser.Structs.RTree}
         * @since 3.0.0
         */this.staticTree=new w(this.maxEntries),/**
         * Recycled input for tree searches.
         *
         * @name Phaser.Physics.Arcade.World#treeMinMax
         * @type {Phaser.Types.Physics.Arcade.ArcadeWorldTreeMinMax}
         * @since 3.0.0
         */this.treeMinMax={minX:0,minY:0,maxX:0,maxY:0},/**
         * A temporary Transform Matrix used by bodies for calculations without them needing their own local copy.
         *
         * @name Phaser.Physics.Arcade.World#_tempMatrix
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @private
         * @since 3.12.0
         */this._tempMatrix=new C,/**
         * A temporary Transform Matrix used by bodies for calculations without them needing their own local copy.
         *
         * @name Phaser.Physics.Arcade.World#_tempMatrix2
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @private
         * @since 3.12.0
         */this._tempMatrix2=new C,this.drawDebug&&this.createDebugGraphic()},/**
     * Adds an Arcade Physics Body to a Game Object, an array of Game Objects, or the children of a Group.
     *
     * The difference between this and the `enableBody` method is that you can pass arrays or Groups
     * to this method.
     *
     * You can specify if the bodies are to be Dynamic or Static. A dynamic body can move via velocity and
     * acceleration. A static body remains fixed in place and as such is able to use an optimized search
     * tree, making it ideal for static elements such as level objects. You can still collide and overlap
     * with static bodies.
     *
     * Normally, rather than calling this method directly, you'd use the helper methods available in the
     * Arcade Physics Factory, such as:
     *
     * ```javascript
     * this.physics.add.image(x, y, textureKey);
     * this.physics.add.sprite(x, y, textureKey);
     * ```
     *
     * Calling factory methods encapsulates the creation of a Game Object and the creation of its
     * body at the same time. If you are creating custom classes then you can pass them to this
     * method to have their bodies created.
     *
     * @method Phaser.Physics.Arcade.World#enable
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to create the bodies.
     * @param {integer} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.
     */enable:function(t,e){void 0===e&&(e=a.DYNAMIC_BODY),Array.isArray(t)||(t=[t]);for(var i=0;i<t.length;i++){var n=t[i];if(n.isParent)for(var s=n.getChildren(),r=0;r<s.length;r++){var o=s[r];o.isParent?this.enable(o,e):this.enableBody(o,e)}else this.enableBody(n,e)}},/**
     * Creates an Arcade Physics Body on a single Game Object.
     *
     * If the Game Object already has a body, this method will simply add it back into the simulation.
     *
     * You can specify if the body is Dynamic or Static. A dynamic body can move via velocity and
     * acceleration. A static body remains fixed in place and as such is able to use an optimized search
     * tree, making it ideal for static elements such as level objects. You can still collide and overlap
     * with static bodies.
     *
     * Normally, rather than calling this method directly, you'd use the helper methods available in the
     * Arcade Physics Factory, such as:
     *
     * ```javascript
     * this.physics.add.image(x, y, textureKey);
     * this.physics.add.sprite(x, y, textureKey);
     * ```
     *
     * Calling factory methods encapsulates the creation of a Game Object and the creation of its
     * body at the same time. If you are creating custom classes then you can pass them to this
     * method to have their bodies created.
     *
     * @method Phaser.Physics.Arcade.World#enableBody
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} object - The Game Object on which to create the body.
     * @param {integer} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object on which the body was created.
     */enableBody:function(t,e){return void 0===e&&(e=a.DYNAMIC_BODY),t.body||(e===a.DYNAMIC_BODY?t.body=new i(this,t):e===a.STATIC_BODY&&(t.body=new E(this,t))),this.add(t.body),t},/**
     * Adds an existing Arcade Physics Body or StaticBody to the simulation.
     *
     * The body is enabled and added to the local search trees.
     *
     * @method Phaser.Physics.Arcade.World#add
     * @since 3.10.0
     *
     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be added to the simulation.
     *
     * @return {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} The Body that was added to the simulation.
     */add:function(t){return t.physicsType===a.DYNAMIC_BODY?this.bodies.set(t):t.physicsType===a.STATIC_BODY&&(this.staticBodies.set(t),this.staticTree.insert(t)),t.enable=!0,t},/**
     * Disables the Arcade Physics Body of a Game Object, an array of Game Objects, or the children of a Group.
     *
     * The difference between this and the `disableBody` method is that you can pass arrays or Groups
     * to this method.
     *
     * The body itself is not deleted, it just has its `enable` property set to false, which
     * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.
     *
     * @method Phaser.Physics.Arcade.World#disable
     * @since 3.0.0
     *
     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to disable the bodies.
     */disable:function(t){Array.isArray(t)||(t=[t]);for(var e=0;e<t.length;e++){var i=t[e];if(i.isParent)for(var n=i.getChildren(),s=0;s<n.length;s++){var r=n[s];r.isParent?this.disable(r):this.disableBody(r.body)}else this.disableBody(i.body)}},/**
     * Disables an existing Arcade Physics Body or StaticBody and removes it from the simulation.
     *
     * The body is disabled and removed from the local search trees.
     *
     * The body itself is not deleted, it just has its `enable` property set to false, which
     * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.
     *
     * @method Phaser.Physics.Arcade.World#disableBody
     * @since 3.0.0
     *
     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be disabled.
     */disableBody:function(t){this.remove(t),t.enable=!1},/**
     * Removes an existing Arcade Physics Body or StaticBody from the simulation.
     *
     * The body is disabled and removed from the local search trees.
     *
     * The body itself is not deleted, it just has its `enabled` property set to false, which
     * means you can re-enable it again at any point by passing it to enable `enable` or `add`.
     *
     * @method Phaser.Physics.Arcade.World#remove
     * @since 3.0.0
     *
     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The body to be removed from the simulation.
     */remove:function(t){t.physicsType===a.DYNAMIC_BODY?(this.tree.remove(t),this.bodies.delete(t)):t.physicsType===a.STATIC_BODY&&(this.staticBodies.delete(t),this.staticTree.remove(t))},/**
     * Creates a Graphics Game Object that the world will use to render the debug display to.
     *
     * This is called automatically when the World is instantiated if the `debug` config property
     * was set to `true`. However, you can call it at any point should you need to display the
     * debug Graphic from a fixed point.
     *
     * You can control which objects are drawn to the Graphics object, and the colors they use,
     * by setting the debug properties in the physics config.
     *
     * You should not typically use this in a production game. Use it to aid during debugging.
     *
     * @method Phaser.Physics.Arcade.World#createDebugGraphic
     * @since 3.0.0
     *
     * @return {Phaser.GameObjects.Graphics} The Graphics object that was created for use by the World.
     */createDebugGraphic:function(){var t=this.scene.sys.add.graphics({x:0,y:0});return t.setDepth(Number.MAX_VALUE),this.debugGraphic=t,this.drawDebug=!0,t},/**
     * Sets the position, size and properties of the World boundary.
     *
     * The World boundary is an invisible rectangle that defines the edges of the World.
     * If a Body is set to collide with the world bounds then it will automatically stop
     * when it reaches any of the edges. You can optionally set which edges of the boundary
     * should be checked against.
     *
     * @method Phaser.Physics.Arcade.World#setBounds
     * @since 3.0.0
     *
     * @param {number} x - The top-left x coordinate of the boundary.
     * @param {number} y - The top-left y coordinate of the boundary.
     * @param {number} width - The width of the boundary.
     * @param {number} height - The height of the boundary.
     * @param {boolean} [checkLeft] - Should bodies check against the left edge of the boundary?
     * @param {boolean} [checkRight] - Should bodies check against the right edge of the boundary?
     * @param {boolean} [checkUp] - Should bodies check against the top edge of the boundary?
     * @param {boolean} [checkDown] - Should bodies check against the bottom edge of the boundary?
     *
     * @return {Phaser.Physics.Arcade.World} This World object.
     */setBounds:function(t,e,i,n,s,r,o,a){return this.bounds.setTo(t,e,i,n),void 0!==s&&this.setBoundsCollision(s,r,o,a),this},/**
     * Enables or disables collisions on each edge of the World boundary.
     *
     * @method Phaser.Physics.Arcade.World#setBoundsCollision
     * @since 3.0.0
     *
     * @param {boolean} [left=true] - Should bodies check against the left edge of the boundary?
     * @param {boolean} [right=true] - Should bodies check against the right edge of the boundary?
     * @param {boolean} [up=true] - Should bodies check against the top edge of the boundary?
     * @param {boolean} [down=true] - Should bodies check against the bottom edge of the boundary?
     *
     * @return {Phaser.Physics.Arcade.World} This World object.
     */setBoundsCollision:function(t,e,i,n){return void 0===t&&(t=!0),void 0===e&&(e=!0),void 0===i&&(i=!0),void 0===n&&(n=!0),this.checkCollision.left=t,this.checkCollision.right=e,this.checkCollision.up=i,this.checkCollision.down=n,this},/**
     * Pauses the simulation.
     *
     * A paused simulation does not update any existing bodies, or run any Colliders.
     *
     * However, you can still enable and disable bodies within it, or manually run collide or overlap
     * checks.
     *
     * @method Phaser.Physics.Arcade.World#pause
     * @fires Phaser.Physics.Arcade.Events#PAUSE
     * @since 3.0.0
     *
     * @return {Phaser.Physics.Arcade.World} This World object.
     */pause:function(){return this.isPaused=!0,this.emit(u.PAUSE),this},/**
     * Resumes the simulation, if paused.
     *
     * @method Phaser.Physics.Arcade.World#resume
     * @fires Phaser.Physics.Arcade.Events#RESUME
     * @since 3.0.0
     *
     * @return {Phaser.Physics.Arcade.World} This World object.
     */resume:function(){return this.isPaused=!1,this.emit(u.RESUME),this},/**
     * Creates a new Collider object and adds it to the simulation.
     *
     * A Collider is a way to automatically perform collision checks between two objects,
     * calling the collide and process callbacks if they occur.
     *
     * Colliders are run as part of the World update, after all of the Bodies have updated.
     *
     * By creating a Collider you don't need then call `World.collide` in your `update` loop,
     * as it will be handled for you automatically.
     *
     * @method Phaser.Physics.Arcade.World#addCollider
     * @since 3.0.0
     * @see Phaser.Physics.Arcade.World#collide
     *
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for collision.
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object to check for collision.
     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.
     * @param {*} [callbackContext] - The scope in which to call the callbacks.
     *
     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.
     */addCollider:function(t,e,i,n,s){void 0===i&&(i=null),void 0===n&&(n=null),void 0===s&&(s=i);var r=new o(this,!1,t,e,i,n,s);return this.colliders.add(r),r},/**
     * Creates a new Overlap Collider object and adds it to the simulation.
     *
     * A Collider is a way to automatically perform overlap checks between two objects,
     * calling the collide and process callbacks if they occur.
     *
     * Colliders are run as part of the World update, after all of the Bodies have updated.
     *
     * By creating a Collider you don't need then call `World.overlap` in your `update` loop,
     * as it will be handled for you automatically.
     *
     * @method Phaser.Physics.Arcade.World#addOverlap
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for overlap.
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object to check for overlap.
     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects overlap.
     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects overlap. Must return a boolean.
     * @param {*} [callbackContext] - The scope in which to call the callbacks.
     *
     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.
     */addOverlap:function(t,e,i,n,s){void 0===i&&(i=null),void 0===n&&(n=null),void 0===s&&(s=i);var r=new o(this,!0,t,e,i,n,s);return this.colliders.add(r),r},/**
     * Removes a Collider from the simulation so it is no longer processed.
     *
     * This method does not destroy the Collider. If you wish to add it back at a later stage you can call
     * `World.colliders.add(Collider)`.
     *
     * If you no longer need the Collider you can call the `Collider.destroy` method instead, which will
     * automatically clear all of its references and then remove it from the World. If you call destroy on
     * a Collider you _don't_ need to pass it to this method too.
     *
     * @method Phaser.Physics.Arcade.World#removeCollider
     * @since 3.0.0
     *
     * @param {Phaser.Physics.Arcade.Collider} collider - The Collider to remove from the simulation.
     *
     * @return {Phaser.Physics.Arcade.World} This World object.
     */removeCollider:function(t){return this.colliders.remove(t),this},/**
     * Sets the frame rate to run the simulation at.
     *
     * The frame rate value is used to simulate a fixed update time step. This fixed
     * time step allows for a straightforward implementation of a deterministic game state.
     *
     * This frame rate is independent of the frequency at which the game is rendering. The
     * higher you set the fps, the more physics simulation steps will occur per game step.
     * Conversely, the lower you set it, the less will take place.
     *
     * You can optionally advance the simulation directly yourself by calling the `step` method.
     *
     * @method Phaser.Physics.Arcade.World#setFPS
     * @since 3.10.0
     *
     * @param {integer} framerate - The frame rate to advance the simulation at.
     *
     * @return {this} This World object.
     */setFPS:function(t){return this.fps=t,this._frameTime=1/this.fps,this._frameTimeMS=1e3*this._frameTime,this},/**
     * Advances the simulation based on the elapsed time and fps rate.
     *
     * This is called automatically by your Scene and does not need to be invoked directly.
     *
     * @method Phaser.Physics.Arcade.World#update
     * @protected
     * @fires Phaser.Physics.Arcade.Events#WORLD_STEP
     * @since 3.0.0
     *
     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
     * @param {number} delta - The delta time, in ms, elapsed since the last frame.
     */update:function(t,e){if(!this.isPaused&&0!==this.bodies.size){var i,n,s=this._frameTime,r=this._frameTimeMS*this.timeScale;this._elapsed+=e;var o=this.bodies.entries,a=this._elapsed>=r;for(this.fixedStep||(s=.001*e,a=!0,this._elapsed=0),i=0;i<o.length;i++)(n=o[i]).enable&&n.preUpdate(a,s);//  We know that a step will happen this frame, so let's bundle it all together to save branching and iteration costs
if(a){this._elapsed-=r,this.stepsLastFrame=1,this.useTree&&(this.tree.clear(),this.tree.load(o));//  Process any colliders
var h=this.colliders.update();for(i=0;i<h.length;i++){var l=h[i];l.active&&l.update()}this.emit(u.WORLD_STEP)}//  Process any additional steps this frame
for(;this._elapsed>=r;)this._elapsed-=r,this.step(s)}},/**
     * Advances the simulation by a time increment.
     *
     * @method Phaser.Physics.Arcade.World#step
     * @fires Phaser.Physics.Arcade.Events#WORLD_STEP
     * @since 3.10.0
     *
     * @param {number} delta - The delta time amount, in seconds, by which to advance the simulation.
     */step:function(t){var e,i,n=this.bodies.entries,s=n.length;for(e=0;e<s;e++)(i=n[e]).enable&&i.update(t);this.useTree&&(this.tree.clear(),this.tree.load(n));//  Process any colliders
var r=this.colliders.update();for(e=0;e<r.length;e++){var o=r[e];o.active&&o.update()}this.emit(u.WORLD_STEP),this.stepsLastFrame++},/**
     * Updates bodies, draws the debug display, and handles pending queue operations.
     *
     * @method Phaser.Physics.Arcade.World#postUpdate
     * @since 3.0.0
     */postUpdate:function(){var t,e,i=this.bodies.entries,n=i.length,s=this.bodies,r=this.staticBodies;//  We don't need to postUpdate if there wasn't a step this frame
if(this.stepsLastFrame)for(t=0,this.stepsLastFrame=0;t<n;t++)(e=i[t]).enable&&e.postUpdate();if(this.drawDebug){var o=this.debugGraphic;for(o.clear(),t=0;t<n;t++)(e=i[t]).willDrawDebug()&&e.drawDebug(o);for(t=0,n=(i=r.entries).length;t<n;t++)(e=i[t]).willDrawDebug()&&e.drawDebug(o)}var h=this.pendingDestroy;if(h.size>0){var l=this.tree,u=this.staticTree;for(t=0,n=(i=h.entries).length;t<n;t++)(e=i[t]).physicsType===a.DYNAMIC_BODY?(l.remove(e),s.delete(e)):e.physicsType===a.STATIC_BODY&&(u.remove(e),r.delete(e)),e.world=void 0,e.gameObject=void 0;h.clear()}},/**
     * Calculates a Body's velocity and updates its position.
     *
     * @method Phaser.Physics.Arcade.World#updateMotion
     * @since 3.0.0
     *
     * @param {Phaser.Physics.Arcade.Body} body - The Body to be updated.
     * @param {number} delta - The delta value to be used in the motion calculations, in seconds.
     */updateMotion:function(t,e){t.allowRotation&&this.computeAngularVelocity(t,e),this.computeVelocity(t,e)},/**
     * Calculates a Body's angular velocity.
     *
     * @method Phaser.Physics.Arcade.World#computeAngularVelocity
     * @since 3.10.0
     *
     * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.
     * @param {number} delta - The delta value to be used in the calculation, in seconds.
     */computeAngularVelocity:function(t,e){var i=t.angularVelocity,s=t.angularAcceleration,r=t.angularDrag,o=t.maxAngular;s?i+=s*e:t.allowDrag&&r&&(d(i-(r*=e),0,.1)?i-=r:f(i+r,0,.1)?i+=r:i=0);var a=(i=n(i,-o,o))-t.angularVelocity;t.angularVelocity+=a,t.rotation+=t.angularVelocity*e},/**
     * Calculates a Body's per-axis velocity.
     *
     * @method Phaser.Physics.Arcade.World#computeVelocity
     * @since 3.0.0
     *
     * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.
     * @param {number} delta - The delta value to be used in the calculation, in seconds.
     */computeVelocity:function(t,e){var i=t.velocity.x,s=t.acceleration.x,r=t.drag.x,o=t.maxVelocity.x,a=t.velocity.y,h=t.acceleration.y,l=t.drag.y,u=t.maxVelocity.y,p=t.speed,g=t.maxSpeed,v=t.allowDrag,m=t.useDamping;t.allowGravity&&(i+=(this.gravity.x+t.gravity.x)*e,a+=(this.gravity.y+t.gravity.y)*e),s?i+=s*e:v&&r&&(m?(//  Damping based deceleration
i*=r,c(p=Math.sqrt(i*i+a*a),0,.001)&&(i=0)):d(i-//  Linear deceleration
(r*=e),0,.01)?i-=r:f(i+r,0,.01)?i+=r:i=0),h?a+=h*e:v&&l&&(m?(//  Damping based deceleration
a*=l,c(p=Math.sqrt(i*i+a*a),0,.001)&&(a=0)):d(a-//  Linear deceleration
(l*=e),0,.01)?a-=l:f(a+l,0,.01)?a+=l:a=0),i=n(i,-o,o),a=n(a,-u,u),t.velocity.set(i,a),g>-1&&p>g&&(t.velocity.normalize().scale(g),p=g),t.speed=p},/**
     * Separates two Bodies.
     *
     * @method Phaser.Physics.Arcade.World#separate
     * @fires Phaser.Physics.Arcade.Events#COLLIDE
     * @fires Phaser.Physics.Arcade.Events#OVERLAP
     * @since 3.0.0
     *
     * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.
     * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.
     * @param {ArcadePhysicsCallback} [processCallback] - The process callback.
     * @param {*} [callbackContext] - The context in which to invoke the callback.
     * @param {boolean} [overlapOnly] - If this a collide or overlap check?
     *
     * @return {boolean} True if separation occurred, otherwise false.
     */separate:function(t,e,i,n,s){if(!t.enable||!e.enable||t.checkCollision.none||e.checkCollision.none||!this.intersects(t,e)||i&&!1===i.call(n,t.gameObject,e.gameObject))return!1;//  Circle vs. Circle quick bail out
if(t.isCircle&&e.isCircle)return this.separateCircle(t,e,s);// We define the behavior of bodies in a collision circle and rectangle
// If a collision occurs in the corner points of the rectangle, the body behave like circles
//  Either body1 or body2 is a circle
if(t.isCircle!==e.isCircle){var r=t.isCircle?e:t,o=t.isCircle?t:e,a={x:r.x,y:r.y,right:r.right,bottom:r.bottom},h=o.center;if((h.y<a.y||h.y>a.bottom)&&(h.x<a.x||h.x>a.right))return this.separateCircle(t,e,s)}var l=!1,c=!1;this.forceX||Math.abs(this.gravity.y+t.gravity.y)<Math.abs(this.gravity.x+t.gravity.x)?(l=b(t,e,s,this.OVERLAP_BIAS),this.intersects(t,e)&&(c=S(t,e,s,this.OVERLAP_BIAS))):(c=S(t,e,s,this.OVERLAP_BIAS),this.intersects(t,e)&&(l=b(t,e,s,this.OVERLAP_BIAS)));var d=l||c;return d&&(s?(t.onOverlap||e.onOverlap)&&this.emit(u.OVERLAP,t.gameObject,e.gameObject,t,e):(t.onCollide||e.onCollide)&&this.emit(u.COLLIDE,t.gameObject,e.gameObject,t,e)),d},/**
     * Separates two Bodies, when both are circular.
     *
     * @method Phaser.Physics.Arcade.World#separateCircle
     * @fires Phaser.Physics.Arcade.Events#COLLIDE
     * @fires Phaser.Physics.Arcade.Events#OVERLAP
     * @since 3.0.0
     *
     * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.
     * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.
     * @param {boolean} [overlapOnly] - If this a collide or overlap check?
     * @param {number} [bias] - A small value added to the calculations.
     *
     * @return {boolean} True if separation occurred, otherwise false.
     */separateCircle:function(t,e,i,n){//  Set the bounding box overlap values into the bodies themselves (hence we don't use the return values here)
p(t,e,!1,n),g(t,e,!1,n);var s=0;if(t.isCircle!==e.isCircle){var r={x:e.isCircle?t.position.x:e.position.x,y:e.isCircle?t.position.y:e.position.y,right:e.isCircle?t.right:e.right,bottom:e.isCircle?t.bottom:e.bottom},o={x:t.isCircle?t.center.x:e.center.x,y:t.isCircle?t.center.y:e.center.y,radius:t.isCircle?t.halfWidth:e.halfWidth};o.y<r.y?o.x<r.x?s=h(o.x,o.y,r.x,r.y)-o.radius:o.x>r.right&&(s=h(o.x,o.y,r.right,r.y)-o.radius):o.y>r.bottom&&(o.x<r.x?s=h(o.x,o.y,r.x,r.bottom)-o.radius:o.x>r.right&&(s=h(o.x,o.y,r.right,r.bottom)-o.radius)),s*=-1}else s=t.halfWidth+e.halfWidth-h(t.center.x,t.center.y,e.center.x,e.center.y);//  Can't separate two immovable bodies, or a body with its own custom separation logic
if(i||0===s||t.immovable&&e.immovable||t.customSeparateX||e.customSeparateX)//  return true if there was some overlap, otherwise false
return 0!==s&&(t.onOverlap||e.onOverlap)&&this.emit(u.OVERLAP,t.gameObject,e.gameObject,t,e),0!==s;var a=Math.sqrt(Math.pow(t.center.x-e.center.x,2)+Math.pow(t.center.y-e.center.y,2)),l=(e.center.x-t.center.x)/a||0,c=(e.center.y-t.center.y)/a||0,d=2*(t.velocity.x*l+t.velocity.y*c-e.velocity.x*l-e.velocity.y*c)/(t.mass+e.mass);t.immovable||(t.velocity.x=t.velocity.x-d*t.mass*l,t.velocity.y=t.velocity.y-d*t.mass*c),e.immovable||(e.velocity.x=e.velocity.x+d*e.mass*l,e.velocity.y=e.velocity.y+d*e.mass*c);var f=e.velocity.x-t.velocity.x,v=Math.atan2(e.velocity.y-t.velocity.y,f),m=this._frameTime;return t.immovable||e.immovable||(s/=2),t.immovable||(t.x+=t.velocity.x*m-s*Math.cos(v),t.y+=t.velocity.y*m-s*Math.sin(v)),e.immovable||(e.x+=e.velocity.x*m+s*Math.cos(v),e.y+=e.velocity.y*m+s*Math.sin(v)),t.velocity.x*=t.bounce.x,t.velocity.y*=t.bounce.y,e.velocity.x*=e.bounce.x,e.velocity.y*=e.bounce.y,(t.onCollide||e.onCollide)&&this.emit(u.COLLIDE,t.gameObject,e.gameObject,t,e),!0},/**
     * Checks to see if two Bodies intersect at all.
     *
     * @method Phaser.Physics.Arcade.World#intersects
     * @since 3.0.0
     *
     * @param {Phaser.Physics.Arcade.Body} body1 - The first body to check.
     * @param {Phaser.Physics.Arcade.Body} body2 - The second body to check.
     *
     * @return {boolean} True if the two bodies intersect, otherwise false.
     */intersects:function(t,e){return t!==e&&(t.isCircle||e.isCircle?t.isCircle?e.isCircle?h(t.center.x,t.center.y,e.center.x,e.center.y)<=t.halfWidth+e.halfWidth:this.circleBodyIntersects(t,e):this.circleBodyIntersects(e,t):!(t.right<=e.position.x||t.bottom<=e.position.y||t.position.x>=e.right||t.position.y>=e.bottom))},/**
     * Tests if a circular Body intersects with another Body.
     *
     * @method Phaser.Physics.Arcade.World#circleBodyIntersects
     * @since 3.0.0
     *
     * @param {Phaser.Physics.Arcade.Body} circle - The circular body to test.
     * @param {Phaser.Physics.Arcade.Body} body - The rectangular body to test.
     *
     * @return {boolean} True if the two bodies intersect, otherwise false.
     */circleBodyIntersects:function(t,e){var i=n(t.center.x,e.left,e.right),s=n(t.center.y,e.top,e.bottom);return(t.center.x-i)*(t.center.x-i)+(t.center.y-s)*(t.center.y-s)<=t.halfWidth*t.halfWidth},/**
     * Tests if Game Objects overlap.
     *
     * See details in {@link Phaser.Physics.Arcade.World#collide}.
     *
     * @method Phaser.Physics.Arcade.World#overlap
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.
     * @param {ArcadePhysicsCallback} [overlapCallback] - An optional callback function that is called if the objects overlap.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `overlapCallback` will only be called if this callback returns `true`.
     * @param {*} [callbackContext] - The context in which to run the callbacks.
     *
     * @return {boolean} True if at least one Game Object overlaps another.
     *
     * @see Phaser.Physics.Arcade.World#collide
     */overlap:function(t,e,i,n,s){return void 0===i&&(i=null),void 0===n&&(n=null),void 0===s&&(s=i),this.collideObjects(t,e,i,n,s,!0)},/**
     * Performs a collision check and separation between the two physics enabled objects given, which can be single
     * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.
     *
     * If you don't require separation then use {@link Phaser.Physics.Arcade.World#overlap} instead.
     *
     * If two Groups or arrays are passed, each member of one will be tested against each member of the other.
     *
     * If **only** one Group is passed (as `object1`), each member of the Group will be collided against the other members.
     *
     * If **only** one Array is passed, the array is iterated and every element in it is tested against the others.
     *
     * Two callbacks can be provided; they receive the colliding game objects as arguments.
     * If an overlap is detected, the `processCallback` is called first. It can cancel the collision by returning false.
     * Next the objects are separated and `collideCallback` is invoked.
     *
     * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable
     * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.
     * The separation that stops two objects penetrating may create a new penetration against a different object. If you
     * require a high level of stability please consider using an alternative physics system, such as Matter.js.
     *
     * @method Phaser.Physics.Arcade.World#collide
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.
     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {any} [callbackContext] - The context in which to run the callbacks.
     *
     * @return {boolean} `true` if any overlapping Game Objects were separated, otherwise `false`.
     */collide:function(t,e,i,n,s){return void 0===i&&(i=null),void 0===n&&(n=null),void 0===s&&(s=i),this.collideObjects(t,e,i,n,s,!1)},/**
     * Internal helper function. Please use Phaser.Physics.Arcade.World#collide instead.
     *
     * @method Phaser.Physics.Arcade.World#collideObjects
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for collision.
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object to check for collision.
     * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.
     * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.
     * @param {any} callbackContext - The scope in which to call the callbacks.
     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.
     *
     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.
     */collideObjects:function(t,e,i,n,s,r){t.isParent&&void 0===t.physicsType&&(t=t.children.entries),e&&e.isParent&&void 0===e.physicsType&&(e=e.children.entries);var o,a,h=Array.isArray(t),l=Array.isArray(e);if(this._total=0,h||l){if(!h&&l)for(o=0;o<e.length;o++)this.collideHandler(t,e[o],i,n,s,r);else if(h&&!l){//  Object 1 is an Array
if(e)for(o=0;o<t.length;o++)this.collideHandler(t[o],e,i,n,s,r);else for(o=0;o<t.length;o++){var u=t[o];for(a=o+1;a<t.length;a++)o!==a&&this.collideHandler(u,t[a],i,n,s,r)}}else //  They're both arrays
for(o=0;o<t.length;o++)for(a=0;a<e.length;a++)this.collideHandler(t[o],e[a],i,n,s,r)}else this.collideHandler(t,e,i,n,s,r);return this._total>0},/**
     * Internal helper function. Please use Phaser.Physics.Arcade.World#collide and Phaser.Physics.Arcade.World#overlap instead.
     *
     * @method Phaser.Physics.Arcade.World#collideHandler
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.
     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object or array of objects to check, or `undefined`.
     * @param {ArcadePhysicsCallback} collideCallback - An optional callback function that is called if the objects collide.
     * @param {ArcadePhysicsCallback} processCallback - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {any} callbackContext - The context in which to run the callbacks.
     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.
     *
     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.
     */collideHandler:function(t,e,i,n,s,r){//  Collide Group with Self
//  Only collide valid objects
if(void 0===e&&t.isParent)return this.collideGroupVsGroup(t,t,i,n,s,r);//  If neither of the objects are set then bail out
if(!t||!e)return!1;//  A Body
if(t.body){if(e.body)return this.collideSpriteVsSprite(t,e,i,n,s,r);if(e.isParent)return this.collideSpriteVsGroup(t,e,i,n,s,r);if(e.isTilemap)return this.collideSpriteVsTilemapLayer(t,e,i,n,s,r)}else if(t.isParent){if(e.body)return this.collideSpriteVsGroup(e,t,i,n,s,r);if(e.isParent)return this.collideGroupVsGroup(t,e,i,n,s,r);if(e.isTilemap)return this.collideGroupVsTilemapLayer(t,e,i,n,s,r)}else if(t.isTilemap){if(e.body)return this.collideSpriteVsTilemapLayer(e,t,i,n,s,r);if(e.isParent)return this.collideGroupVsTilemapLayer(e,t,i,n,s,r)}},/**
     * Internal handler for Sprite vs. Sprite collisions.
     * Please use Phaser.Physics.Arcade.World#collide instead.
     *
     * @method Phaser.Physics.Arcade.World#collideSpriteVsSprite
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} sprite1 - The first object to check for collision.
     * @param {Phaser.GameObjects.GameObject} sprite2 - The second object to check for collision.
     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {any} [callbackContext] - The context in which to run the callbacks.
     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.
     *
     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.
     */collideSpriteVsSprite:function(t,e,i,n,s,r){return!!t.body&&!!e.body&&(this.separate(t.body,e.body,n,s,r)&&(i&&i.call(s,t,e),this._total++),!0)},/**
     * Internal handler for Sprite vs. Group collisions.
     * Please use Phaser.Physics.Arcade.World#collide instead.
     *
     * @method Phaser.Physics.Arcade.World#collideSpriteVsGroup
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.
     * @param {Phaser.GameObjects.Group} group - The second object to check for collision.
     * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.
     * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.
     * @param {any} callbackContext - The scope in which to call the callbacks.
     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.
     *
     * @return {boolean} `true` if the Sprite collided with the given Group, otherwise `false`.
     */collideSpriteVsGroup:function(t,e,i,n,s,r){var o,h,l,u=t.body;if(0!==e.length&&u&&u.enable&&!u.checkCollision.none){if(this.useTree){var c=this.treeMinMax;c.minX=u.left,c.minY=u.top,c.maxX=u.right,c.maxY=u.bottom;var d=e.physicsType===a.DYNAMIC_BODY?this.tree.search(c):this.staticTree.search(c);for(o=0,h=d.length;o<h;o++)u!==(l=d[o])&&l.enable&&!l.checkCollision.none&&e.contains(l.gameObject)&&this.separate(u,l,n,s,r)&&(i&&i.call(s,u.gameObject,l.gameObject),this._total++)}else{var f=e.getChildren(),p=e.children.entries.indexOf(t);for(o=0,h=f.length;o<h;o++)(l=f[o].body)&&o!==p&&l.enable&&this.separate(u,l,n,s,r)&&(i&&i.call(s,u.gameObject,l.gameObject),this._total++)}}},/**
     * Internal handler for Group vs. Tilemap collisions.
     * Please use Phaser.Physics.Arcade.World#collide instead.
     *
     * @method Phaser.Physics.Arcade.World#collideGroupVsTilemapLayer
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Group} group - The first object to check for collision.
     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The second object to check for collision.
     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {any} [callbackContext] - The context in which to run the callbacks.
     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.
     *
     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.
     */collideGroupVsTilemapLayer:function(t,e,i,n,s,r){var o=t.getChildren();if(0===o.length)return!1;for(var a=!1,h=0;h<o.length;h++)o[h].body&&this.collideSpriteVsTilemapLayer(o[h],e,i,n,s,r)&&(a=!0);return a},/**
     * This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects.
     *
     * You should generally use the `collide` method instead, with a Sprite vs. a Tilemap Layer, as that will perform
     * tile filtering and culling for you, as well as handle the interesting face collision automatically.
     *
     * This method is offered for those who would like to check for collision with specific Tiles in a layer, without
     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions
     * on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,
     * you should filter them before passing them to this method.
     *
     * Important: Use of this method skips the `interesting faces` system that Tilemap Layers use. This means if you have
     * say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the
     * tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on
     * dynamic maps, this method can prove very useful.
     *
     * @method Phaser.Physics.Arcade.World#collideTiles
     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE
     * @since 3.17.0
     *
     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.
     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.
     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {any} [callbackContext] - The context in which to run the callbacks.
     *
     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.
     */collideTiles:function(t,e,i,n,s){return!!t.body.enable&&0!==e.length&&this.collideSpriteVsTilesHandler(t,e,i,n,s,!1,!1)},/**
     * This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects.
     *
     * You should generally use the `overlap` method instead, with a Sprite vs. a Tilemap Layer, as that will perform
     * tile filtering and culling for you, as well as handle the interesting face collision automatically.
     *
     * This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without
     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap
     * tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,
     * you should filter them before passing them to this method.
     *
     * @method Phaser.Physics.Arcade.World#overlapTiles
     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP
     * @since 3.17.0
     *
     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.
     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.
     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects overlap.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {any} [callbackContext] - The context in which to run the callbacks.
     *
     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.
     */overlapTiles:function(t,e,i,n,s){return!!t.body.enable&&0!==e.length&&this.collideSpriteVsTilesHandler(t,e,i,n,s,!0,!1)},/**
     * Internal handler for Sprite vs. Tilemap collisions.
     * Please use Phaser.Physics.Arcade.World#collide instead.
     *
     * @method Phaser.Physics.Arcade.World#collideSpriteVsTilemapLayer
     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE
     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.
     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The second object to check for collision.
     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {any} [callbackContext] - The context in which to run the callbacks.
     * @param {boolean} [overlapOnly] - Whether this is a collision or overlap check.
     *
     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.
     */collideSpriteVsTilemapLayer:function(t,e,i,n,s,r){var o=t.body;if(!o.enable||o.checkCollision.none)return!1;var a=o.position.x,h=o.position.y,l=o.width,u=o.height,c=e.layer;if(c.tileWidth>c.baseTileWidth){// The x origin of a tile is the left side, so x and width need to be adjusted.
var d=(c.tileWidth-c.baseTileWidth)*e.scaleX;a-=d,l+=d}c.tileHeight>c.baseTileHeight&&(u+=(c.tileHeight-c.baseTileHeight)*e.scaleY);var f=e.getTilesWithinWorldXY(a,h,l,u);return 0!==f.length&&this.collideSpriteVsTilesHandler(t,f,i,n,s,r,!0)},/**
     * Internal handler for Sprite vs. Tilemap collisions.
     * Please use Phaser.Physics.Arcade.World#collide instead.
     *
     * @method Phaser.Physics.Arcade.World#collideSpriteVsTilesHandler
     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE
     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP
     * @private
     * @since 3.17.0
     *
     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.
     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The second object to check for collision.
     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {any} [callbackContext] - The context in which to run the callbacks.
     * @param {boolean} [overlapOnly] - Whether this is a collision or overlap check.
     * @param {boolean} [isLayer] - Is this check coming from a TilemapLayer or an array of tiles?
     *
     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.
     */collideSpriteVsTilesHandler:function(t,e,i,n,s,r,o){for(var a,h,l=t.body,c={left:0,right:0,top:0,bottom:0},d=!1,f=0;f<e.length;f++)h=(a=e[f]).tilemapLayer,c.left=h.tileToWorldX(a.x),c.top=h.tileToWorldY(a.y),a.baseHeight!==a.height&&(c.top-=(a.height-a.baseHeight)*h.scaleY),c.right=c.left+a.width*h.scaleX,c.bottom=c.top+a.height*h.scaleY,_(c,l)&&(!n||n.call(s,t,a))&&y(a,t)&&(r||T(f,l,a,c,h,this.TILE_BIAS,o))&&(this._total++,d=!0,i&&i.call(s,t,a),r&&l.onOverlap?this.emit(u.TILE_OVERLAP,t,a,l):l.onCollide&&this.emit(u.TILE_COLLIDE,t,a,l));return d},/**
     * Internal helper for Group vs. Group collisions.
     * Please use Phaser.Physics.Arcade.World#collide instead.
     *
     * @method Phaser.Physics.Arcade.World#collideGroupVsGroup
     * @private
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Group} group1 - The first object to check for collision.
     * @param {Phaser.GameObjects.Group} group2 - The second object to check for collision.
     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.
     * @param {any} [callbackContext] - The context in which to run the callbacks.
     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.
     *
     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.
     */collideGroupVsGroup:function(t,e,i,n,s,r){if(0!==t.length&&0!==e.length)for(var o=t.getChildren(),a=0;a<o.length;a++)this.collideSpriteVsGroup(o[a],e,i,n,s,r)},/**
     * Wrap an object's coordinates (or several objects' coordinates) within {@link Phaser.Physics.Arcade.World#bounds}.
     *
     * If the object is outside any boundary edge (left, top, right, bottom), it will be moved to the same offset from the opposite edge (the interior).
     *
     * @method Phaser.Physics.Arcade.World#wrap
     * @since 3.3.0
     *
     * @param {*} object - A Game Object, a Group, an object with `x` and `y` coordinates, or an array of such objects.
     * @param {number} [padding=0] - An amount added to each boundary edge during the operation.
     */wrap:function(t,e){t.body?this.wrapObject(t,e):t.getChildren?this.wrapArray(t.getChildren(),e):Array.isArray(t)?this.wrapArray(t,e):this.wrapObject(t,e)},/**
     * Wrap each object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.
     *
     * @method Phaser.Physics.Arcade.World#wrapArray
     * @since 3.3.0
     *
     * @param {Array.<*>} objects - An array of objects to be wrapped.
     * @param {number} [padding=0] - An amount added to the boundary.
     */wrapArray:function(t,e){for(var i=0;i<t.length;i++)this.wrapObject(t[i],e)},/**
     * Wrap an object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.
     *
     * @method Phaser.Physics.Arcade.World#wrapObject
     * @since 3.3.0
     *
     * @param {*} object - A Game Object, a Physics Body, or any object with `x` and `y` coordinates
     * @param {number} [padding=0] - An amount added to the boundary.
     */wrapObject:function(t,e){void 0===e&&(e=0),t.x=P(t.x,this.bounds.left-e,this.bounds.right+e),t.y=P(t.y,this.bounds.top-e,this.bounds.bottom+e)},/**
     * Shuts down the simulation, clearing physics data and removing listeners.
     *
     * @method Phaser.Physics.Arcade.World#shutdown
     * @since 3.0.0
     */shutdown:function(){this.tree.clear(),this.staticTree.clear(),this.bodies.clear(),this.staticBodies.clear(),this.colliders.destroy(),this.removeAllListeners()},/**
     * Shuts down the simulation and disconnects it from the current scene.
     *
     * @method Phaser.Physics.Arcade.World#destroy
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.scene=null}});t.exports=O}),r("eJKdR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Benjamin D. Richards <benjamindrichards@gmail.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("ilZSx"),r=s("cPwjQ"),o=s("dcSyA"),a=s("cwr8X"),h=s("6pEze"),l=s("7SBSk"),u=new i({initialize:function(t,e){var i=e.displayWidth?e.displayWidth:64,s=e.displayHeight?e.displayHeight:64;/**
         * The Arcade Physics simulation this Body belongs to.
         *
         * @name Phaser.Physics.Arcade.Body#world
         * @type {Phaser.Physics.Arcade.World}
         * @since 3.0.0
         */this.world=t,/**
         * The Game Object this Body belongs to.
         *
         * @name Phaser.Physics.Arcade.Body#gameObject
         * @type {Phaser.GameObjects.GameObject}
         * @since 3.0.0
         */this.gameObject=e,/**
         * Transformations applied to this Body.
         *
         * @name Phaser.Physics.Arcade.Body#transform
         * @type {object}
         * @since 3.4.0
         */this.transform={x:e.x,y:e.y,rotation:e.angle,scaleX:e.scaleX,scaleY:e.scaleY,displayOriginX:e.displayOriginX,displayOriginY:e.displayOriginY},/**
         * Whether the Body's boundary is drawn to the debug display.
         *
         * @name Phaser.Physics.Arcade.Body#debugShowBody
         * @type {boolean}
         * @since 3.0.0
         */this.debugShowBody=t.defaults.debugShowBody,/**
         * Whether the Body's velocity is drawn to the debug display.
         *
         * @name Phaser.Physics.Arcade.Body#debugShowVelocity
         * @type {boolean}
         * @since 3.0.0
         */this.debugShowVelocity=t.defaults.debugShowVelocity,/**
         * The color of this Body on the debug display.
         *
         * @name Phaser.Physics.Arcade.Body#debugBodyColor
         * @type {integer}
         * @since 3.0.0
         */this.debugBodyColor=t.defaults.bodyDebugColor,/**
         * Whether this Body is updated by the physics simulation.
         *
         * @name Phaser.Physics.Arcade.Body#enable
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.enable=!0,/**
         * Whether this Body's boundary is circular (true) or rectangular (false).
         *
         * @name Phaser.Physics.Arcade.Body#isCircle
         * @type {boolean}
         * @default false
         * @since 3.0.0
         * @see Phaser.Physics.Arcade.Body#setCircle
         */this.isCircle=!1,/**
         * If this Body is circular, this is the unscaled radius of the Body's boundary, as set by setCircle(), in source pixels.
         * The true radius is equal to `halfWidth`.
         *
         * @name Phaser.Physics.Arcade.Body#radius
         * @type {number}
         * @default 0
         * @since 3.0.0
         * @see Phaser.Physics.Arcade.Body#setCircle
         */this.radius=0,/**
         * The offset of this Body's position from its Game Object's position, in source pixels.
         *
         * @name Phaser.Physics.Arcade.Body#offset
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         * @see Phaser.Physics.Arcade.Body#setOffset
         */this.offset=new l,/**
         * The position of this Body within the simulation.
         *
         * @name Phaser.Physics.Arcade.Body#position
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.position=new l(e.x-e.scaleX*e.displayOriginX,e.y-e.scaleY*e.displayOriginY),/**
         * The position of this Body during the previous step.
         *
         * @name Phaser.Physics.Arcade.Body#prev
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.prev=new l(e.x,e.y),/**
         * The position of this Body during the previous frame.
         *
         * @name Phaser.Physics.Arcade.Body#prevFrame
         * @type {Phaser.Math.Vector2}
         * @since 3.20.0
         */this.prevFrame=new l(e.x,e.y),/**
         * Whether this Body's `rotation` is affected by its angular acceleration and angular velocity.
         *
         * @name Phaser.Physics.Arcade.Body#allowRotation
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.allowRotation=!0,/**
         * This body's rotation, in degrees, based on its angular acceleration and angular velocity.
         * The Body's rotation controls the `angle` of its Game Object.
         * It doesn't rotate the Body's boundary, which is always an axis-aligned rectangle or a circle.
         *
         * @name Phaser.Physics.Arcade.Body#rotation
         * @type {number}
         * @since 3.0.0
         */this.rotation=e.angle,/**
         * The Body rotation, in degrees, during the previous step.
         *
         * @name Phaser.Physics.Arcade.Body#preRotation
         * @type {number}
         * @since 3.0.0
         */this.preRotation=e.angle,/**
         * The width of the Body boundary, in pixels.
         * If the Body is circular, this is also the diameter.
         * If you wish to change the width use the `Body.setSize` method.
         *
         * @name Phaser.Physics.Arcade.Body#width
         * @type {number}
         * @readonly
         * @default 64
         * @since 3.0.0
         */this.width=i,/**
         * The height of the Body boundary, in pixels.
         * If the Body is circular, this is also the diameter.
         * If you wish to change the height use the `Body.setSize` method.
         *
         * @name Phaser.Physics.Arcade.Body#height
         * @type {number}
         * @readonly
         * @default 64
         * @since 3.0.0
         */this.height=s,/**
         * The unscaled width of the Body, in source pixels, as set by setSize().
         * The default is the width of the Body's Game Object's texture frame.
         *
         * @name Phaser.Physics.Arcade.Body#sourceWidth
         * @type {number}
         * @since 3.0.0
         * @see Phaser.Physics.Arcade.Body#setSize
         */this.sourceWidth=i,/**
         * The unscaled height of the Body, in source pixels, as set by setSize().
         * The default is the height of the Body's Game Object's texture frame.
         *
         * @name Phaser.Physics.Arcade.Body#sourceHeight
         * @type {number}
         * @since 3.0.0
         * @see Phaser.Physics.Arcade.Body#setSize
         */this.sourceHeight=s,e.frame&&(this.sourceWidth=e.frame.realWidth,this.sourceHeight=e.frame.realHeight),/**
         * Half the Body's width, in pixels.
         *
         * @name Phaser.Physics.Arcade.Body#halfWidth
         * @type {number}
         * @since 3.0.0
         */this.halfWidth=Math.abs(i/2),/**
         * Half the Body's height, in pixels.
         *
         * @name Phaser.Physics.Arcade.Body#halfHeight
         * @type {number}
         * @since 3.0.0
         */this.halfHeight=Math.abs(s/2),/**
         * The center of the Body's boundary.
         * The midpoint of its `position` (top-left corner) and its bottom-right corner.
         *
         * @name Phaser.Physics.Arcade.Body#center
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.center=new l(this.position.x+this.halfWidth,this.position.y+this.halfHeight),/**
         * The Body's velocity, in pixels per second.
         *
         * @name Phaser.Physics.Arcade.Body#velocity
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.velocity=new l,/**
         * The Body's change in position (due to velocity) at the last step, in pixels.
         *
         * The size of this value depends on the simulation's step rate.
         *
         * @name Phaser.Physics.Arcade.Body#newVelocity
         * @type {Phaser.Math.Vector2}
         * @readonly
         * @since 3.0.0
         */this.newVelocity=new l,/**
         * The Body's absolute maximum change in position, in pixels per step.
         *
         * @name Phaser.Physics.Arcade.Body#deltaMax
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.deltaMax=new l,/**
         * The Body's change in velocity, in pixels per second squared.
         *
         * @name Phaser.Physics.Arcade.Body#acceleration
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.acceleration=new l,/**
         * Whether this Body's velocity is affected by its `drag`.
         *
         * @name Phaser.Physics.Arcade.Body#allowDrag
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.allowDrag=!0,/**
         * When `useDamping` is false (the default), this is absolute loss of velocity due to movement, in pixels per second squared (a vector).
         * The x and y components are applied separately.
         *
         * When `useDamping` is true, this is 1 minus the damping factor (a number).
         * A value of 1 means the Body loses no velocity.
         * A value of 0.95 means the Body loses 5% of its velocity per step.
         * A value of 0.5 means the Body loses 50% of its velocity per step.
         *
         * Drag is applied only when `acceleration` is zero.
         *
         * @name Phaser.Physics.Arcade.Body#drag
         * @type {(Phaser.Math.Vector2|number)}
         * @since 3.0.0
         */this.drag=new l,/**
         * Whether this Body's position is affected by gravity (local or world).
         *
         * @name Phaser.Physics.Arcade.Body#allowGravity
         * @type {boolean}
         * @default true
         * @since 3.0.0
         * @see Phaser.Physics.Arcade.Body#gravity
         * @see Phaser.Physics.Arcade.World#gravity
         */this.allowGravity=!0,/**
         * Acceleration due to gravity (specific to this Body), in pixels per second squared.
         * Total gravity is the sum of this vector and the simulation's `gravity`.
         *
         * @name Phaser.Physics.Arcade.Body#gravity
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         * @see Phaser.Physics.Arcade.World#gravity
         */this.gravity=new l,/**
         * Rebound following a collision, relative to 1.
         *
         * @name Phaser.Physics.Arcade.Body#bounce
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.bounce=new l,/**
         * Rebound following a collision with the world boundary, relative to 1.
         * If null, `bounce` is used instead.
         *
         * @name Phaser.Physics.Arcade.Body#worldBounce
         * @type {?Phaser.Math.Vector2}
         * @default null
         * @since 3.0.0
         */this.worldBounce=null,/**
         * The rectangle used for world boundary collisions.
         *
         * By default it is set to the world boundary rectangle. Or, if this Body was
         * created by a Physics Group, then whatever rectangle that Group defined.
         *
         * You can also change it by using the `Body.setBoundsRectangle` method.
         *
         * @name Phaser.Physics.Arcade.Body#customBoundsRectangle
         * @type {?Phaser.Geom.Rectangle}
         * @since 3.20
         */this.customBoundsRectangle=t.bounds,//  If true this Body will dispatch events
/**
         * Whether the simulation emits a `worldbounds` event when this Body collides with the world boundary (and `collideWorldBounds` is also true).
         *
         * @name Phaser.Physics.Arcade.Body#onWorldBounds
         * @type {boolean}
         * @default false
         * @since 3.0.0
         * @see Phaser.Physics.Arcade.World#WORLD_BOUNDS
         */this.onWorldBounds=!1,/**
         * Whether the simulation emits a `collide` event when this Body collides with another.
         *
         * @name Phaser.Physics.Arcade.Body#onCollide
         * @type {boolean}
         * @default false
         * @since 3.0.0
         * @see Phaser.Physics.Arcade.World#COLLIDE
         */this.onCollide=!1,/**
         * Whether the simulation emits an `overlap` event when this Body overlaps with another.
         *
         * @name Phaser.Physics.Arcade.Body#onOverlap
         * @type {boolean}
         * @default false
         * @since 3.0.0
         * @see Phaser.Physics.Arcade.World#OVERLAP
         */this.onOverlap=!1,/**
         * The Body's absolute maximum velocity, in pixels per second.
         * The horizontal and vertical components are applied separately.
         *
         * @name Phaser.Physics.Arcade.Body#maxVelocity
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.maxVelocity=new l(1e4,1e4),/**
         * The maximum speed this Body is allowed to reach, in pixels per second.
         *
         * If not negative it limits the scalar value of speed.
         *
         * Any negative value means no maximum is being applied (the default).
         *
         * @name Phaser.Physics.Arcade.Body#maxSpeed
         * @type {number}
         * @default -1
         * @since 3.16.0
         */this.maxSpeed=-1,/**
         * If this Body is `immovable` and in motion, `friction` is the proportion of this Body's motion received by the riding Body on each axis, relative to 1.
         * The horizontal component (x) is applied only when two colliding Bodies are separated vertically.
         * The vertical component (y) is applied only when two colliding Bodies are separated horizontally.
         * The default value (1, 0) moves the riding Body horizontally in equal proportion to this Body and vertically not at all.
         *
         * @name Phaser.Physics.Arcade.Body#friction
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.friction=new l(1,0),/**
         * If this Body is using `drag` for deceleration this property controls how the drag is applied.
         * If set to `true` drag will use a damping effect rather than a linear approach. If you are
         * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in
         * the game Asteroids) then you will get a far smoother and more visually correct deceleration
         * by using damping, avoiding the axis-drift that is prone with linear deceleration.
         *
         * If you enable this property then you should use far smaller `drag` values than with linear, as
         * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow
         * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.
         *
         * @name Phaser.Physics.Arcade.Body#useDamping
         * @type {boolean}
         * @default false
         * @since 3.10.0
         */this.useDamping=!1,/**
         * The rate of change of this Body's `rotation`, in degrees per second.
         *
         * @name Phaser.Physics.Arcade.Body#angularVelocity
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.angularVelocity=0,/**
         * The Body's angular acceleration (change in angular velocity), in degrees per second squared.
         *
         * @name Phaser.Physics.Arcade.Body#angularAcceleration
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.angularAcceleration=0,/**
         * Loss of angular velocity due to angular movement, in degrees per second.
         *
         * Angular drag is applied only when angular acceleration is zero.
         *
         * @name Phaser.Physics.Arcade.Body#angularDrag
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.angularDrag=0,/**
         * The Body's maximum angular velocity, in degrees per second.
         *
         * @name Phaser.Physics.Arcade.Body#maxAngular
         * @type {number}
         * @default 1000
         * @since 3.0.0
         */this.maxAngular=1e3,/**
         * The Body's inertia, relative to a default unit (1).
         * With `bounce`, this affects the exchange of momentum (velocities) during collisions.
         *
         * @name Phaser.Physics.Arcade.Body#mass
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.mass=1,/**
         * The calculated angle of this Body's velocity vector, in radians, during the last step.
         *
         * @name Phaser.Physics.Arcade.Body#angle
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.angle=0,/**
         * The calculated magnitude of the Body's velocity, in pixels per second, during the last step.
         *
         * @name Phaser.Physics.Arcade.Body#speed
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.speed=0,/**
         * The direction of the Body's velocity, as calculated during the last step.
         * If the Body is moving on both axes (diagonally), this describes motion on the vertical axis only.
         *
         * @name Phaser.Physics.Arcade.Body#facing
         * @type {integer}
         * @since 3.0.0
         */this.facing=n.FACING_NONE,/**
         * Whether this Body can be moved by collisions with another Body.
         *
         * @name Phaser.Physics.Arcade.Body#immovable
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.immovable=!1,/**
         * Whether the Body's position and rotation are affected by its velocity, acceleration, drag, and gravity.
         *
         * @name Phaser.Physics.Arcade.Body#moves
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.moves=!0,/**
         * A flag disabling the default horizontal separation of colliding bodies.
         * Pass your own `collideCallback` to the collider.
         *
         * @name Phaser.Physics.Arcade.Body#customSeparateX
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.customSeparateX=!1,/**
         * A flag disabling the default vertical separation of colliding bodies.
         * Pass your own `collideCallback` to the collider.
         *
         * @name Phaser.Physics.Arcade.Body#customSeparateY
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.customSeparateY=!1,/**
         * The amount of horizontal overlap (before separation), if this Body is colliding with another.
         *
         * @name Phaser.Physics.Arcade.Body#overlapX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.overlapX=0,/**
         * The amount of vertical overlap (before separation), if this Body is colliding with another.
         *
         * @name Phaser.Physics.Arcade.Body#overlapY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.overlapY=0,/**
         * The amount of overlap (before separation), if this Body is circular and colliding with another circular body.
         *
         * @name Phaser.Physics.Arcade.Body#overlapR
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.overlapR=0,/**
         * Whether this Body is overlapped with another and both are not moving, on at least one axis.
         *
         * @name Phaser.Physics.Arcade.Body#embedded
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.embedded=!1,/**
         * Whether this Body interacts with the world boundary.
         *
         * @name Phaser.Physics.Arcade.Body#collideWorldBounds
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.collideWorldBounds=!1,/**
         * Whether this Body is checked for collisions and for which directions.
         * You can set `checkCollision.none = true` to disable collision checks.
         *
         * @name Phaser.Physics.Arcade.Body#checkCollision
         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}
         * @since 3.0.0
         */this.checkCollision={none:!1,up:!0,down:!0,left:!0,right:!0},/**
         * Whether this Body is colliding with a Body or Static Body and in which direction.
         * In a collision where both bodies have zero velocity, `embedded` will be set instead.
         *
         * @name Phaser.Physics.Arcade.Body#touching
         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}
         * @since 3.0.0
         *
         * @see Phaser.Physics.Arcade.Body#blocked
         * @see Phaser.Physics.Arcade.Body#embedded
         */this.touching={none:!0,up:!1,down:!1,left:!1,right:!1},/**
         * This Body's `touching` value during the previous step.
         *
         * @name Phaser.Physics.Arcade.Body#wasTouching
         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}
         * @since 3.0.0
         *
         * @see Phaser.Physics.Arcade.Body#touching
         */this.wasTouching={none:!0,up:!1,down:!1,left:!1,right:!1},/**
         * Whether this Body is colliding with a Static Body, a tile, or the world boundary.
         * In a collision with a Static Body, if this Body has zero velocity then `embedded` will be set instead.
         *
         * @name Phaser.Physics.Arcade.Body#blocked
         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}
         * @since 3.0.0
         *
         * @see Phaser.Physics.Arcade.Body#embedded
         * @see Phaser.Physics.Arcade.Body#touching
         */this.blocked={none:!0,up:!1,down:!1,left:!1,right:!1},/**
         * Whether to automatically synchronize this Body's dimensions to the dimensions of its Game Object's visual bounds.
         *
         * @name Phaser.Physics.Arcade.Body#syncBounds
         * @type {boolean}
         * @default false
         * @since 3.0.0
         * @see Phaser.GameObjects.Components.GetBounds#getBounds
         */this.syncBounds=!1,/**
         * The Body's physics type (dynamic or static).
         *
         * @name Phaser.Physics.Arcade.Body#physicsType
         * @type {integer}
         * @readonly
         * @default Phaser.Physics.Arcade.DYNAMIC_BODY
         * @since 3.0.0
         */this.physicsType=n.DYNAMIC_BODY,/**
         * Cached horizontal scale of the Body's Game Object.
         *
         * @name Phaser.Physics.Arcade.Body#_sx
         * @type {number}
         * @private
         * @since 3.0.0
         */this._sx=e.scaleX,/**
         * Cached vertical scale of the Body's Game Object.
         *
         * @name Phaser.Physics.Arcade.Body#_sy
         * @type {number}
         * @private
         * @since 3.0.0
         */this._sy=e.scaleY,/**
         * The calculated change in the Body's horizontal position during the last step.
         *
         * @name Phaser.Physics.Arcade.Body#_dx
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._dx=0,/**
         * The calculated change in the Body's vertical position during the last step.
         *
         * @name Phaser.Physics.Arcade.Body#_dy
         * @type {number}
         * @private
         * @default 0
         * @since 3.0.0
         */this._dy=0,/**
         * The final calculated change in the Body's horizontal position as of `postUpdate`.
         *
         * @name Phaser.Physics.Arcade.Body#_tx
         * @type {number}
         * @private
         * @default 0
         * @since 3.22.0
         */this._tx=0,/**
         * The final calculated change in the Body's vertical position as of `postUpdate`.
         *
         * @name Phaser.Physics.Arcade.Body#_ty
         * @type {number}
         * @private
         * @default 0
         * @since 3.22.0
         */this._ty=0,/**
         * Stores the Game Object's bounds.
         *
         * @name Phaser.Physics.Arcade.Body#_bounds
         * @type {Phaser.Geom.Rectangle}
         * @private
         * @since 3.0.0
         */this._bounds=new a},/**
     * Updates the Body's `transform`, `width`, `height`, and `center` from its Game Object.
     * The Body's `position` isn't changed.
     *
     * @method Phaser.Physics.Arcade.Body#updateBounds
     * @since 3.0.0
     */updateBounds:function(){var t=this.gameObject,e=this.transform;if(t.parentContainer){var i=t.getWorldTransformMatrix(this.world._tempMatrix,this.world._tempMatrix2);e.x=i.tx,e.y=i.ty,e.rotation=o(i.rotation),e.scaleX=i.scaleX,e.scaleY=i.scaleY,e.displayOriginX=t.displayOriginX,e.displayOriginY=t.displayOriginY}else e.x=t.x,e.y=t.y,e.rotation=t.angle,e.scaleX=t.scaleX,e.scaleY=t.scaleY,e.displayOriginX=t.displayOriginX,e.displayOriginY=t.displayOriginY;var n=!1;if(this.syncBounds){var s=t.getBounds(this._bounds);this.width=s.width,this.height=s.height,n=!0}else{var r=Math.abs(e.scaleX),a=Math.abs(e.scaleY);(this._sx!==r||this._sy!==a)&&(this.width=this.sourceWidth*r,this.height=this.sourceHeight*a,this._sx=r,this._sy=a,n=!0)}n&&(this.halfWidth=Math.floor(this.width/2),this.halfHeight=Math.floor(this.height/2),this.updateCenter())},/**
     * Updates the Body's `center` from its `position`, `width`, and `height`.
     *
     * @method Phaser.Physics.Arcade.Body#updateCenter
     * @since 3.0.0
     */updateCenter:function(){this.center.set(this.position.x+this.halfWidth,this.position.y+this.halfHeight)},/**
     * Prepares the Body for a physics step by resetting the `wasTouching`, `touching` and `blocked` states.
     *
     * This method is only called if the physics world is going to run a step this frame.
     *
     * @method Phaser.Physics.Arcade.Body#resetFlags
     * @since 3.18.0
     */resetFlags:function(){//  Store and reset collision flags
var t=this.wasTouching,e=this.touching,i=this.blocked;t.none=e.none,t.up=e.up,t.down=e.down,t.left=e.left,t.right=e.right,e.none=!0,e.up=!1,e.down=!1,e.left=!1,e.right=!1,i.none=!0,i.up=!1,i.down=!1,i.left=!1,i.right=!1,this.overlapR=0,this.overlapX=0,this.overlapY=0,this.embedded=!1},/**
     * Syncs the position body position with the parent Game Object.
     *
     * This method is called every game frame, regardless if the world steps or not.
     *
     * @method Phaser.Physics.Arcade.Body#preUpdate
     * @since 3.17.0
     *
     * @param {boolean} willStep - Will this Body run an update as well?
     * @param {number} delta - The delta time, in seconds, elapsed since the last frame.
     */preUpdate:function(t,e){t&&this.resetFlags(),this.updateBounds();var i=this.transform;this.position.x=i.x+i.scaleX*(this.offset.x-i.displayOriginX),this.position.y=i.y+i.scaleY*(this.offset.y-i.displayOriginY),this.updateCenter(),this.rotation=i.rotation,this.preRotation=this.rotation,this.moves&&(this.prev.x=this.position.x,this.prev.y=this.position.y,this.prevFrame.x=this.position.x,this.prevFrame.y=this.position.y),t&&this.update(e)},/**
     * Performs a single physics step and updates the body velocity, angle, speed and other properties.
     *
     * This method can be called multiple times per game frame, depending on the physics step rate.
     *
     * The results are synced back to the Game Object in `postUpdate`.
     *
     * @method Phaser.Physics.Arcade.Body#update
     * @fires Phaser.Physics.Arcade.Events#WORLD_BOUNDS
     * @since 3.0.0
     *
     * @param {number} delta - The delta time, in seconds, elapsed since the last frame.
     */update:function(t){if(this.prev.x=this.position.x,this.prev.y=this.position.y,this.moves){this.world.updateMotion(this,t);var e=this.velocity.x,i=this.velocity.y;this.newVelocity.set(e*t,i*t),this.position.add(this.newVelocity),this.updateCenter(),this.angle=Math.atan2(i,e),this.speed=Math.sqrt(e*e+i*i),this.collideWorldBounds&&this.checkWorldBounds()&&this.onWorldBounds&&this.world.emit(r.WORLD_BOUNDS,this,this.blocked.up,this.blocked.down,this.blocked.left,this.blocked.right)}this._dx=this.position.x-this.prev.x,this._dy=this.position.y-this.prev.y},/**
     * Feeds the Body results back into the parent Game Object.
     *
     * This method is called every game frame, regardless if the world steps or not.
     *
     * @method Phaser.Physics.Arcade.Body#postUpdate
     * @since 3.0.0
     */postUpdate:function(){var t=this.position.x-this.prevFrame.x,e=this.position.y-this.prevFrame.y;if(this.moves){var i=this.deltaMax.x,s=this.deltaMax.y;0!==i&&0!==t&&(t<0&&t<-i?t=-i:t>0&&t>i&&(t=i)),0!==s&&0!==e&&(e<0&&e<-s?e=-s:e>0&&e>s&&(e=s)),this.gameObject.x+=t,this.gameObject.y+=e}t<0?this.facing=n.FACING_LEFT:t>0&&(this.facing=n.FACING_RIGHT),e<0?this.facing=n.FACING_UP:e>0&&(this.facing=n.FACING_DOWN),this.allowRotation&&(this.gameObject.angle+=this.deltaZ()),this._tx=t,this._ty=e},/**
     * Sets a custom collision boundary rectangle. Use if you want to have a custom
     * boundary instead of the world boundaries.
     *
     * @method Phaser.Physics.Arcade.Body#setBoundsRectangle
     * @since 3.20
     *
     * @param {?Phaser.Geom.Rectangle} [bounds] - The new boundary rectangle. Pass `null` to use the World bounds.
     *
     * @return {this} This Body object.
     */setBoundsRectangle:function(t){return this.customBoundsRectangle=t||this.world.bounds,this},/**
     * Checks for collisions between this Body and the world boundary and separates them.
     *
     * @method Phaser.Physics.Arcade.Body#checkWorldBounds
     * @since 3.0.0
     *
     * @return {boolean} True if this Body is colliding with the world boundary.
     */checkWorldBounds:function(){var t=this.position,e=this.customBoundsRectangle,i=this.world.checkCollision,n=this.worldBounce?-this.worldBounce.x:-this.bounce.x,s=this.worldBounce?-this.worldBounce.y:-this.bounce.y,r=!1;return t.x<e.x&&i.left?(t.x=e.x,this.velocity.x*=n,this.blocked.left=!0,r=!0):this.right>e.right&&i.right&&(t.x=e.right-this.width,this.velocity.x*=n,this.blocked.right=!0,r=!0),t.y<e.y&&i.up?(t.y=e.y,this.velocity.y*=s,this.blocked.up=!0,r=!0):this.bottom>e.bottom&&i.down&&(t.y=e.bottom-this.height,this.velocity.y*=s,this.blocked.down=!0,r=!0),r&&(this.blocked.none=!1),r},/**
     * Sets the offset of the Body's position from its Game Object's position.
     *
     * @method Phaser.Physics.Arcade.Body#setOffset
     * @since 3.0.0
     *
     * @param {number} x - The horizontal offset, in source pixels.
     * @param {number} [y=x] - The vertical offset, in source pixels.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setOffset:function(t,e){return void 0===e&&(e=t),this.offset.set(t,e),this.updateCenter(),this},/**
     * Sizes and positions this Body's boundary, as a rectangle.
     * Modifies the Body `offset` if `center` is true (the default).
     * Resets the width and height to match current frame, if no width and height provided and a frame is found.
     *
     * @method Phaser.Physics.Arcade.Body#setSize
     * @since 3.0.0
     *
     * @param {integer} [width] - The width of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.
     * @param {integer} [height] - The height of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.
     * @param {boolean} [center=true] - Modify the Body's `offset`, placing the Body's center on its Game Object's center. Only works if the Game Object has the `getCenter` method.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setSize:function(t,e,i){void 0===i&&(i=!0);var n=this.gameObject;if(!t&&n.frame&&(t=n.frame.realWidth),!e&&n.frame&&(e=n.frame.realHeight),this.sourceWidth=t,this.sourceHeight=e,this.width=this.sourceWidth*this._sx,this.height=this.sourceHeight*this._sy,this.halfWidth=Math.floor(this.width/2),this.halfHeight=Math.floor(this.height/2),this.updateCenter(),i&&n.getCenter){var s=(n.width-t)/2,r=(n.height-e)/2;this.offset.set(s,r)}return this.isCircle=!1,this.radius=0,this},/**
     * Sizes and positions this Body's boundary, as a circle.
     *
     * @method Phaser.Physics.Arcade.Body#setCircle
     * @since 3.0.0
     *
     * @param {number} radius - The radius of the Body, in source pixels.
     * @param {number} [offsetX] - The horizontal offset of the Body from its Game Object, in source pixels.
     * @param {number} [offsetY] - The vertical offset of the Body from its Game Object, in source pixels.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setCircle:function(t,e,i){return void 0===e&&(e=this.offset.x),void 0===i&&(i=this.offset.y),t>0?(this.isCircle=!0,this.radius=t,this.sourceWidth=2*t,this.sourceHeight=2*t,this.width=this.sourceWidth*this._sx,this.height=this.sourceHeight*this._sy,this.halfWidth=Math.floor(this.width/2),this.halfHeight=Math.floor(this.height/2),this.offset.set(e,i),this.updateCenter()):this.isCircle=!1,this},/**
     * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.
     * If the Body had any velocity or acceleration it is lost as a result of calling this.
     *
     * @method Phaser.Physics.Arcade.Body#reset
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position to place the Game Object and Body.
     * @param {number} y - The vertical position to place the Game Object and Body.
     */reset:function(t,e){this.stop();var i=this.gameObject;i.setPosition(t,e),i.getTopLeft?i.getTopLeft(this.position):this.position.set(t,e),this.prev.copy(this.position),this.prevFrame.copy(this.position),this.rotation=i.angle,this.preRotation=i.angle,this.updateBounds(),this.updateCenter()},/**
     * Sets acceleration, velocity, and speed to zero.
     *
     * @method Phaser.Physics.Arcade.Body#stop
     * @since 3.0.0
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */stop:function(){return this.velocity.set(0),this.acceleration.set(0),this.speed=0,this.angularVelocity=0,this.angularAcceleration=0,this},/**
     * Copies the coordinates of this Body's edges into an object.
     *
     * @method Phaser.Physics.Arcade.Body#getBounds
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} obj - An object to copy the values into.
     *
     * @return {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} - An object with {x, y, right, bottom}.
     */getBounds:function(t){return t.x=this.x,t.y=this.y,t.right=this.right,t.bottom=this.bottom,t},/**
     * Tests if the coordinates are within this Body's boundary.
     *
     * @method Phaser.Physics.Arcade.Body#hitTest
     * @since 3.0.0
     *
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     *
     * @return {boolean} True if (x, y) is within this Body.
     */hitTest:function(t,e){return this.isCircle?this.radius>0&&t>=this.left&&t<=this.right&&e>=this.top&&e<=this.bottom&&(this.center.x-t)*(this.center.x-t)+(this.center.y-e)*(this.center.y-e)<=this.radius*this.radius:h(this,t,e)},/**
     * Whether this Body is touching a tile or the world boundary while moving down.
     *
     * @method Phaser.Physics.Arcade.Body#onFloor
     * @since 3.0.0
     * @see Phaser.Physics.Arcade.Body#blocked
     *
     * @return {boolean} True if touching.
     */onFloor:function(){return this.blocked.down},/**
     * Whether this Body is touching a tile or the world boundary while moving up.
     *
     * @method Phaser.Physics.Arcade.Body#onCeiling
     * @since 3.0.0
     * @see Phaser.Physics.Arcade.Body#blocked
     *
     * @return {boolean} True if touching.
     */onCeiling:function(){return this.blocked.up},/**
     * Whether this Body is touching a tile or the world boundary while moving left or right.
     *
     * @method Phaser.Physics.Arcade.Body#onWall
     * @since 3.0.0
     * @see Phaser.Physics.Arcade.Body#blocked
     *
     * @return {boolean} True if touching.
     */onWall:function(){return this.blocked.left||this.blocked.right},/**
     * The absolute (non-negative) change in this Body's horizontal position from the previous step.
     *
     * @method Phaser.Physics.Arcade.Body#deltaAbsX
     * @since 3.0.0
     *
     * @return {number} The delta value.
     */deltaAbsX:function(){return this._dx>0?this._dx:-this._dx},/**
     * The absolute (non-negative) change in this Body's vertical position from the previous step.
     *
     * @method Phaser.Physics.Arcade.Body#deltaAbsY
     * @since 3.0.0
     *
     * @return {number} The delta value.
     */deltaAbsY:function(){return this._dy>0?this._dy:-this._dy},/**
     * The change in this Body's horizontal position from the previous step.
     * This value is set during the Body's update phase.
     *
     * As a Body can update multiple times per step this may not hold the final
     * delta value for the Body. In this case, please see the `deltaXFinal` method.
     *
     * @method Phaser.Physics.Arcade.Body#deltaX
     * @since 3.0.0
     *
     * @return {number} The delta value.
     */deltaX:function(){return this._dx},/**
     * The change in this Body's vertical position from the previous step.
     * This value is set during the Body's update phase.
     *
     * As a Body can update multiple times per step this may not hold the final
     * delta value for the Body. In this case, please see the `deltaYFinal` method.
     *
     * @method Phaser.Physics.Arcade.Body#deltaY
     * @since 3.0.0
     *
     * @return {number} The delta value.
     */deltaY:function(){return this._dy},/**
     * The change in this Body's horizontal position from the previous game update.
     *
     * This value is set during the `postUpdate` phase and takes into account the
     * `deltaMax` and final position of the Body.
     *
     * Because this value is not calculated until `postUpdate`, you must listen for it
     * during a Scene `POST_UPDATE` or `RENDER` event, and not in `update`, as it will
     * not be calculated by that point. If you _do_ use these values in `update` they
     * will represent the delta from the _previous_ game frame.
     *
     * @method Phaser.Physics.Arcade.Body#deltaXFinal
     * @since 3.22.0
     *
     * @return {number} The final delta x value.
     */deltaXFinal:function(){return this._tx},/**
     * The change in this Body's vertical position from the previous game update.
     *
     * This value is set during the `postUpdate` phase and takes into account the
     * `deltaMax` and final position of the Body.
     *
     * Because this value is not calculated until `postUpdate`, you must listen for it
     * during a Scene `POST_UPDATE` or `RENDER` event, and not in `update`, as it will
     * not be calculated by that point. If you _do_ use these values in `update` they
     * will represent the delta from the _previous_ game frame.
     *
     * @method Phaser.Physics.Arcade.Body#deltaYFinal
     * @since 3.22.0
     *
     * @return {number} The final delta y value.
     */deltaYFinal:function(){return this._ty},/**
     * The change in this Body's rotation from the previous step, in degrees.
     *
     * @method Phaser.Physics.Arcade.Body#deltaZ
     * @since 3.0.0
     *
     * @return {number} The delta value.
     */deltaZ:function(){return this.rotation-this.preRotation},/**
     * Disables this Body and marks it for deletion by the simulation.
     *
     * @method Phaser.Physics.Arcade.Body#destroy
     * @since 3.0.0
     */destroy:function(){this.enable=!1,this.world&&this.world.pendingDestroy.set(this)},/**
     * Draws this Body's boundary and velocity, if enabled.
     *
     * @method Phaser.Physics.Arcade.Body#drawDebug
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Graphics} graphic - The Graphics object to draw on.
     */drawDebug:function(t){var e=this.position,i=e.x+this.halfWidth,n=e.y+this.halfHeight;this.debugShowBody&&(t.lineStyle(t.defaultStrokeWidth,this.debugBodyColor),this.isCircle?t.strokeCircle(i,n,this.width/2):(this.checkCollision.up&&t.lineBetween(e.x,e.y,e.x+this.width,e.y),this.checkCollision.right&&t.lineBetween(e.x+this.width,e.y,e.x+this.width,e.y+this.height),this.checkCollision.down&&t.lineBetween(e.x,e.y+this.height,e.x+this.width,e.y+this.height),this.checkCollision.left&&t.lineBetween(e.x,e.y,e.x,e.y+this.height))),this.debugShowVelocity&&(t.lineStyle(t.defaultStrokeWidth,this.world.defaults.velocityDebugColor,1),t.lineBetween(i,n,i+this.velocity.x/2,n+this.velocity.y/2))},/**
     * Whether this Body will be drawn to the debug display.
     *
     * @method Phaser.Physics.Arcade.Body#willDrawDebug
     * @since 3.0.0
     *
     * @return {boolean} True if either `debugShowBody` or `debugShowVelocity` are enabled.
     */willDrawDebug:function(){return this.debugShowBody||this.debugShowVelocity},/**
     * Sets whether this Body collides with the world boundary.
     *
     * Optionally also sets the World Bounce values. If the `Body.worldBounce` is null, it's set to a new Phaser.Math.Vector2 first.
     *
     * @method Phaser.Physics.Arcade.Body#setCollideWorldBounds
     * @since 3.0.0
     *
     * @param {boolean} [value=true] - `true` if this body should collide with the world bounds, otherwise `false`.
     * @param {number} [bounceX] - If given this will be replace the `worldBounce.x` value.
     * @param {number} [bounceY] - If given this will be replace the `worldBounce.y` value.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setCollideWorldBounds:function(t,e,i){void 0===t&&(t=!0),this.collideWorldBounds=t;var n=void 0!==e,s=void 0!==i;return(n||s)&&(this.worldBounce||(this.worldBounce=new l),n&&(this.worldBounce.x=e),s&&(this.worldBounce.y=i)),this},/**
     * Sets the Body's velocity.
     *
     * @method Phaser.Physics.Arcade.Body#setVelocity
     * @since 3.0.0
     *
     * @param {number} x - The horizontal velocity, in pixels per second.
     * @param {number} [y=x] - The vertical velocity, in pixels per second.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setVelocity:function(t,e){return this.velocity.set(t,e),t=this.velocity.x,e=this.velocity.y,this.speed=Math.sqrt(t*t+e*e),this},/**
     * Sets the Body's horizontal velocity.
     *
     * @method Phaser.Physics.Arcade.Body#setVelocityX
     * @since 3.0.0
     *
     * @param {number} value - The velocity, in pixels per second.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setVelocityX:function(t){this.velocity.x=t;var e=this.velocity.y;return this.speed=Math.sqrt(t*t+e*e),this},/**
     * Sets the Body's vertical velocity.
     *
     * @method Phaser.Physics.Arcade.Body#setVelocityY
     * @since 3.0.0
     *
     * @param {number} value - The velocity, in pixels per second.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setVelocityY:function(t){this.velocity.y=t;var e=this.velocity.x;return this.speed=Math.sqrt(e*e+t*t),this},/**
     * Sets the Body's maximum velocity.
     *
     * @method Phaser.Physics.Arcade.Body#setMaxVelocity
     * @since 3.10.0
     *
     * @param {number} x - The horizontal velocity, in pixels per second.
     * @param {number} [y=x] - The vertical velocity, in pixels per second.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setMaxVelocity:function(t,e){return this.maxVelocity.set(t,e),this},/**
     * Sets the maximum speed the Body can move.
     *
     * @method Phaser.Physics.Arcade.Body#setMaxSpeed
     * @since 3.16.0
     *
     * @param {number} value - The maximum speed value, in pixels per second. Set to a negative value to disable.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setMaxSpeed:function(t){return this.maxSpeed=t,this},/**
     * Sets the Body's bounce.
     *
     * @method Phaser.Physics.Arcade.Body#setBounce
     * @since 3.0.0
     *
     * @param {number} x - The horizontal bounce, relative to 1.
     * @param {number} y - The vertical bounce, relative to 1.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setBounce:function(t,e){return this.bounce.set(t,e),this},/**
     * Sets the Body's horizontal bounce.
     *
     * @method Phaser.Physics.Arcade.Body#setBounceX
     * @since 3.0.0
     *
     * @param {number} value - The bounce, relative to 1.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setBounceX:function(t){return this.bounce.x=t,this},/**
     * Sets the Body's vertical bounce.
     *
     * @method Phaser.Physics.Arcade.Body#setBounceY
     * @since 3.0.0
     *
     * @param {number} value - The bounce, relative to 1.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setBounceY:function(t){return this.bounce.y=t,this},/**
     * Sets the Body's acceleration.
     *
     * @method Phaser.Physics.Arcade.Body#setAcceleration
     * @since 3.0.0
     *
     * @param {number} x - The horizontal component, in pixels per second squared.
     * @param {number} y - The vertical component, in pixels per second squared.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setAcceleration:function(t,e){return this.acceleration.set(t,e),this},/**
     * Sets the Body's horizontal acceleration.
     *
     * @method Phaser.Physics.Arcade.Body#setAccelerationX
     * @since 3.0.0
     *
     * @param {number} value - The acceleration, in pixels per second squared.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setAccelerationX:function(t){return this.acceleration.x=t,this},/**
     * Sets the Body's vertical acceleration.
     *
     * @method Phaser.Physics.Arcade.Body#setAccelerationY
     * @since 3.0.0
     *
     * @param {number} value - The acceleration, in pixels per second squared.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setAccelerationY:function(t){return this.acceleration.y=t,this},/**
     * Enables or disables drag.
     *
     * @method Phaser.Physics.Arcade.Body#setAllowDrag
     * @since 3.9.0
     * @see Phaser.Physics.Arcade.Body#allowDrag
     *
     * @param {boolean} [value=true] - `true` to allow drag on this body, or `false` to disable it.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setAllowDrag:function(t){return void 0===t&&(t=!0),this.allowDrag=t,this},/**
     * Enables or disables gravity's effect on this Body.
     *
     * @method Phaser.Physics.Arcade.Body#setAllowGravity
     * @since 3.9.0
     * @see Phaser.Physics.Arcade.Body#allowGravity
     *
     * @param {boolean} [value=true] - `true` to allow gravity on this body, or `false` to disable it.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setAllowGravity:function(t){return void 0===t&&(t=!0),this.allowGravity=t,this},/**
     * Enables or disables rotation.
     *
     * @method Phaser.Physics.Arcade.Body#setAllowRotation
     * @since 3.9.0
     * @see Phaser.Physics.Arcade.Body#allowRotation
     *
     * @param {boolean} [value=true] - `true` to allow rotation on this body, or `false` to disable it.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setAllowRotation:function(t){return void 0===t&&(t=!0),this.allowRotation=t,this},/**
     * Sets the Body's drag.
     *
     * @method Phaser.Physics.Arcade.Body#setDrag
     * @since 3.0.0
     *
     * @param {number} x - The horizontal component, in pixels per second squared.
     * @param {number} y - The vertical component, in pixels per second squared.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setDrag:function(t,e){return this.drag.set(t,e),this},/**
     * Sets the Body's horizontal drag.
     *
     * @method Phaser.Physics.Arcade.Body#setDragX
     * @since 3.0.0
     *
     * @param {number} value - The drag, in pixels per second squared.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setDragX:function(t){return this.drag.x=t,this},/**
     * Sets the Body's vertical drag.
     *
     * @method Phaser.Physics.Arcade.Body#setDragY
     * @since 3.0.0
     *
     * @param {number} value - The drag, in pixels per second squared.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setDragY:function(t){return this.drag.y=t,this},/**
     * Sets the Body's gravity.
     *
     * @method Phaser.Physics.Arcade.Body#setGravity
     * @since 3.0.0
     *
     * @param {number} x - The horizontal component, in pixels per second squared.
     * @param {number} y - The vertical component, in pixels per second squared.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setGravity:function(t,e){return this.gravity.set(t,e),this},/**
     * Sets the Body's horizontal gravity.
     *
     * @method Phaser.Physics.Arcade.Body#setGravityX
     * @since 3.0.0
     *
     * @param {number} value - The gravity, in pixels per second squared.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setGravityX:function(t){return this.gravity.x=t,this},/**
     * Sets the Body's vertical gravity.
     *
     * @method Phaser.Physics.Arcade.Body#setGravityY
     * @since 3.0.0
     *
     * @param {number} value - The gravity, in pixels per second squared.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setGravityY:function(t){return this.gravity.y=t,this},/**
     * Sets the Body's friction.
     *
     * @method Phaser.Physics.Arcade.Body#setFriction
     * @since 3.0.0
     *
     * @param {number} x - The horizontal component, relative to 1.
     * @param {number} y - The vertical component, relative to 1.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setFriction:function(t,e){return this.friction.set(t,e),this},/**
     * Sets the Body's horizontal friction.
     *
     * @method Phaser.Physics.Arcade.Body#setFrictionX
     * @since 3.0.0
     *
     * @param {number} value - The friction value, relative to 1.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setFrictionX:function(t){return this.friction.x=t,this},/**
     * Sets the Body's vertical friction.
     *
     * @method Phaser.Physics.Arcade.Body#setFrictionY
     * @since 3.0.0
     *
     * @param {number} value - The friction value, relative to 1.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setFrictionY:function(t){return this.friction.y=t,this},/**
     * Sets the Body's angular velocity.
     *
     * @method Phaser.Physics.Arcade.Body#setAngularVelocity
     * @since 3.0.0
     *
     * @param {number} value - The velocity, in degrees per second.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setAngularVelocity:function(t){return this.angularVelocity=t,this},/**
     * Sets the Body's angular acceleration.
     *
     * @method Phaser.Physics.Arcade.Body#setAngularAcceleration
     * @since 3.0.0
     *
     * @param {number} value - The acceleration, in degrees per second squared.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setAngularAcceleration:function(t){return this.angularAcceleration=t,this},/**
     * Sets the Body's angular drag.
     *
     * @method Phaser.Physics.Arcade.Body#setAngularDrag
     * @since 3.0.0
     *
     * @param {number} value - The drag, in degrees per second squared.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setAngularDrag:function(t){return this.angularDrag=t,this},/**
     * Sets the Body's mass.
     *
     * @method Phaser.Physics.Arcade.Body#setMass
     * @since 3.0.0
     *
     * @param {number} value - The mass value, relative to 1.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setMass:function(t){return this.mass=t,this},/**
     * Sets the Body's `immovable` property.
     *
     * @method Phaser.Physics.Arcade.Body#setImmovable
     * @since 3.0.0
     *
     * @param {boolean} [value=true] - The value to assign to `immovable`.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setImmovable:function(t){return void 0===t&&(t=!0),this.immovable=t,this},/**
     * Sets the Body's `enable` property.
     *
     * @method Phaser.Physics.Arcade.Body#setEnable
     * @since 3.15.0
     *
     * @param {boolean} [value=true] - The value to assign to `enable`.
     *
     * @return {Phaser.Physics.Arcade.Body} This Body object.
     */setEnable:function(t){return void 0===t&&(t=!0),this.enable=t,this},/**
     * The Body's horizontal position (left edge).
     *
     * @name Phaser.Physics.Arcade.Body#x
     * @type {number}
     * @since 3.0.0
     */x:{get:function(){return this.position.x},set:function(t){this.position.x=t}},/**
     * The Body's vertical position (top edge).
     *
     * @name Phaser.Physics.Arcade.Body#y
     * @type {number}
     * @since 3.0.0
     */y:{get:function(){return this.position.y},set:function(t){this.position.y=t}},/**
     * The left edge of the Body's boundary. Identical to x.
     *
     * @name Phaser.Physics.Arcade.Body#left
     * @type {number}
     * @readonly
     * @since 3.0.0
     */left:{get:function(){return this.position.x}},/**
     * The right edge of the Body's boundary.
     *
     * @name Phaser.Physics.Arcade.Body#right
     * @type {number}
     * @readonly
     * @since 3.0.0
     */right:{get:function(){return this.position.x+this.width}},/**
     * The top edge of the Body's boundary. Identical to y.
     *
     * @name Phaser.Physics.Arcade.Body#top
     * @type {number}
     * @readonly
     * @since 3.0.0
     */top:{get:function(){return this.position.y}},/**
     * The bottom edge of this Body's boundary.
     *
     * @name Phaser.Physics.Arcade.Body#bottom
     * @type {number}
     * @readonly
     * @since 3.0.0
     */bottom:{get:function(){return this.position.y+this.height}}});t.exports=u}),r("cPwjQ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Physics.Arcade.Events
 */t.exports={COLLIDE:s("2J462"),OVERLAP:s("bCoGZ"),PAUSE:s("1x8rI"),RESUME:s("bDLNe"),TILE_COLLIDE:s("2PD9b"),TILE_OVERLAP:s("ctCMH"),WORLD_BOUNDS:s("LCFnI"),WORLD_STEP:s("3Y2Od")}}),r("2J462",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Arcade Physics World Collide Event.
 * 
 * This event is dispatched by an Arcade Physics World instance if two bodies collide _and_ at least
 * one of them has their [onCollide]{@link Phaser.Physics.Arcade.Body#onCollide} property set to `true`.
 * 
 * It provides an alternative means to handling collide events rather than using the callback approach.
 * 
 * Listen to it from a Scene using: `this.physics.world.on('collide', listener)`.
 * 
 * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.
 *
 * @event Phaser.Physics.Arcade.Events#COLLIDE
 * @since 3.0.0
 * 
 * @param {Phaser.GameObjects.GameObject} gameObject1 - The first Game Object involved in the collision. This is the parent of `body1`.
 * @param {Phaser.GameObjects.GameObject} gameObject2 - The second Game Object involved in the collision. This is the parent of `body2`.
 * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body1 - The first Physics Body involved in the collision.
 * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body2 - The second Physics Body involved in the collision.
 */t.exports="collide"}),r("bCoGZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Arcade Physics World Overlap Event.
 * 
 * This event is dispatched by an Arcade Physics World instance if two bodies overlap _and_ at least
 * one of them has their [onOverlap]{@link Phaser.Physics.Arcade.Body#onOverlap} property set to `true`.
 * 
 * It provides an alternative means to handling overlap events rather than using the callback approach.
 * 
 * Listen to it from a Scene using: `this.physics.world.on('overlap', listener)`.
 * 
 * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.
 *
 * @event Phaser.Physics.Arcade.Events#OVERLAP
 * @since 3.0.0
 * 
 * @param {Phaser.GameObjects.GameObject} gameObject1 - The first Game Object involved in the overlap. This is the parent of `body1`.
 * @param {Phaser.GameObjects.GameObject} gameObject2 - The second Game Object involved in the overlap. This is the parent of `body2`.
 * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body1 - The first Physics Body involved in the overlap.
 * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body2 - The second Physics Body involved in the overlap.
 */t.exports="overlap"}),r("1x8rI",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Arcade Physics World Pause Event.
 * 
 * This event is dispatched by an Arcade Physics World instance when it is paused.
 * 
 * Listen to it from a Scene using: `this.physics.world.on('pause', listener)`.
 *
 * @event Phaser.Physics.Arcade.Events#PAUSE
 * @since 3.0.0
 */t.exports="pause"}),r("bDLNe",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Arcade Physics World Resume Event.
 * 
 * This event is dispatched by an Arcade Physics World instance when it resumes from a paused state.
 * 
 * Listen to it from a Scene using: `this.physics.world.on('resume', listener)`.
 *
 * @event Phaser.Physics.Arcade.Events#RESUME
 * @since 3.0.0
 */t.exports="resume"}),r("2PD9b",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Arcade Physics Tile Collide Event.
 * 
 * This event is dispatched by an Arcade Physics World instance if a body collides with a Tile _and_
 * has its [onCollide]{@link Phaser.Physics.Arcade.Body#onCollide} property set to `true`.
 * 
 * It provides an alternative means to handling collide events rather than using the callback approach.
 * 
 * Listen to it from a Scene using: `this.physics.world.on('tilecollide', listener)`.
 * 
 * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.
 *
 * @event Phaser.Physics.Arcade.Events#TILE_COLLIDE
 * @since 3.16.1
 * 
 * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object involved in the collision. This is the parent of `body`.
 * @param {Phaser.Tilemaps.Tile} tile - The tile the body collided with.
 * @param {Phaser.Physics.Arcade.Body} body - The Arcade Physics Body of the Game Object involved in the collision.
 */t.exports="tilecollide"}),r("ctCMH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Arcade Physics Tile Overlap Event.
 * 
 * This event is dispatched by an Arcade Physics World instance if a body overlaps with a Tile _and_
 * has its [onOverlap]{@link Phaser.Physics.Arcade.Body#onOverlap} property set to `true`.
 * 
 * It provides an alternative means to handling overlap events rather than using the callback approach.
 * 
 * Listen to it from a Scene using: `this.physics.world.on('tileoverlap', listener)`.
 * 
 * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.
 *
 * @event Phaser.Physics.Arcade.Events#TILE_OVERLAP
 * @since 3.16.1
 * 
 * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object involved in the overlap. This is the parent of `body`.
 * @param {Phaser.Tilemaps.Tile} tile - The tile the body overlapped.
 * @param {Phaser.Physics.Arcade.Body} body - The Arcade Physics Body of the Game Object involved in the overlap.
 */t.exports="tileoverlap"}),r("LCFnI",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Arcade Physics World Bounds Event.
 * 
 * This event is dispatched by an Arcade Physics World instance if a body makes contact with the world bounds _and_
 * it has its [onWorldBounds]{@link Phaser.Physics.Arcade.Body#onWorldBounds} property set to `true`.
 * 
 * It provides an alternative means to handling collide events rather than using the callback approach.
 * 
 * Listen to it from a Scene using: `this.physics.world.on('worldbounds', listener)`.
 *
 * @event Phaser.Physics.Arcade.Events#WORLD_BOUNDS
 * @since 3.0.0
 * 
 * @param {Phaser.Physics.Arcade.Body} body - The Arcade Physics Body that hit the world bounds.
 * @param {boolean} up - Is the Body blocked up? I.e. collided with the top of the world bounds.
 * @param {boolean} down - Is the Body blocked down? I.e. collided with the bottom of the world bounds.
 * @param {boolean} left - Is the Body blocked left? I.e. collided with the left of the world bounds.
 * @param {boolean} right - Is the Body blocked right? I.e. collided with the right of the world bounds.
 */t.exports="worldbounds"}),r("3Y2Od",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Arcade Physics World Step Event.
 * 
 * This event is dispatched by an Arcade Physics World instance whenever a physics step is run.
 * It is emitted _after_ the bodies and colliders have been updated.
 * 
 * In high framerate settings this can be multiple times per game frame.
 * 
 * Listen to it from a Scene using: `this.physics.world.on('worldstep', listener)`.
 *
 * @event Phaser.Physics.Arcade.Events#WORLD_STEP
 * @since 3.18.0
 */t.exports="worldstep"}),r("egqqo",function(t,e){/**
 * @classdesc
 * An Arcade Physics Collider will automatically check for collision, or overlaps, between two objects
 * every step. If a collision, or overlap, occurs it will invoke the given callbacks.
 *
 * @class Collider
 * @memberof Phaser.Physics.Arcade
 * @constructor
 * @since 3.0.0
 *
 * @param {Phaser.Physics.Arcade.World} world - The Arcade physics World that will manage the collisions.
 * @param {boolean} overlapOnly - Whether to check for collisions or overlap.
 * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for collision.
 * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object to check for collision.
 * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.
 * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.
 * @param {any} callbackContext - The scope in which to call the callbacks.
 */var i=new(s("jwj1g"))({initialize:function(t,e,i,n,s,r,o){/**
         * The world in which the bodies will collide.
         *
         * @name Phaser.Physics.Arcade.Collider#world
         * @type {Phaser.Physics.Arcade.World}
         * @since 3.0.0
         */this.world=t,/**
         * The name of the collider (unused by Phaser).
         *
         * @name Phaser.Physics.Arcade.Collider#name
         * @type {string}
         * @since 3.1.0
         */this.name="",/**
         * Whether the collider is active.
         *
         * @name Phaser.Physics.Arcade.Collider#active
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.active=!0,/**
         * Whether to check for collisions or overlaps.
         *
         * @name Phaser.Physics.Arcade.Collider#overlapOnly
         * @type {boolean}
         * @since 3.0.0
         */this.overlapOnly=e,/**
         * The first object to check for collision.
         *
         * @name Phaser.Physics.Arcade.Collider#object1
         * @type {Phaser.Types.Physics.Arcade.ArcadeColliderType}
         * @since 3.0.0
         */this.object1=i,/**
         * The second object to check for collision.
         *
         * @name Phaser.Physics.Arcade.Collider#object2
         * @type {Phaser.Types.Physics.Arcade.ArcadeColliderType}
         * @since 3.0.0
         */this.object2=n,/**
         * The callback to invoke when the two objects collide.
         *
         * @name Phaser.Physics.Arcade.Collider#collideCallback
         * @type {ArcadePhysicsCallback}
         * @since 3.0.0
         */this.collideCallback=s,/**
         * If a processCallback exists it must return true or collision checking will be skipped.
         *
         * @name Phaser.Physics.Arcade.Collider#processCallback
         * @type {ArcadePhysicsCallback}
         * @since 3.0.0
         */this.processCallback=r,/**
         * The context the collideCallback and processCallback will run in.
         *
         * @name Phaser.Physics.Arcade.Collider#callbackContext
         * @type {object}
         * @since 3.0.0
         */this.callbackContext=o},/**
     * A name for the Collider.
     * 
     * Phaser does not use this value, it's for your own reference.
     *
     * @method Phaser.Physics.Arcade.Collider#setName
     * @since 3.1.0
     *
     * @param {string} name - The name to assign to the Collider.
     *
     * @return {Phaser.Physics.Arcade.Collider} This Collider instance.
     */setName:function(t){return this.name=t,this},/**
     * Called by World as part of its step processing, initial operation of collision checking.
     *
     * @method Phaser.Physics.Arcade.Collider#update
     * @since 3.0.0
     */update:function(){this.world.collideObjects(this.object1,this.object2,this.collideCallback,this.processCallback,this.callbackContext,this.overlapOnly)},/**
     * Removes Collider from World and disposes of its resources.
     *
     * @method Phaser.Physics.Arcade.Collider#destroy
     * @since 3.0.0
     */destroy:function(){this.world.removeCollider(this),this.active=!1,this.world=null,this.object1=null,this.object2=null,this.collideCallback=null,this.processCallback=null,this.callbackContext=null}});t.exports=i}),r("e6piX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ilZSx");t.exports=function(t,e,n,s){var r=0,o=t.deltaAbsX()+e.deltaAbsX()+s;return 0===t._dx&&0===e._dx?(//  They overlap but neither of them are moving
t.embedded=!0,e.embedded=!0):t._dx>e._dx?//  Body1 is moving right and / or Body2 is moving left
(r=t.right-e.x)>o&&!n||!1===t.checkCollision.right||!1===e.checkCollision.left?r=0:(t.touching.none=!1,t.touching.right=!0,e.touching.none=!1,e.touching.left=!0,e.physicsType===i.STATIC_BODY&&(t.blocked.none=!1,t.blocked.right=!0),t.physicsType===i.STATIC_BODY&&(e.blocked.none=!1,e.blocked.left=!0)):t._dx<e._dx&&(-//  Body1 is moving left and/or Body2 is moving right
(r=t.x-e.width-e.x)>o&&!n||!1===t.checkCollision.left||!1===e.checkCollision.right?r=0:(t.touching.none=!1,t.touching.left=!0,e.touching.none=!1,e.touching.right=!0,e.physicsType===i.STATIC_BODY&&(t.blocked.none=!1,t.blocked.left=!0),t.physicsType===i.STATIC_BODY&&(e.blocked.none=!1,e.blocked.right=!0))),//  Resets the overlapX to zero if there is no overlap, or to the actual pixel value if there is
t.overlapX=r,e.overlapX=r,r}}),r("iBYsy",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ilZSx");t.exports=function(t,e,n,s){var r=0,o=t.deltaAbsY()+e.deltaAbsY()+s;return 0===t._dy&&0===e._dy?(//  They overlap but neither of them are moving
t.embedded=!0,e.embedded=!0):t._dy>e._dy?//  Body1 is moving down and/or Body2 is moving up
(r=t.bottom-e.y)>o&&!n||!1===t.checkCollision.down||!1===e.checkCollision.up?r=0:(t.touching.none=!1,t.touching.down=!0,e.touching.none=!1,e.touching.up=!0,e.physicsType===i.STATIC_BODY&&(t.blocked.none=!1,t.blocked.down=!0),t.physicsType===i.STATIC_BODY&&(e.blocked.none=!1,e.blocked.up=!0)):t._dy<e._dy&&(-//  Body1 is moving up and/or Body2 is moving down
(r=t.y-e.bottom)>o&&!n||!1===t.checkCollision.up||!1===e.checkCollision.down?r=0:(t.touching.none=!1,t.touching.up=!0,e.touching.none=!1,e.touching.down=!0,e.physicsType===i.STATIC_BODY&&(t.blocked.none=!1,t.blocked.up=!0),t.physicsType===i.STATIC_BODY&&(e.blocked.none=!1,e.blocked.down=!0))),//  Resets the overlapY to zero if there is no overlap, or to the actual pixel value if there is
t.overlapY=r,e.overlapY=r,r}}),r("7KmsS",function(t,e){t.exports=function(t,e){return(//  Tile callbacks take priority over layer level callbacks
t.collisionCallback?!t.collisionCallback.call(t.collisionCallbackContext,e,t):!t.layer.callbacks[t.index]||!t.layer.callbacks[t.index].callback.call(t.layer.callbacks[t.index].callbackContext,e,t))}}),r("aVlAx",function(t,e){/**
 * @author       Vladimir Agafonkin
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1ohUM");/**
 * @classdesc
 * RBush is a high-performance JavaScript library for 2D spatial indexing of points and rectangles.
 * It's based on an optimized R-tree data structure with bulk insertion support.
 *
 * Spatial index is a special data structure for points and rectangles that allows you to perform queries like
 * "all items within this bounding box" very efficiently (e.g. hundreds of times faster than looping over all items).
 *
 * This version of RBush uses a fixed min/max accessor structure of `[ '.left', '.top', '.right', '.bottom' ]`.
 * This is to avoid the eval like function creation that the original library used, which caused CSP policy violations.
 * 
 * rbush is forked from https://github.com/mourner/rbush by Vladimir Agafonkin
 *
 * @class RTree
 * @memberof Phaser.Structs
 * @constructor
 * @since 3.0.0
 */function n(t){if(!(this instanceof n))return new n(t,[".left",".top",".right",".bottom"]);// max entries in a node is 9 by default; min node fill is 40% for best performance
this._maxEntries=Math.max(4,t||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()}// calculate node's bbox from bboxes of its children
function r(t,e){o(t,0,t.children.length,e,t)}// min bounding rectangle of node children from k to p-1
function o(t,e,i,n,s){s||(s=p(null)),s.minX=1/0,s.minY=1/0,s.maxX=-1/0,s.maxY=-1/0;for(var r,o=e;o<i;o++)r=t.children[o],a(s,t.leaf?n(r):r);return s}function a(t,e){return t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),t}function h(t,e){return t.minX-e.minX}function l(t,e){return t.minY-e.minY}function u(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function c(t){return t.maxX-t.minX+(t.maxY-t.minY)}function d(t,e){return t.minX<=e.minX&&t.minY<=e.minY&&e.maxX<=t.maxX&&e.maxY<=t.maxY}function f(t,e){return e.minX<=t.maxX&&e.minY<=t.maxY&&e.maxX>=t.minX&&e.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach
function g(t,e,n,s,r){for(var o,a=[e,n];a.length;)(n=a.pop())-(e=a.pop())<=s||(i(t,o=e+Math.ceil((n-e)/s/2)*s,e,n,r),a.push(e,o,o,n))}n.prototype={all:function(){return this._all(this.data,[])},search:function(t){var e=this.data,i=[],n=this.toBBox;if(!f(t,e))return i;for(var s,r,o,a,h=[];e;){for(s=0,r=e.children.length;s<r;s++)o=e.children[s],f(t,a=e.leaf?n(o):o)&&(e.leaf?i.push(o):d(t,a)?this._all(o,i):h.push(o));e=h.pop()}return i},collides:function(t){var e=this.data,i=this.toBBox;if(!f(t,e))return!1;for(var n,s,r,o,a=[];e;){for(n=0,s=e.children.length;n<s;n++)if(r=e.children[n],f(t,o=e.leaf?i(r):r)){if(e.leaf||d(t,o))return!0;a.push(r)}e=a.pop()}return!1},load:function(t){if(!(t&&t.length))return this;if(t.length<this._minEntries){for(var e=0,i=t.length;e<i;e++)this.insert(t[e]);return this}// recursively build the tree with the given data from scratch using OMT algorithm
var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length){if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){// swap trees if inserted one is bigger
var s=this.data;this.data=n,n=s}// insert the small tree into the large tree at appropriate level
this._insert(n,this.data.height-n.height-1,!0)}}else this.data=n;return this},insert:function(t){return t&&this._insert(t,this.data.height-1),this},clear:function(){return this.data=p([]),this},remove:function(t,e){if(!t)return this;// depth-first iterative tree traversal
for(var i,n,s,r,o=this.data,a=this.toBBox(t),h=[],l=[];o||h.length;){if(o||(o=h.pop(),n=h[h.length-1],i=l.pop(),r=!0),o.leaf&&-1!==(s=function(t,e,i){if(!i)return e.indexOf(t);for(var n=0;n<e.length;n++)if(i(t,e[n]))return n;return -1}(t,o.children,e))){// item found, remove the item and condense tree upwards
o.children.splice(s,1),h.push(o),this._condense(h);break}!r&&!o.leaf&&d(o,a)?(h.push(o),l.push(i),i=0,n=o,o=o.children[0]):n?(i++,o=n.children[i],r=!1):o=null}return this},toBBox:function(t){return t},compareMinX:h,compareMinY:l,toJSON:function(){return this.data},fromJSON:function(t){return this.data=t,this},_all:function(t,e){for(var i=[];t;)t.leaf?e.push.apply(e,t.children):i.push.apply(i,t.children),t=i.pop();return e},_build:function(t,e,i,n){var s,o=i-e+1,a=this._maxEntries;if(o<=a)return r(// reached leaf level; return leaf
s=p(t.slice(e,i+1)),this.toBBox),s;n||(// target height of the bulk-loaded tree
n=Math.ceil(Math.log(o)/Math.log(a)),// target number of root entries to maximize storage utilization
a=Math.ceil(o/Math.pow(a,n-1))),(s=p([])).leaf=!1,s.height=n;// split the items into M mostly square tiles
var h,l,u,c,d=Math.ceil(o/a),f=d*Math.ceil(Math.sqrt(a));for(g(t,e,i,f,this.compareMinX),h=e;h<=i;h+=f)for(u=Math.min(h+f-1,i),g(t,h,u,d,this.compareMinY),l=h;l<=u;l+=d)c=Math.min(l+d-1,u),// pack each entry recursively
s.children.push(this._build(t,l,c,n-1));return r(s,this.toBBox),s},_chooseSubtree:function(t,e,i,n){for(var s,r,o,a,h,l,c,d;n.push(e),!e.leaf&&n.length-1!==i;){for(s=0,c=d=1/0,r=e.children.length;s<r;s++)h=u(o=e.children[s]),(l=(Math.max(o.maxX,t.maxX)-Math.min(o.minX,t.minX))*(Math.max(o.maxY,t.maxY)-Math.min(o.minY,t.minY))-h)<d?(d=l,c=h<c?h:c,a=o):l===d&&h<c&&(c=h,a=o);e=a||e.children[0]}return e},_insert:function(t,e,i){var n=this.toBBox,s=i?t:n(t),r=[],o=this._chooseSubtree(s,this.data,e,r);// split on node overflow; propagate upwards if necessary
for(// put the item into the node
o.children.push(t),a(o,s);e>=0;)if(r[e].children.length>this._maxEntries)this._split(r,e),e--;else break;// adjust bboxes along the insertion path
this._adjustParentBBoxes(s,r,e)},// split overflowed node into two
_split:function(t,e){var i=t[e],n=i.children.length,s=this._minEntries;this._chooseSplitAxis(i,s,n);var o=this._chooseSplitIndex(i,s,n),a=p(i.children.splice(o,i.children.length-o));a.height=i.height,a.leaf=i.leaf,r(i,this.toBBox),r(a,this.toBBox),e?t[e-1].children.push(a):this._splitRoot(i,a)},_splitRoot:function(t,e){// split root node
this.data=p([t,e]),this.data.height=t.height+1,this.data.leaf=!1,r(this.data,this.toBBox)},_chooseSplitIndex:function(t,e,i){var n,s,r,a,h,l,c,d;for(l=c=1/0,n=e;n<=i-e;n++)a=function(t,e){var i=Math.max(t.minX,e.minX),n=Math.max(t.minY,e.minY);return Math.max(0,Math.min(t.maxX,e.maxX)-i)*Math.max(0,Math.min(t.maxY,e.maxY)-n)}(s=o(t,0,n,this.toBBox),r=o(t,n,i,this.toBBox)),h=u(s)+u(r),a<l?(l=a,d=n,c=h<c?h:c):a===l&&h<c&&(c=h,d=n);return d},// sorts node children by the best axis for split
_chooseSplitAxis:function(t,e,i){var n=t.leaf?this.compareMinX:h,s=t.leaf?this.compareMinY:l;// if total distributions margin value is minimal for x, sort by minX,
// otherwise it's already sorted by minY
this._allDistMargin(t,e,i,n)<this._allDistMargin(t,e,i,s)&&t.children.sort(n)},// total margin of all possible split distributions where each node is at least m full
_allDistMargin:function(t,e,i,n){t.children.sort(n);var s,r,h=this.toBBox,l=o(t,0,e,h),u=o(t,i-e,i,h),d=c(l)+c(u);for(s=e;s<i-e;s++)r=t.children[s],a(l,t.leaf?h(r):r),d+=c(l);for(s=i-e-1;s>=e;s--)r=t.children[s],a(u,t.leaf?h(r):r),d+=c(u);return d},_adjustParentBBoxes:function(t,e,i){// adjust bboxes along the given tree path
for(var n=i;n>=0;n--)a(e[n],t)},_condense:function(t){// go through the path, removing empty nodes and updating bboxes
for(var e,i=t.length-1;i>=0;i--)0===t[i].children.length?i>0?(e=t[i-1].children).splice(e.indexOf(t[i]),1):this.clear():r(t[i],this.toBBox)},compareMinX:function(t,e){return t.left-e.left},compareMinY:function(t,e){return t.top-e.top},toBBox:function(t){return{minX:t.left,minY:t.top,maxX:t.right,maxY:t.bottom}}},t.exports=n}),r("j3Ns0",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5s70Z"),n=s("dH1E5"),r=s("eXUBz");t.exports=function(t,e,s,o,a,h,l){var u=o.left,c=o.top,d=o.right,f=o.bottom,p=s.faceLeft||s.faceRight,g=s.faceTop||s.faceBottom;//  We don't need to go any further if this tile doesn't actually have any colliding faces. This
//  could happen if the tile was meant to be collided with re: a callback, but otherwise isn't
//  needed for separation.
if(l||(p=!0,g=!0),!p&&!g)return!1;var v=0,m=0,y=0,x=1;if(e.deltaAbsX()>e.deltaAbsY()?y=-1:e.deltaAbsX()<e.deltaAbsY()&&(x=-1),0!==e.deltaX()&&0!==e.deltaY()&&p&&g&&(//  We only need do this if both axes have colliding faces AND we're moving in both
//  directions
y=Math.min(Math.abs(e.position.x-d),Math.abs(e.right-u)),x=Math.min(Math.abs(e.position.y-f),Math.abs(e.bottom-c))),y<x){if(p&&0!==(v=i(e,s,u,d,h,l))&&!r(o,e))return!0;g&&(m=n(e,s,c,f,h,l))}else{if(g&&0!==(m=n(e,s,c,f,h,l))&&!r(o,e))return!0;p&&(v=i(e,s,u,d,h,l))}return 0!==v||0!==m}}),r("5s70Z",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("04QFi");t.exports=function(t,e,n,s,r,o){var a=0,h=e.faceLeft,l=e.faceRight,u=e.collideLeft,c=e.collideRight;return o||(h=!0,l=!0,u=!0,c=!0),0>t.deltaX()&&c&&t.checkCollision.left?l&&t.x<s&&(a=t.x-s)<-r&&(a=0):t.deltaX()>0&&u&&t.checkCollision.right&&h&&t.right>n&&(a=t.right-n)>r&&(a=0),0!==a&&(t.customSeparateX?t.overlapX=a:i(t,a)),a}}),r("04QFi",function(t,e){t.exports=function(t,e){e<0?(t.blocked.none=!1,t.blocked.left=!0):e>0&&(t.blocked.none=!1,t.blocked.right=!0),t.position.x-=e,0===t.bounce.x?t.velocity.x=0:t.velocity.x=-t.velocity.x*t.bounce.x}}),r("dH1E5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("aOKfs");t.exports=function(t,e,n,s,r,o){var a=0,h=e.faceTop,l=e.faceBottom,u=e.collideUp,c=e.collideDown;return o||(h=!0,l=!0,u=!0,c=!0),0>t.deltaY()&&c&&t.checkCollision.up?l&&t.y<s&&(a=t.y-s)<-r&&(a=0):t.deltaY()>0&&u&&t.checkCollision.down&&h&&t.bottom>n&&(a=t.bottom-n)>r&&(a=0),0!==a&&(t.customSeparateY?t.overlapY=a:i(t,a)),a}}),r("aOKfs",function(t,e){t.exports=function(t,e){e<0?(t.blocked.none=!1,t.blocked.up=!0):e>0&&(t.blocked.none=!1,t.blocked.down=!0),t.position.y-=e,0===t.bounce.y?t.velocity.y=0:t.velocity.y=-t.velocity.y*t.bounce.y}}),r("eXUBz",function(t,e){t.exports=function(t,e){// Currently, all bodies are treated as rectangles when colliding with a Tile.
return!(e.right<=t.left||e.bottom<=t.top||e.position.x>=t.right||e.position.y>=t.bottom)}}),r("i83ko",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("e6piX");t.exports=function(t,e,n,s){var r=i(t,e,n,s);//  Can't separate two immovable bodies, or a body with its own custom separation logic
if(n||0===r||t.immovable&&e.immovable||t.customSeparateX||e.customSeparateX)return 0!==r||t.embedded&&e.embedded;//  Adjust their positions and velocities accordingly (if there was any overlap)
var o=t.velocity.x,a=e.velocity.x;if(t.immovable||e.immovable)t.immovable?(e.x+=r,e.velocity.x=o-a*e.bounce.x,t.moves&&(e.y+=(t.y-t.prev.y)*t.friction.y)):(t.x-=r,t.velocity.x=a-o*t.bounce.x,e.moves&&(t.y+=(e.y-e.prev.y)*e.friction.y));else{r*=.5,t.x-=r,e.x+=r;var h=Math.sqrt(a*a*e.mass/t.mass)*(a>0?1:-1),l=Math.sqrt(o*o*t.mass/e.mass)*(o>0?1:-1),u=(h+l)*.5;h-=u,l-=u,t.velocity.x=u+h*t.bounce.x,e.velocity.x=u+l*e.bounce.x}//  If we got this far then there WAS overlap, and separation is complete, so return true
return!0}}),r("8u1DC",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iBYsy");t.exports=function(t,e,n,s){var r=i(t,e,n,s);//  Can't separate two immovable bodies, or a body with its own custom separation logic
if(n||0===r||t.immovable&&e.immovable||t.customSeparateY||e.customSeparateY)return 0!==r||t.embedded&&e.embedded;//  Adjust their positions and velocities accordingly (if there was any overlap)
var o=t.velocity.y,a=e.velocity.y;if(t.immovable||e.immovable)t.immovable?(e.y+=r,e.velocity.y=o-a*e.bounce.y,t.moves&&(e.x+=(t.x-t.prev.x)*t.friction.x)):(t.y-=r,t.velocity.y=a-o*t.bounce.y,e.moves&&(t.x+=(e.x-e.prev.x)*e.friction.x));else{r*=.5,t.y-=r,e.y+=r;var h=Math.sqrt(a*a*e.mass/t.mass)*(a>0?1:-1),l=Math.sqrt(o*o*t.mass/e.mass)*(o>0?1:-1),u=(h+l)*.5;h-=u,l-=u,t.velocity.y=u+h*t.bounce.y,e.velocity.y=u+l*e.bounce.y}//  If we got this far then there WAS overlap, and separation is complete, so return true
return!0}}),r("k8alZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6hp2k"),n=s("jwj1g"),r=s("ilZSx"),o=s("6pEze"),a=s("7SBSk"),h=new n({initialize:function(t,e){var i=e.displayWidth?e.displayWidth:64,n=e.displayHeight?e.displayHeight:64;/**
         * The Arcade Physics simulation this Static Body belongs to.
         *
         * @name Phaser.Physics.Arcade.StaticBody#world
         * @type {Phaser.Physics.Arcade.World}
         * @since 3.0.0
         */this.world=t,/**
         * The Game Object this Static Body belongs to.
         *
         * @name Phaser.Physics.Arcade.StaticBody#gameObject
         * @type {Phaser.GameObjects.GameObject}
         * @since 3.0.0
         */this.gameObject=e,/**
         * Whether the Static Body's boundary is drawn to the debug display.
         *
         * @name Phaser.Physics.Arcade.StaticBody#debugShowBody
         * @type {boolean}
         * @since 3.0.0
         */this.debugShowBody=t.defaults.debugShowStaticBody,/**
         * The color of this Static Body on the debug display.
         *
         * @name Phaser.Physics.Arcade.StaticBody#debugBodyColor
         * @type {integer}
         * @since 3.0.0
         */this.debugBodyColor=t.defaults.staticBodyDebugColor,/**
         * Whether this Static Body is updated by the physics simulation.
         *
         * @name Phaser.Physics.Arcade.StaticBody#enable
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.enable=!0,/**
         * Whether this Static Body's boundary is circular (`true`) or rectangular (`false`).
         *
         * @name Phaser.Physics.Arcade.StaticBody#isCircle
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.isCircle=!1,/**
         * If this Static Body is circular, this is the radius of the boundary, as set by {@link Phaser.Physics.Arcade.StaticBody#setCircle}, in pixels.
         * Equal to `halfWidth`.
         *
         * @name Phaser.Physics.Arcade.StaticBody#radius
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.radius=0,/**
         * The offset set by {@link Phaser.Physics.Arcade.StaticBody#setCircle} or {@link Phaser.Physics.Arcade.StaticBody#setSize}.
         *
         * This doesn't affect the Static Body's position, because a Static Body does not follow its Game Object.
         *
         * @name Phaser.Physics.Arcade.StaticBody#offset
         * @type {Phaser.Math.Vector2}
         * @readonly
         * @since 3.0.0
         */this.offset=new a,/**
         * The position of this Static Body within the simulation.
         *
         * @name Phaser.Physics.Arcade.StaticBody#position
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.position=new a(e.x-e.displayOriginX,e.y-e.displayOriginY),/**
         * The width of the Static Body's boundary, in pixels.
         * If the Static Body is circular, this is also the Static Body's diameter.
         *
         * @name Phaser.Physics.Arcade.StaticBody#width
         * @type {number}
         * @since 3.0.0
         */this.width=i,/**
         * The height of the Static Body's boundary, in pixels.
         * If the Static Body is circular, this is also the Static Body's diameter.
         *
         * @name Phaser.Physics.Arcade.StaticBody#height
         * @type {number}
         * @since 3.0.0
         */this.height=n,/**
         * Half the Static Body's width, in pixels.
         * If the Static Body is circular, this is also the Static Body's radius.
         *
         * @name Phaser.Physics.Arcade.StaticBody#halfWidth
         * @type {number}
         * @since 3.0.0
         */this.halfWidth=Math.abs(this.width/2),/**
         * Half the Static Body's height, in pixels.
         * If the Static Body is circular, this is also the Static Body's radius.
         *
         * @name Phaser.Physics.Arcade.StaticBody#halfHeight
         * @type {number}
         * @since 3.0.0
         */this.halfHeight=Math.abs(this.height/2),/**
         * The center of the Static Body's boundary.
         * This is the midpoint of its `position` (top-left corner) and its bottom-right corner.
         *
         * @name Phaser.Physics.Arcade.StaticBody#center
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.center=new a(this.position.x+this.halfWidth,this.position.y+this.halfHeight),/**
         * A constant zero velocity used by the Arcade Physics simulation for calculations.
         *
         * @name Phaser.Physics.Arcade.StaticBody#velocity
         * @type {Phaser.Math.Vector2}
         * @readonly
         * @since 3.0.0
         */this.velocity=a.ZERO,/**
         * A constant `false` value expected by the Arcade Physics simulation.
         *
         * @name Phaser.Physics.Arcade.StaticBody#allowGravity
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.0.0
         */this.allowGravity=!1,/**
         * Gravitational force applied specifically to this Body. Values are in pixels per second squared. Always zero for a Static Body.
         *
         * @name Phaser.Physics.Arcade.StaticBody#gravity
         * @type {Phaser.Math.Vector2}
         * @readonly
         * @since 3.0.0
         */this.gravity=a.ZERO,/**
         * Rebound, or restitution, following a collision, relative to 1. Always zero for a Static Body.
         *
         * @name Phaser.Physics.Arcade.StaticBody#bounce
         * @type {Phaser.Math.Vector2}
         * @readonly
         * @since 3.0.0
         */this.bounce=a.ZERO,//  If true this Body will dispatch events
/**
         * Whether the simulation emits a `worldbounds` event when this StaticBody collides with the world boundary.
         * Always false for a Static Body. (Static Bodies never collide with the world boundary and never trigger a `worldbounds` event.)
         *
         * @name Phaser.Physics.Arcade.StaticBody#onWorldBounds
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.0.0
         */this.onWorldBounds=!1,/**
         * Whether the simulation emits a `collide` event when this StaticBody collides with another.
         *
         * @name Phaser.Physics.Arcade.StaticBody#onCollide
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.onCollide=!1,/**
         * Whether the simulation emits an `overlap` event when this StaticBody overlaps with another.
         *
         * @name Phaser.Physics.Arcade.StaticBody#onOverlap
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.onOverlap=!1,/**
         * The StaticBody's inertia, relative to a default unit (1). With `bounce`, this affects the exchange of momentum (velocities) during collisions.
         *
         * @name Phaser.Physics.Arcade.StaticBody#mass
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.mass=1,/**
         * Whether this object can be moved by collisions with another body.
         *
         * @name Phaser.Physics.Arcade.StaticBody#immovable
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.immovable=!0,/**
         * A flag disabling the default horizontal separation of colliding bodies. Pass your own `collideHandler` to the collider.
         *
         * @name Phaser.Physics.Arcade.StaticBody#customSeparateX
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.customSeparateX=!1,/**
         * A flag disabling the default vertical separation of colliding bodies. Pass your own `collideHandler` to the collider.
         *
         * @name Phaser.Physics.Arcade.StaticBody#customSeparateY
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.customSeparateY=!1,/**
         * The amount of horizontal overlap (before separation), if this Body is colliding with another.
         *
         * @name Phaser.Physics.Arcade.StaticBody#overlapX
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.overlapX=0,/**
         * The amount of vertical overlap (before separation), if this Body is colliding with another.
         *
         * @name Phaser.Physics.Arcade.StaticBody#overlapY
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.overlapY=0,/**
         * The amount of overlap (before separation), if this StaticBody is circular and colliding with another circular body.
         *
         * @name Phaser.Physics.Arcade.StaticBody#overlapR
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.overlapR=0,/**
         * Whether this StaticBody has ever overlapped with another while both were not moving.
         *
         * @name Phaser.Physics.Arcade.StaticBody#embedded
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.embedded=!1,/**
         * Whether this StaticBody interacts with the world boundary.
         * Always false for a Static Body. (Static Bodies never collide with the world boundary.)
         *
         * @name Phaser.Physics.Arcade.StaticBody#collideWorldBounds
         * @type {boolean}
         * @readonly
         * @default false
         * @since 3.0.0
         */this.collideWorldBounds=!1,/**
         * Whether this StaticBody is checked for collisions and for which directions. You can set `checkCollision.none = false` to disable collision checks.
         *
         * @name Phaser.Physics.Arcade.StaticBody#checkCollision
         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}
         * @since 3.0.0
         */this.checkCollision={none:!1,up:!0,down:!0,left:!0,right:!0},/**
         * Whether this StaticBody has ever collided with another body and in which direction.
         *
         * @name Phaser.Physics.Arcade.StaticBody#touching
         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}
         * @since 3.0.0
         */this.touching={none:!0,up:!1,down:!1,left:!1,right:!1},/**
         * Whether this StaticBody was colliding with another body during the last step or any previous step, and in which direction.
         *
         * @name Phaser.Physics.Arcade.StaticBody#wasTouching
         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}
         * @since 3.0.0
         */this.wasTouching={none:!0,up:!1,down:!1,left:!1,right:!1},/**
         * Whether this StaticBody has ever collided with a tile or the world boundary.
         *
         * @name Phaser.Physics.Arcade.StaticBody#blocked
         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}
         * @since 3.0.0
         */this.blocked={none:!0,up:!1,down:!1,left:!1,right:!1},/**
         * The StaticBody's physics type (static by default).
         *
         * @name Phaser.Physics.Arcade.StaticBody#physicsType
         * @type {integer}
         * @default Phaser.Physics.Arcade.STATIC_BODY
         * @since 3.0.0
         */this.physicsType=r.STATIC_BODY,/**
         * The calculated change in the Static Body's horizontal position during the current step.
         * For a static body this is always zero.
         *
         * @name Phaser.Physics.Arcade.StaticBody#_dx
         * @type {number}
         * @private
         * @default 0
         * @since 3.10.0
         */this._dx=0,/**
         * The calculated change in the Static Body's vertical position during the current step.
         * For a static body this is always zero.
         *
         * @name Phaser.Physics.Arcade.StaticBody#_dy
         * @type {number}
         * @private
         * @default 0
         * @since 3.10.0
         */this._dy=0},/**
     * Changes the Game Object this Body is bound to.
     * First it removes its reference from the old Game Object, then sets the new one.
     * You can optionally update the position and dimensions of this Body to reflect that of the new Game Object.
     *
     * @method Phaser.Physics.Arcade.StaticBody#setGameObject
     * @since 3.1.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The new Game Object that will own this Body.
     * @param {boolean} [update=true] - Reposition and resize this Body to match the new Game Object?
     *
     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.
     *
     * @see Phaser.Physics.Arcade.StaticBody#updateFromGameObject
     */setGameObject:function(t,e){return t&&t!==this.gameObject&&(//  Remove this body from the old game object
this.gameObject.body=null,t.body=this,//  Update our reference
this.gameObject=t),e&&this.updateFromGameObject(),this},/**
     * Syncs the Static Body's position and size with its parent Game Object.
     *
     * @method Phaser.Physics.Arcade.StaticBody#updateFromGameObject
     * @since 3.1.0
     *
     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.
     */updateFromGameObject:function(){this.world.staticTree.remove(this);var t=this.gameObject;return t.getTopLeft(this.position),this.width=t.displayWidth,this.height=t.displayHeight,this.halfWidth=Math.abs(this.width/2),this.halfHeight=Math.abs(this.height/2),this.center.set(this.position.x+this.halfWidth,this.position.y+this.halfHeight),this.world.staticTree.insert(this),this},/**
     * Positions the Static Body at an offset from its Game Object.
     *
     * @method Phaser.Physics.Arcade.StaticBody#setOffset
     * @since 3.4.0
     *
     * @param {number} x - The horizontal offset of the Static Body from the Game Object's `x`.
     * @param {number} y - The vertical offset of the Static Body from the Game Object's `y`.
     *
     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.
     */setOffset:function(t,e){return void 0===e&&(e=t),this.world.staticTree.remove(this),this.position.x-=this.offset.x,this.position.y-=this.offset.y,this.offset.set(t,e),this.position.x+=this.offset.x,this.position.y+=this.offset.y,this.updateCenter(),this.world.staticTree.insert(this),this},/**
     * Sets the size of the Static Body.
     * When `center` is true, also repositions it.
     * Resets the width and height to match current frame, if no width and height provided and a frame is found.
     *
     * @method Phaser.Physics.Arcade.StaticBody#setSize
     * @since 3.0.0
     *
     * @param {integer} [width] - The width of the Static Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.
     * @param {integer} [height] - The height of the Static Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.
     * @param {boolean} [center=true] - Place the Static Body's center on its Game Object's center. Only works if the Game Object has the `getCenter` method.
     *
     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.
     */setSize:function(t,e,i){void 0===i&&(i=!0);var n=this.gameObject;if(!t&&n.frame&&(t=n.frame.realWidth),!e&&n.frame&&(e=n.frame.realHeight),this.world.staticTree.remove(this),this.width=t,this.height=e,this.halfWidth=Math.floor(t/2),this.halfHeight=Math.floor(e/2),i&&n.getCenter){var s=n.displayWidth/2,r=n.displayHeight/2;this.position.x-=this.offset.x,this.position.y-=this.offset.y,this.offset.set(s-this.halfWidth,r-this.halfHeight),this.position.x+=this.offset.x,this.position.y+=this.offset.y}return this.updateCenter(),this.isCircle=!1,this.radius=0,this.world.staticTree.insert(this),this},/**
     * Sets this Static Body to have a circular body and sets its size and position.
     *
     * @method Phaser.Physics.Arcade.StaticBody#setCircle
     * @since 3.0.0
     *
     * @param {number} radius - The radius of the StaticBody, in pixels.
     * @param {number} [offsetX] - The horizontal offset of the StaticBody from its Game Object, in pixels.
     * @param {number} [offsetY] - The vertical offset of the StaticBody from its Game Object, in pixels.
     *
     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.
     */setCircle:function(t,e,i){return void 0===e&&(e=this.offset.x),void 0===i&&(i=this.offset.y),t>0?(this.world.staticTree.remove(this),this.isCircle=!0,this.radius=t,this.width=2*t,this.height=2*t,this.halfWidth=Math.floor(this.width/2),this.halfHeight=Math.floor(this.height/2),this.offset.set(e,i),this.updateCenter(),this.world.staticTree.insert(this)):this.isCircle=!1,this},/**
     * Updates the StaticBody's `center` from its `position` and dimensions.
     *
     * @method Phaser.Physics.Arcade.StaticBody#updateCenter
     * @since 3.0.0
     */updateCenter:function(){this.center.set(this.position.x+this.halfWidth,this.position.y+this.halfHeight)},/**
     * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.
     *
     * @method Phaser.Physics.Arcade.StaticBody#reset
     * @since 3.0.0
     *
     * @param {number} [x] - The x coordinate to reset the body to. If not given will use the parent Game Object's coordinate.
     * @param {number} [y] - The y coordinate to reset the body to. If not given will use the parent Game Object's coordinate.
     */reset:function(t,e){var i=this.gameObject;void 0===t&&(t=i.x),void 0===e&&(e=i.y),this.world.staticTree.remove(this),i.setPosition(t,e),i.getTopLeft(this.position),this.updateCenter(),this.world.staticTree.insert(this)},/**
     * NOOP function. A Static Body cannot be stopped.
     *
     * @method Phaser.Physics.Arcade.StaticBody#stop
     * @since 3.0.0
     *
     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.
     */stop:function(){return this},/**
     * Returns the x and y coordinates of the top left and bottom right points of the StaticBody.
     *
     * @method Phaser.Physics.Arcade.StaticBody#getBounds
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} obj - The object which will hold the coordinates of the bounds.
     *
     * @return {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} The same object that was passed with `x`, `y`, `right` and `bottom` values matching the respective values of the StaticBody.
     */getBounds:function(t){return t.x=this.x,t.y=this.y,t.right=this.right,t.bottom=this.bottom,t},/**
     * Checks to see if a given x,y coordinate is colliding with this Static Body.
     *
     * @method Phaser.Physics.Arcade.StaticBody#hitTest
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate to check against this body.
     * @param {number} y - The y coordinate to check against this body.
     *
     * @return {boolean} `true` if the given coordinate lies within this body, otherwise `false`.
     */hitTest:function(t,e){return this.isCircle?i(this,t,e):o(this,t,e)},/**
     * NOOP
     *
     * @method Phaser.Physics.Arcade.StaticBody#postUpdate
     * @since 3.12.0
     */postUpdate:function(){},/**
     * The absolute (non-negative) change in this StaticBody's horizontal position from the previous step. Always zero.
     *
     * @method Phaser.Physics.Arcade.StaticBody#deltaAbsX
     * @since 3.0.0
     *
     * @return {number} Always zero for a Static Body.
     */deltaAbsX:function(){return 0},/**
     * The absolute (non-negative) change in this StaticBody's vertical position from the previous step. Always zero.
     *
     * @method Phaser.Physics.Arcade.StaticBody#deltaAbsY
     * @since 3.0.0
     *
     * @return {number} Always zero for a Static Body.
     */deltaAbsY:function(){return 0},/**
     * The change in this StaticBody's horizontal position from the previous step. Always zero.
     *
     * @method Phaser.Physics.Arcade.StaticBody#deltaX
     * @since 3.0.0
     *
     * @return {number} The change in this StaticBody's velocity from the previous step. Always zero.
     */deltaX:function(){return 0},/**
     * The change in this StaticBody's vertical position from the previous step. Always zero.
     *
     * @method Phaser.Physics.Arcade.StaticBody#deltaY
     * @since 3.0.0
     *
     * @return {number} The change in this StaticBody's velocity from the previous step. Always zero.
     */deltaY:function(){return 0},/**
     * The change in this StaticBody's rotation from the previous step. Always zero.
     *
     * @method Phaser.Physics.Arcade.StaticBody#deltaZ
     * @since 3.0.0
     *
     * @return {number} The change in this StaticBody's rotation from the previous step. Always zero.
     */deltaZ:function(){return 0},/**
     * Disables this Body and marks it for destruction during the next step.
     *
     * @method Phaser.Physics.Arcade.StaticBody#destroy
     * @since 3.0.0
     */destroy:function(){this.enable=!1,this.world.pendingDestroy.set(this)},/**
     * Draws a graphical representation of the StaticBody for visual debugging purposes.
     *
     * @method Phaser.Physics.Arcade.StaticBody#drawDebug
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Graphics} graphic - The Graphics object to use for the debug drawing of the StaticBody.
     */drawDebug:function(t){var e=this.position,i=e.x+this.halfWidth,n=e.y+this.halfHeight;this.debugShowBody&&(t.lineStyle(t.defaultStrokeWidth,this.debugBodyColor,1),this.isCircle?t.strokeCircle(i,n,this.width/2):t.strokeRect(e.x,e.y,this.width,this.height))},/**
     * Indicates whether the StaticBody is going to be showing a debug visualization during postUpdate.
     *
     * @method Phaser.Physics.Arcade.StaticBody#willDrawDebug
     * @since 3.0.0
     *
     * @return {boolean} Whether or not the StaticBody is going to show the debug visualization during postUpdate.
     */willDrawDebug:function(){return this.debugShowBody},/**
     * Sets the Mass of the StaticBody. Will set the Mass to 0.1 if the value passed is less than or equal to zero.
     *
     * @method Phaser.Physics.Arcade.StaticBody#setMass
     * @since 3.0.0
     *
     * @param {number} value - The value to set the Mass to. Values of zero or less are changed to 0.1.
     *
     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.
     */setMass:function(t){return t<=0&&(t=.1),this.mass=t,this},/**
     * The x coordinate of the StaticBody.
     *
     * @name Phaser.Physics.Arcade.StaticBody#x
     * @type {number}
     * @since 3.0.0
     */x:{get:function(){return this.position.x},set:function(t){this.world.staticTree.remove(this),this.position.x=t,this.world.staticTree.insert(this)}},/**
     * The y coordinate of the StaticBody.
     *
     * @name Phaser.Physics.Arcade.StaticBody#y
     * @type {number}
     * @since 3.0.0
     */y:{get:function(){return this.position.y},set:function(t){this.world.staticTree.remove(this),this.position.y=t,this.world.staticTree.insert(this)}},/**
     * Returns the left-most x coordinate of the area of the StaticBody.
     *
     * @name Phaser.Physics.Arcade.StaticBody#left
     * @type {number}
     * @readonly
     * @since 3.0.0
     */left:{get:function(){return this.position.x}},/**
     * The right-most x coordinate of the area of the StaticBody.
     *
     * @name Phaser.Physics.Arcade.StaticBody#right
     * @type {number}
     * @readonly
     * @since 3.0.0
     */right:{get:function(){return this.position.x+this.width}},/**
     * The highest y coordinate of the area of the StaticBody.
     *
     * @name Phaser.Physics.Arcade.StaticBody#top
     * @type {number}
     * @readonly
     * @since 3.0.0
     */top:{get:function(){return this.position.y}},/**
     * The lowest y coordinate of the area of the StaticBody. (y + height)
     *
     * @name Phaser.Physics.Arcade.StaticBody#bottom
     * @type {number}
     * @readonly
     * @since 3.0.0
     */bottom:{get:function(){return this.position.y+this.height}}});t.exports=h}),r("6xUMs",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Physics.Matter
 */t.exports={BodyBounds:s("kr4xd"),Factory:s("bImJl"),Image:s("k5BpG"),Matter:s("ln6QG"),MatterPhysics:s("iIWxd"),PolyDecomp:s("l2Xwu"),Sprite:s("9dw29"),TileBody:s("cRMRu"),PhysicsEditorParser:s("gInVG"),PhysicsJSONParser:s("eA2TZ"),World:s("ilxnW")}}),r("kr4xd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7SBSk"),r=new i({initialize:function(){/**
         * A Vector2 that stores the temporary bounds center value during calculations by methods in this class.
         *
         * @name Phaser.Physics.Matter.BodyBounds#boundsCenter
         * @type {Phaser.Math.Vector2}
         * @since 3.22.0
         */this.boundsCenter=new n,/**
         * A Vector2 that stores the temporary center diff values during calculations by methods in this class.
         *
         * @name Phaser.Physics.Matter.BodyBounds#centerDiff
         * @type {Phaser.Math.Vector2}
         * @since 3.22.0
         */this.centerDiff=new n},/**
     * Parses the given body to get the bounds diff values from it.
     * 
     * They're stored in this class in the temporary properties `boundsCenter` and `centerDiff`.
     * 
     * This method is called automatically by all other methods in this class.
     *
     * @method Phaser.Physics.Matter.BodyBounds#parseBody
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the bounds position from.
     *
     * @return {boolean} `true` if it was able to get the bounds, otherwise `false`.
     */parseBody:function(t){if(!(t=t.hasOwnProperty("body")?t.body:t).hasOwnProperty("bounds")||!t.hasOwnProperty("centerOfMass"))return!1;var e=this.boundsCenter,i=this.centerDiff,n=t.bounds.max.x-t.bounds.min.x,s=t.bounds.max.y-t.bounds.min.y,r=n*t.centerOfMass.x,o=s*t.centerOfMass.y;return e.set(n/2,s/2),i.set(r-e.x,o-e.y),!0},/**
     * Takes a Body and returns the world coordinates of the top-left of its _bounds_.
     * 
     * Body bounds are updated by Matter each step and factor in scale and rotation.
     * This will return the world coordinate based on the bodies _current_ position and bounds.
     *
     * @method Phaser.Physics.Matter.BodyBounds#getTopLeft
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.
     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.
     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.
     *
     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.
     */getTopLeft:function(t,e,i){if(void 0===e&&(e=0),void 0===i&&(i=0),this.parseBody(t)){var s=this.boundsCenter,r=this.centerDiff;return new n(e+s.x+r.x,i+s.y+r.y)}return!1},/**
     * Takes a Body and returns the world coordinates of the top-center of its _bounds_.
     * 
     * Body bounds are updated by Matter each step and factor in scale and rotation.
     * This will return the world coordinate based on the bodies _current_ position and bounds.
     *
     * @method Phaser.Physics.Matter.BodyBounds#getTopCenter
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.
     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.
     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.
     *
     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.
     */getTopCenter:function(t,e,i){if(void 0===e&&(e=0),void 0===i&&(i=0),this.parseBody(t)){var s=this.boundsCenter,r=this.centerDiff;return new n(e+r.x,i+s.y+r.y)}return!1},/**
     * Takes a Body and returns the world coordinates of the top-right of its _bounds_.
     * 
     * Body bounds are updated by Matter each step and factor in scale and rotation.
     * This will return the world coordinate based on the bodies _current_ position and bounds.
     *
     * @method Phaser.Physics.Matter.BodyBounds#getTopRight
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.
     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.
     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.
     *
     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.
     */getTopRight:function(t,e,i){if(void 0===e&&(e=0),void 0===i&&(i=0),this.parseBody(t)){var s=this.boundsCenter,r=this.centerDiff;return new n(e-(s.x-r.x),i+s.y+r.y)}return!1},/**
     * Takes a Body and returns the world coordinates of the left-center of its _bounds_.
     * 
     * Body bounds are updated by Matter each step and factor in scale and rotation.
     * This will return the world coordinate based on the bodies _current_ position and bounds.
     *
     * @method Phaser.Physics.Matter.BodyBounds#getLeftCenter
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.
     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.
     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.
     *
     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.
     */getLeftCenter:function(t,e,i){if(void 0===e&&(e=0),void 0===i&&(i=0),this.parseBody(t)){var s=this.boundsCenter,r=this.centerDiff;return new n(e+s.x+r.x,i+r.y)}return!1},/**
     * Takes a Body and returns the world coordinates of the center of its _bounds_.
     * 
     * Body bounds are updated by Matter each step and factor in scale and rotation.
     * This will return the world coordinate based on the bodies _current_ position and bounds.
     *
     * @method Phaser.Physics.Matter.BodyBounds#getCenter
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.
     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.
     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.
     *
     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.
     */getCenter:function(t,e,i){if(void 0===e&&(e=0),void 0===i&&(i=0),this.parseBody(t)){var s=this.centerDiff;return new n(e+s.x,i+s.y)}return!1},/**
     * Takes a Body and returns the world coordinates of the right-center of its _bounds_.
     * 
     * Body bounds are updated by Matter each step and factor in scale and rotation.
     * This will return the world coordinate based on the bodies _current_ position and bounds.
     *
     * @method Phaser.Physics.Matter.BodyBounds#getRightCenter
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.
     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.
     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.
     *
     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.
     */getRightCenter:function(t,e,i){if(void 0===e&&(e=0),void 0===i&&(i=0),this.parseBody(t)){var s=this.boundsCenter,r=this.centerDiff;return new n(e-(s.x-r.x),i+r.y)}return!1},/**
     * Takes a Body and returns the world coordinates of the bottom-left of its _bounds_.
     * 
     * Body bounds are updated by Matter each step and factor in scale and rotation.
     * This will return the world coordinate based on the bodies _current_ position and bounds.
     *
     * @method Phaser.Physics.Matter.BodyBounds#getBottomLeft
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.
     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.
     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.
     *
     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.
     */getBottomLeft:function(t,e,i){if(void 0===e&&(e=0),void 0===i&&(i=0),this.parseBody(t)){var s=this.boundsCenter,r=this.centerDiff;return new n(e+s.x+r.x,i-(s.y-r.y))}return!1},/**
     * Takes a Body and returns the world coordinates of the bottom-center of its _bounds_.
     * 
     * Body bounds are updated by Matter each step and factor in scale and rotation.
     * This will return the world coordinate based on the bodies _current_ position and bounds.
     *
     * @method Phaser.Physics.Matter.BodyBounds#getBottomCenter
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.
     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.
     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.
     *
     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.
     */getBottomCenter:function(t,e,i){if(void 0===e&&(e=0),void 0===i&&(i=0),this.parseBody(t)){var s=this.boundsCenter,r=this.centerDiff;return new n(e+r.x,i-(s.y-r.y))}return!1},/**
     * Takes a Body and returns the world coordinates of the bottom-right of its _bounds_.
     * 
     * Body bounds are updated by Matter each step and factor in scale and rotation.
     * This will return the world coordinate based on the bodies _current_ position and bounds.
     *
     * @method Phaser.Physics.Matter.BodyBounds#getBottomRight
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.
     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.
     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.
     *
     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.
     */getBottomRight:function(t,e,i){if(void 0===e&&(e=0),void 0===i&&(i=0),this.parseBody(t)){var s=this.boundsCenter,r=this.centerDiff;return new n(e-(s.x-r.x),i-(s.y-r.y))}return!1}});t.exports=r}),r("bImJl",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gY9LZ"),n=s("jwj1g"),r=s("cbd5m"),o=s("dmTql"),a=s("dmaXf"),h=s("5NLqi"),l=s("k5BpG"),u=s("9dw29"),c=s("cRMRu"),d=s("gInVG"),f=s("eA2TZ"),p=s("a7FiE"),g=s("laRjh"),v=new n({initialize:function(t){/**
         * The Matter World which this Factory adds to.
         *
         * @name Phaser.Physics.Matter.Factory#world
         * @type {Phaser.Physics.Matter.World}
         * @since 3.0.0
         */this.world=t,/**
         * The Scene which this Factory's Matter World belongs to.
         *
         * @name Phaser.Physics.Matter.Factory#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t.scene,/**
         * A reference to the Scene.Systems this Matter Physics instance belongs to.
         *
         * @name Phaser.Physics.Matter.Factory#sys
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.sys=t.scene.sys},/**
     * Creates a new rigid rectangular Body and adds it to the World.
     *
     * @method Phaser.Physics.Matter.Factory#rectangle
     * @since 3.0.0
     *
     * @param {number} x - The X coordinate of the center of the Body.
     * @param {number} y - The Y coordinate of the center of the Body.
     * @param {number} width - The width of the Body.
     * @param {number} height - The height of the Body.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     *
     * @return {MatterJS.BodyType} A Matter JS Body.
     */rectangle:function(t,e,n,s,r){var o=i.rectangle(t,e,n,s,r);return this.world.add(o),o},/**
     * Creates a new rigid trapezoidal Body and adds it to the World.
     *
     * @method Phaser.Physics.Matter.Factory#trapezoid
     * @since 3.0.0
     *
     * @param {number} x - The X coordinate of the center of the Body.
     * @param {number} y - The Y coordinate of the center of the Body.
     * @param {number} width - The width of the trapezoid Body.
     * @param {number} height - The height of the trapezoid Body.
     * @param {number} slope - The slope of the trapezoid. 0 creates a rectangle, while 1 creates a triangle. Positive values make the top side shorter, while negative values make the bottom side shorter.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     *
     * @return {MatterJS.BodyType} A Matter JS Body.
     */trapezoid:function(t,e,n,s,r,o){var a=i.trapezoid(t,e,n,s,r,o);return this.world.add(a),a},/**
     * Creates a new rigid circular Body and adds it to the World.
     *
     * @method Phaser.Physics.Matter.Factory#circle
     * @since 3.0.0
     *
     * @param {number} x - The X coordinate of the center of the Body.
     * @param {number} y - The Y coordinate of the center of the Body.
     * @param {number} radius - The radius of the circle.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     * @param {number} [maxSides] - The maximum amount of sides to use for the polygon which will approximate this circle.
     *
     * @return {MatterJS.BodyType} A Matter JS Body.
     */circle:function(t,e,n,s,r){var o=i.circle(t,e,n,s,r);return this.world.add(o),o},/**
     * Creates a new rigid polygonal Body and adds it to the World.
     *
     * @method Phaser.Physics.Matter.Factory#polygon
     * @since 3.0.0
     *
     * @param {number} x - The X coordinate of the center of the Body.
     * @param {number} y - The Y coordinate of the center of the Body.
     * @param {number} sides - The number of sides the polygon will have.
     * @param {number} radius - The "radius" of the polygon, i.e. the distance from its center to any vertex. This is also the radius of its circumcircle.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     *
     * @return {MatterJS.BodyType} A Matter JS Body.
     */polygon:function(t,e,n,s,r){var o=i.polygon(t,e,n,s,r);return this.world.add(o),o},/**
     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices) and adds it to the World.
     * If the vertices are convex, they will pass through as supplied. Otherwise, if the vertices are concave, they will be decomposed. Note that this process is not guaranteed to support complex sets of vertices, e.g. ones with holes.
     *
     * @method Phaser.Physics.Matter.Factory#fromVertices
     * @since 3.0.0
     *
     * @param {number} x - The X coordinate of the center of the Body.
     * @param {number} y - The Y coordinate of the center of the Body.
     * @param {(string|array)} vertexSets - The vertices data. Either a path string or an array of vertices.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     * @param {boolean} [flagInternal=false] - Flag internal edges (coincident part edges)
     * @param {number} [removeCollinear=0.01] - Whether Matter.js will discard collinear edges (to improve performance).
     * @param {number} [minimumArea=10] - During decomposition discard parts that have an area less than this.
     *
     * @return {MatterJS.BodyType} A Matter JS Body.
     */fromVertices:function(t,e,n,s,r,o,a){"string"==typeof n&&(n=g.fromPath(n));var h=i.fromVertices(t,e,n,s,r,o,a);return this.world.add(h),h},/**
     * Creates a body using data exported from the application PhysicsEditor (https://www.codeandweb.com/physicseditor)
     * 
     * The PhysicsEditor file should be loaded as JSON:
     * 
     * ```javascript
     * preload ()
     * {
     *   this.load.json('vehicles', 'assets/vehicles.json);
     * }
     * 
     * create ()
     * {
     *   const vehicleShapes = this.cache.json.get('vehicles');
     *   this.matter.add.fromPhysicsEditor(400, 300, vehicleShapes.truck);
     * }
     * ```
     * 
     * Do not pass the entire JSON file to this method, but instead pass one of the shapes contained within it.
     * 
     * If you pas in an `options` object, any settings in there will override those in the PhysicsEditor config object.
     *
     * @method Phaser.Physics.Matter.Factory#fromPhysicsEditor
     * @since 3.22.0
     *
     * @param {number} x - The horizontal world location of the body.
     * @param {number} y - The vertical world location of the body.
     * @param {any} config - The JSON data exported from PhysicsEditor.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     * @param {boolean} [addToWorld=true] - Should the newly created body be immediately added to the World?
     *
     * @return {MatterJS.BodyType} A Matter JS Body.
     */fromPhysicsEditor:function(t,e,i,n,s){void 0===s&&(s=!0);var r=d.parseBody(t,e,i,n);return s&&!this.world.has(r)&&this.world.add(r),r},/**
     * Creates a body using the path data from an SVG file.
     * 
     * SVG Parsing requires the pathseg polyfill from https://github.com/progers/pathseg
     * 
     * The SVG file should be loaded as XML, as this method requires the ability to extract
     * the path data from it. I.e.:
     * 
     * ```javascript
     * preload ()
     * {
     *   this.load.xml('face', 'assets/face.svg);
     * }
     * 
     * create ()
     * {
     *   this.matter.add.fromSVG(400, 300, this.cache.xml.get('face'));
     * }
     * ```
     *
     * @method Phaser.Physics.Matter.Factory#fromSVG
     * @since 3.22.0
     *
     * @param {number} x - The X coordinate of the body.
     * @param {number} y - The Y coordinate of the body.
     * @param {object} xml - The SVG Path data.
     * @param {number} [scale=1] - Scale the vertices by this amount after creation.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     * @param {boolean} [addToWorld=true] - Should the newly created body be immediately added to the World?
     *
     * @return {MatterJS.BodyType} A Matter JS Body.
     */fromSVG:function(t,e,n,s,r,o){void 0===s&&(s=1),void 0===r&&(r={}),void 0===o&&(o=!0);for(var h=n.getElementsByTagName("path"),l=[],u=0;u<h.length;u++){var c=a.pathToVertices(h[u],30);1!==s&&g.scale(c,s,s),l.push(c)}var d=i.fromVertices(t,e,l,r);return o&&this.world.add(d),d},/**
     * Creates a body using the supplied physics data, as provided by a JSON file.
     * 
     * The data file should be loaded as JSON:
     * 
     * ```javascript
     * preload ()
     * {
     *   this.load.json('ninjas', 'assets/ninjas.json);
     * }
     * 
     * create ()
     * {
     *   const ninjaShapes = this.cache.json.get('ninjas');
     * 
     *   this.matter.add.fromJSON(400, 300, ninjaShapes.shinobi);
     * }
     * ```
     * 
     * Do not pass the entire JSON file to this method, but instead pass one of the shapes contained within it.
     * 
     * If you pas in an `options` object, any settings in there will override those in the config object.
     * 
     * The structure of the JSON file is as follows:
     * 
     * ```text
     * {
     *   'generator_info': // The name of the application that created the JSON data
     *   'shapeName': {
     *     'type': // The type of body
     *     'label': // Optional body label
     *     'vertices': // An array, or an array of arrays, containing the vertex data in x/y object pairs
     *   }
     * }
     * ```
     * 
     * At the time of writing, only the Phaser Physics Tracer App exports in this format.
     *
     * @method Phaser.Physics.Matter.Factory#fromJSON
     * @since 3.22.0
     *
     * @param {number} x - The X coordinate of the body.
     * @param {number} y - The Y coordinate of the body.
     * @param {any} config - The JSON physics data.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     * @param {boolean} [addToWorld=true] - Should the newly created body be immediately added to the World?
     *
     * @return {MatterJS.BodyType} A Matter JS Body.
     */fromJSON:function(t,e,i,n,s){void 0===n&&(n={}),void 0===s&&(s=!0);var r=f.parseBody(t,e,i,n);return r&&s&&this.world.add(r),r},/**
     * Create a new composite containing Matter Image objects created in a grid arrangement.
     * This function uses the body bounds to prevent overlaps.
     *
     * @method Phaser.Physics.Matter.Factory#imageStack
     * @since 3.0.0
     *
     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param {(string|integer)} frame - An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.
     * @param {number} x - The horizontal position of this composite in the world.
     * @param {number} y - The vertical position of this composite in the world.
     * @param {number} columns - The number of columns in the grid.
     * @param {number} rows - The number of rows in the grid.
     * @param {number} [columnGap=0] - The distance between each column.
     * @param {number} [rowGap=0] - The distance between each row.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     *
     * @return {MatterJS.CompositeType} A Matter JS Composite Stack.
     */imageStack:function(t,e,i,n,s,o,a,h,u){void 0===a&&(a=0),void 0===h&&(h=0),void 0===u&&(u={});var c=this.world,d=this.sys.displayList;u.addToWorld=!1;var f=r.stack(i,n,s,o,a,h,function(i,n){var s=new l(c,i,n,t,e,u);return d.add(s),s.body});return c.add(f),f},/**
     * Create a new composite containing bodies created in the callback in a grid arrangement.
     * 
     * This function uses the body bounds to prevent overlaps.
     *
     * @method Phaser.Physics.Matter.Factory#stack
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of this composite in the world.
     * @param {number} y - The vertical position of this composite in the world.
     * @param {number} columns - The number of columns in the grid.
     * @param {number} rows - The number of rows in the grid.
     * @param {number} columnGap - The distance between each column.
     * @param {number} rowGap - The distance between each row.
     * @param {function} callback - The callback that creates the stack.
     *
     * @return {MatterJS.CompositeType} A new composite containing objects created in the callback.
     */stack:function(t,e,i,n,s,o,a){var h=r.stack(t,e,i,n,s,o,a);return this.world.add(h),h},/**
     * Create a new composite containing bodies created in the callback in a pyramid arrangement.
     * This function uses the body bounds to prevent overlaps.
     *
     * @method Phaser.Physics.Matter.Factory#pyramid
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of this composite in the world.
     * @param {number} y - The vertical position of this composite in the world.
     * @param {number} columns - The number of columns in the pyramid.
     * @param {number} rows - The number of rows in the pyramid.
     * @param {number} columnGap - The distance between each column.
     * @param {number} rowGap - The distance between each row.
     * @param {function} callback - The callback function to be invoked.
     *
     * @return {MatterJS.CompositeType} A Matter JS Composite pyramid.
     */pyramid:function(t,e,i,n,s,o,a){var h=r.pyramid(t,e,i,n,s,o,a);return this.world.add(h),h},/**
     * Chains all bodies in the given composite together using constraints.
     *
     * @method Phaser.Physics.Matter.Factory#chain
     * @since 3.0.0
     *
     * @param {MatterJS.CompositeType} composite - The composite in which all bodies will be chained together sequentially.
     * @param {number} xOffsetA - The horizontal offset of the BodyA constraint. This is a percentage based on the body size, not a world position.
     * @param {number} yOffsetA - The vertical offset of the BodyA constraint. This is a percentage based on the body size, not a world position.
     * @param {number} xOffsetB - The horizontal offset of the BodyB constraint. This is a percentage based on the body size, not a world position.
     * @param {number} yOffsetB - The vertical offset of the BodyB constraint. This is a percentage based on the body size, not a world position.
     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.
     *
     * @return {MatterJS.CompositeType} The original composite that was passed to this method.
     */chain:function(t,e,i,n,s,o){return r.chain(t,e,i,n,s,o)},/**
     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
     *
     * @method Phaser.Physics.Matter.Factory#mesh
     * @since 3.0.0
     *
     * @param {MatterJS.CompositeType} composite - The composite in which all bodies will be chained together.
     * @param {number} columns - The number of columns in the mesh.
     * @param {number} rows - The number of rows in the mesh.
     * @param {boolean} crossBrace - Create cross braces for the mesh as well?
     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.
     *
     * @return {MatterJS.CompositeType} The original composite that was passed to this method.
     */mesh:function(t,e,i,n,s){return r.mesh(t,e,i,n,s)},/**
     * Creates a composite with a Newton's Cradle setup of bodies and constraints.
     *
     * @method Phaser.Physics.Matter.Factory#newtonsCradle
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of the start of the cradle.
     * @param {number} y - The vertical position of the start of the cradle.
     * @param {number} number - The number of balls in the cradle.
     * @param {number} size - The radius of each ball in the cradle.
     * @param {number} length - The length of the 'string' the balls hang from.
     *
     * @return {MatterJS.CompositeType} A Newton's cradle composite.
     */newtonsCradle:function(t,e,i,n,s){var o=r.newtonsCradle(t,e,i,n,s);return this.world.add(o),o},/**
     * Creates a composite with simple car setup of bodies and constraints.
     *
     * @method Phaser.Physics.Matter.Factory#car
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of the car in the world.
     * @param {number} y - The vertical position of the car in the world.
     * @param {number} width - The width of the car chasis.
     * @param {number} height - The height of the car chasis.
     * @param {number} wheelSize - The radius of the car wheels.
     *
     * @return {MatterJS.CompositeType} A new composite car body.
     */car:function(t,e,i,n,s){var o=r.car(t,e,i,n,s);return this.world.add(o),o},/**
     * Creates a simple soft body like object.
     *
     * @method Phaser.Physics.Matter.Factory#softBody
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of this composite in the world.
     * @param {number} y - The vertical position of this composite in the world.
     * @param {number} columns - The number of columns in the Composite.
     * @param {number} rows - The number of rows in the Composite.
     * @param {number} columnGap - The distance between each column.
     * @param {number} rowGap - The distance between each row.
     * @param {boolean} crossBrace - `true` to create cross braces between the bodies, or `false` to create just straight braces.
     * @param {number} particleRadius - The radius of this circlular composite.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [particleOptions] - An optional Body configuration object that is used to set initial Body properties on creation.
     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [constraintOptions] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.
     *
     * @return {MatterJS.CompositeType} A new composite simple soft body.
     */softBody:function(t,e,i,n,s,o,a,h,l,u){var c=r.softBody(t,e,i,n,s,o,a,h,l,u);return this.world.add(c),c},/**
     * This method is an alias for `Factory.constraint`.
     * 
     * Constraints (or joints) are used for specifying that a fixed distance must be maintained
     * between two bodies, or a body and a fixed world-space position.
     * 
     * The stiffness of constraints can be modified to create springs or elastic.
     * 
     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness`
     * value (e.g. `0.7` or above).
     * 
     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing
     * `constraintIterations` within the Matter Config.
     * 
     * For compound bodies, constraints must be applied to the parent body and not one of its parts.
     *
     * @method Phaser.Physics.Matter.Factory#joint
     * @since 3.0.0
     *
     * @param {MatterJS.BodyType} bodyA - The first possible `Body` that this constraint is attached to.
     * @param {MatterJS.BodyType} bodyB - The second possible `Body` that this constraint is attached to.
     * @param {number} [length] - A Number that specifies the target resting length of the constraint. If not given it is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.
     * @param {number} [stiffness=1] - A Number that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`. A value of `1` means the constraint should be very stiff. A value of `0.2` means the constraint acts as a soft spring.
     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.
     *
     * @return {MatterJS.ConstraintType} A Matter JS Constraint.
     */joint:function(t,e,i,n,s){return this.constraint(t,e,i,n,s)},/**
     * This method is an alias for `Factory.constraint`.
     * 
     * Constraints (or joints) are used for specifying that a fixed distance must be maintained
     * between two bodies, or a body and a fixed world-space position.
     * 
     * The stiffness of constraints can be modified to create springs or elastic.
     * 
     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness`
     * value (e.g. `0.7` or above).
     * 
     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing
     * `constraintIterations` within the Matter Config.
     * 
     * For compound bodies, constraints must be applied to the parent body and not one of its parts.
     *
     * @method Phaser.Physics.Matter.Factory#spring
     * @since 3.0.0
     *
     * @param {MatterJS.BodyType} bodyA - The first possible `Body` that this constraint is attached to.
     * @param {MatterJS.BodyType} bodyB - The second possible `Body` that this constraint is attached to.
     * @param {number} [length] - A Number that specifies the target resting length of the constraint. If not given it is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.
     * @param {number} [stiffness=1] - A Number that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`. A value of `1` means the constraint should be very stiff. A value of `0.2` means the constraint acts as a soft spring.
     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.
     *
     * @return {MatterJS.ConstraintType} A Matter JS Constraint.
     */spring:function(t,e,i,n,s){return this.constraint(t,e,i,n,s)},/**
     * Constraints (or joints) are used for specifying that a fixed distance must be maintained
     * between two bodies, or a body and a fixed world-space position.
     * 
     * The stiffness of constraints can be modified to create springs or elastic.
     * 
     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness`
     * value (e.g. `0.7` or above).
     * 
     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing
     * `constraintIterations` within the Matter Config.
     * 
     * For compound bodies, constraints must be applied to the parent body and not one of its parts.
     *
     * @method Phaser.Physics.Matter.Factory#constraint
     * @since 3.0.0
     *
     * @param {MatterJS.BodyType} bodyA - The first possible `Body` that this constraint is attached to.
     * @param {MatterJS.BodyType} bodyB - The second possible `Body` that this constraint is attached to.
     * @param {number} [length] - A Number that specifies the target resting length of the constraint. If not given it is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.
     * @param {number} [stiffness=1] - A Number that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`. A value of `1` means the constraint should be very stiff. A value of `0.2` means the constraint acts as a soft spring.
     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.
     *
     * @return {MatterJS.ConstraintType} A Matter JS Constraint.
     */constraint:function(t,e,i,n,s){void 0===n&&(n=1),void 0===s&&(s={}),s.bodyA="body"===t.type?t:t.body,s.bodyB="body"===e.type?e:e.body,isNaN(i)||(s.length=i),s.stiffness=n;var r=o.create(s);return this.world.add(r),r},/**
     * Constraints (or joints) are used for specifying that a fixed distance must be maintained
     * between two bodies, or a body and a fixed world-space position.
     * 
     * A world constraint has only one body, you should specify a `pointA` position in
     * the constraint options parameter to attach the constraint to the world.
     * 
     * The stiffness of constraints can be modified to create springs or elastic.
     * 
     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness`
     * value (e.g. `0.7` or above).
     * 
     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing
     * `constraintIterations` within the Matter Config.
     * 
     * For compound bodies, constraints must be applied to the parent body and not one of its parts.
     *
     * @method Phaser.Physics.Matter.Factory#worldConstraint
     * @since 3.0.0
     *
     * @param {MatterJS.BodyType} body - The Matter `Body` that this constraint is attached to.
     * @param {number} [length] - A number that specifies the target resting length of the constraint. If not given it is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.
     * @param {number} [stiffness=1] - A Number that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`. A value of `1` means the constraint should be very stiff. A value of `0.2` means the constraint acts as a soft spring.
     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.
     *
     * @return {MatterJS.ConstraintType} A Matter JS Constraint.
     */worldConstraint:function(t,e,i,n){void 0===i&&(i=1),void 0===n&&(n={}),n.bodyB="body"===t.type?t:t.body,isNaN(e)||(n.length=e),n.stiffness=i;var s=o.create(n);return this.world.add(s),s},/**
     * This method is an alias for `Factory.pointerConstraint`.
     * 
     * A Pointer Constraint is a special type of constraint that allows you to click
     * and drag bodies in a Matter World. It monitors the active Pointers in a Scene,
     * and when one is pressed down it checks to see if that hit any part of any active
     * body in the world. If it did, and the body has input enabled, it will begin to
     * drag it until either released, or you stop it via the `stopDrag` method.
     * 
     * You can adjust the stiffness, length and other properties of the constraint via
     * the `options` object on creation.
     *
     * @method Phaser.Physics.Matter.Factory#mouseSpring
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.
     *
     * @return {MatterJS.ConstraintType} A Matter JS Constraint.
     */mouseSpring:function(t){return this.pointerConstraint(t)},/**
     * A Pointer Constraint is a special type of constraint that allows you to click
     * and drag bodies in a Matter World. It monitors the active Pointers in a Scene,
     * and when one is pressed down it checks to see if that hit any part of any active
     * body in the world. If it did, and the body has input enabled, it will begin to
     * drag it until either released, or you stop it via the `stopDrag` method.
     * 
     * You can adjust the stiffness, length and other properties of the constraint via
     * the `options` object on creation.
     *
     * @method Phaser.Physics.Matter.Factory#pointerConstraint
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.
     *
     * @return {MatterJS.ConstraintType} A Matter JS Constraint.
     */pointerConstraint:function(t){void 0===t&&(t={}),t.hasOwnProperty("render")||(t.render={visible:!1});var e=new p(this.scene,this.world,t);return this.world.add(e.constraint),e},/**
     * Creates a Matter Physics Image Game Object.
     * 
     * An Image is a light-weight Game Object useful for the display of static images in your game,
     * such as logos, backgrounds, scenery or other non-animated elements. Images can have input
     * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an
     * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.
     *
     * @method Phaser.Physics.Matter.Factory#image
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of this Game Object in the world.
     * @param {number} y - The vertical position of this Game Object in the world.
     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     *
     * @return {Phaser.Physics.Matter.Image} The Matter Image Game Object.
     */image:function(t,e,i,n,s){var r=new l(this.world,t,e,i,n,s);return this.sys.displayList.add(r),r},/**
     * Creates a wrapper around a Tile that provides access to a corresponding Matter body. A tile can only
     * have one Matter body associated with it. You can either pass in an existing Matter body for
     * the tile or allow the constructor to create the corresponding body for you. If the Tile has a
     * collision group (defined in Tiled), those shapes will be used to create the body. If not, the
     * tile's rectangle bounding box will be used.
     *
     * The corresponding body will be accessible on the Tile itself via Tile.physics.matterBody.
     *
     * Note: not all Tiled collision shapes are supported. See
     * Phaser.Physics.Matter.TileBody#setFromTileCollision for more information.
     *
     * @method Phaser.Physics.Matter.Factory#tileBody
     * @since 3.0.0
     *
     * @param {Phaser.Tilemaps.Tile} tile - The target tile that should have a Matter body.
     * @param {Phaser.Types.Physics.Matter.MatterTileOptions} [options] - Options to be used when creating the Matter body.
     *
     * @return {Phaser.Physics.Matter.TileBody} The Matter Tile Body Game Object.
     */tileBody:function(t,e){return new c(this.world,t,e)},/**
     * Creates a Matter Physics Sprite Game Object.
     *
     * A Sprite Game Object is used for the display of both static and animated images in your game.
     * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled
     * and animated.
     *
     * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.
     * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation
     * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.
     *
     * @method Phaser.Physics.Matter.Factory#sprite
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of this Game Object in the world.
     * @param {number} y - The vertical position of this Game Object in the world.
     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     *
     * @return {Phaser.Physics.Matter.Sprite} The Matter Sprite Game Object.
     */sprite:function(t,e,i,n,s){var r=new u(this.world,t,e,i,n,s);return this.sys.displayList.add(r),this.sys.updateList.add(r),r},/**
     * Takes an existing Game Object and injects all of the Matter Components into it.
     * 
     * This enables you to use component methods such as `setVelocity` or `isSensor` directly from
     * this Game Object.
     * 
     * You can also pass in either a Matter Body Configuration object, or a Matter Body instance
     * to link with this Game Object.
     *
     * @method Phaser.Physics.Matter.Factory#gameObject
     * @since 3.3.0
     *
     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to inject the Matter Components in to.
     * @param {(Phaser.Types.Physics.Matter.MatterBodyConfig|MatterJS.Body)} [options] - A Matter Body configuration object, or an instance of a Matter Body.
     * @param {boolean} [addToWorld=true] - Add this Matter Body to the World?
     *
     * @return {Phaser.GameObjects.GameObject} The Game Object that had the Matter Components injected into it.
     */gameObject:function(t,e,i){return h(this.world,t,e,i)},/**
     * Destroys this Factory.
     *
     * @method Phaser.Physics.Matter.Factory#destroy
     * @since 3.5.0
     */destroy:function(){this.world=null,this.scene=null,this.sys=null}});t.exports=v}),r("gY9LZ",function(t,e){/**
* The `Matter.Bodies` module contains factory methods for creating rigid body models 
* with commonly used body configurations (such as rectangles, circles and other polygons).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Bodies
*/// TODO: true circle bodies
var i={};t.exports=i;var n=s("laRjh"),r=s("4tPKt"),o=s("lMiYr"),a=s("6V4ls"),h=s("a7bN0"),l=s("l2Xwu");/**
     * Creates a new rigid body model with a rectangle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method rectangle
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {object} [options]
     * @return {body} A new rectangle body
     */i.rectangle=function(t,e,i,s,a){a=a||{};var h={label:"Rectangle Body",position:{x:t,y:e},vertices:n.fromPath("L 0 0 L "+i+" 0 L "+i+" "+s+" L 0 "+s)};if(a.chamfer){var l=a.chamfer;h.vertices=n.chamfer(h.vertices,l.radius,l.quality,l.qualityMin,l.qualityMax),delete a.chamfer}return o.create(r.extend({},h,a))},/**
     * Creates a new rigid body model with a trapezoid hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method trapezoid
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} slope
     * @param {object} [options]
     * @return {body} A new trapezoid body
     */i.trapezoid=function(t,e,i,s,a,h){h=h||{};var l,u=(1-2*(a*=.5))*i,c=i*a,d=c+u,f=d+c;l=a<.5?"L 0 0 L "+c+" "+-s+" L "+d+" "+-s+" L "+f+" 0":"L 0 0 L "+d+" "+-s+" L "+f+" 0";var p={label:"Trapezoid Body",position:{x:t,y:e},vertices:n.fromPath(l)};if(h.chamfer){var g=h.chamfer;p.vertices=n.chamfer(p.vertices,g.radius,g.quality,g.qualityMin,g.qualityMax),delete h.chamfer}return o.create(r.extend({},p,h))},/**
     * Creates a new rigid body model with a circle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method circle
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {object} [options]
     * @param {number} [maxSides]
     * @return {body} A new circle body
     */i.circle=function(t,e,n,s,o){s=s||{};var a=Math.ceil(Math.max(10,Math.min(// approximate circles with polygons until true circles implemented in SAT
o=o||25,n)));return a%2==1&&(a+=1),i.polygon(t,e,a,n,r.extend({},{label:"Circle Body",circleRadius:n},s))},/**
     * Creates a new rigid body model with a regular polygon hull with the given number of sides. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method polygon
     * @param {number} x
     * @param {number} y
     * @param {number} sides
     * @param {number} radius
     * @param {object} [options]
     * @return {body} A new regular polygon body
     */i.polygon=function(t,e,s,a,h){if(h=h||{},s<3)return i.circle(t,e,a,h);for(var l=2*Math.PI/s,u="",c=.5*l,d=0;d<s;d+=1){var f=c+d*l,p=Math.cos(f)*a,g=Math.sin(f)*a;u+="L "+p.toFixed(3)+" "+g.toFixed(3)+" "}var v={label:"Polygon Body",position:{x:t,y:e},vertices:n.fromPath(u)};if(h.chamfer){var m=h.chamfer;v.vertices=n.chamfer(v.vertices,m.radius,m.quality,m.qualityMin,m.qualityMax),delete h.chamfer}return o.create(r.extend({},v,h))},/**
     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).
     * If the vertices are convex, they will pass through as supplied.
     * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.
     * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).
     * By default the decomposition will discard collinear edges (to improve performance).
     * It can also optionally discard any parts that have an area less than `minimumArea`.
     * If the vertices can not be decomposed, the result will fall back to using the convex hull.
     * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method fromVertices
     * @param {number} x
     * @param {number} y
     * @param [[vector]] vertexSets
     * @param {object} [options]
     * @param {bool} [flagInternal=false]
     * @param {number} [removeCollinear=0.01]
     * @param {number} [minimumArea=10]
     * @return {body}
     */i.fromVertices=function(t,e,s,a,h,u,c){var d,f,p,g,v,m;for(a=a||{},f=[],h=void 0!==h&&h,u=void 0!==u?u:.01,c=void 0!==c?c:10,l||r.warn("Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull."),r.isArray(s[0])||(s=[s]),m=0;m<s.length;m+=1)if(g=s[m],(p=n.isConvex(g))||!l)g=p?n.clockwiseSort(g):n.hull(g),f.push({position:{x:t,y:e},vertices:g});else{// initialise a decomposition
var y=g.map(function(t){return[t.x,t.y]});// vertices are concave and simple, we can decompose into parts
l.makeCCW(y),!1!==u&&l.removeCollinearPoints(y,u);// use the quick decomposition algorithm (Bayazit)
var x=l.quickDecomp(y);// for each decomposed chunk
for(v=0;v<x.length;v++){// convert vertices into the correct structure
var w=x[v].map(function(t){return{x:t[0],y:t[1]}});// skip small chunks
c>0&&n.area(w)<c||// create a compound part
f.push({position:n.centre(w),vertices:w})}}// create body parts
for(v=0;v<f.length;v++)f[v]=o.create(r.extend(f[v],a));return(h&&i.flagCoincidentParts(f,5),f.length>1)?(// create the parent body to be returned, that contains generated compound parts
d=o.create(r.extend({parts:f.slice(0)},a)),o.setPosition(d,{x:t,y:e}),d):f[0]},/**
     * Takes an array of Body objects and flags all internal edges (coincident parts) based on the maxDistance
     * value. The array is changed in-place and returned, so you can pass this function a `Body.parts` property.
     * 
     * @method flagCoincidentParts
     * @param {body[]} parts - The Body parts, or array of bodies, to flag.
     * @param {number} [maxDistance=5]
     * @return {body[]} The modified `parts` parameter.
     */i.flagCoincidentParts=function(t,e){void 0===e&&(e=5);for(var i=0;i<t.length;i++)for(var n=t[i],s=i+1;s<t.length;s++){var r=t[s];if(a.overlaps(n.bounds,r.bounds))// iterate vertices of both parts
for(var o=n.vertices,l=r.vertices,u=0;u<n.vertices.length;u++)for(var c=0;c<r.vertices.length;c++){// find distances between the vertices
var d=h.magnitudeSquared(h.sub(o[(u+1)%o.length],l[c])),f=h.magnitudeSquared(h.sub(o[u],l[(c+1)%l.length]));// if both vertices are very close, consider the edge concident (internal)
d<e&&f<e&&(o[u].isInternal=!0,l[c].isInternal=!0)}}return t}}),r("laRjh",function(t,e){/**
* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vertices
*/var i={};t.exports=i;var n=s("a7bN0"),r=s("4tPKt");/**
     * Creates a new set of `Matter.Body` compatible vertices.
     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,
     * but with some additional references required for efficient collision detection routines.
     *
     * Vertices must be specified in clockwise order.
     *
     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.
     *
     * @method create
     * @param {vector[]} points
     * @param {body} body
     */i.create=function(t,e){for(var i=[],n=0;n<t.length;n++){var s=t[n],r={x:s.x,y:s.y,index:n,body:e,isInternal:!1,contact:null,offset:null};r.contact={vertex:r,normalImpulse:0,tangentImpulse:0},i.push(r)}return i},/**
     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), 
     * into a `Matter.Vertices` object for the given `Matter.Body`.
     * For parsing SVG paths, see `Svg.pathToVertices`.
     * @method fromPath
     * @param {string} path
     * @param {body} body
     * @return {vertices} vertices
     */i.fromPath=function(t,e){var n=[];return t.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig,function(t,e,i){n.push({x:parseFloat(e),y:parseFloat(i)})}),i.create(n,e)},/**
     * Returns the centre (centroid) of the set of vertices.
     * @method centre
     * @param {vertices} vertices
     * @return {vector} The centre point
     */i.centre=function(t){for(var e,s,r,o=i.area(t,!0),a={x:0,y:0},h=0;h<t.length;h++)r=(h+1)%t.length,e=n.cross(t[h],t[r]),s=n.mult(n.add(t[h],t[r]),e),a=n.add(a,s);return n.div(a,6*o)},/**
     * Returns the average (mean) of the set of vertices.
     * @method mean
     * @param {vertices} vertices
     * @return {vector} The average point
     */i.mean=function(t){for(var e={x:0,y:0},i=0;i<t.length;i++)e.x+=t[i].x,e.y+=t[i].y;return n.div(e,t.length)},/**
     * Returns the area of the set of vertices.
     * @method area
     * @param {vertices} vertices
     * @param {bool} signed
     * @return {number} The area
     */i.area=function(t,e){for(var i=0,n=t.length-1,s=0;s<t.length;s++)i+=(t[n].x-t[s].x)*(t[n].y+t[s].y),n=s;return e?i/2:Math.abs(i)/2},/**
     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.
     * @method inertia
     * @param {vertices} vertices
     * @param {number} mass
     * @return {number} The polygon's moment of inertia
     */i.inertia=function(t,e){// find the polygon's moment of inertia, using second moment of area
// from equations at http://www.physicsforums.com/showthread.php?t=25293
for(var i,s,r=0,o=0,a=0;a<t.length;a++)s=(a+1)%t.length,r+=(i=Math.abs(n.cross(t[s],t[a])))*(n.dot(t[s],t[s])+n.dot(t[s],t[a])+n.dot(t[a],t[a])),o+=i;return e/6*(r/o)},/**
     * Translates the set of vertices in-place.
     * @method translate
     * @param {vertices} vertices
     * @param {vector} vector
     * @param {number} scalar
     */i.translate=function(t,e,i){var n;if(i)for(n=0;n<t.length;n++)t[n].x+=e.x*i,t[n].y+=e.y*i;else for(n=0;n<t.length;n++)t[n].x+=e.x,t[n].y+=e.y;return t},/**
     * Rotates the set of vertices in-place.
     * @method rotate
     * @param {vertices} vertices
     * @param {number} angle
     * @param {vector} point
     */i.rotate=function(t,e,i){if(0!==e){for(var n=Math.cos(e),s=Math.sin(e),r=0;r<t.length;r++){var o=t[r],a=o.x-i.x,h=o.y-i.y;o.x=i.x+(a*n-h*s),o.y=i.y+(a*s+h*n)}return t}},/**
     * Returns `true` if the `point` is inside the set of `vertices`.
     * @method contains
     * @param {vertices} vertices
     * @param {vector} point
     * @return {boolean} True if the vertices contains point, otherwise false
     */i.contains=function(t,e){for(var i=0;i<t.length;i++){var n=t[i],s=t[(i+1)%t.length];if((e.x-n.x)*(s.y-n.y)+(e.y-n.y)*(n.x-s.x)>0)return!1}return!0},/**
     * Scales the vertices from a point (default is centre) in-place.
     * @method scale
     * @param {vertices} vertices
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     */i.scale=function(t,e,s,r){if(1===e&&1===s)return t;r=r||i.centre(t);for(var o,a,h=0;h<t.length;h++)o=t[h],a=n.sub(o,r),t[h].x=r.x+a.x*e,t[h].y=r.y+a.y*s;return t},/**
     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.
     * The radius parameter is a single number or an array to specify the radius for each vertex.
     * @method chamfer
     * @param {vertices} vertices
     * @param {number[]} radius
     * @param {number} quality
     * @param {number} qualityMin
     * @param {number} qualityMax
     */i.chamfer=function(t,e,i,s,o){e="number"==typeof e?[e]:e||[8],// quality defaults to -1, which is auto
i=void 0!==i?i:-1,s=s||2,o=o||14;for(var a=[],h=0;h<t.length;h++){var l=t[h-1>=0?h-1:t.length-1],u=t[h],c=t[(h+1)%t.length],d=e[h<e.length?h:e.length-1];if(0===d){a.push(u);continue}var f=n.normalise({x:u.y-l.y,y:l.x-u.x}),p=n.normalise({x:c.y-u.y,y:u.x-c.x}),g=Math.sqrt(2*Math.pow(d,2)),v=n.mult(r.clone(f),d),m=n.normalise(n.mult(n.add(f,p),.5)),y=n.sub(u,n.mult(m,g)),x=i;-1===i&&(x=1.75*Math.pow(d,.32)),(x=r.clamp(x,s,o))%2==1&&(x+=1);for(var w=Math.acos(n.dot(f,p))/x,T=0;T<x;T++)a.push(n.add(n.rotate(v,w*T),y))}return a},/**
     * Sorts the input vertices into clockwise order in place.
     * @method clockwiseSort
     * @param {vertices} vertices
     * @return {vertices} vertices
     */i.clockwiseSort=function(t){var e=i.mean(t);return t.sort(function(t,i){return n.angle(e,t)-n.angle(e,i)}),t},/**
     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).
     * @method isConvex
     * @param {vertices} vertices
     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).
     */i.isConvex=function(t){// http://paulbourke.net/geometry/polygonmesh/
// Copyright (c) Paul Bourke (use permitted)
var e,i,n,s,r=0,o=t.length;if(o<3)return null;for(e=0;e<o;e++)if(i=(e+1)%o,n=(e+2)%o,(s=(t[i].x-t[e].x)*(t[n].y-t[i].y)-(t[i].y-t[e].y)*(t[n].x-t[i].x))<0?r|=1:s>0&&(r|=2),3===r)return!1;return 0!==r||null},/**
     * Returns the convex hull of the input vertices as a new array of points.
     * @method hull
     * @param {vertices} vertices
     * @return [vertex] vertices
     */i.hull=function(t){// http://geomalgorithms.com/a10-_hull-1.html
var e,i,s=[],r=[];// build lower hull
for(// sort vertices on x-axis (y-axis for ties)
(t=t.slice(0)).sort(function(t,e){var i=t.x-e.x;return 0!==i?i:t.y-e.y}),i=0;i<t.length;i+=1){for(e=t[i];r.length>=2&&0>=n.cross3(r[r.length-2],r[r.length-1],e);)r.pop();r.push(e)}// build upper hull
for(i=t.length-1;i>=0;i-=1){for(e=t[i];s.length>=2&&0>=n.cross3(s[s.length-2],s[s.length-1],e);)s.pop();s.push(e)}return(// concatenation of the lower and upper hulls gives the convex hull
// omit last points because they are repeated at the beginning of the other list
s.pop(),r.pop(),s.concat(r))}}),r("a7bN0",function(t,e){/**
* The `Matter.Vector` module contains methods for creating and manipulating vectors.
* Vectors are the basis of all the geometry related operations in the engine.
* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vector
*/// TODO: consider params for reusing vector objects
var i={};t.exports=i,/**
     * Creates a new vector.
     * @method create
     * @param {number} x
     * @param {number} y
     * @return {vector} A new vector
     */i.create=function(t,e){return{x:t||0,y:e||0}},/**
     * Returns a new vector with `x` and `y` copied from the given `vector`.
     * @method clone
     * @param {vector} vector
     * @return {vector} A new cloned vector
     */i.clone=function(t){return{x:t.x,y:t.y}},/**
     * Returns the magnitude (length) of a vector.
     * @method magnitude
     * @param {vector} vector
     * @return {number} The magnitude of the vector
     */i.magnitude=function(t){return Math.sqrt(t.x*t.x+t.y*t.y)},/**
     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).
     * @method magnitudeSquared
     * @param {vector} vector
     * @return {number} The squared magnitude of the vector
     */i.magnitudeSquared=function(t){return t.x*t.x+t.y*t.y},/**
     * Rotates the vector about (0, 0) by specified angle.
     * @method rotate
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} [output]
     * @return {vector} The vector rotated about (0, 0)
     */i.rotate=function(t,e,i){var n=Math.cos(e),s=Math.sin(e);i||(i={});var r=t.x*n-t.y*s;return i.y=t.x*s+t.y*n,i.x=r,i},/**
     * Rotates the vector about a specified point by specified angle.
     * @method rotateAbout
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} point
     * @param {vector} [output]
     * @return {vector} A new vector rotated about the point
     */i.rotateAbout=function(t,e,i,n){var s=Math.cos(e),r=Math.sin(e);n||(n={});var o=i.x+((t.x-i.x)*s-(t.y-i.y)*r);return n.y=i.y+((t.x-i.x)*r+(t.y-i.y)*s),n.x=o,n},/**
     * Normalises a vector (such that its magnitude is `1`).
     * @method normalise
     * @param {vector} vector
     * @return {vector} A new vector normalised
     */i.normalise=function(t){var e=i.magnitude(t);return 0===e?{x:0,y:0}:{x:t.x/e,y:t.y/e}},/**
     * Returns the dot-product of two vectors.
     * @method dot
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The dot product of the two vectors
     */i.dot=function(t,e){return t.x*e.x+t.y*e.y},/**
     * Returns the cross-product of two vectors.
     * @method cross
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The cross product of the two vectors
     */i.cross=function(t,e){return t.x*e.y-t.y*e.x},/**
     * Returns the cross-product of three vectors.
     * @method cross3
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} vectorC
     * @return {number} The cross product of the three vectors
     */i.cross3=function(t,e,i){return(e.x-t.x)*(i.y-t.y)-(e.y-t.y)*(i.x-t.x)},/**
     * Adds the two vectors.
     * @method add
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB added
     */i.add=function(t,e,i){return i||(i={}),i.x=t.x+e.x,i.y=t.y+e.y,i},/**
     * Subtracts the two vectors.
     * @method sub
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB subtracted
     */i.sub=function(t,e,i){return i||(i={}),i.x=t.x-e.x,i.y=t.y-e.y,i},/**
     * Multiplies a vector and a scalar.
     * @method mult
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector multiplied by scalar
     */i.mult=function(t,e){return{x:t.x*e,y:t.y*e}},/**
     * Divides a vector and a scalar.
     * @method div
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector divided by scalar
     */i.div=function(t,e){return{x:t.x/e,y:t.y/e}},/**
     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.
     * @method perp
     * @param {vector} vector
     * @param {bool} [negate=false]
     * @return {vector} The perpendicular vector
     */i.perp=function(t,e){return{x:-((e=!0===e?-1:1)*t.y),y:e*t.x}},/**
     * Negates both components of a vector such that it points in the opposite direction.
     * @method neg
     * @param {vector} vector
     * @return {vector} The negated vector
     */i.neg=function(t){return{x:-t.x,y:-t.y}},/**
     * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.
     * @method angle
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The angle in radians
     */i.angle=function(t,e){return Math.atan2(e.y-t.y,e.x-t.x)},/**
     * Temporary vector pool (not thread-safe).
     * @property _temp
     * @type {vector[]}
     * @private
     */i._temp=[i.create(),i.create(),i.create(),i.create(),i.create(),i.create()]}),r("4tPKt",function(t,e){/**
* The `Matter.Common` module contains utility functions that are common to all modules.
*
* @class Common
*/var i,n={};t.exports=n,n._nextId=0,n._seed=0,n._nowStartTime=+new Date,/**
     * Extends the object in the first argument using the object in the second argument.
     * @method extend
     * @param {} obj
     * @param {boolean} deep
     * @return {} obj extended
     */n.extend=function(t,e){var i,s;"boolean"==typeof e?(i=2,s=e):(i=1,s=!0);for(var r=i;r<arguments.length;r++){var o=arguments[r];if(o)for(var a in o)s&&o[a]&&o[a].constructor===Object?t[a]&&t[a].constructor!==Object?t[a]=o[a]:(t[a]=t[a]||{},n.extend(t[a],s,o[a])):t[a]=o[a]}return t},/**
     * Creates a new clone of the object, if deep is true references will also be cloned.
     * @method clone
     * @param {} obj
     * @param {bool} deep
     * @return {} obj cloned
     */n.clone=function(t,e){return n.extend({},e,t)},/**
     * Returns the list of keys for the given object.
     * @method keys
     * @param {} obj
     * @return {string[]} keys
     */n.keys=function(t){if(Object.keys)return Object.keys(t);// avoid hasOwnProperty for performance
var e=[];for(var i in t)e.push(i);return e},/**
     * Returns the list of values for the given object.
     * @method values
     * @param {} obj
     * @return {array} Array of the objects property values
     */n.values=function(t){var e=[];if(Object.keys){for(var i=Object.keys(t),n=0;n<i.length;n++)e.push(t[i[n]]);return e}// avoid hasOwnProperty for performance
for(var s in t)e.push(t[s]);return e},/**
     * Gets a value from `base` relative to the `path` string.
     * @method get
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} The object at the given path
     */n.get=function(t,e,i,n){e=e.split(".").slice(i,n);for(var s=0;s<e.length;s+=1)t=t[e[s]];return t},/**
     * Sets a value on `base` relative to the given `path` string.
     * @method set
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {} val The value to set
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} Pass through `val` for chaining
     */n.set=function(t,e,i,s,r){var o=e.split(".").slice(s,r);return n.get(t,e,0,-1)[o[o.length-1]]=i,i},/**
     * Shuffles the given array in-place.
     * The function uses a seeded random generator.
     * @method shuffle
     * @param {array} array
     * @return {array} array shuffled randomly
     */n.shuffle=function(t){for(var e=t.length-1;e>0;e--){var i=Math.floor(n.random()*(e+1)),s=t[e];t[e]=t[i],t[i]=s}return t},/**
     * Randomly chooses a value from a list with equal probability.
     * The function uses a seeded random generator.
     * @method choose
     * @param {array} choices
     * @return {object} A random choice object from the array
     */n.choose=function(t){return t[Math.floor(n.random()*t.length)]},/**
     * Returns true if the object is a HTMLElement, otherwise false.
     * @method isElement
     * @param {object} obj
     * @return {boolean} True if the object is a HTMLElement, otherwise false
     */n.isElement=function(t){return"undefined"!=typeof HTMLElement?t instanceof HTMLElement:!!(t&&t.nodeType&&t.nodeName)},/**
     * Returns true if the object is an array.
     * @method isArray
     * @param {object} obj
     * @return {boolean} True if the object is an array, otherwise false
     */n.isArray=function(t){return"[object Array]"===Object.prototype.toString.call(t)},/**
     * Returns true if the object is a function.
     * @method isFunction
     * @param {object} obj
     * @return {boolean} True if the object is a function, otherwise false
     */n.isFunction=function(t){return"function"==typeof t},/**
     * Returns true if the object is a plain object.
     * @method isPlainObject
     * @param {object} obj
     * @return {boolean} True if the object is a plain object, otherwise false
     */n.isPlainObject=function(t){return"object"==typeof t&&t.constructor===Object},/**
     * Returns true if the object is a string.
     * @method isString
     * @param {object} obj
     * @return {boolean} True if the object is a string, otherwise false
     */n.isString=function(t){return"[object String]"===Object.prototype.toString.call(t)},/**
     * Returns the given value clamped between a minimum and maximum value.
     * @method clamp
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @return {number} The value clamped between min and max inclusive
     */n.clamp=function(t,e,i){return t<e?e:t>i?i:t},/**
     * Returns the sign of the given value.
     * @method sign
     * @param {number} value
     * @return {number} -1 if negative, +1 if 0 or positive
     */n.sign=function(t){return t<0?-1:1},/**
     * Returns the current timestamp since the time origin (e.g. from page load).
     * The result will be high-resolution including decimal places if available.
     * @method now
     * @return {number} the current timestamp
     */n.now=function(){if("undefined"!=typeof window&&window.performance){if(window.performance.now)return window.performance.now();if(window.performance.webkitNow)return window.performance.webkitNow()}return new Date-n._nowStartTime},/**
     * Returns a random value between a minimum and a maximum value inclusive.
     * The function uses a seeded random generator.
     * @method random
     * @param {number} min
     * @param {number} max
     * @return {number} A random number between min and max inclusive
     */n.random=function(t,e){return e=void 0!==e?e:1,(t=void 0!==t?t:0)+i()*(e-t)},i=function(){return(// https://en.wikipedia.org/wiki/Linear_congruential_generator
n._seed=(9301*n._seed+49297)%233280,n._seed/233280)},/**
     * Converts a CSS hex colour string into an integer.
     * @method colorToNumber
     * @param {string} colorString
     * @return {number} An integer representing the CSS hex string
     */n.colorToNumber=function(t){return 3==(t=t.replace("#","")).length&&(t=t.charAt(0)+t.charAt(0)+t.charAt(1)+t.charAt(1)+t.charAt(2)+t.charAt(2)),parseInt(t,16)},/**
     * The console logging level to use, where each level includes all levels above and excludes the levels below.
     * The default level is 'debug' which shows all console messages.  
     *
     * Possible level values are:
     * - 0 = None
     * - 1 = Debug
     * - 2 = Info
     * - 3 = Warn
     * - 4 = Error
     * @property Common.logLevel
     * @type {Number}
     * @default 1
     */n.logLevel=1,/**
     * Shows a `console.log` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method log
     * @param ...objs {} The objects to log.
     */n.log=function(){console&&n.logLevel>0&&n.logLevel<=3&&console.log.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},/**
     * Shows a `console.info` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method info
     * @param ...objs {} The objects to log.
     */n.info=function(){console&&n.logLevel>0&&n.logLevel<=2&&console.info.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},/**
     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method warn
     * @param ...objs {} The objects to log.
     */n.warn=function(){console&&n.logLevel>0&&n.logLevel<=3&&console.warn.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},/**
     * Returns the next unique sequential ID.
     * @method nextId
     * @return {Number} Unique sequential ID
     */n.nextId=function(){return n._nextId++},/**
     * A cross browser compatible indexOf implementation.
     * @method indexOf
     * @param {array} haystack
     * @param {object} needle
     * @return {number} The position of needle in haystack, otherwise -1.
     */n.indexOf=function(t,e){if(t.indexOf)return t.indexOf(e);for(var i=0;i<t.length;i++)if(t[i]===e)return i;return -1},/**
     * A cross browser compatible array map implementation.
     * @method map
     * @param {array} list
     * @param {function} func
     * @return {array} Values from list transformed by func.
     */n.map=function(t,e){if(t.map)return t.map(e);for(var i=[],n=0;n<t.length;n+=1)i.push(e(t[n]));return i},/**
     * Takes a directed graph and returns the partially ordered set of vertices in topological order.
     * Circular dependencies are allowed.
     * @method topologicalSort
     * @param {object} graph
     * @return {array} Partially ordered set of vertices in topological order.
     */n.topologicalSort=function(t){// https://github.com/mgechev/javascript-algorithms
// Copyright (c) Minko Gechev (MIT license)
// Modifications: tidy formatting and naming
var e=[],i=[],s=[];for(var r in t)i[r]||s[r]||n._topologicalSort(r,i,s,t,e);return e},n._topologicalSort=function(t,e,i,s,r){var o=s[t]||[];i[t]=!0;for(var a=0;a<o.length;a+=1){var h=o[a];i[h]||e[h]||n._topologicalSort(h,e,i,s,r)}i[t]=!1,e[t]=!0,r.push(t)},/**
     * Takes _n_ functions as arguments and returns a new function that calls them in order.
     * The arguments applied when calling the new function will also be applied to every function passed.
     * The value of `this` refers to the last value returned in the chain that was not `undefined`.
     * Therefore if a passed function does not return a value, the previously returned value is maintained.
     * After all passed functions have been called the new function returns the last returned value (if any).
     * If any of the passed functions are a chain, then the chain will be flattened.
     * @method chain
     * @param ...funcs {function} The functions to chain.
     * @return {function} A new function that calls the passed functions in order.
     */n.chain=function(){for(var t=[],e=0;e<arguments.length;e+=1){var i=arguments[e];i._chained?t.push.apply(t,i._chained):t.push(i)}var n=function(){for(var e,i=Array(arguments.length),n=0,s=arguments.length;n<s;n++)i[n]=arguments[n];for(n=0;n<t.length;n+=1){var r=t[n].apply(e,i);void 0!==r&&(e=r)}return e};return n._chained=t,n},/**
     * Chains a function to excute before the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathBefore
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */n.chainPathBefore=function(t,e,i){return n.set(t,e,n.chain(i,n.get(t,e)))},/**
     * Chains a function to excute after the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathAfter
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */n.chainPathAfter=function(t,e,i){return n.set(t,e,n.chain(n.get(t,e),i))}}),r("lMiYr",function(t,e){/**
 * The `Matter.Body` module contains methods for creating and manipulating body models.
 * A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
 * Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.
 *
 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class Body
 */var i,n={};t.exports=n;var r=s("laRjh"),o=s("a7bN0"),a=s("azFoo"),h=s("4tPKt"),l=s("6V4ls"),u=s("hUjHB");n._inertiaScale=4,n._nextCollidingGroupId=1,n._nextNonCollidingGroupId=-1,n._nextCategory=1,/**
     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * Vertices must be specified in clockwise order.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {body} body
     */n.create=function(t){var e={id:h.nextId(),type:"body",label:"Body",parts:[],plugin:{},angle:0,vertices:null,position:{x:0,y:0},force:{x:0,y:0},torque:0,positionImpulse:{x:0,y:0},previousPositionImpulse:{x:0,y:0},constraintImpulse:{x:0,y:0,angle:0},totalContacts:0,speed:0,angularSpeed:0,velocity:{x:0,y:0},angularVelocity:0,isSensor:!1,isStatic:!1,isSleeping:!1,motion:0,sleepThreshold:60,density:.001,restitution:0,friction:.1,frictionStatic:.5,frictionAir:.01,collisionFilter:{category:1,mask:4294967295,group:0},slop:.05,timeScale:1,events:null,bounds:null,chamfer:null,circleRadius:0,positionPrev:null,anglePrev:0,parent:null,axes:null,area:0,mass:0,inverseMass:0,inertia:0,inverseInertia:0,_original:null,render:{visible:!0,opacity:1,sprite:{xOffset:0,yOffset:0},fillColor:null,fillOpacity:null,lineColor:null,lineOpacity:null,lineThickness:null// custom Phaser property
},gameObject:null,scale:{x:1,y:1},centerOfMass:{x:0,y:0},centerOffset:{x:0,y:0},gravityScale:{x:1,y:1},ignoreGravity:!1,ignorePointer:!1,onCollideCallback:null,onCollideEndCallback:null,onCollideActiveCallback:null,onCollideWith:{}// custom Phaser property
};!t.hasOwnProperty("position")&&t.hasOwnProperty("vertices")?t.position=r.centre(t.vertices):t.hasOwnProperty("vertices")||(e.vertices=r.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"));var n=h.extend(e,t);return i(n,t),//  Helper function
n.setOnCollideWith=function(t,e){return e?this.onCollideWith[t.id]=e:delete this.onCollideWith[t.id],this},n},/**
     * Returns the next unique group index for which bodies will collide.
     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.
     * See `body.collisionFilter` for more information.
     * @method nextGroup
     * @param {bool} [isNonColliding=false]
     * @return {Number} Unique group index
     */n.nextGroup=function(t){return t?n._nextNonCollidingGroupId--:n._nextCollidingGroupId++},/**
     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).
     * There are 32 available. See `body.collisionFilter` for more information.
     * @method nextCategory
     * @return {Number} Unique category bitfield
     */n.nextCategory=function(){return n._nextCategory=n._nextCategory<<1,n._nextCategory},i=function(t,e){e=e||{},// init required properties (order is important)
n.set(t,{bounds:t.bounds||l.create(t.vertices),positionPrev:t.positionPrev||o.clone(t.position),anglePrev:t.anglePrev||t.angle,vertices:t.vertices,parts:t.parts||[t],isStatic:t.isStatic,isSleeping:t.isSleeping,parent:t.parent||t});var i=t.bounds;if(r.rotate(t.vertices,t.angle,t.position),u.rotate(t.axes,t.angle),l.update(i,t.vertices,t.velocity),// allow options to override the automatically calculated properties
n.set(t,{axes:e.axes||t.axes,area:e.area||t.area,mass:e.mass||t.mass,inertia:e.inertia||t.inertia}),1===t.parts.length){var s=t.centerOfMass,a=t.centerOffset,h=i.max.x-i.min.x,c=i.max.y-i.min.y;s.x=-(i.min.x-t.position.x)/h,s.y=-(i.min.y-t.position.y)/c,a.x=h*s.x,a.y=c*s.y}},/**
     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.
     * Prefer to use the actual setter functions in performance critical situations.
     * @method set
     * @param {body} body
     * @param {} settings A property name (or map of properties and values) to set on the body.
     * @param {} value The value to set if `settings` is a single property name.
     */n.set=function(t,e,i){var s;for(s in"string"==typeof e&&(s=e,(e={})[s]=i),e)if(Object.prototype.hasOwnProperty.call(e,s))switch(i=e[s],s){case"isStatic":n.setStatic(t,i);break;case"isSleeping":a.set(t,i);break;case"mass":n.setMass(t,i);break;case"density":n.setDensity(t,i);break;case"inertia":n.setInertia(t,i);break;case"vertices":n.setVertices(t,i);break;case"position":n.setPosition(t,i);break;case"angle":n.setAngle(t,i);break;case"velocity":n.setVelocity(t,i);break;case"angularVelocity":n.setAngularVelocity(t,i);break;case"parts":n.setParts(t,i);break;case"centre":n.setCentre(t,i);break;default:t[s]=i}},/**
     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
     * @method setStatic
     * @param {body} body
     * @param {bool} isStatic
     */n.setStatic=function(t,e){for(var i=0;i<t.parts.length;i++){var n=t.parts[i];n.isStatic=e,e?(n._original={restitution:n.restitution,friction:n.friction,mass:n.mass,inertia:n.inertia,density:n.density,inverseMass:n.inverseMass,inverseInertia:n.inverseInertia},n.restitution=0,n.friction=1,n.mass=n.inertia=n.density=1/0,n.inverseMass=n.inverseInertia=0,n.positionPrev.x=n.position.x,n.positionPrev.y=n.position.y,n.anglePrev=n.angle,n.angularVelocity=0,n.speed=0,n.angularSpeed=0,n.motion=0):n._original&&(n.restitution=n._original.restitution,n.friction=n._original.friction,n.mass=n._original.mass,n.inertia=n._original.inertia,n.density=n._original.density,n.inverseMass=n._original.inverseMass,n.inverseInertia=n._original.inverseInertia,n._original=null)}},/**
     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.
     * @method setMass
     * @param {body} body
     * @param {number} mass
     */n.setMass=function(t,e){var i=t.inertia/(t.mass/6);t.inertia=i*(e/6),t.inverseInertia=1/t.inertia,t.mass=e,t.inverseMass=1/t.mass,t.density=t.mass/t.area},/**
     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.
     * @method setDensity
     * @param {body} body
     * @param {number} density
     */n.setDensity=function(t,e){n.setMass(t,e*t.area),t.density=e},/**
     * Sets the moment of inertia (i.e. second moment of area) of the body. 
     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
     * @method setInertia
     * @param {body} body
     * @param {number} inertia
     */n.setInertia=function(t,e){t.inertia=e,t.inverseInertia=1/t.inertia},/**
     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
     * They are then automatically translated to world space based on `body.position`.
     *
     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
     * Vertices must form a convex hull, concave hulls are not supported.
     *
     * @method setVertices
     * @param {body} body
     * @param {vector[]} vertices
     */n.setVertices=function(t,e){e[0].body===t?t.vertices=e:t.vertices=r.create(e,t),// update properties
t.axes=u.fromVertices(t.vertices),t.area=r.area(t.vertices),n.setMass(t,t.density*t.area);// orient vertices around the centre of mass at origin (0, 0)
var i=r.centre(t.vertices);r.translate(t.vertices,i,-1),// update inertia while vertices are at origin (0, 0)
n.setInertia(t,n._inertiaScale*r.inertia(t.vertices,t.mass)),// update geometry
r.translate(t.vertices,t.position),l.update(t.bounds,t.vertices,t.velocity)},/**
     * Sets the parts of the `body` and updates mass, inertia and centroid.
     * Each part will have its parent set to `body`.
     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.
     * @method setParts
     * @param {body} body
     * @param [body] parts
     * @param {bool} [autoHull=true]
     */n.setParts=function(t,e,i){for(// add all the parts, ensuring that the first part is always the parent body
e=e.slice(0),t.parts.length=0,t.parts.push(t),t.parent=t,s=0;s<e.length;s++){var s,o=e[s];o!==t&&(o.parent=t,t.parts.push(o))}if(1!==t.parts.length){// find the convex hull of all parts to set on the parent body
if(i=void 0===i||i){var a=[];for(s=0;s<e.length;s++)a=a.concat(e[s].vertices);r.clockwiseSort(a);var h=r.hull(a),u=r.centre(h);n.setVertices(t,h),r.translate(t.vertices,u)}// sum the properties of all compound parts of the parent body
var c=n._totalProperties(t),d=c.centre.x,f=c.centre.y,p=t.bounds,g=t.centerOfMass,v=t.centerOffset;l.update(p,t.vertices,t.velocity),g.x=-(p.min.x-d)/(p.max.x-p.min.x),g.y=-(p.min.y-f)/(p.max.y-p.min.y),v.x=d,v.y=f,t.area=c.area,t.parent=t,t.position.x=d,t.position.y=f,t.positionPrev.x=d,t.positionPrev.y=f,n.setMass(t,c.mass),n.setInertia(t,c.inertia),n.setPosition(t,c.centre)}},/**
     * Set the centre of mass of the body. 
     * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.
     * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.
     * This is equal to moving `body.position` but not the `body.vertices`.
     * Invalid if the `centre` falls outside the body's convex hull.
     * @method setCentre
     * @param {body} body
     * @param {vector} centre
     * @param {bool} relative
     */n.setCentre=function(t,e,i){i?(t.positionPrev.x+=e.x,t.positionPrev.y+=e.y,t.position.x+=e.x,t.position.y+=e.y):(t.positionPrev.x=e.x-(t.position.x-t.positionPrev.x),t.positionPrev.y=e.y-(t.position.y-t.positionPrev.y),t.position.x=e.x,t.position.y=e.y)},/**
     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.
     * @method setPosition
     * @param {body} body
     * @param {vector} position
     */n.setPosition=function(t,e){var i=o.sub(e,t.position);t.positionPrev.x+=i.x,t.positionPrev.y+=i.y;for(var n=0;n<t.parts.length;n++){var s=t.parts[n];s.position.x+=i.x,s.position.y+=i.y,r.translate(s.vertices,i),l.update(s.bounds,s.vertices,t.velocity)}},/**
     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
     * @method setAngle
     * @param {body} body
     * @param {number} angle
     */n.setAngle=function(t,e){var i=e-t.angle;t.anglePrev+=i;for(var n=0;n<t.parts.length;n++){var s=t.parts[n];s.angle+=i,r.rotate(s.vertices,i,t.position),u.rotate(s.axes,i),l.update(s.bounds,s.vertices,t.velocity),n>0&&o.rotateAbout(s.position,i,t.position,s.position)}},/**
     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setVelocity
     * @param {body} body
     * @param {vector} velocity
     */n.setVelocity=function(t,e){t.positionPrev.x=t.position.x-e.x,t.positionPrev.y=t.position.y-e.y,t.velocity.x=e.x,t.velocity.y=e.y,t.speed=o.magnitude(t.velocity)},/**
     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setAngularVelocity
     * @param {body} body
     * @param {number} velocity
     */n.setAngularVelocity=function(t,e){t.anglePrev=t.angle-e,t.angularVelocity=e,t.angularSpeed=Math.abs(t.angularVelocity)},/**
     * Moves a body by a given vector relative to its current position, without imparting any velocity.
     * @method translate
     * @param {body} body
     * @param {vector} translation
     */n.translate=function(t,e){n.setPosition(t,o.add(t.position,e))},/**
     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.
     * @method rotate
     * @param {body} body
     * @param {number} rotation
     * @param {vector} [point]
     */n.rotate=function(t,e,i){if(i){var s=Math.cos(e),r=Math.sin(e),o=t.position.x-i.x,a=t.position.y-i.y;n.setPosition(t,{x:i.x+(o*s-a*r),y:i.y+(o*r+a*s)}),n.setAngle(t,t.angle+e)}else n.setAngle(t,t.angle+e)},/**
     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
     * @method scale
     * @param {body} body
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} [point]
     */n.scale=function(t,e,i,s){var o=0,a=0;s=s||t.position;for(var h=0;h<t.parts.length;h++){var c=t.parts[h];c.scale.x=e,c.scale.y=i,// scale vertices
r.scale(c.vertices,e,i,s),// update properties
c.axes=u.fromVertices(c.vertices),c.area=r.area(c.vertices),n.setMass(c,t.density*c.area),// update inertia (requires vertices to be at origin)
r.translate(c.vertices,{x:-c.position.x,y:-c.position.y}),n.setInertia(c,n._inertiaScale*r.inertia(c.vertices,c.mass)),r.translate(c.vertices,{x:c.position.x,y:c.position.y}),h>0&&(o+=c.area,a+=c.inertia),// scale position
c.position.x=s.x+(c.position.x-s.x)*e,c.position.y=s.y+(c.position.y-s.y)*i,// update bounds
l.update(c.bounds,c.vertices,t.velocity)}t.parts.length>1&&(t.area=o,t.isStatic||(n.setMass(t,t.density*o),n.setInertia(t,a))),t.circleRadius&&(e===i?t.circleRadius*=e:t.circleRadius=null)},/**
     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.
     * @method update
     * @param {body} body
     * @param {number} deltaTime
     * @param {number} timeScale
     * @param {number} correction
     */n.update=function(t,e,i,n){var s=Math.pow(e*i*t.timeScale,2),a=1-t.frictionAir*i*t.timeScale,h=t.position.x-t.positionPrev.x,c=t.position.y-t.positionPrev.y;// update velocity with Verlet integration
t.velocity.x=h*a*n+t.force.x/t.mass*s,t.velocity.y=c*a*n+t.force.y/t.mass*s,t.positionPrev.x=t.position.x,t.positionPrev.y=t.position.y,t.position.x+=t.velocity.x,t.position.y+=t.velocity.y,// update angular velocity with Verlet integration
t.angularVelocity=(t.angle-t.anglePrev)*a*n+t.torque/t.inertia*s,t.anglePrev=t.angle,t.angle+=t.angularVelocity,// track speed and acceleration
t.speed=o.magnitude(t.velocity),t.angularSpeed=Math.abs(t.angularVelocity);// transform the body geometry
for(var d=0;d<t.parts.length;d++){var f=t.parts[d];r.translate(f.vertices,t.velocity),d>0&&(f.position.x+=t.velocity.x,f.position.y+=t.velocity.y),0!==t.angularVelocity&&(r.rotate(f.vertices,t.angularVelocity,t.position),u.rotate(f.axes,t.angularVelocity),d>0&&o.rotateAbout(f.position,t.angularVelocity,t.position,f.position)),l.update(f.bounds,f.vertices,t.velocity)}},/**
     * Applies a force to a body from a given world-space position, including resulting torque.
     * @method applyForce
     * @param {body} body
     * @param {vector} position
     * @param {vector} force
     */n.applyForce=function(t,e,i){t.force.x+=i.x,t.force.y+=i.y;var n={x:e.x-t.position.x,y:e.y-t.position.y};t.torque+=n.x*i.y-n.y*i.x},/**
     * Returns the sums of the properties of all compound parts of the parent body.
     * @method _totalProperties
     * @private
     * @param {body} body
     * @return {}
     */n._totalProperties=function(t){// sum the properties of all compound parts of the parent body
for(var e={mass:0,area:0,inertia:0,centre:{x:0,y:0}},i=1===t.parts.length?0:1;i<t.parts.length;i++){var n=t.parts[i],s=n.mass!==1/0?n.mass:1;e.mass+=s,e.area+=n.area,e.inertia+=n.inertia,e.centre=o.add(e.centre,o.mult(n.position,s))}return e.centre=o.div(e.centre,e.mass),e}}),r("azFoo",function(t,e){/**
* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.
*
* @class Sleeping
*/var i={};t.exports=i;var n=s("aKoE7");i._motionWakeThreshold=.18,i._motionSleepThreshold=.08,i._minBias=.9,/**
     * Puts bodies to sleep or wakes them up depending on their motion.
     * @method update
     * @param {body[]} bodies
     * @param {number} timeScale
     */i.update=function(t,e){// update bodies sleeping status
for(var n=e*e*e,s=0;s<t.length;s++){var r=t[s],o=r.speed*r.speed+r.angularSpeed*r.angularSpeed;// wake up bodies if they have a force applied
if(0!==r.force.x||0!==r.force.y){i.set(r,!1);continue}var a=Math.min(r.motion,o),h=Math.max(r.motion,o);// biased average motion estimation between frames
r.motion=i._minBias*a+(1-i._minBias)*h,r.sleepThreshold>0&&r.motion<i._motionSleepThreshold*n?(r.sleepCounter+=1,r.sleepCounter>=r.sleepThreshold&&i.set(r,!0)):r.sleepCounter>0&&(r.sleepCounter-=1)}},/**
     * Given a set of colliding pairs, wakes the sleeping bodies involved.
     * @method afterCollisions
     * @param {pair[]} pairs
     * @param {number} timeScale
     */i.afterCollisions=function(t,e){// wake up bodies involved in collisions
for(var n=e*e*e,s=0;s<t.length;s++){var r=t[s];// don't wake inactive pairs
if(r.isActive){var o=r.collision,a=o.bodyA.parent,h=o.bodyB.parent;// don't wake if at least one body is static
if((!a.isSleeping||!h.isSleeping)&&!a.isStatic&&!h.isStatic&&(a.isSleeping||h.isSleeping)){var l=a.isSleeping&&!a.isStatic?a:h,u=l===a?h:a;!l.isStatic&&u.motion>i._motionWakeThreshold*n&&i.set(l,!1)}}}},/**
     * Set a body as sleeping or awake.
     * @method set
     * @param {body} body
     * @param {boolean} isSleeping
     */i.set=function(t,e){var i=t.isSleeping;e?(t.isSleeping=!0,t.sleepCounter=t.sleepThreshold,t.positionImpulse.x=0,t.positionImpulse.y=0,t.positionPrev.x=t.position.x,t.positionPrev.y=t.position.y,t.anglePrev=t.angle,t.speed=0,t.angularSpeed=0,t.motion=0,i||n.trigger(t,"sleepStart")):(t.isSleeping=!1,t.sleepCounter=0,i&&n.trigger(t,"sleepEnd"))}}),r("aKoE7",function(t,e){/**
* The `Matter.Events` module contains methods to fire and listen to events on other objects.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Events
*/var i={};t.exports=i;var n=s("4tPKt");/**
     * Subscribes a callback function to the given object's `eventName`.
     * @method on
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */i.on=function(t,e,i){for(var n,s=e.split(" "),r=0;r<s.length;r++)n=s[r],t.events=t.events||{},t.events[n]=t.events[n]||[],t.events[n].push(i);return i},/**
     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.
     * @method off
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */i.off=function(t,e,i){if(!e){t.events={};return}// handle Events.off(object, callback)
"function"==typeof e&&(i=e,e=n.keys(t.events).join(" "));for(var s=e.split(" "),r=0;r<s.length;r++){var o=t.events[s[r]],a=[];if(i&&o)for(var h=0;h<o.length;h++)o[h]!==i&&a.push(o[h]);t.events[s[r]]=a}},/**
     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.
     * @method trigger
     * @param {} object
     * @param {string} eventNames
     * @param {} event
     */i.trigger=function(t,e,i){var s,r,o,a,h=t.events;if(h&&n.keys(h).length>0){i||(i={}),s=e.split(" ");for(var l=0;l<s.length;l++)if(o=h[r=s[l]]){(a=n.clone(i,!1)).name=r,a.source=t;for(var u=0;u<o.length;u++)o[u].apply(t,[a])}}}}),r("6V4ls",function(t,e){/**
* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).
*
* @class Bounds
*/var i={};t.exports=i,/**
     * Creates a new axis-aligned bounding box (AABB) for the given vertices.
     * @method create
     * @param {vertices} vertices
     * @return {bounds} A new bounds object
     */i.create=function(t){var e={min:{x:0,y:0},max:{x:0,y:0}};return t&&i.update(e,t),e},/**
     * Updates bounds using the given vertices and extends the bounds given a velocity.
     * @method update
     * @param {bounds} bounds
     * @param {vertices} vertices
     * @param {vector} velocity
     */i.update=function(t,e,i){t.min.x=1/0,t.max.x=-1/0,t.min.y=1/0,t.max.y=-1/0;for(var n=0;n<e.length;n++){var s=e[n];s.x>t.max.x&&(t.max.x=s.x),s.x<t.min.x&&(t.min.x=s.x),s.y>t.max.y&&(t.max.y=s.y),s.y<t.min.y&&(t.min.y=s.y)}i&&(i.x>0?t.max.x+=i.x:t.min.x+=i.x,i.y>0?t.max.y+=i.y:t.min.y+=i.y)},/**
     * Returns true if the bounds contains the given point.
     * @method contains
     * @param {bounds} bounds
     * @param {vector} point
     * @return {boolean} True if the bounds contain the point, otherwise false
     */i.contains=function(t,e){return e.x>=t.min.x&&e.x<=t.max.x&&e.y>=t.min.y&&e.y<=t.max.y},/**
     * Returns true if the two bounds intersect.
     * @method overlaps
     * @param {bounds} boundsA
     * @param {bounds} boundsB
     * @return {boolean} True if the bounds overlap, otherwise false
     */i.overlaps=function(t,e){return t.min.x<=e.max.x&&t.max.x>=e.min.x&&t.max.y>=e.min.y&&t.min.y<=e.max.y},/**
     * Translates the bounds by the given vector.
     * @method translate
     * @param {bounds} bounds
     * @param {vector} vector
     */i.translate=function(t,e){t.min.x+=e.x,t.max.x+=e.x,t.min.y+=e.y,t.max.y+=e.y},/**
     * Shifts the bounds to the given position.
     * @method shift
     * @param {bounds} bounds
     * @param {vector} position
     */i.shift=function(t,e){var i=t.max.x-t.min.x,n=t.max.y-t.min.y;t.min.x=e.x,t.max.x=e.x+i,t.min.y=e.y,t.max.y=e.y+n}}),r("hUjHB",function(t,e){/**
* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.
*
* @class Axes
*/var i={};t.exports=i;var n=s("a7bN0"),r=s("4tPKt");/**
     * Creates a new set of axes from the given vertices.
     * @method fromVertices
     * @param {vertices} vertices
     * @return {axes} A new axes from the given vertices
     */i.fromVertices=function(t){// find the unique axes, using edge normal gradients
for(var e={},i=0;i<t.length;i++){var s=(i+1)%t.length,o=n.normalise({x:t[s].y-t[i].y,y:t[i].x-t[s].x}),a=0===o.y?1/0:o.x/o.y;e[// limit precision
a=a.toFixed(3).toString()]=o}return r.values(e)},/**
     * Rotates a set of axes by the given angle.
     * @method rotate
     * @param {axes} axes
     * @param {number} angle
     */i.rotate=function(t,e){if(0!==e)for(var i=Math.cos(e),n=Math.sin(e),s=0;s<t.length;s++){var r,o=t[s];r=o.x*i-o.y*n,o.y=o.x*n+o.y*i,o.x=r}}}),r("l2Xwu",function(t,e){/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */function i(t,e,i,n){var s=e[0]-t[0],r=e[1]-t[1],o=n[0]-i[0],a=n[1]-i[1];// segments are parallel
if(o*r-a*s==0)return!1;var h=(s*(i[1]-t[1])+r*(t[0]-i[0]))/(o*r-a*s),l=(o*(t[1]-i[1])+a*(i[0]-t[0]))/(a*s-o*r);return h>=0&&h<=1&&l>=0&&l<=1}/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */function n(t,e,i){return(e[0]-t[0])*(i[1]-t[1])-(i[0]-t[0])*(e[1]-t[1])}function s(t,e,i){return 0>=n(t,e,i)}/**
 * @author       Stefan Hedman <schteppe@gmail.com> (http://steffe.se)
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  v0.3.0
t.exports={decomp:/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */function(t){var e=/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */function t(e){for(var i=[],r=[],o=[],l=[],p=Number.MAX_VALUE,v=0;v<e.length;++v)if(u(e,v)){for(var m=0;m<e.length;++m)if(/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */function(t,e,i){if(n(h(t,e+1),h(t,e),h(t,i))>=0&&s(h(t,e-1),h(t,e),h(t,i)))return!1;o=a(h(t,e),h(t,i));for(var r,o,l=0;l!==t.length;++l)if((l+1)%t.length!==e&&l!==e&&n(h(t,e),h(t,i),h(t,l+1))>=0&&s(h(t,e),h(t,i),h(t,l))&&([][0]=h(t,e),[][1]=h(t,i),[][0]=h(t,l),[][1]=h(t,l+1),r=/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */function(t,e,i){i=i||0;var n,s,r,o,a,h,l,u=[0,0];// point
return n=t[1][1]-t[0][1],s=t[0][0]-t[1][0],r=n*t[0][0]+s*t[0][1],o=e[1][1]-e[0][1],a=e[0][0]-e[1][0],h=o*e[0][0]+a*e[0][1],g(l=n*a-o*s,0,i)||(u[0]=(a*r-s*h)/l,u[1]=(n*h-o*r)/l),u}(c,d),a(h(t,e),r)<o))return!1;return!0}(e,v,m)){r=t(f(e,v,m,l)),o=t(f(e,m,v,l));for(var y=0;y<o.length;y++)r.push(o[y]);r.length<p&&(i=r,p=r.length,i.push([h(e,v),h(e,m)]))}}return i}(t);return e.length>0?/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */function t(e,i){if(0===i.length)return[e];if(i instanceof Array&&i.length&&i[0]instanceof Array&&2===i[0].length&&i[0][0]instanceof Array){for(var n=[e],s=0;s<i.length;s++)// Cut all polys
for(var r=i[s],o=0;o<n.length;o++){var a=t(n[o],r);if(a){// Found poly! Cut and quit
n.splice(o,1),n.push(a[0],a[1]);break}}return n}// Was given one edge
var r=i,s=e.indexOf(r[0]),o=e.indexOf(r[1]);return -1!==s&&-1!==o&&[f(e,s,o),f(e,o,s)]}(t,e):[t]},quickDecomp:/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */function t(e,r,o,c,d,f,g){f=f||100,g=g||0,d=d||25,r=void 0!==r?r:[],o=o||[],c=c||[];var v=[0,0],m=[0,0],y=[0,0],x=0,w=0,T=0,b=0,S=0,A=0,E=0,_=[],C=[];// Points
if(e.length<3)return r;if(++g>f)return console.warn("quickDecomp: max level ("+f+") reached."),r;for(var M=0;M<e.length;++M)if(u(e,M)){o.push(e[M]),x=w=Number.MAX_VALUE;for(var P=0;P<e.length;++P)n(h(e,M-1),h(e,M),h(e,P))>0&&s(h(e,M-1),h(e,M),h(e,P-1))&&(y=p(h(e,M-1),h(e,M),h(e,P),h(e,P-1)),0>n(h(e,M+1),h(e,M),y)&&(T=a(e[M],y))<w&&(w=T,m=y,A=P)),n(h(e,M+1),h(e,M),h(e,P+1))>0&&s(h(e,M+1),h(e,M),h(e,P))&&(y=p(h(e,M+1),h(e,M),h(e,P),h(e,P+1)),n(h(e,M-1),h(e,M),y)>0&&(T=a(e[M],y))<x&&(x=T,v=y,S=P));// if there are no vertices to connect to, choose a point in the middle
if(A===(S+1)%e.length)//console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+polygon.length+")");
y[0]=(m[0]+v[0])/2,y[1]=(m[1]+v[1])/2,c.push(y),M<S?(//lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
l(_,e,M,S+1),_.push(y),C.push(y),0!==A&&l(C,e,A,e.length),//upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
l(C,e,0,M+1)):(0!==M&&l(_,e,M,e.length),//lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
l(_,e,0,S+1),_.push(y),C.push(y),//upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
l(C,e,A,M+1));else{if(A>S&&(S+=e.length),b=Number.MAX_VALUE,S<A)return r;for(var P=A;P<=S;++P)n(h(e,M-1),h(e,M),h(e,P))>=0&&s(h(e,M+1),h(e,M),h(e,P))&&(T=a(h(e,M),h(e,P)))<b&&/**
 * Check if two vertices in the polygon can see each other
 * @method canSee2
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */function(t,e,n){// for each edge
for(var s=0;s!==t.length;++s)// ignore incident edges
if(s!==e&&s!==n&&(s+1)%t.length!==e&&(s+1)%t.length!==n&&i(h(t,e),h(t,n),h(t,s),h(t,s+1)))return!1;return!0}(e,M,P)&&(b=T,E=P%e.length);M<E?(l(_,e,M,E+1),0!==E&&l(C,e,E,e.length),l(C,e,0,M+1)):(0!==M&&l(_,e,M,e.length),l(_,e,0,E+1),l(C,e,E,M+1))}return _.length<C.length?(t(_,r,o,c,d,f,g),t(C,r,o,c,d,f,g)):(t(C,r,o,c,d,f,g),t(_,r,o,c,d,f,g)),r}return r.push(e),r},isSimple:/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */function(t){var e;// Check
for(e=0;e<t.length-1;e++)for(var n=0;n<e-1;n++)if(i(t[e],t[e+1],t[n],t[n+1]))return!1;// Check the segment between the last and the first point to all others
for(e=1;e<t.length-2;e++)if(i(t[0],t[t.length-1],t[e],t[e+1]))return!1;return!0},removeCollinearPoints:/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */function(t,e){for(var i,s,a,l=0,u=t.length-1;t.length>3&&u>=0;--u)i=h(t,u-1),s=h(t,u),a=h(t,u+1),(e?(r[0]=s[0]-i[0],r[1]=s[1]-i[1],o[0]=a[0]-s[0],o[1]=a[1]-s[1],Math.acos((r[0]*o[0]+r[1]*o[1])/(Math.sqrt(r[0]*r[0]+r[1]*r[1])*Math.sqrt(o[0]*o[0]+o[1]*o[1])))<e):0===n(i,s,a))&&(// Remove the middle point
t.splice(u%t.length,1),l++);return l},removeDuplicatePoints:/**
 * Remove duplicate points in the polygon.
 * @method removeDuplicatePoints
 * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.
 */function(t,e){for(var i,n=t.length-1;n>=1;--n)for(var s=t[n],r=n-1;r>=0;--r)if(i=t[r],g(s[0],i[0],e)&&g(s[1],i[1],e)){t.splice(n,1);continue}},makeCCW:/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */function(t){// find bottom right point
for(var e=0,i=1;i<t.length;++i)(t[i][1]<t[e][1]||t[i][1]===t[e][1]&&t[i][0]>t[e][0])&&(e=i);return!(n(h(t,e-1),h(t,e),h(t,e+1))>0)&&(/**
 * Reverse the vertices in the polygon
 * @method reverse
 */function(t){for(var e=[],i=t.length,n=0;n!==i;n++)e.push(t.pop());for(var n=0;n!==i;n++)t[n]=e[n]}(t),!0)}};var r=[],o=[];function a(t,e){var i=e[0]-t[0],n=e[1]-t[1];return i*i+n*n}/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */function h(t,e){var i=t.length;return t[e<0?e%i+i:e%i]}/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */function l(t,e,i,n){for(var s=i;s<n;s++)t.push(e[s])}/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */function u(t,e){return 0>n(h(t,e-1),h(t,e),h(t,e+1))}var c=[],d=[];/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */function f(t,e,i,n){var s=n||[];if(s.length=0,e<i)for(var r=e;r<=i;r++)s.push(t[r]);else{// Insert vertices 0 to j
for(var r=0;r<=i;r++)s.push(t[r]);// Insert vertices i to end
for(var r=e;r<t.length;r++)s.push(t[r])}return s}function p(t,e,i,n,s){s=s||0;var r=e[1]-t[1],o=t[0]-e[0],a=r*t[0]+o*t[1],h=n[1]-i[1],l=i[0]-n[0],u=h*i[0]+l*i[1],c=r*l-h*o;return g(c,0,s)?[0,0]:[(l*a-o*u)/c,(r*u-h*a)/c]}/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */function g(t,e,i){return Math.abs(t-e)<=(i=i||0)}}),r("cbd5m",function(t,e){/**
* The `Matter.Composites` module contains factory methods for creating composite bodies
* with commonly used configurations (such as stacks and chains).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composites
*/var i={};t.exports=i;var n=s("in8Gg"),r=s("dmTql"),o=s("4tPKt"),a=s("lMiYr"),h=s("gY9LZ");/**
     * Create a new composite containing bodies created in the callback in a grid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method stack
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */i.stack=function(t,e,i,s,r,o,h){for(var l,u=n.create({label:"Stack"}),c=t,d=e,f=0,p=0;p<s;p++){for(var g=0,v=0;v<i;v++){var m=h(c,d,v,p,l,f);if(m){var y=m.bounds.max.y-m.bounds.min.y,x=m.bounds.max.x-m.bounds.min.x;y>g&&(g=y),a.translate(m,{x:.5*x,y:.5*y}),c=m.bounds.max.x+r,n.addBody(u,m),l=m,f+=1}else c+=r}d+=g+o,c=t}return u},/**
     * Chains all bodies in the given composite together using constraints.
     * @method chain
     * @param {composite} composite
     * @param {number} xOffsetA
     * @param {number} yOffsetA
     * @param {number} xOffsetB
     * @param {number} yOffsetB
     * @param {object} options
     * @return {composite} A new composite containing objects chained together with constraints
     */i.chain=function(t,e,i,s,a,h){for(var l=t.bodies,u=1;u<l.length;u++){var c=l[u-1],d=l[u],f=c.bounds.max.y-c.bounds.min.y,p=c.bounds.max.x-c.bounds.min.x,g=d.bounds.max.y-d.bounds.min.y,v=d.bounds.max.x-d.bounds.min.x,m={bodyA:c,pointA:{x:p*e,y:f*i},bodyB:d,pointB:{x:v*s,y:g*a}},y=o.extend(m,h);n.addConstraint(t,r.create(y))}return t.label+=" Chain",t},/**
     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
     * @method mesh
     * @param {composite} composite
     * @param {number} columns
     * @param {number} rows
     * @param {boolean} crossBrace
     * @param {object} options
     * @return {composite} The composite containing objects meshed together with constraints
     */i.mesh=function(t,e,i,s,a){var h,l,u,c,d,f=t.bodies;for(h=0;h<i;h++){for(l=1;l<e;l++)u=f[l-1+h*e],c=f[l+h*e],n.addConstraint(t,r.create(o.extend({bodyA:u,bodyB:c},a)));if(h>0)for(l=0;l<e;l++)u=f[l+(h-1)*e],c=f[l+h*e],n.addConstraint(t,r.create(o.extend({bodyA:u,bodyB:c},a))),s&&l>0&&(d=f[l-1+(h-1)*e],n.addConstraint(t,r.create(o.extend({bodyA:d,bodyB:c},a)))),s&&l<e-1&&(d=f[l+1+(h-1)*e],n.addConstraint(t,r.create(o.extend({bodyA:d,bodyB:c},a))))}return t.label+=" Mesh",t},/**
     * Create a new composite containing bodies created in the callback in a pyramid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method pyramid
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */i.pyramid=function(t,e,n,s,r,o,h){return i.stack(t,e,n,s,r,o,function(e,i,o,l,u,c){var d=Math.min(s,Math.ceil(n/2)),f=u?u.bounds.max.x-u.bounds.min.x:0;if(!(l>d)){var p=// reverse row order
l=d-l,g=n-1-l;if(!(o<p)&&!(o>g))return 1===c&&a.translate(u,{x:(o+(n%2==1?1:-1))*f,y:0}),h(t+(u?o*f:0)+o*r,i,o,l,u,c)}})},/**
     * Creates a composite with a Newton's Cradle setup of bodies and constraints.
     * @method newtonsCradle
     * @param {number} xx
     * @param {number} yy
     * @param {number} number
     * @param {number} size
     * @param {number} length
     * @return {composite} A new composite newtonsCradle body
     */i.newtonsCradle=function(t,e,i,s,o){for(var a=n.create({label:"Newtons Cradle"}),l=0;l<i;l++){var u=h.circle(t+l*(1.9*s),e+o,s,{inertia:1/0,restitution:1,friction:0,frictionAir:1e-4,slop:1}),c=r.create({pointA:{x:t+l*(1.9*s),y:e},bodyB:u});n.addBody(a,u),n.addConstraint(a,c)}return a},/**
     * Creates a composite with simple car setup of bodies and constraints.
     * @method car
     * @param {number} xx
     * @param {number} yy
     * @param {number} width
     * @param {number} height
     * @param {number} wheelSize
     * @return {composite} A new composite car body
     */i.car=function(t,e,i,s,o){var l=a.nextGroup(!0),u=-(.5*i)+20,c=.5*i-20,d=n.create({label:"Car"}),f=h.rectangle(t,e,i,s,{collisionFilter:{group:l},chamfer:{radius:.5*s},density:2e-4}),p=h.circle(t+u,e+0,o,{collisionFilter:{group:l},friction:.8}),g=h.circle(t+c,e+0,o,{collisionFilter:{group:l},friction:.8}),v=r.create({bodyB:f,pointB:{x:u,y:0},bodyA:p,stiffness:1,length:0}),m=r.create({bodyB:f,pointB:{x:c,y:0},bodyA:g,stiffness:1,length:0});return n.addBody(d,f),n.addBody(d,p),n.addBody(d,g),n.addConstraint(d,v),n.addConstraint(d,m),d},/**
     * Creates a simple soft body like object.
     * @method softBody
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {boolean} crossBrace
     * @param {number} particleRadius
     * @param {} particleOptions
     * @param {} constraintOptions
     * @return {composite} A new composite softBody
     */i.softBody=function(t,e,n,s,r,a,l,u,c,d){c=o.extend({inertia:1/0},c),d=o.extend({stiffness:.2,render:{type:"line",anchors:!1}},d);var f=i.stack(t,e,n,s,r,a,function(t,e){return h.circle(t,e,u,c)});return i.mesh(f,n,s,l,d),f.label="Soft Body",f}}),r("in8Gg",function(t,e){/**
* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.
* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.
* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.
* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composite
*/var i={};t.exports=i;var n=s("aKoE7"),r=s("4tPKt"),o=s("6V4ls"),a=s("lMiYr");/**
     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properites section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} [options]
     * @return {composite} A new composite
     */i.create=function(t){return r.extend({id:r.nextId(),type:"composite",parent:null,isModified:!1,bodies:[],constraints:[],composites:[],label:"Composite",plugin:{}},t)},/**
     * Sets the composite's `isModified` flag. 
     * If `updateParents` is true, all parents will be set (default: false).
     * If `updateChildren` is true, all children will be set (default: false).
     * @method setModified
     * @param {composite} composite
     * @param {boolean} isModified
     * @param {boolean} [updateParents=false]
     * @param {boolean} [updateChildren=false]
     */i.setModified=function(t,e,s,r){if(n.trigger(t,"compositeModified",t),t.isModified=e,s&&t.parent&&i.setModified(t.parent,e,s,r),r)for(var o=0;o<t.composites.length;o++){var a=t.composites[o];i.setModified(a,e,s,r)}},/**
     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.
     * @method add
     * @param {composite} composite
     * @param {} object
     * @return {composite} The original composite with the objects added
     */i.add=function(t,e){var s=[].concat(e);n.trigger(t,"beforeAdd",{object:e});for(var o=0;o<s.length;o++){var a=s[o];switch(a.type){case"body":// skip adding compound parts
if(a.parent!==a){r.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");break}i.addBody(t,a);break;case"constraint":i.addConstraint(t,a);break;case"composite":i.addComposite(t,a);break;case"mouseConstraint":i.addConstraint(t,a.constraint)}}return n.trigger(t,"afterAdd",{object:e}),t},/**
     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Optionally searching its children recursively.
     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.
     * @method remove
     * @param {composite} composite
     * @param {} object
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the objects removed
     */i.remove=function(t,e,s){var r=[].concat(e);n.trigger(t,"beforeRemove",{object:e});for(var o=0;o<r.length;o++){var a=r[o];switch(a.type){case"body":i.removeBody(t,a,s);break;case"constraint":i.removeConstraint(t,a,s);break;case"composite":i.removeComposite(t,a,s);break;case"mouseConstraint":i.removeConstraint(t,a.constraint)}}return n.trigger(t,"afterRemove",{object:e}),t},/**
     * Adds a composite to the given composite.
     * @private
     * @method addComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @return {composite} The original compositeA with the objects from compositeB added
     */i.addComposite=function(t,e){return t.composites.push(e),e.parent=t,i.setModified(t,!0,!0,!1),t},/**
     * Removes a composite from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @param {boolean} [deep=false]
     * @return {composite} The original compositeA with the composite removed
     */i.removeComposite=function(t,e,n){var s=t.composites.indexOf(e);if(-1!==s&&(i.removeCompositeAt(t,s),i.setModified(t,!0,!0,!1)),n)for(var r=0;r<t.composites.length;r++)i.removeComposite(t.composites[r],e,!0);return t},/**
     * Removes a composite from the given composite.
     * @private
     * @method removeCompositeAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the composite removed
     */i.removeCompositeAt=function(t,e){return t.composites.splice(e,1),i.setModified(t,!0,!0,!1),t},/**
     * Adds a body to the given composite.
     * @private
     * @method addBody
     * @param {composite} composite
     * @param {body} body
     * @return {composite} The original composite with the body added
     */i.addBody=function(t,e){return t.bodies.push(e),i.setModified(t,!0,!0,!1),t},/**
     * Removes a body from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeBody
     * @param {composite} composite
     * @param {body} body
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the body removed
     */i.removeBody=function(t,e,n){var s=t.bodies.indexOf(e);if(-1!==s&&(i.removeBodyAt(t,s),i.setModified(t,!0,!0,!1)),n)for(var r=0;r<t.composites.length;r++)i.removeBody(t.composites[r],e,!0);return t},/**
     * Removes a body from the given composite.
     * @private
     * @method removeBodyAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the body removed
     */i.removeBodyAt=function(t,e){return t.bodies.splice(e,1),i.setModified(t,!0,!0,!1),t},/**
     * Adds a constraint to the given composite.
     * @private
     * @method addConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @return {composite} The original composite with the constraint added
     */i.addConstraint=function(t,e){return t.constraints.push(e),i.setModified(t,!0,!0,!1),t},/**
     * Removes a constraint from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the constraint removed
     */i.removeConstraint=function(t,e,n){var s=t.constraints.indexOf(e);if(-1!==s&&i.removeConstraintAt(t,s),n)for(var r=0;r<t.composites.length;r++)i.removeConstraint(t.composites[r],e,!0);return t},/**
     * Removes a body from the given composite.
     * @private
     * @method removeConstraintAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the constraint removed
     */i.removeConstraintAt=function(t,e){return t.constraints.splice(e,1),i.setModified(t,!0,!0,!1),t},/**
     * Removes all bodies, constraints and composites from the given composite.
     * Optionally clearing its children recursively.
     * @method clear
     * @param {composite} composite
     * @param {boolean} keepStatic
     * @param {boolean} [deep=false]
     */i.clear=function(t,e,n){if(n)for(var s=0;s<t.composites.length;s++)i.clear(t.composites[s],e,!0);return e?t.bodies=t.bodies.filter(function(t){return t.isStatic}):t.bodies.length=0,t.constraints.length=0,t.composites.length=0,i.setModified(t,!0,!0,!1),t},/**
     * Returns all bodies in the given composite, including all bodies in its children, recursively.
     * @method allBodies
     * @param {composite} composite
     * @return {body[]} All the bodies
     */i.allBodies=function(t){for(var e=[].concat(t.bodies),n=0;n<t.composites.length;n++)e=e.concat(i.allBodies(t.composites[n]));return e},/**
     * Returns all constraints in the given composite, including all constraints in its children, recursively.
     * @method allConstraints
     * @param {composite} composite
     * @return {constraint[]} All the constraints
     */i.allConstraints=function(t){for(var e=[].concat(t.constraints),n=0;n<t.composites.length;n++)e=e.concat(i.allConstraints(t.composites[n]));return e},/**
     * Returns all composites in the given composite, including all composites in its children, recursively.
     * @method allComposites
     * @param {composite} composite
     * @return {composite[]} All the composites
     */i.allComposites=function(t){for(var e=[].concat(t.composites),n=0;n<t.composites.length;n++)e=e.concat(i.allComposites(t.composites[n]));return e},/**
     * Searches the composite recursively for an object matching the type and id supplied, null if not found.
     * @method get
     * @param {composite} composite
     * @param {number} id
     * @param {string} type
     * @return {object} The requested object, if found
     */i.get=function(t,e,n){var s,r;switch(n){case"body":s=i.allBodies(t);break;case"constraint":s=i.allConstraints(t);break;case"composite":s=i.allComposites(t).concat(t)}return s?0===(r=s.filter(function(t){return t.id.toString()===e.toString()})).length?null:r[0]:null},/**
     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).
     * @method move
     * @param {compositeA} compositeA
     * @param {object[]} objects
     * @param {compositeB} compositeB
     * @return {composite} Returns compositeA
     */i.move=function(t,e,n){return i.remove(t,e),i.add(n,e),t},/**
     * Assigns new ids for all objects in the composite, recursively.
     * @method rebase
     * @param {composite} composite
     * @return {composite} Returns composite
     */i.rebase=function(t){for(var e=i.allBodies(t).concat(i.allConstraints(t)).concat(i.allComposites(t)),n=0;n<e.length;n++)e[n].id=r.nextId();return i.setModified(t,!0,!0,!1),t},/**
     * Translates all children in the composite by a given vector relative to their current positions, 
     * without imparting any velocity.
     * @method translate
     * @param {composite} composite
     * @param {vector} translation
     * @param {bool} [recursive=true]
     */i.translate=function(t,e,n){for(var s=n?i.allBodies(t):t.bodies,r=0;r<s.length;r++)a.translate(s[r],e);return i.setModified(t,!0,!0,!1),t},/**
     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.
     * @method rotate
     * @param {composite} composite
     * @param {number} rotation
     * @param {vector} point
     * @param {bool} [recursive=true]
     */i.rotate=function(t,e,n,s){for(var r=Math.cos(e),o=Math.sin(e),h=s?i.allBodies(t):t.bodies,l=0;l<h.length;l++){var u=h[l],c=u.position.x-n.x,d=u.position.y-n.y;a.setPosition(u,{x:n.x+(c*r-d*o),y:n.y+(c*o+d*r)}),a.rotate(u,e)}return i.setModified(t,!0,!0,!1),t},/**
     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.
     * @method scale
     * @param {composite} composite
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     * @param {bool} [recursive=true]
     */i.scale=function(t,e,n,s,r){for(var o=r?i.allBodies(t):t.bodies,h=0;h<o.length;h++){var l=o[h],u=l.position.x-s.x,c=l.position.y-s.y;a.setPosition(l,{x:s.x+u*e,y:s.y+c*n}),a.scale(l,e,n)}return i.setModified(t,!0,!0,!1),t},/**
     * Returns the union of the bounds of all of the composite's bodies.
     * @method bounds
     * @param {composite} composite The composite.
     * @returns {bounds} The composite bounds.
     */i.bounds=function(t){for(var e=i.allBodies(t),n=[],s=0;s<e.length;s+=1){var r=e[s];n.push(r.bounds.min,r.bounds.max)}return o.create(n)}}),r("dmTql",function(t,e){/**
* The `Matter.Constraint` module contains methods for creating and manipulating constraints.
* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
* The stiffness of constraints can be modified to create springs or elastic.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Constraint
*/var i={};t.exports=i;var n=s("laRjh"),r=s("a7bN0"),o=s("azFoo"),a=s("6V4ls"),h=s("hUjHB"),l=s("4tPKt");i._warming=.4,i._torqueDampen=1,i._minLength=1e-6,/**
     * Creates a new constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).
     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.
     * For compound bodies, constraints must be applied to the parent body (not one of its parts).
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {constraint} constraint
     */i.create=function(t){t.bodyA&&!t.pointA&&(t.pointA={x:0,y:0}),t.bodyB&&!t.pointB&&(t.pointB={x:0,y:0});// calculate static length using initial world space points
var e=t.bodyA?r.add(t.bodyA.position,t.pointA):t.pointA,i=t.bodyB?r.add(t.bodyB.position,t.pointB):t.pointB,n=r.magnitude(r.sub(e,i));t.length=void 0!==t.length?t.length:n,// option defaults
t.id=t.id||l.nextId(),t.label=t.label||"Constraint",t.type="constraint",t.stiffness=t.stiffness||(t.length>0?1:.7),t.damping=t.damping||0,t.angularStiffness=t.angularStiffness||0,t.angleA=t.bodyA?t.bodyA.angle:t.angleA,t.angleB=t.bodyB?t.bodyB.angle:t.angleB,t.plugin={};// render
var s={visible:!0,type:"line",anchors:!0,lineColor:null,lineOpacity:null,lineThickness:null,pinSize:null,anchorColor:null,anchorSize:null// custom Phaser property
};return 0===t.length&&t.stiffness>.1?(s.type="pin",s.anchors=!1):t.stiffness<.9&&(s.type="spring"),t.render=l.extend(s,t.render),t},/**
     * Prepares for solving by constraint warming.
     * @private
     * @method preSolveAll
     * @param {body[]} bodies
     */i.preSolveAll=function(t){for(var e=0;e<t.length;e+=1){var i=t[e],n=i.constraintImpulse;i.isStatic||0===n.x&&0===n.y&&0===n.angle||(i.position.x+=n.x,i.position.y+=n.y,i.angle+=n.angle)}},/**
     * Solves all constraints in a list of collisions.
     * @private
     * @method solveAll
     * @param {constraint[]} constraints
     * @param {number} timeScale
     */i.solveAll=function(t,e){// Solve fixed constraints first.
for(var n=0;n<t.length;n+=1){var s=t[n],r=!s.bodyA||s.bodyA&&s.bodyA.isStatic,o=!s.bodyB||s.bodyB&&s.bodyB.isStatic;(r||o)&&i.solve(t[n],e)}// Solve free constraints last.
for(n=0;n<t.length;n+=1)r=!(s=t[n]).bodyA||s.bodyA&&s.bodyA.isStatic,o=!s.bodyB||s.bodyB&&s.bodyB.isStatic,r||o||i.solve(t[n],e)},/**
     * Solves a distance constraint with Gauss-Siedel method.
     * @private
     * @method solve
     * @param {constraint} constraint
     * @param {number} timeScale
     */i.solve=function(t,e){var n=t.bodyA,s=t.bodyB,o=t.pointA,a=t.pointB;if(n||s){n&&!n.isStatic&&(r.rotate(o,n.angle-t.angleA,o),t.angleA=n.angle),s&&!s.isStatic&&(r.rotate(a,s.angle-t.angleB,a),t.angleB=s.angle);var h=o,l=a;if(n&&(h=r.add(n.position,o)),s&&(l=r.add(s.position,a)),h&&l){var u=r.sub(h,l),c=r.magnitude(u);c<i._minLength&&(c=i._minLength);// solve distance constraint with Gauss-Siedel method
var d,f,p,g,v,m=(c-t.length)/c,y=t.stiffness<1?t.stiffness*e:t.stiffness,x=r.mult(u,m*y),w=(n?n.inverseMass:0)+(s?s.inverseMass:0),T=w+((n?n.inverseInertia:0)+(s?s.inverseInertia:0));if(t.damping){var b=r.create();p=r.div(u,c),v=r.sub(s&&r.sub(s.position,s.positionPrev)||b,n&&r.sub(n.position,n.positionPrev)||b),g=r.dot(p,v)}n&&!n.isStatic&&(f=n.inverseMass/w,// keep track of applied impulses for post solving
n.constraintImpulse.x-=x.x*f,n.constraintImpulse.y-=x.y*f,// apply forces
n.position.x-=x.x*f,n.position.y-=x.y*f,t.damping&&(n.positionPrev.x-=t.damping*p.x*g*f,n.positionPrev.y-=t.damping*p.y*g*f),// apply torque
d=r.cross(o,x)/T*i._torqueDampen*n.inverseInertia*(1-t.angularStiffness),n.constraintImpulse.angle-=d,n.angle-=d),s&&!s.isStatic&&(f=s.inverseMass/w,// keep track of applied impulses for post solving
s.constraintImpulse.x+=x.x*f,s.constraintImpulse.y+=x.y*f,// apply forces
s.position.x+=x.x*f,s.position.y+=x.y*f,t.damping&&(s.positionPrev.x+=t.damping*p.x*g*f,s.positionPrev.y+=t.damping*p.y*g*f),// apply torque
d=r.cross(a,x)/T*i._torqueDampen*s.inverseInertia*(1-t.angularStiffness),s.constraintImpulse.angle+=d,s.angle+=d)}}},/**
     * Performs body updates required after solving constraints.
     * @private
     * @method postSolveAll
     * @param {body[]} bodies
     */i.postSolveAll=function(t){for(var e=0;e<t.length;e++){var s=t[e],l=s.constraintImpulse;if(!s.isStatic&&(0!==l.x||0!==l.y||0!==l.angle)){o.set(s,!1);// update geometry and reset
for(var u=0;u<s.parts.length;u++){var c=s.parts[u];n.translate(c.vertices,l),u>0&&(c.position.x+=l.x,c.position.y+=l.y),0!==l.angle&&(n.rotate(c.vertices,l.angle,s.position),h.rotate(c.axes,l.angle),u>0&&r.rotateAbout(c.position,l.angle,s.position,c.position)),a.update(c.bounds,c.vertices,s.velocity)}// dampen the cached impulse for warming next step
l.angle*=i._warming,l.x*=i._warming,l.y*=i._warming}}},/**
     * Returns the world-space position of `constraint.pointA`, accounting for `constraint.bodyA`.
     * @method pointAWorld
     * @param {constraint} constraint
     * @returns {vector} the world-space position
     */i.pointAWorld=function(t){return{x:(t.bodyA?t.bodyA.position.x:0)+t.pointA.x,y:(t.bodyA?t.bodyA.position.y:0)+t.pointA.y}},/**
     * Returns the world-space position of `constraint.pointB`, accounting for `constraint.bodyB`.
     * @method pointBWorld
     * @param {constraint} constraint
     * @returns {vector} the world-space position
     */i.pointBWorld=function(t){return{x:(t.bodyB?t.bodyB.position.x:0)+t.pointB.x,y:(t.bodyB?t.bodyB.position.y:0)+t.pointB.y}}}),r("dmaXf",function(t,e){/**
* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.
*
* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Svg
*/var i={};t.exports=i,s("6V4ls");var n=s("4tPKt");/**
     * Converts an SVG path into an array of vector points.
     * If the input path forms a concave shape, you must decompose the result into convex parts before use.
     * See `Bodies.fromVertices` which provides support for this.
     * Note that this function is not guaranteed to support complex paths (such as those with holes).
     * You must load the `pathseg.js` polyfill on newer browsers.
     * @method pathToVertices
     * @param {SVGPathElement} path
     * @param {Number} [sampleLength=15]
     * @return {Vector[]} points
     */i.pathToVertices=function(t,e){"undefined"==typeof window||"SVGPathSeg"in window||n.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");// https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js
var s,r,o,a,h,l,u,c,d,f,p,g=[],v=0,m=0,y=0;e=e||15;var x=function(t,e,i){// all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)
var n=i%2==1&&i>1;// when the last point doesn't equal the current point add the current point
if(!d||t!=d.x||e!=d.y){d&&n?(f=d.x,p=d.y):(f=0,p=0);var s={x:f+t,y:p+e};(n||!d)&&(d=s),g.push(s),m=f+t,y=p+e}},w=function(t){var e=t.pathSegTypeAsLetter.toUpperCase();// skip path ends
if("Z"!==e){// map segment to x and y
switch(e){case"M":case"L":case"T":case"C":case"S":case"Q":m=t.x,y=t.y;break;case"H":m=t.x;break;case"V":y=t.y}x(m,y,t.pathSegType)}};for(// ensure path is absolute
i._svgPathToAbsolute(t),// get total length
o=t.getTotalLength(),// queue segments
l=[],s=0;s<t.pathSegList.numberOfItems;s+=1)l.push(t.pathSegList.getItem(s));// sample through path
for(u=l.concat();v<o;){// new segment
if((h=l[t.getPathSegAtLength(v)])!=c){for(;u.length&&u[0]!=h;)w(u.shift());c=h}// add points in between when curving
// TODO: adaptive sampling
switch(h.pathSegTypeAsLetter.toUpperCase()){case"C":case"T":case"S":case"Q":case"A":x((a=t.getPointAtLength(v)).x,a.y,0)}// increment by sample value
v+=e}// add remaining segments not passed by sampling
for(s=0,r=u.length;s<r;++s)w(u[s]);return g},i._svgPathToAbsolute=function(t){for(var e,i,n,s,r,o,a=t.pathSegList,h=0,l=0,u=a.numberOfItems,c=0;c<u;++c){var d=a.getItem(c),f=d.pathSegTypeAsLetter;if(/[MLHVCSQTA]/.test(f))"x"in d&&(h=d.x),"y"in d&&(l=d.y);else switch("x1"in d&&(n=h+d.x1),"x2"in d&&(r=h+d.x2),"y1"in d&&(s=l+d.y1),"y2"in d&&(o=l+d.y2),"x"in d&&(h+=d.x),"y"in d&&(l+=d.y),f){case"m":a.replaceItem(t.createSVGPathSegMovetoAbs(h,l),c);break;case"l":a.replaceItem(t.createSVGPathSegLinetoAbs(h,l),c);break;case"h":a.replaceItem(t.createSVGPathSegLinetoHorizontalAbs(h),c);break;case"v":a.replaceItem(t.createSVGPathSegLinetoVerticalAbs(l),c);break;case"c":a.replaceItem(t.createSVGPathSegCurvetoCubicAbs(h,l,n,s,r,o),c);break;case"s":a.replaceItem(t.createSVGPathSegCurvetoCubicSmoothAbs(h,l,r,o),c);break;case"q":a.replaceItem(t.createSVGPathSegCurvetoQuadraticAbs(h,l,n,s),c);break;case"t":a.replaceItem(t.createSVGPathSegCurvetoQuadraticSmoothAbs(h,l),c);break;case"a":a.replaceItem(t.createSVGPathSegArcAbs(h,l,d.r1,d.r2,d.angle,d.largeArcFlag,d.sweepFlag),c);break;case"z":case"Z":h=e,l=i}("M"==f||"m"==f)&&(e=h,i=l)}}}),r("5NLqi",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kkcpJ"),n=s("7BSWl"),r=s("7SBSk");t.exports=function(t,e,s,o){void 0===s&&(s={}),void 0===o&&(o=!0);var a=e.x,h=e.y;if(//  Temp body pos to avoid body null checks
e.body={temp:!0,position:{x:a,y:h}},//  First let's inject all of the components into the Game Object
[i.Bounce,i.Collision,i.Force,i.Friction,i.Gravity,i.Mass,i.Sensor,i.SetBody,i.Sleep,i.Static,i.Transform,i.Velocity].forEach(function(t){for(var i in t){var n;(n=t[i]).get&&"function"==typeof n.get||n.set&&"function"==typeof n.set?Object.defineProperty(e,i,{get:t[i].get,set:t[i].set}):Object.defineProperty(e,i,{value:t[i]})}}),e.world=t,e._tempVec2=new r(a,h),s.hasOwnProperty("type")&&"body"===s.type)e.setExistingBody(s,o);else{var l=n(s,"shape",null);l||(l="rectangle"),s.addToWorld=o,e.setBody(l,s)}return e}}),r("kkcpJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Physics.Matter.Components
 */t.exports={Bounce:s("fjhQk"),Collision:s("eQULH"),Force:s("fUFbJ"),Friction:s("gNeMi"),Gravity:s("aqQIn"),Mass:s("7gOTE"),Static:s("k0ju0"),Sensor:s("2Vt0K"),SetBody:s("2v5Yq"),Sleep:s("1m3zA"),Transform:s("8HGtH"),Velocity:s("cd88S")}}),r("fjhQk",function(t,e){t.exports={/**
     * Sets the restitution on the physics object.
     *
     * @method Phaser.Physics.Matter.Components.Bounce#setBounce
     * @since 3.0.0
     *
     * @param {number} value - A Number that defines the restitution (elasticity) of the body. The value is always positive and is in the range (0, 1). A value of 0 means collisions may be perfectly inelastic and no bouncing may occur. A value of 0.8 means the body may bounce back with approximately 80% of its kinetic energy. Note that collision response is based on pairs of bodies, and that restitution values are combined with the following formula: `Math.max(bodyA.restitution, bodyB.restitution)`
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setBounce:function(t){return this.body.restitution=t,this}}}),r("eQULH",function(t,e){t.exports={/**
     * Sets the collision category of this Game Object's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.
     * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision
     * categories are included in their collision masks (see {@link #setCollidesWith}).
     *
     * @method Phaser.Physics.Matter.Components.Collision#setCollisionCategory
     * @since 3.0.0
     *
     * @param {number} value - Unique category bitfield.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setCollisionCategory:function(t){return this.body.collisionFilter.category=t,this},/**
     * Sets the collision group of this Game Object's Matter Body. If this is zero or two Matter Bodies have different values,
     * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).
     * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,
     * they will never collide.
     *
     * @method Phaser.Physics.Matter.Components.Collision#setCollisionGroup
     * @since 3.0.0
     *
     * @param {number} value - Unique group index.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setCollisionGroup:function(t){return this.body.collisionFilter.group=t,this},/**
     * Sets the collision mask for this Game Object's Matter Body. Two Matter Bodies with different collision groups will only
     * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`
     * and `(categoryB & maskA) !== 0` are both true.
     *
     * @method Phaser.Physics.Matter.Components.Collision#setCollidesWith
     * @since 3.0.0
     *
     * @param {(number|number[])} categories - A unique category bitfield, or an array of them.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setCollidesWith:function(t){var e=0;if(Array.isArray(t))for(var i=0;i<t.length;i++)e|=t[i];else e=t;return this.body.collisionFilter.mask=e,this},/**
     * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.
     * 
     * This does not change the bodies collision category, group or filter. Those must be set in addition
     * to the callback.
     *
     * @method Phaser.Physics.Matter.Components.Collision#setOnCollide
     * @since 3.22.0
     *
     * @param {function} callback - The callback to invoke when this body starts colliding with another.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setOnCollide:function(t){return this.body.onCollideCallback=t,this},/**
     * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.
     * 
     * This does not change the bodies collision category, group or filter. Those must be set in addition
     * to the callback.
     *
     * @method Phaser.Physics.Matter.Components.Collision#setOnCollideEnd
     * @since 3.22.0
     *
     * @param {function} callback - The callback to invoke when this body stops colliding with another.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setOnCollideEnd:function(t){return this.body.onCollideEndCallback=t,this},/**
     * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.
     * 
     * This does not change the bodies collision category, group or filter. Those must be set in addition
     * to the callback.
     *
     * @method Phaser.Physics.Matter.Components.Collision#setOnCollideActive
     * @since 3.22.0
     *
     * @param {function} callback - The callback to invoke for the duration of this body colliding with another.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setOnCollideActive:function(t){return this.body.onCollideActiveCallback=t,this},/**
     * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.
     * 
     * This does not change the bodies collision category, group or filter. Those must be set in addition
     * to the callback.
     *
     * @method Phaser.Physics.Matter.Components.Collision#setOnCollideWith
     * @since 3.22.0
     *
     * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.
     * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setOnCollideWith:function(t,e){Array.isArray(t)||(t=[t]);for(var i=0;i<t.length;i++){var n=t[i].hasOwnProperty("body")?t[i].body:t[i];this.body.setOnCollideWith(n,e)}return this}}}),r("fUFbJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("lMiYr");t.exports={//  force = vec2 / point
/**
     * Applies a force to a body.
     *
     * @method Phaser.Physics.Matter.Components.Force#applyForce
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} force - A Vector that specifies the force to apply.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */applyForce:function(t){return this._tempVec2.set(this.body.position.x,this.body.position.y),i.applyForce(this.body,this._tempVec2,t),this},/**
     * Applies a force to a body from a given position.
     *
     * @method Phaser.Physics.Matter.Components.Force#applyForceFrom
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} position - The position in which the force comes from.
     * @param {Phaser.Math.Vector2} force - A Vector that specifies the force to apply.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */applyForceFrom:function(t,e){return i.applyForce(this.body,t,e),this},/**
     * Apply thrust to the forward position of the body.
     * 
     * Use very small values, such as 0.1, depending on the mass and required speed.
     *
     * @method Phaser.Physics.Matter.Components.Force#thrust
     * @since 3.0.0
     *
     * @param {number} speed - A speed value to be applied to a directional force.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */thrust:function(t){var e=this.body.angle;return this._tempVec2.set(t*Math.cos(e),t*Math.sin(e)),i.applyForce(this.body,{x:this.body.position.x,y:this.body.position.y},this._tempVec2),this},/**
     * Apply thrust to the left position of the body.
     * 
     * Use very small values, such as 0.1, depending on the mass and required speed.
     *
     * @method Phaser.Physics.Matter.Components.Force#thrustLeft
     * @since 3.0.0
     *
     * @param {number} speed - A speed value to be applied to a directional force.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */thrustLeft:function(t){var e=this.body.angle-Math.PI/2;return this._tempVec2.set(t*Math.cos(e),t*Math.sin(e)),i.applyForce(this.body,{x:this.body.position.x,y:this.body.position.y},this._tempVec2),this},/**
     * Apply thrust to the right position of the body.
     * 
     * Use very small values, such as 0.1, depending on the mass and required speed.
     *
     * @method Phaser.Physics.Matter.Components.Force#thrustRight
     * @since 3.0.0
     *
     * @param {number} speed - A speed value to be applied to a directional force.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */thrustRight:function(t){var e=this.body.angle+Math.PI/2;return this._tempVec2.set(t*Math.cos(e),t*Math.sin(e)),i.applyForce(this.body,{x:this.body.position.x,y:this.body.position.y},this._tempVec2),this},/**
     * Apply thrust to the back position of the body.
     * 
     * Use very small values, such as 0.1, depending on the mass and required speed.
     *
     * @method Phaser.Physics.Matter.Components.Force#thrustBack
     * @since 3.0.0
     *
     * @param {number} speed - A speed value to be applied to a directional force.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */thrustBack:function(t){var e=this.body.angle-Math.PI;return this._tempVec2.set(t*Math.cos(e),t*Math.sin(e)),i.applyForce(this.body,{x:this.body.position.x,y:this.body.position.y},this._tempVec2),this}}}),r("gNeMi",function(t,e){t.exports={/**
     * Sets new friction values for this Game Object's Matter Body.
     *
     * @method Phaser.Physics.Matter.Components.Friction#setFriction
     * @since 3.0.0
     *
     * @param {number} value - The new friction of the body, between 0 and 1, where 0 allows the Body to slide indefinitely, while 1 allows it to stop almost immediately after a force is applied.
     * @param {number} [air] - If provided, the new air resistance of the Body. The higher the value, the faster the Body will slow as it moves through space. 0 means the body has no air resistance.
     * @param {number} [fstatic] - If provided, the new static friction of the Body. The higher the value (e.g. 10), the more force it will take to initially get the Body moving when it is nearly stationary. 0 means the body will never "stick" when it is nearly stationary.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setFriction:function(t,e,i){return this.body.friction=t,void 0!==e&&(this.body.frictionAir=e),void 0!==i&&(this.body.frictionStatic=i),this},/**
     * Sets a new air resistance for this Game Object's Matter Body.
     * A value of 0 means the Body will never slow as it moves through space.
     * The higher the value, the faster a Body slows when moving through space.
     *
     * @method Phaser.Physics.Matter.Components.Friction#setFrictionAir
     * @since 3.0.0
     *
     * @param {number} value - The new air resistance for the Body.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setFrictionAir:function(t){return this.body.frictionAir=t,this},/**
     * Sets a new static friction for this Game Object's Matter Body.
     * A value of 0 means the Body will never "stick" when it is nearly stationary.
     * The higher the value (e.g. 10), the more force it will take to initially get the Body moving when it is nearly stationary.
     *
     * @method Phaser.Physics.Matter.Components.Friction#setFrictionStatic
     * @since 3.0.0
     *
     * @param {number} value - The new static friction for the Body.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setFrictionStatic:function(t){return this.body.frictionStatic=t,this}}}),r("aqQIn",function(t,e){t.exports={/**
     * A togglable function for ignoring world gravity in real-time on the current body.
     *
     * @method Phaser.Physics.Matter.Components.Gravity#setIgnoreGravity
     * @since 3.0.0
     *
     * @param {boolean} value - Set to true to ignore the effect of world gravity, or false to not ignore it.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setIgnoreGravity:function(t){return this.body.ignoreGravity=t,this}}}),r("7gOTE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("lMiYr"),n=s("7SBSk");t.exports={/**
     * Sets the mass of the Game Object's Matter Body.
     *
     * @method Phaser.Physics.Matter.Components.Mass#setMass
     * @since 3.0.0
     *
     * @param {number} value - The new mass of the body.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setMass:function(t){return i.setMass(this.body,t),this},/**
     * Sets density of the body.
     *
     * @method Phaser.Physics.Matter.Components.Mass#setDensity
     * @since 3.0.0
     *
     * @param {number} value - The new density of the body.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setDensity:function(t){return i.setDensity(this.body,t),this},/**
     * The body's center of mass.
     * 
     * Calling this creates a new `Vector2 each time to avoid mutation.
     * 
     * If you only need to read the value and won't change it, you can get it from `GameObject.body.centerOfMass`.
     *
     * @name Phaser.Physics.Matter.Components.Mass#centerOfMass
     * @type {Phaser.Math.Vector2}
     * @readonly
     * @since 3.10.0
     *
     * @return {Phaser.Math.Vector2} The center of mass.
     */centerOfMass:{get:function(){return new n(this.body.centerOfMass.x,this.body.centerOfMass.y)}}}}),r("k0ju0",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("lMiYr");t.exports={/**
     * Changes the physics body to be either static `true` or dynamic `false`.
     *
     * @method Phaser.Physics.Matter.Components.Static#setStatic
     * @since 3.0.0
     *
     * @param {boolean} value - `true` to set the body as being static, or `false` to make it dynamic.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setStatic:function(t){return i.setStatic(this.body,t),this},/**
     * Returns `true` if the body is static, otherwise `false` for a dynamic body.
     *
     * @method Phaser.Physics.Matter.Components.Static#isStatic
     * @since 3.0.0
     *
     * @return {boolean} `true` if the body is static, otherwise `false`.
     */isStatic:function(){return this.body.isStatic}}}),r("2Vt0K",function(t,e){t.exports={/**
     * Set the body belonging to this Game Object to be a sensor.
     * Sensors trigger collision events, but don't react with colliding body physically.
     *
     * @method Phaser.Physics.Matter.Components.Sensor#setSensor
     * @since 3.0.0
     *
     * @param {boolean} value - `true` to set the body as a sensor, or `false` to disable it.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setSensor:function(t){return this.body.isSensor=t,this},/**
     * Is the body belonging to this Game Object a sensor or not?
     *
     * @method Phaser.Physics.Matter.Components.Sensor#isSensor
     * @since 3.0.0
     *
     * @return {boolean} `true` if the body is a sensor, otherwise `false`.
     */isSensor:function(){return this.body.isSensor}}}),r("2v5Yq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gY9LZ"),n=s("lMiYr"),r=s("4cohD"),o=s("7BSWl"),a=s("gInVG"),h=s("eA2TZ"),l=s("laRjh");t.exports={/**
     * Set the body on a Game Object to a rectangle.
     * 
     * Calling this methods resets previous properties you may have set on the body, including
     * plugins, mass, friction, etc. So be sure to re-apply these in the options object if needed.
     *
     * @method Phaser.Physics.Matter.Components.SetBody#setRectangle
     * @since 3.0.0
     *
     * @param {number} width - Width of the rectangle.
     * @param {number} height - Height of the rectangle.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setRectangle:function(t,e,i){return this.setBody({type:"rectangle",width:t,height:e},i)},/**
     * Set the body on a Game Object to a circle.
     * 
     * Calling this methods resets previous properties you may have set on the body, including
     * plugins, mass, friction, etc. So be sure to re-apply these in the options object if needed.
     *
     * @method Phaser.Physics.Matter.Components.SetBody#setCircle
     * @since 3.0.0
     *
     * @param {number} radius - The radius of the circle.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setCircle:function(t,e){return this.setBody({type:"circle",radius:t},e)},/**
     * Set the body on the Game Object to a polygon shape.
     * 
     * Calling this methods resets previous properties you may have set on the body, including
     * plugins, mass, friction, etc. So be sure to re-apply these in the options object if needed.
     *
     * @method Phaser.Physics.Matter.Components.SetBody#setPolygon
     * @since 3.0.0
     *
     * @param {number} sides - The number of sides the polygon will have.
     * @param {number} radius - The "radius" of the polygon, i.e. the distance from its center to any vertex. This is also the radius of its circumcircle.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setPolygon:function(t,e,i){return this.setBody({type:"polygon",sides:e,radius:t},i)},/**
     * Set the body on the Game Object to a trapezoid shape.
     * 
     * Calling this methods resets previous properties you may have set on the body, including
     * plugins, mass, friction, etc. So be sure to re-apply these in the options object if needed.
     *
     * @method Phaser.Physics.Matter.Components.SetBody#setTrapezoid
     * @since 3.0.0
     *
     * @param {number} width - The width of the trapezoid Body.
     * @param {number} height - The height of the trapezoid Body.
     * @param {number} slope - The slope of the trapezoid. 0 creates a rectangle, while 1 creates a triangle. Positive values make the top side shorter, while negative values make the bottom side shorter.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setTrapezoid:function(t,e,i,n){return this.setBody({type:"trapezoid",width:t,height:e,slope:i},n)},/**
     * Set this Game Object to use the given existing Matter Body.
     * 
     * The body is first removed from the world before being added to this Game Object.
     *
     * @method Phaser.Physics.Matter.Components.SetBody#setExistingBody
     * @since 3.0.0
     *
     * @param {MatterJS.BodyType} body - The Body this Game Object should use.
     * @param {boolean} [addToWorld=true] - Should the body be immediately added to the World?
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setExistingBody:function(t,e){void 0===e&&(e=!0),this.body&&this.world.remove(this.body,!0),this.body=t;for(var i=0;i<t.parts.length;i++)t.parts[i].gameObject=this;var n=this;if(t.destroy=function(){n.world.remove(n.body,!0),n.body.gameObject=null},e&&(this.world.has(t)&&this.world.remove(t,!0),this.world.add(t)),this._originComponent){var s=t.render.sprite.xOffset,o=t.render.sprite.yOffset,a=t.centerOfMass.x,h=t.centerOfMass.y;if(r(a,.5)&&r(h,.5))this.setOrigin(s+.5,o+.5);else{var l=t.centerOffset.x,u=t.centerOffset.y;this.setOrigin(s+l/this.displayWidth,o+u/this.displayHeight)}}return this},/**
     * Set this Game Object to create and use a new Body based on the configuration object given.
     * 
     * Calling this method resets previous properties you may have set on the body, including
     * plugins, mass, friction, etc. So be sure to re-apply these in the options object if needed.
     *
     * @method Phaser.Physics.Matter.Components.SetBody#setBody
     * @since 3.0.0
     *
     * @param {(string|Phaser.Types.Physics.Matter.MatterSetBodyConfig)} config - Either a string, such as `circle`, or a Matter Set Body Configuration object.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setBody:function(t,e){if(!t)return this;"string"==typeof t&&(t={type:t});var s,r=o(t,"type","rectangle"),u=o(t,"x",this._tempVec2.x),c=o(t,"y",this._tempVec2.y),d=o(t,"width",this.width),f=o(t,"height",this.height);switch(r){case"rectangle":s=i.rectangle(u,c,d,f,e);break;case"circle":var p=o(t,"radius",Math.max(d,f)/2),g=o(t,"maxSides",25);s=i.circle(u,c,p,e,g);break;case"trapezoid":var v=o(t,"slope",.5);s=i.trapezoid(u,c,d,f,v,e);break;case"polygon":var m=o(t,"sides",5),y=o(t,"radius",Math.max(d,f)/2);s=i.polygon(u,c,m,y,e);break;case"fromVertices":case"fromVerts":var x=o(t,"verts",null);if(x){if("string"==typeof x&&(x=l.fromPath(x)),this.body&&!this.body.hasOwnProperty("temp"))n.setVertices(this.body,x),s=this.body;else{var w=o(t,"flagInternal",!1),T=o(t,"removeCollinear",.01),b=o(t,"minimumArea",10);s=i.fromVertices(u,c,x,e,w,T,b)}}break;case"fromPhysicsEditor":s=a.parseBody(u,c,t,e);break;case"fromPhysicsTracer":s=h.parseBody(u,c,t,e)}return s&&this.setExistingBody(s,t.addToWorld),this}}}),r("gInVG",function(t,e){/**
 * @author       Joachim Grill <joachim@codeandweb.com>
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 CodeAndWeb GmbH
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gY9LZ"),n=s("lMiYr"),r=s("4tPKt"),o=s("7BSWl"),a=s("laRjh");t.exports={/**
     * Parses a body element exported by PhysicsEditor.
     *
     * @function Phaser.Physics.Matter.PhysicsEditorParser.parseBody
     * @since 3.10.0
     *
     * @param {number} x - The horizontal world location of the body.
     * @param {number} y - The vertical world location of the body.
     * @param {object} config - The body configuration and fixture (child body) definitions, as exported by PhysicsEditor.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     * 
     * @return {MatterJS.BodyType} A compound Matter JS Body.
     */parseBody:function(t,e,i,s){void 0===s&&(s={});for(var a=o(i,"fixtures",[]),h=[],l=0;l<a.length;l++)for(var u=this.parseFixture(a[l]),c=0;c<u.length;c++)h.push(u[c]);var d=r.clone(i,!0);r.extend(d,s,!0),delete d.fixtures,delete d.type;var f=n.create(d);return n.setParts(f,h),n.setPosition(f,{x:t,y:e}),f},/**
     * Parses an element of the "fixtures" list exported by PhysicsEditor
     *
     * @function Phaser.Physics.Matter.PhysicsEditorParser.parseFixture
     * @since 3.10.0
     *
     * @param {object} fixtureConfig - The fixture object to parse.
     * 
     * @return {MatterJS.BodyType[]} - An array of Matter JS Bodies.
     */parseFixture:function(t){var e,n=r.extend({},!1,t);if(delete n.circle,delete n.vertices,t.circle){var s=o(t.circle,"x"),a=o(t.circle,"y"),h=o(t.circle,"radius");e=[i.circle(s,a,h,n)]}else t.vertices&&(e=this.parseVertices(t.vertices,n));return e},/**
     * Parses the "vertices" lists exported by PhysicsEditor.
     *
     * @function Phaser.Physics.Matter.PhysicsEditorParser.parseVertices
     * @since 3.10.0
     *
     * @param {array} vertexSets - The vertex lists to parse.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     * 
     * @return {MatterJS.BodyType[]} - An array of Matter JS Bodies.
     */parseVertices:function(t,e){void 0===e&&(e={});for(var s=[],o=0;o<t.length;o++)a.clockwiseSort(t[o]),s.push(n.create(r.extend({position:a.centre(t[o]),vertices:t[o]},e)));// flag coincident part edges
return i.flagCoincidentParts(s)}}}),r("eA2TZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gY9LZ"),n=s("lMiYr");t.exports={/**
     * Parses a body element from the given JSON data.
     *
     * @function Phaser.Physics.Matter.PhysicsJSONParser.parseBody
     * @since 3.22.0
     *
     * @param {number} x - The horizontal world location of the body.
     * @param {number} y - The vertical world location of the body.
     * @param {object} config - The body configuration data.
     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.
     * 
     * @return {MatterJS.BodyType} A Matter JS Body.
     */parseBody:function(t,e,s,r){void 0===r&&(r={});var o,a=s.vertices;if(1===a.length)//  Just a single Body
r.vertices=a[0],o=n.create(r),i.flagCoincidentParts(o.parts);else{for(var h=[],l=0;l<a.length;l++){var u=n.create({vertices:a[l]});h.push(u)}i.flagCoincidentParts(h),r.parts=h,o=n.create(r)}return o.label=s.label,n.setPosition(o,{x:t,y:e}),o}}}),r("1m3zA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("989p0"),n=s("azFoo"),r=s("aKoE7");t.exports={/**
     * Sets this Body to sleep.
     *
     * @method Phaser.Physics.Matter.Components.Sleep#setToSleep
     * @since 3.22.0
     *
     * @return {this} This Game Object.
     */setToSleep:function(){n.set(this.body,!0)},/**
     * Wakes this Body if asleep.
     *
     * @method Phaser.Physics.Matter.Components.Sleep#setAwake
     * @since 3.22.0
     *
     * @return {this} This Game Object.
     */setAwake:function(){n.set(this.body,!1)},/**
     * Sets the number of updates in which this body must have near-zero velocity before it is set as sleeping (if sleeping is enabled by the engine).
     *
     * @method Phaser.Physics.Matter.Components.Sleep#setSleepThreshold
     * @since 3.0.0
     *
     * @param {number} [value=60] - A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping.
     *
     * @return {this} This Game Object.
     */setSleepThreshold:function(t){return void 0===t&&(t=60),this.body.sleepThreshold=t,this},/**
     * Enable sleep and wake events for this body.
     * 
     * By default when a body goes to sleep, or wakes up, it will not emit any events.
     * 
     * The events are emitted by the Matter World instance and can be listened to via
     * the `SLEEP_START` and `SLEEP_END` events.
     *
     * @method Phaser.Physics.Matter.Components.Sleep#setSleepEvents
     * @since 3.0.0
     *
     * @param {boolean} start - `true` if you want the sleep start event to be emitted for this body.
     * @param {boolean} end - `true` if you want the sleep end event to be emitted for this body.
     *
     * @return {this} This Game Object.
     */setSleepEvents:function(t,e){return this.setSleepStartEvent(t),this.setSleepEndEvent(e),this},/**
     * Enables or disables the Sleep Start event for this body.
     *
     * @method Phaser.Physics.Matter.Components.Sleep#setSleepStartEvent
     * @since 3.0.0
     *
     * @param {boolean} value - `true` to enable the sleep event, or `false` to disable it.
     *
     * @return {this} This Game Object.
     */setSleepStartEvent:function(t){if(t){var e=this.world;r.on(this.body,"sleepStart",function(t){e.emit(i.SLEEP_START,t,this)})}else r.off(this.body,"sleepStart");return this},/**
     * Enables or disables the Sleep End event for this body.
     *
     * @method Phaser.Physics.Matter.Components.Sleep#setSleepEndEvent
     * @since 3.0.0
     *
     * @param {boolean} value - `true` to enable the sleep event, or `false` to disable it.
     *
     * @return {this} This Game Object.
     */setSleepEndEvent:function(t){if(t){var e=this.world;r.on(this.body,"sleepEnd",function(t){e.emit(i.SLEEP_END,t,this)})}else r.off(this.body,"sleepEnd");return this}}}),r("989p0",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Physics.Matter.Events
 */t.exports={AFTER_ADD:s("woJTz"),AFTER_REMOVE:s("cdvml"),AFTER_UPDATE:s("b8E6d"),BEFORE_ADD:s("bY0h8"),BEFORE_REMOVE:s("lUsZU"),BEFORE_UPDATE:s("lHsqm"),COLLISION_ACTIVE:s("3BnZl"),COLLISION_END:s("4E78h"),COLLISION_START:s("jJ99m"),DRAG_END:s("ae7k4"),DRAG:s("bPqam"),DRAG_START:s("4jqvM"),PAUSE:s("jYDYo"),RESUME:s("3tsUc"),SLEEP_END:s("95fmR"),SLEEP_START:s("gjhJU")}}),r("woJTz",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @typedef {object} Phaser.Physics.Matter.Events.AfterAddEvent
 *
 * @property {any[]} object - An array of the object(s) that have been added. May be a single body, constraint, composite or a mixture of these.
 * @property {any} source - The source object of the event.
 * @property {string} name - The name of the event.
 *//**
 * The Matter Physics After Add Event.
 * 
 * This event is dispatched by a Matter Physics World instance at the end of the process when a new Body
 * or Constraint has just been added to the world.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('afteradd', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#AFTER_ADD
 * @since 3.22.0
 * 
 * @param {Phaser.Physics.Matter.Events.AfterAddEvent} event - The Add Event object.
 */t.exports="afteradd"}),r("cdvml",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @typedef {object} Phaser.Physics.Matter.Events.AfterRemoveEvent
 *
 * @property {any[]} object - An array of the object(s) that were removed. May be a single body, constraint, composite or a mixture of these.
 * @property {any} source - The source object of the event.
 * @property {string} name - The name of the event.
 *//**
 * The Matter Physics After Remove Event.
 * 
 * This event is dispatched by a Matter Physics World instance at the end of the process when a 
 * Body or Constraint was removed from the world.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('afterremove', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#AFTER_REMOVE
 * @since 3.22.0
 * 
 * @param {Phaser.Physics.Matter.Events.AfterRemoveEvent} event - The Remove Event object.
 */t.exports="afterremove"}),r("b8E6d",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @typedef {object} Phaser.Physics.Matter.Events.AfterUpdateEvent
 *
 * @property {number} timestamp - The Matter Engine `timing.timestamp` value for the event.
 * @property {any} source - The source object of the event.
 * @property {string} name - The name of the event.
 *//**
 * The Matter Physics After Update Event.
 * 
 * This event is dispatched by a Matter Physics World instance after the engine has updated and all collision events have resolved.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('afterupdate', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#AFTER_UPDATE
 * @since 3.0.0
 * 
 * @param {Phaser.Physics.Matter.Events.AfterUpdateEvent} event - The Update Event object.
 */t.exports="afterupdate"}),r("bY0h8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @typedef {object} Phaser.Physics.Matter.Events.BeforeAddEvent
 *
 * @property {any[]} object - An array of the object(s) to be added. May be a single body, constraint, composite or a mixture of these.
 * @property {any} source - The source object of the event.
 * @property {string} name - The name of the event.
 *//**
 * The Matter Physics Before Add Event.
 * 
 * This event is dispatched by a Matter Physics World instance at the start of the process when a new Body
 * or Constraint is being added to the world.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('beforeadd', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#BEFORE_ADD
 * @since 3.22.0
 * 
 * @param {Phaser.Physics.Matter.Events.BeforeAddEvent} event - The Add Event object.
 */t.exports="beforeadd"}),r("lUsZU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @typedef {object} Phaser.Physics.Matter.Events.BeforeRemoveEvent
 *
 * @property {any[]} object - An array of the object(s) to be removed. May be a single body, constraint, composite or a mixture of these.
 * @property {any} source - The source object of the event.
 * @property {string} name - The name of the event.
 *//**
 * The Matter Physics Before Remove Event.
 * 
 * This event is dispatched by a Matter Physics World instance at the start of the process when a 
 * Body or Constraint is being removed from the world.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('beforeremove', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#BEFORE_REMOVE
 * @since 3.22.0
 * 
 * @param {Phaser.Physics.Matter.Events.BeforeRemoveEvent} event - The Remove Event object.
 */t.exports="beforeremove"}),r("lHsqm",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @typedef {object} Phaser.Physics.Matter.Events.BeforeUpdateEvent
 *
 * @property {number} timestamp - The Matter Engine `timing.timestamp` value for the event.
 * @property {any} source - The source object of the event.
 * @property {string} name - The name of the event.
 *//**
 * The Matter Physics Before Update Event.
 * 
 * This event is dispatched by a Matter Physics World instance right before all the collision processing takes place.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('beforeupdate', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#BEFORE_UPDATE
 * @since 3.0.0
 * 
 * @param {Phaser.Physics.Matter.Events.BeforeUpdateEvent} event - The Update Event object.
 */t.exports="beforeupdate"}),r("3BnZl",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @typedef {object} Phaser.Physics.Matter.Events.CollisionActiveEvent
 *
 * @property {Phaser.Types.Physics.Matter.MatterCollisionData[]} pairs - A list of all affected pairs in the collision.
 * @property {number} timestamp - The Matter Engine `timing.timestamp` value for the event.
 * @property {any} source - The source object of the event.
 * @property {string} name - The name of the event.
 *//**
 * The Matter Physics Collision Active Event.
 * 
 * This event is dispatched by a Matter Physics World instance after the engine has updated.
 * It provides a list of all pairs that are colliding in the current tick (if any).
 * 
 * Listen to it from a Scene using: `this.matter.world.on('collisionactive', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#COLLISION_ACTIVE
 * @since 3.0.0
 * 
 * @param {Phaser.Physics.Matter.Events.CollisionActiveEvent} event - The Collision Event object.
 * @param {MatterJS.BodyType} bodyA - The first body of the first colliding pair. The `event.pairs` array may contain more colliding bodies.
 * @param {MatterJS.BodyType} bodyB - The second body of the first colliding pair. The `event.pairs` array may contain more colliding bodies.
 */t.exports="collisionactive"}),r("4E78h",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @typedef {object} Phaser.Physics.Matter.Events.CollisionEndEvent
 *
 * @property {Phaser.Types.Physics.Matter.MatterCollisionData[]} pairs - A list of all affected pairs in the collision.
 * @property {number} timestamp - The Matter Engine `timing.timestamp` value for the event.
 * @property {any} source - The source object of the event.
 * @property {string} name - The name of the event.
 *//**
 * The Matter Physics Collision End Event.
 * 
 * This event is dispatched by a Matter Physics World instance after the engine has updated.
 * It provides a list of all pairs that have finished colliding in the current tick (if any).
 * 
 * Listen to it from a Scene using: `this.matter.world.on('collisionend', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#COLLISION_END
 * @since 3.0.0
 * 
 * @param {Phaser.Physics.Matter.Events.CollisionEndEvent} event - The Collision Event object.
 * @param {MatterJS.BodyType} bodyA - The first body of the first colliding pair. The `event.pairs` array may contain more colliding bodies.
 * @param {MatterJS.BodyType} bodyB - The second body of the first colliding pair. The `event.pairs` array may contain more colliding bodies.
 */t.exports="collisionend"}),r("jJ99m",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @typedef {object} Phaser.Physics.Matter.Events.CollisionStartEvent
 *
 * @property {Phaser.Types.Physics.Matter.MatterCollisionData[]} pairs - A list of all affected pairs in the collision.
 * @property {number} timestamp - The Matter Engine `timing.timestamp` value for the event.
 * @property {any} source - The source object of the event.
 * @property {string} name - The name of the event.
 *//**
 * The Matter Physics Collision Start Event.
 * 
 * This event is dispatched by a Matter Physics World instance after the engine has updated.
 * It provides a list of all pairs that have started to collide in the current tick (if any).
 * 
 * Listen to it from a Scene using: `this.matter.world.on('collisionstart', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#COLLISION_START
 * @since 3.0.0
 * 
 * @param {Phaser.Physics.Matter.Events.CollisionStartEvent} event - The Collision Event object.
 * @param {MatterJS.BodyType} bodyA - The first body of the first colliding pair. The `event.pairs` array may contain more colliding bodies.
 * @param {MatterJS.BodyType} bodyB - The second body of the first colliding pair. The `event.pairs` array may contain more colliding bodies.
 */t.exports="collisionstart"}),r("ae7k4",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Matter Physics Drag End Event.
 * 
 * This event is dispatched by a Matter Physics World instance when a Pointer Constraint
 * stops dragging a body.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('dragend', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#DRAG_END
 * @since 3.16.2
 * 
 * @param {MatterJS.BodyType} body - The Body that has stopped being dragged. This is a Matter Body, not a Phaser Game Object.
 * @param {Phaser.Physics.Matter.PointerConstraint} constraint - The Pointer Constraint that was dragging the body.
 */t.exports="dragend"}),r("bPqam",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Matter Physics Drag Event.
 * 
 * This event is dispatched by a Matter Physics World instance when a Pointer Constraint
 * is actively dragging a body. It is emitted each time the pointer moves.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('drag', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#DRAG
 * @since 3.16.2
 * 
 * @param {MatterJS.BodyType} body - The Body that is being dragged. This is a Matter Body, not a Phaser Game Object.
 * @param {Phaser.Physics.Matter.PointerConstraint} constraint - The Pointer Constraint that is dragging the body.
 */t.exports="drag"}),r("4jqvM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Matter Physics Drag Start Event.
 * 
 * This event is dispatched by a Matter Physics World instance when a Pointer Constraint
 * starts dragging a body.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('dragstart', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#DRAG_START
 * @since 3.16.2
 * 
 * @param {MatterJS.BodyType} body - The Body that has started being dragged. This is a Matter Body, not a Phaser Game Object.
 * @param {MatterJS.BodyType} part - The part of the body that was clicked on.
 * @param {Phaser.Physics.Matter.PointerConstraint} constraint - The Pointer Constraint that is dragging the body.
 */t.exports="dragstart"}),r("jYDYo",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Matter Physics World Pause Event.
 * 
 * This event is dispatched by an Matter Physics World instance when it is paused.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('pause', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#PAUSE
 * @since 3.0.0
 */t.exports="pause"}),r("3tsUc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Matter Physics World Resume Event.
 * 
 * This event is dispatched by an Matter Physics World instance when it resumes from a paused state.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('resume', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#RESUME
 * @since 3.0.0
 */t.exports="resume"}),r("95fmR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @typedef {object} Phaser.Physics.Matter.Events.SleepEndEvent
 *
 * @property {any} source - The source object of the event.
 * @property {string} name - The name of the event.
 *//**
 * The Matter Physics Sleep End Event.
 * 
 * This event is dispatched by a Matter Physics World instance when a Body stop sleeping.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('sleepend', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#SLEEP_END
 * @since 3.0.0
 * 
 * @param {Phaser.Physics.Matter.Events.SleepEndEvent} event - The Sleep Event object.
 * @param {MatterJS.BodyType} body - The body that has stopped sleeping.
 */t.exports="sleepend"}),r("gjhJU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @typedef {object} Phaser.Physics.Matter.Events.SleepStartEvent
 *
 * @property {any} source - The source object of the event.
 * @property {string} name - The name of the event.
 *//**
 * The Matter Physics Sleep Start Event.
 * 
 * This event is dispatched by a Matter Physics World instance when a Body goes to sleep.
 * 
 * Listen to it from a Scene using: `this.matter.world.on('sleepstart', listener)`.
 *
 * @event Phaser.Physics.Matter.Events#SLEEP_START
 * @since 3.0.0
 * 
 * @param {Phaser.Physics.Matter.Events.SleepStartEvent} event - The Sleep Event object.
 * @param {MatterJS.BodyType} body - The body that has gone to sleep.
 */t.exports="sleepstart"}),r("8HGtH",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("lMiYr"),n=s("bNtDi"),r=s("1W59j"),o=s("dokq5");t.exports={/**
     * The x position of this Game Object.
     *
     * @name Phaser.Physics.Matter.Components.Transform#x
     * @type {number}
     * @since 3.0.0
     */x:{get:function(){return this.body.position.x},set:function(t){this._tempVec2.set(t,this.y),i.setPosition(this.body,this._tempVec2)}},/**
     * The y position of this Game Object.
     *
     * @name Phaser.Physics.Matter.Components.Transform#y
     * @type {number}
     * @since 3.0.0
     */y:{get:function(){return this.body.position.y},set:function(t){this._tempVec2.set(this.x,t),i.setPosition(this.body,this._tempVec2)}},/**
     * The horizontal scale of this Game Object.
     *
     * @name Phaser.Physics.Matter.Components.Transform#scaleX
     * @type {number}
     * @since 3.0.0
     */scaleX:{get:function(){return this._scaleX},set:function(t){var e=1/this._scaleX,n=1/this._scaleY;this._scaleX=t,0===this._scaleX?this.renderFlags&=-5:this.renderFlags|=4,//  Reset Matter scale back to 1 (sigh)
i.scale(this.body,e,n),i.scale(this.body,t,this._scaleY)}},/**
     * The vertical scale of this Game Object.
     *
     * @name Phaser.Physics.Matter.Components.Transform#scaleY
     * @type {number}
     * @since 3.0.0
     */scaleY:{get:function(){return this._scaleY},set:function(t){var e=1/this._scaleX,n=1/this._scaleY;this._scaleY=t,0===this._scaleY?this.renderFlags&=-5:this.renderFlags|=4,i.scale(this.body,e,n),i.scale(this.body,this._scaleX,t)}},/**
     * Use `angle` to set or get rotation of the physics body associated to this GameObject.
     * Unlike rotation, when using set the value can be in degrees, which will be converted to radians internally.
     *
     * @name Phaser.Physics.Matter.Components.Transform#angle
     * @type {number}
     * @since 3.0.0
     */angle:{get:function(){return o(this.body.angle*n.RAD_TO_DEG)},set:function(t){//  value is in degrees
this.rotation=o(t)*n.DEG_TO_RAD}},/**
     * Use `rotation` to set or get the rotation of the physics body associated with this GameObject.
     * The value when set must be in radians.
     *
     * @name Phaser.Physics.Matter.Components.Transform#rotation
     * @type {number}
     * @since 3.0.0
     */rotation:{get:function(){return this.body.angle},set:function(t){//  value is in radians
this._rotation=r(t),i.setAngle(this.body,this._rotation)}},/**
     * Sets the position of the physics body along x and y axes.
     * Both the parameters to this function are optional and if not passed any they default to 0.
     * Velocity, angle, force etc. are unchanged.
     *
     * @method Phaser.Physics.Matter.Components.Transform#setPosition
     * @since 3.0.0
     *
     * @param {number} [x=0] - The horizontal position of the body.
     * @param {number} [y=x] - The vertical position of the body.
     *
     * @return {this} This Game Object.
     */setPosition:function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),this._tempVec2.set(t,e),i.setPosition(this.body,this._tempVec2),this},/**
     * Immediately sets the angle of the Body.
     * Angular velocity, position, force etc. are unchanged.
     *
     * @method Phaser.Physics.Matter.Components.Transform#setRotation
     * @since 3.0.0
     *
     * @param {number} [radians=0] - The angle of the body, in radians.
     *
     * @return {this} This Game Object.
     */setRotation:function(t){return void 0===t&&(t=0),this._rotation=r(t),i.setAngle(this.body,t),this},/**
     * Setting fixed rotation sets the Body inertia to Infinity, which stops it
     * from being able to rotate when forces are applied to it.
     *
     * @method Phaser.Physics.Matter.Components.Transform#setFixedRotation
     * @since 3.0.0
     *
     * @return {this} This Game Object.
     */setFixedRotation:function(){return i.setInertia(this.body,1/0),this},/**
     * Immediately sets the angle of the Body.
     * Angular velocity, position, force etc. are unchanged.
     *
     * @method Phaser.Physics.Matter.Components.Transform#setAngle
     * @since 3.0.0
     *
     * @param {number} [degrees=0] - The angle to set, in degrees.
     *
     * @return {this} This Game Object.
     */setAngle:function(t){return void 0===t&&(t=0),this.angle=t,i.setAngle(this.body,this.rotation),this},/**
     * Sets the scale of this Game Object.
     *
     * @method Phaser.Physics.Matter.Components.Transform#setScale
     * @since 3.0.0
     *
     * @param {number} [x=1] - The horizontal scale of this Game Object.
     * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the x value.
     * @param {Phaser.Math.Vector2} [point] - The point (Vector2) from which scaling will occur.
     *
     * @return {this} This Game Object.
     */setScale:function(t,e,n){void 0===t&&(t=1),void 0===e&&(e=t);var s=1/this._scaleX,r=1/this._scaleY;return this._scaleX=t,this._scaleY=e,i.scale(this.body,s,r,n),i.scale(this.body,t,e,n),this}}}),r("cd88S",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("lMiYr");t.exports={/**
     * Sets the angular velocity of the body instantly.
     * Position, angle, force etc. are unchanged.
     *
     * @method Phaser.Physics.Matter.Components.Velocity#setAngularVelocity
     * @since 3.0.0
     *
     * @param {number} value - The angular velocity.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setAngularVelocity:function(t){return i.setAngularVelocity(this.body,t),this},/**
     * Sets the horizontal velocity of the physics body.
     *
     * @method Phaser.Physics.Matter.Components.Velocity#setVelocityX
     * @since 3.0.0
     *
     * @param {number} x - The horizontal velocity value.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setVelocityX:function(t){return this._tempVec2.set(t,this.body.velocity.y),i.setVelocity(this.body,this._tempVec2),this},/**
     * Sets vertical velocity of the physics body.
     *
     * @method Phaser.Physics.Matter.Components.Velocity#setVelocityY
     * @since 3.0.0
     *
     * @param {number} y - The vertical velocity value.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setVelocityY:function(t){return this._tempVec2.set(this.body.velocity.x,t),i.setVelocity(this.body,this._tempVec2),this},/**
     * Sets both the horizontal and vertical velocity of the physics body.
     *
     * @method Phaser.Physics.Matter.Components.Velocity#setVelocity
     * @since 3.0.0
     *
     * @param {number} x - The horizontal velocity value.
     * @param {number} [y=x] - The vertical velocity value, it can be either positive or negative. If not given, it will be the same as the `x` value.
     *
     * @return {Phaser.GameObjects.GameObject} This Game Object.
     */setVelocity:function(t,e){return this._tempVec2.set(t,e),i.setVelocity(this.body,this._tempVec2),this}}}),r("k5BpG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("kkcpJ"),r=s("1zqlR"),o=s("7BSWl"),a=s("8qGvv"),h=s("DznIZ"),l=s("7SBSk"),u=new i({Extends:a,Mixins:[n.Bounce,n.Collision,n.Force,n.Friction,n.Gravity,n.Mass,n.Sensor,n.SetBody,n.Sleep,n.Static,n.Transform,n.Velocity,h],initialize:function(t,e,i,n,s,a){r.call(this,t.scene,"Image"),this.setTexture(n,s),this.setSizeToFrame(),this.setOrigin(),/**
         * A reference to the Matter.World instance that this body belongs to.
         *
         * @name Phaser.Physics.Matter.Image#world
         * @type {Phaser.Physics.Matter.World}
         * @since 3.0.0
         */this.world=t,/**
         * An internal temp vector used for velocity and force calculations.
         *
         * @name Phaser.Physics.Matter.Image#_tempVec2
         * @type {Phaser.Math.Vector2}
         * @private
         * @since 3.0.0
         */this._tempVec2=new l(e,i);var h=o(a,"shape",null);h?this.setBody(h,a):this.setRectangle(this.width,this.height,a),this.setPosition(e,i),this.initPipeline("TextureTintPipeline")}});t.exports=u}),r("9dw29",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("18ZZu"),n=s("jwj1g"),r=s("kkcpJ"),o=s("1zqlR"),a=s("7BSWl"),h=s("DznIZ"),l=s("gXuc8"),u=s("7SBSk"),c=new n({Extends:l,Mixins:[r.Bounce,r.Collision,r.Force,r.Friction,r.Gravity,r.Mass,r.Sensor,r.SetBody,r.Sleep,r.Static,r.Transform,r.Velocity,h],initialize:function(t,e,n,s,r,h){o.call(this,t.scene,"Sprite"),this.anims=new i(this),this.setTexture(s,r),this.setSizeToFrame(),this.setOrigin(),/**
         * A reference to the Matter.World instance that this body belongs to.
         *
         * @name Phaser.Physics.Matter.Sprite#world
         * @type {Phaser.Physics.Matter.World}
         * @since 3.0.0
         */this.world=t,/**
         * An internal temp vector used for velocity and force calculations.
         *
         * @name Phaser.Physics.Matter.Sprite#_tempVec2
         * @type {Phaser.Math.Vector2}
         * @private
         * @since 3.0.0
         */this._tempVec2=new u(e,n);var l=a(h,"shape",null);l?this.setBody(l,h):this.setRectangle(this.width,this.height,h),this.setPosition(e,n),this.initPipeline("TextureTintPipeline")}});t.exports=c}),r("cRMRu",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gY9LZ"),n=s("lMiYr"),r=s("jwj1g"),o=s("kkcpJ"),a=s("3vRz3"),h=s("7BSWl"),l=s("evjs6"),u=s("laRjh"),c=new r({Extends:a,Mixins:[o.Bounce,o.Collision,o.Friction,o.Gravity,o.Mass,o.Sensor,o.Sleep,o.Static],initialize:function(t,e,i){a.call(this),/**
         * The tile object the body is associated with.
         *
         * @name Phaser.Physics.Matter.TileBody#tile
         * @type {Phaser.Tilemaps.Tile}
         * @since 3.0.0
         */this.tile=e,/**
         * The Matter world the body exists within.
         *
         * @name Phaser.Physics.Matter.TileBody#world
         * @type {Phaser.Physics.Matter.World}
         * @since 3.0.0
         */this.world=t,e.physics.matterBody&&e.physics.matterBody.destroy(),e.physics.matterBody=this;// Set the body either from an existing body (if provided), the shapes in the tileset
// collision layer (if it exists) or a rectangle matching the tile.
var n=h(i,"body",null),s=h(i,"addToWorld",!0);n?this.setBody(n,s):h(e.getCollisionGroup(),"objects",[]).length>0?this.setFromTileCollision(i):this.setFromTileRectangle(i)},/**
     * Sets the current body to a rectangle that matches the bounds of the tile.
     *
     * @method Phaser.Physics.Matter.TileBody#setFromTileRectangle
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBodyTileOptions} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.
     * 
     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.
     */setFromTileRectangle:function(t){void 0===t&&(t={}),l(t,"isStatic")||(t.isStatic=!0),l(t,"addToWorld")||(t.addToWorld=!0);var e=this.tile.getBounds(),n=e.x+e.width/2,s=e.y+e.height/2,r=i.rectangle(n,s,e.width,e.height,t);return this.setBody(r,t.addToWorld),this},/**
     * Sets the current body from the collision group associated with the Tile. This is typically
     * set up in Tiled's collision editor.
     *
     * Note: Matter doesn't support all shapes from Tiled. Rectangles and polygons are directly
     * supported. Ellipses are converted into circle bodies. Polylines are treated as if they are
     * closed polygons. If a tile has multiple shapes, a multi-part body will be created. Concave
     * shapes are supported if poly-decomp library is included. Decomposition is not guaranteed to
     * work for complex shapes (e.g. holes), so it's often best to manually decompose a concave
     * polygon into multiple convex polygons yourself.
     *
     * @method Phaser.Physics.Matter.TileBody#setFromTileCollision
     * @since 3.0.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBodyTileOptions} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.
     * 
     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.
     */setFromTileCollision:function(t){void 0===t&&(t={}),l(t,"isStatic")||(t.isStatic=!0),l(t,"addToWorld")||(t.addToWorld=!0);for(var e=this.tile.tilemapLayer.scaleX,s=this.tile.tilemapLayer.scaleY,r=this.tile.getLeft(),o=this.tile.getTop(),a=h(this.tile.getCollisionGroup(),"objects",[]),c=[],d=0;d<a.length;d++){var f=a[d],p=r+f.x*e,g=o+f.y*s,v=f.width*e,m=f.height*s,y=null;if(f.rectangle)y=i.rectangle(p+v/2,g+m/2,v,m,t);else if(f.ellipse)y=i.circle(p+v/2,g+m/2,v/2,t);else if(f.polygon||f.polyline){var x=(f.polygon?f.polygon:f.polyline).map(function(t){return{x:t.x*e,y:t.y*s}}),w=u.create(x),T=u.centre(w);p+=T.x,g+=T.y,y=i.fromVertices(p,g,w,t)}y&&c.push(y)}return 1===c.length?this.setBody(c[0],t.addToWorld):c.length>1&&(t.parts=c,this.setBody(n.create(t),t.addToWorld)),this},/**
     * Sets the current body to the given body. This will remove the previous body, if one already
     * exists.
     *
     * @method Phaser.Physics.Matter.TileBody#setBody
     * @since 3.0.0
     *
     * @param {MatterJS.BodyType} body - The new Matter body to use.
     * @param {boolean} [addToWorld=true] - Whether or not to add the body to the Matter world.
     * 
     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.
     */setBody:function(t,e){return void 0===e&&(e=!0),this.body&&this.removeBody(),this.body=t,this.body.gameObject=this,e&&this.world.add(this.body),this},/**
     * Removes the current body from the TileBody and from the Matter world
     *
     * @method Phaser.Physics.Matter.TileBody#removeBody
     * @since 3.0.0
     *
     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.
     */removeBody:function(){return this.body&&(this.world.remove(this.body),this.body.gameObject=void 0,this.body=void 0),this},/**
     * Removes the current body from the tile and the world.
     *
     * @method Phaser.Physics.Matter.TileBody#destroy
     * @since 3.0.0
     *
     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.
     */destroy:function(){this.removeBody(),this.tile.physics.matterBody=void 0,this.removeAllListeners()}});t.exports=c}),r("a7FiE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6V4ls"),n=s("jwj1g"),r=s("in8Gg"),o=s("dmTql"),a=s("ldsg1"),h=s("989p0"),l=s("2nOjn"),u=s("awyQk"),c=s("azFoo"),d=s("7SBSk"),f=s("laRjh"),p=new n({initialize:function(t,e,i){void 0===i&&(i={}),/**
         * A reference to the Scene to which this Pointer Constraint belongs.
         * This is the same Scene as the Matter World instance.
         *
         * @name Phaser.Physics.Matter.PointerConstraint#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * A reference to the Matter World instance to which this Constraint belongs.
         *
         * @name Phaser.Physics.Matter.PointerConstraint#world
         * @type {Phaser.Physics.Matter.World}
         * @since 3.0.0
         */this.world=e,/**
         * The Camera the Pointer was interacting with when the input
         * down event was processed.
         *
         * @name Phaser.Physics.Matter.PointerConstraint#camera
         * @type {Phaser.Cameras.Scene2D.Camera}
         * @since 3.0.0
         */this.camera=null,/**
         * A reference to the Input Pointer that activated this Constraint.
         * This is set in the `onDown` handler.
         *
         * @name Phaser.Physics.Matter.PointerConstraint#pointer
         * @type {Phaser.Input.Pointer}
         * @default null
         * @since 3.0.0
         */this.pointer=null,/**
         * Is this Constraint active or not?
         * 
         * An active constraint will be processed each update. An inactive one will be skipped.
         * Use this to toggle a Pointer Constraint on and off.
         *
         * @name Phaser.Physics.Matter.PointerConstraint#active
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.active=!0,/**
         * The internal transformed position.
         *
         * @name Phaser.Physics.Matter.PointerConstraint#position
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.position=new d,/**
         * The body that is currently being dragged, if any.
         *
         * @name Phaser.Physics.Matter.PointerConstraint#body
         * @type {?MatterJS.BodyType}
         * @since 3.16.2
         */this.body=null,/**
         * The part of the body that was clicked on to start the drag.
         *
         * @name Phaser.Physics.Matter.PointerConstraint#part
         * @type {?MatterJS.BodyType}
         * @since 3.16.2
         */this.part=null,/**
         * The native Matter Constraint that is used to attach to bodies.
         *
         * @name Phaser.Physics.Matter.PointerConstraint#constraint
         * @type {MatterJS.ConstraintType}
         * @since 3.0.0
         */this.constraint=o.create(u(i,{label:"Pointer Constraint",pointA:{x:0,y:0},pointB:{x:0,y:0},length:.01,stiffness:.1,angularStiffness:1,collisionFilter:{category:1,mask:4294967295,group:0}})),this.world.on(h.BEFORE_UPDATE,this.update,this),t.sys.input.on(l.POINTER_DOWN,this.onDown,this),t.sys.input.on(l.POINTER_UP,this.onUp,this)},/**
     * A Pointer has been pressed down onto the Scene.
     * 
     * If this Constraint doesn't have an active Pointer then a hit test is set to
     * run against all active bodies in the world during the _next_ call to `update`.
     * If a body is found, it is bound to this constraint and the drag begins.
     *
     * @method Phaser.Physics.Matter.PointerConstraint#onDown
     * @since 3.0.0
     *
     * @param {Phaser.Input.Pointer} pointer - A reference to the Pointer that was pressed.
     */onDown:function(t){this.pointer||(this.pointer=t,this.camera=t.camera)},/**
     * A Pointer has been released from the Scene. If it was the one this constraint was using, it's cleared.
     *
     * @method Phaser.Physics.Matter.PointerConstraint#onUp
     * @since 3.22.0
     *
     * @param {Phaser.Input.Pointer} pointer - A reference to the Pointer that was pressed.
     */onUp:function(t){t===this.pointer&&(this.pointer=null)},/**
     * Scans all active bodies in the current Matter World to see if any of them
     * are hit by the Pointer. The _first one_ found to hit is set as the active contraint
     * body.
     *
     * @method Phaser.Physics.Matter.PointerConstraint#getBody
     * @fires Phaser.Physics.Matter.Events#DRAG_START
     * @since 3.16.2
     * 
     * @return {boolean} `true` if a body was found and set, otherwise `false`.
     */getBody:function(t){var e=this.position,n=this.constraint;this.camera.getWorldPoint(t.x,t.y,e);for(var s=r.allBodies(this.world.localWorld),o=0;o<s.length;o++){var l=s[o];if(!l.ignorePointer&&i.contains(l.bounds,e)&&a.canCollide(l.collisionFilter,n.collisionFilter)&&this.hitTestBody(l,e))return this.world.emit(h.DRAG_START,l,this.part,this),!0}return!1},/**
     * Scans the current body to determine if a part of it was clicked on.
     * If a part is found the body is set as the `constraint.bodyB` property,
     * as well as the `body` property of this class. The part is also set.
     *
     * @method Phaser.Physics.Matter.PointerConstraint#hitTestBody
     * @since 3.16.2
     *
     * @param {MatterJS.BodyType} body - The Matter Body to check.
     * @param {Phaser.Math.Vector2} position - A translated hit test position.
     *
     * @return {boolean} `true` if a part of the body was hit, otherwise `false`.
     */hitTestBody:function(t,e){for(var i=this.constraint,n=t.parts.length,s=n>1?1:0,r=s;r<n;r++){var o=t.parts[r];if(f.contains(o.vertices,e))return i.pointA=e,i.pointB={x:e.x-t.position.x,y:e.y-t.position.y},i.bodyB=t,i.angleB=t.angle,c.set(t,!1),this.part=o,this.body=t,!0}return!1},/**
     * Internal update handler. Called in the Matter BEFORE_UPDATE step.
     *
     * @method Phaser.Physics.Matter.PointerConstraint#update
     * @fires Phaser.Physics.Matter.Events#DRAG
     * @since 3.0.0
     */update:function(){var t=this.pointer,e=this.body;if(!this.active||!t){e&&this.stopDrag();return}if(!t.isDown&&e){this.stopDrag();return}if(t.isDown){if(!e&&!this.getBody(t))return;e=this.body;var i=this.position,n=this.constraint;this.camera.getWorldPoint(t.x,t.y,i),//  Drag update
n.pointA.x=i.x,n.pointA.y=i.y,c.set(e,!1),this.world.emit(h.DRAG,e,this)}},/**
     * Stops the Pointer Constraint from dragging the body any further.
     * 
     * This is called automatically if the Pointer is released while actively
     * dragging a body. Or, you can call it manually to release a body from a
     * constraint without having to first release the pointer.
     *
     * @method Phaser.Physics.Matter.PointerConstraint#stopDrag
     * @fires Phaser.Physics.Matter.Events#DRAG_END
     * @since 3.16.2
     */stopDrag:function(){var t=this.body,e=this.constraint;e.bodyB=null,e.pointB=null,this.pointer=null,this.body=null,this.part=null,t&&this.world.emit(h.DRAG_END,t,this)},/**
     * Destroys this Pointer Constraint instance and all of its references.
     *
     * @method Phaser.Physics.Matter.PointerConstraint#destroy
     * @since 3.0.0
     */destroy:function(){this.world.removeConstraint(this.constraint),this.pointer=null,this.constraint=null,this.body=null,this.part=null,this.world.off(h.BEFORE_UPDATE,this.update),this.scene.sys.input.off(l.POINTER_DOWN,this.onDown,this),this.scene.sys.input.off(l.POINTER_UP,this.onUp,this)}});t.exports=p}),r("ldsg1",function(t,e){/**
* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.
*
* @class Detector
*/// TODO: speculative contacts
var i={};t.exports=i;var n=s("4IHIa"),r=s("8lC3Z"),o=s("6V4ls");/**
     * Finds all collisions given a list of pairs.
     * @method collisions
     * @param {pair[]} broadphasePairs
     * @param {engine} engine
     * @return {array} collisions
     */i.collisions=function(t,e){// @endif
for(var s=[],a=e.pairs.table,h=e.metrics,l=0;l<t.length;l++){var u=t[l][0],c=t[l][1];if((!u.isStatic&&!u.isSleeping||!c.isStatic&&!c.isSleeping)&&i.canCollide(u.collisionFilter,c.collisionFilter)&&(// @if DEBUG
h.midphaseTests+=1,o.overlaps(u.bounds,c.bounds)))for(var d=u.parts.length>1?1:0;d<u.parts.length;d++)for(var f=u.parts[d],p=c.parts.length>1?1:0;p<c.parts.length;p++){var g=c.parts[p];if(f===u&&g===c||o.overlaps(f.bounds,g.bounds)){// find a previous collision we could reuse
var v,m=a[r.id(f,g)];v=m&&m.isActive?m.collision:null;// narrow phase
var y=n.collides(f,g,v);// @if DEBUG
h.narrowphaseTests+=1,y.reused&&(h.narrowReuseCount+=1),y.collided&&(s.push(y),// @if DEBUG
h.narrowDetections+=1)}}}return s},/**
     * Returns `true` if both supplied collision filters will allow a collision to occur.
     * See `body.collisionFilter` for more information.
     * @method canCollide
     * @param {} filterA
     * @param {} filterB
     * @return {bool} `true` if collision can occur
     */i.canCollide=function(t,e){return t.group===e.group&&0!==t.group?t.group>0:(t.mask&e.category)!=0&&(e.mask&t.category)!=0}}),r("4IHIa",function(t,e){/**
* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.
*
* @class SAT
*/// TODO: true circles and curves
var i={};t.exports=i;var n=s("laRjh"),r=s("a7bN0");/**
     * Detect collision between two bodies using the Separating Axis Theorem.
     * @method collides
     * @param {body} bodyA
     * @param {body} bodyB
     * @param {collision} previousCollision
     * @return {collision} collision
     */i.collides=function(t,e,s){var o,a,h,l,u=!1;if(s){// estimate total motion
var c=t.parent,d=e.parent,f=c.speed*c.speed+c.angularSpeed*c.angularSpeed+d.speed*d.speed+d.angularSpeed*d.angularSpeed;// we may be able to (partially) reuse collision result 
// but only safe if collision was resting
u=s&&s.collided&&f<.2,// reuse collision object
l=s}else l={collided:!1,bodyA:t,bodyB:e};if(s&&u){// if we can reuse the collision result
// we only need to test the previously found axis
var p=l.axisBody,g=p===t?e:t,v=[p.axes[s.axisNumber]];if(h=i._overlapAxes(p.vertices,g.vertices,v),l.reused=!0,h.overlap<=0)return l.collided=!1,l}else{if(// if we can't reuse a result, perform a full SAT test
(o=i._overlapAxes(t.vertices,e.vertices,t.axes)).overlap<=0||(a=i._overlapAxes(e.vertices,t.vertices,e.axes)).overlap<=0)return l.collided=!1,l;o.overlap<a.overlap?(h=o,l.axisBody=t):(h=a,l.axisBody=e),// important for reuse later
l.axisNumber=h.axisNumber}l.bodyA=t.id<e.id?t:e,l.bodyB=t.id<e.id?e:t,l.collided=!0,l.depth=h.overlap,l.parentA=l.bodyA.parent,l.parentB=l.bodyB.parent,t=l.bodyA,e=l.bodyB,0>r.dot(h.axis,r.sub(e.position,t.position))?l.normal={x:h.axis.x,y:h.axis.y}:l.normal={x:-h.axis.x,y:-h.axis.y},l.tangent=r.perp(l.normal),l.penetration=l.penetration||{},l.penetration.x=l.normal.x*l.depth,l.penetration.y=l.normal.y*l.depth;// find support points, there is always either exactly one or two
var m=i._findSupports(t,e,l.normal),y=[];// find the supports from bodyA that are inside bodyB
if(n.contains(t.vertices,m[0])&&y.push(m[0]),n.contains(t.vertices,m[1])&&y.push(m[1]),y.length<2){var x=i._findSupports(e,t,r.neg(l.normal));n.contains(e.vertices,x[0])&&y.push(x[0]),y.length<2&&n.contains(e.vertices,x[1])&&y.push(x[1])}return y.length<1&&(y=[m[0]]),l.supports=y,l},/**
     * Find the overlap between two sets of vertices.
     * @method _overlapAxes
     * @private
     * @param {} verticesA
     * @param {} verticesB
     * @param {} axes
     * @return result
     */i._overlapAxes=function(t,e,n){for(var s,o,a=r._temp[0],h=r._temp[1],l={overlap:Number.MAX_VALUE},u=0;u<n.length;u++){if(o=n[u],i._projectToAxis(a,t,o),i._projectToAxis(h,e,o),(s=Math.min(a.max-h.min,h.max-a.min))<=0){l.overlap=s;break}s<l.overlap&&(l.overlap=s,l.axis=o,l.axisNumber=u)}return l},/**
     * Projects vertices on an axis and returns an interval.
     * @method _projectToAxis
     * @private
     * @param {} projection
     * @param {} vertices
     * @param {} axis
     */i._projectToAxis=function(t,e,i){for(var n=r.dot(e[0],i),s=n,o=1;o<e.length;o+=1){var a=r.dot(e[o],i);a>s?s=a:a<n&&(n=a)}t.min=n,t.max=s},/**
     * Finds supporting vertices given two bodies along a given direction using hill-climbing.
     * @method _findSupports
     * @private
     * @param {} bodyA
     * @param {} bodyB
     * @param {} normal
     * @return [vector]
     */i._findSupports=function(t,e,i){// find closest vertex on bodyB
for(var n,s,o,a,h=Number.MAX_VALUE,l=r._temp[0],u=e.vertices,c=t.position,d=0;d<u.length;d++)s=u[d],l.x=s.x-c.x,l.y=s.y-c.y,(n=-r.dot(i,l))<h&&(h=n,o=s);var f=o.index-1>=0?o.index-1:u.length-1;s=u[f],l.x=s.x-c.x,l.y=s.y-c.y,h=-r.dot(i,l),a=s;var p=(o.index+1)%u.length;return s=u[p],l.x=s.x-c.x,l.y=s.y-c.y,(n=-r.dot(i,l))<h&&(a=s),[o,a]}}),r("8lC3Z",function(t,e){/**
* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.
*
* @class Pair
*/var i={};t.exports=i,/**
     * Creates a pair.
     * @method create
     * @param {collision} collision
     * @param {number} timestamp
     * @return {pair} A new pair
     */i.create=function(t,e){var n=t.bodyA,s=t.bodyB,r={id:i.id(n,s),bodyA:n,bodyB:s,activeContacts:[],separation:0,isActive:!0,confirmedActive:!0,isSensor:n.isSensor||s.isSensor,timeCreated:e,timeUpdated:e,collision:null,inverseMass:0,friction:0,frictionStatic:0,restitution:0,slop:0};return i.update(r,t,e),r},/**
     * Updates a pair given a collision.
     * @method update
     * @param {pair} pair
     * @param {collision} collision
     * @param {number} timestamp
     */i.update=function(t,e,n){if(t.collision=e,e.collided){var s=e.supports,r=t.activeContacts,o=e.parentA,a=e.parentB;t.inverseMass=o.inverseMass+a.inverseMass,t.friction=Math.min(o.friction,a.friction),t.frictionStatic=Math.max(o.frictionStatic,a.frictionStatic),t.restitution=Math.max(o.restitution,a.restitution),t.slop=Math.max(o.slop,a.slop);for(var h=0;h<s.length;h++)r[h]=s[h].contact;// optimise array size
var l=s.length;l<r.length&&(r.length=l),t.separation=e.depth,i.setActive(t,!0,n)}else!0===t.isActive&&i.setActive(t,!1,n)},/**
     * Set a pair as active or inactive.
     * @method setActive
     * @param {pair} pair
     * @param {bool} isActive
     * @param {number} timestamp
     */i.setActive=function(t,e,i){e?(t.isActive=!0,t.timeUpdated=i):(t.isActive=!1,t.activeContacts.length=0)},/**
     * Get the id for the given pair.
     * @method id
     * @param {body} bodyA
     * @param {body} bodyB
     * @return {string} Unique pairId
     */i.id=function(t,e){return t.id<e.id?"A"+t.id+"B"+e.id:"A"+e.id+"B"+t.id}}),r("ln6QG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Physics.Matter.Matter
 */var i=s("kesQx");i.Body=s("lMiYr"),i.Composite=s("in8Gg"),i.World=s("koAaK"),i.Detector=s("ldsg1"),i.Grid=s("7ki4D"),i.Pairs=s("jzUT1"),i.Pair=s("8lC3Z"),i.Query=s("6qoEV"),i.Resolver=s("cZK1I"),i.SAT=s("4IHIa"),i.Constraint=s("dmTql"),i.Common=s("4tPKt"),i.Engine=s("d8Zzv"),i.Events=s("aKoE7"),i.Sleeping=s("azFoo"),i.Plugin=s("hw9TH"),i.Bodies=s("gY9LZ"),i.Composites=s("cbd5m"),i.Axes=s("hUjHB"),i.Bounds=s("6V4ls"),i.Svg=s("dmaXf"),i.Vector=s("a7bN0"),i.Vertices=s("laRjh"),// aliases
i.World.add=i.Composite.add,i.World.remove=i.Composite.remove,i.World.addComposite=i.Composite.addComposite,i.World.addBody=i.Composite.addBody,i.World.addConstraint=i.Composite.addConstraint,i.World.clear=i.Composite.clear,t.exports=i}),r("kesQx",function(t,e){/**
* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.
*
* @class Matter
*/var i={};t.exports=i;var n=s("hw9TH"),r=s("4tPKt");/**
     * The library name.
     * @property name
     * @readOnly
     * @type {String}
     */i.name="matter-js",/**
     * The library version.
     * @property version
     * @readOnly
     * @type {String}
     */i.version="0.14.2",/**
     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.
     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.
     * @property uses
     * @type {Array}
     */i.uses=[],/**
     * The plugins that have been installed through `Matter.Plugin.install`. Read only.
     * @property used
     * @readOnly
     * @type {Array}
     */i.used=[],/**
     * Installs the given plugins on the `Matter` namespace.
     * This is a short-hand for `Plugin.use`, see it for more information.
     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.
     * Avoid calling this function multiple times unless you intend to manually control installation order.
     * @method use
     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).
     */i.use=function(){n.use(i,Array.prototype.slice.call(arguments))},/**
     * Chains a function to excute before the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method before
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */i.before=function(t,e){return t=t.replace(/^Matter./,""),r.chainPathBefore(i,t,e)},/**
     * Chains a function to excute after the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method after
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */i.after=function(t,e){return t=t.replace(/^Matter./,""),r.chainPathAfter(i,t,e)}}),r("hw9TH",function(t,e){/**
* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.
*
* @class Plugin
*/var i={};t.exports=i;var n=s("4tPKt");i._registry={},/**
     * Registers a plugin object so it can be resolved later by name.
     * @method register
     * @param plugin {} The plugin to register.
     * @return {object} The plugin.
     */i.register=function(t){if(i.isPlugin(t)||n.warn("Plugin.register:",i.toString(t),"does not implement all required fields."),t.name in i._registry){var e=i._registry[t.name],s=i.versionParse(t.version).number,r=i.versionParse(e.version).number;s>r?(n.warn("Plugin.register:",i.toString(e),"was upgraded to",i.toString(t)),i._registry[t.name]=t):s<r?n.warn("Plugin.register:",i.toString(e),"can not be downgraded to",i.toString(t)):t!==e&&n.warn("Plugin.register:",i.toString(t),"is already registered to different plugin object")}else i._registry[t.name]=t;return t},/**
     * Resolves a dependency to a plugin object from the registry if it exists. 
     * The `dependency` may contain a version, but only the name matters when resolving.
     * @method resolve
     * @param dependency {string} The dependency.
     * @return {object} The plugin if resolved, otherwise `undefined`.
     */i.resolve=function(t){return i._registry[i.dependencyParse(t).name]},/**
     * Returns a pretty printed plugin name and version.
     * @method toString
     * @param plugin {} The plugin.
     * @return {string} Pretty printed plugin name and version.
     */i.toString=function(t){return"string"==typeof t?t:(t.name||"anonymous")+"@"+(t.version||t.range||"0.0.0")},/**
     * Returns `true` if the object meets the minimum standard to be considered a plugin.
     * This means it must define the following properties:
     * - `name`
     * - `version`
     * - `install`
     * @method isPlugin
     * @param obj {} The obj to test.
     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.
     */i.isPlugin=function(t){return t&&t.name&&t.version&&t.install},/**
     * Returns `true` if a plugin with the given `name` been installed on `module`.
     * @method isUsed
     * @param module {} The module.
     * @param name {string} The plugin name.
     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.
     */i.isUsed=function(t,e){return t.used.indexOf(e)>-1},/**
     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.
     * If `plugin.for` is not specified then it is assumed to be applicable.
     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.
     * @method isFor
     * @param plugin {} The plugin.
     * @param module {} The module.
     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.
     */i.isFor=function(t,e){var n=t.for&&i.dependencyParse(t.for);return!t.for||e.name===n.name&&i.versionSatisfies(e.version,n.range)},/**
     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.
     * For installing plugins on `Matter` see the convenience function `Matter.use`.
     * Plugins may be specified either by their name or a reference to the plugin object.
     * Plugins themselves may specify further dependencies, but each plugin is installed only once.
     * Order is important, a topological sort is performed to find the best resulting order of installation.
     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.
     * This function logs the resulting status of each dependency in the console, along with any warnings.
     * - A green tick  indicates a dependency was resolved and installed.
     * - An orange diamond  indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.
     * - A red cross  indicates a dependency could not be resolved.
     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.
     * @method use
     * @param module {} The module install plugins on.
     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).
     */i.use=function(t,e){if(t.uses=(t.uses||[]).concat(e||[]),0===t.uses.length){n.warn("Plugin.use:",i.toString(t),"does not specify any dependencies to install.");return}for(var s=i.dependencies(t),r=n.topologicalSort(s),o=[],a=0;a<r.length;a+=1)if(r[a]!==t.name){var h=i.resolve(r[a]);if(!h){o.push(" "+r[a]);continue}i.isUsed(t,h.name)||(i.isFor(h,t)||(n.warn("Plugin.use:",i.toString(h),"is for",h.for,"but installed on",i.toString(t)+"."),h._warned=!0),h.install?h.install(t):(n.warn("Plugin.use:",i.toString(h),"does not specify an install function."),h._warned=!0),h._warned?(o.push("\uD83D\uDD36 "+i.toString(h)),delete h._warned):o.push(" "+i.toString(h)),t.used.push(h.name))}o.length>0&&!h.silent&&n.info(o.join("  "))},/**
     * Recursively finds all of a module's dependencies and returns a flat dependency graph.
     * @method dependencies
     * @param module {} The module.
     * @return {object} A dependency graph.
     */i.dependencies=function(t,e){var s=i.dependencyParse(t),r=s.name;if(!(r in(e=e||{}))){t=i.resolve(t)||t,e[r]=n.map(t.uses||[],function(e){i.isPlugin(e)&&i.register(e);var r=i.dependencyParse(e),o=i.resolve(e);return o&&!i.versionSatisfies(o.version,r.range)?(n.warn("Plugin.dependencies:",i.toString(o),"does not satisfy",i.toString(r),"used by",i.toString(s)+"."),o._warned=!0,t._warned=!0):o||(n.warn("Plugin.dependencies:",i.toString(e),"used by",i.toString(s),"could not be resolved."),t._warned=!0),r.name});for(var o=0;o<e[r].length;o+=1)i.dependencies(e[r][o],e);return e}},/**
     * Parses a dependency string into its components.
     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * This function can also handle dependencies that are already resolved (e.g. a module object).
     * @method dependencyParse
     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.
     * @return {object} The dependency parsed into its components.
     */i.dependencyParse=function(t){return n.isString(t)?(/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/.test(t)||n.warn("Plugin.dependencyParse:",t,"is not a valid dependency string."),{name:t.split("@")[0],range:t.split("@")[1]||"*"}):{name:t.name,range:t.range||t.version}},/**
     * Parses a version string into its components.  
     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).
     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.
     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).
     * Only the following range types are supported:
     * - Tilde ranges e.g. `~1.2.3`
     * - Caret ranges e.g. `^1.2.3`
     * - Exact version e.g. `1.2.3`
     * - Any version `*`
     * @method versionParse
     * @param range {string} The version string.
     * @return {object} The version range parsed into its components.
     */i.versionParse=function(t){/^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/.test(t)||n.warn("Plugin.versionParse:",t,"is not a valid version or range.");var e=t.split("-"),i=isNaN(Number((t=e[0])[0])),s=i?t.substr(1):t,r=n.map(s.split("."),function(t){return Number(t)});return{isRange:i,version:s,range:t,operator:i?t[0]:"",parts:r,prerelease:e[1],number:1e8*r[0]+1e4*r[1]+r[2]}},/**
     * Returns `true` if `version` satisfies the given `range`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.
     * @method versionSatisfies
     * @param version {string} The version string.
     * @param range {string} The range string.
     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.
     */i.versionSatisfies=function(t,e){e=e||"*";var n=i.versionParse(e),s=n.parts,r=i.versionParse(t),o=r.parts;if(n.isRange){if("*"===n.operator||"*"===t)return!0;if("~"===n.operator)return o[0]===s[0]&&o[1]===s[1]&&o[2]>=s[2];if("^"===n.operator)return s[0]>0?o[0]===s[0]&&r.number>=n.number:s[1]>0?o[1]===s[1]&&o[2]>=s[2]:o[2]===s[2]}return t===e||"*"===t}}),r("koAaK",function(t,e){/**
* The `Matter.World` module contains methods for creating and manipulating the world composite.
* A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.
* A `Matter.World` has a few additional properties including `gravity` and `bounds`.
* It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.
* There are also a few methods here that alias those in `Matter.Composite` for easier readability.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class World
* @extends Composite
*/var i={};t.exports=i;var n=s("in8Gg");s("dmTql");var r=s("4tPKt");/**
     * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @constructor
     * @param {} options
     * @return {world} A new world
     */i.create=function(t){var e=n.create();return r.extend(e,{label:"World",gravity:{x:0,y:1,scale:.001},bounds:{min:{x:-1/0,y:-1/0},max:{x:1/0,y:1/0}}},t)}}),r("7ki4D",function(t,e){/**
* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.
*
* @class Grid
*/var i={};t.exports=i;var n=s("8lC3Z"),r=s("ldsg1"),o=s("4tPKt");/**
     * Creates a new grid.
     * @method create
     * @param {} options
     * @return {grid} A new grid
     */i.create=function(t){var e={controller:i,detector:r.collisions,buckets:{},pairs:{},pairsList:[],bucketWidth:48,bucketHeight:48};return o.extend(e,t)},/**
     * The width of a single grid bucket.
     *
     * @property bucketWidth
     * @type number
     * @default 48
     *//**
     * The height of a single grid bucket.
     *
     * @property bucketHeight
     * @type number
     * @default 48
     *//**
     * Updates the grid.
     * @method update
     * @param {grid} grid
     * @param {body[]} bodies
     * @param {engine} engine
     * @param {boolean} forceUpdate
     */i.update=function(t,e,n,s){var r,o,a,h,l,u=n.world,c=t.buckets,d=!1,f=n.metrics;// @endif
for(r=0,f.broadphaseTests=0;r<e.length;r++){var p=e[r];if((!p.isSleeping||s)&&!(p.bounds.max.x<u.bounds.min.x)&&!(p.bounds.min.x>u.bounds.max.x)&&!(p.bounds.max.y<u.bounds.min.y)&&!(p.bounds.min.y>u.bounds.max.y)){var g=i._getRegion(t,p);// if the body has changed grid region
if(!p.region||g.id!==p.region.id||s){// @if DEBUG
f.broadphaseTests+=1,(!p.region||s)&&(p.region=g);var v=i._regionUnion(g,p.region);// update grid buckets affected by region change
// iterate over the union of both regions
for(o=v.startCol;o<=v.endCol;o++)for(a=v.startRow;a<=v.endRow;a++){h=c[l=i._getBucketId(o,a)];var m=o>=g.startCol&&o<=g.endCol&&a>=g.startRow&&a<=g.endRow,y=o>=p.region.startCol&&o<=p.region.endCol&&a>=p.region.startRow&&a<=p.region.endRow;!m&&y&&y&&h&&i._bucketRemoveBody(t,h,p),(p.region===g||m&&!y||s)&&(h||(h=i._createBucket(c,l)),i._bucketAddBody(t,h,p))}// set the new region
p.region=g,// flag changes so we can update pairs
d=!0}}}d&&(t.pairsList=i._createActivePairsList(t))},/**
     * Clears the grid.
     * @method clear
     * @param {grid} grid
     */i.clear=function(t){t.buckets={},t.pairs={},t.pairsList=[]},/**
     * Finds the union of two regions.
     * @method _regionUnion
     * @private
     * @param {} regionA
     * @param {} regionB
     * @return {} region
     */i._regionUnion=function(t,e){var n=Math.min(t.startCol,e.startCol),s=Math.max(t.endCol,e.endCol),r=Math.min(t.startRow,e.startRow),o=Math.max(t.endRow,e.endRow);return i._createRegion(n,s,r,o)},/**
     * Gets the region a given body falls in for a given grid.
     * @method _getRegion
     * @private
     * @param {} grid
     * @param {} body
     * @return {} region
     */i._getRegion=function(t,e){var n=e.bounds,s=Math.floor(n.min.x/t.bucketWidth),r=Math.floor(n.max.x/t.bucketWidth),o=Math.floor(n.min.y/t.bucketHeight),a=Math.floor(n.max.y/t.bucketHeight);return i._createRegion(s,r,o,a)},/**
     * Creates a region.
     * @method _createRegion
     * @private
     * @param {} startCol
     * @param {} endCol
     * @param {} startRow
     * @param {} endRow
     * @return {} region
     */i._createRegion=function(t,e,i,n){return{id:t+","+e+","+i+","+n,startCol:t,endCol:e,startRow:i,endRow:n}},/**
     * Gets the bucket id at the given position.
     * @method _getBucketId
     * @private
     * @param {} column
     * @param {} row
     * @return {string} bucket id
     */i._getBucketId=function(t,e){return"C"+t+"R"+e},/**
     * Creates a bucket.
     * @method _createBucket
     * @private
     * @param {} buckets
     * @param {} bucketId
     * @return {} bucket
     */i._createBucket=function(t,e){return t[e]=[]},/**
     * Adds a body to a bucket.
     * @method _bucketAddBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */i._bucketAddBody=function(t,e,i){// add new pairs
for(var s=0;s<e.length;s++){var r=e[s];if(i.id!==r.id&&(!i.isStatic||!r.isStatic)){// keep track of the number of buckets the pair exists in
// important for Grid.update to work
var o=n.id(i,r),a=t.pairs[o];a?a[2]+=1:t.pairs[o]=[i,r,1]}}// add to bodies (after pairs, otherwise pairs with self)
e.push(i)},/**
     * Removes a body from a bucket.
     * @method _bucketRemoveBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */i._bucketRemoveBody=function(t,e,i){// remove from bucket
e.splice(e.indexOf(i),1);// update pair counts
for(var s=0;s<e.length;s++){// keep track of the number of buckets the pair exists in
// important for _createActivePairsList to work
var r=e[s],o=n.id(i,r),a=t.pairs[o];a&&(a[2]-=1)}},/**
     * Generates a list of the active pairs in the grid.
     * @method _createActivePairsList
     * @private
     * @param {} grid
     * @return [] pairs
     */i._createActivePairsList=function(t){var e,i,n=[];// grid.pairs is used as a hashmap
e=o.keys(t.pairs);// iterate over grid.pairs
for(var s=0;s<e.length;s++)// if pair exists in at least one bucket
// it is a pair that needs further collision testing so push it
(i=t.pairs[e[s]])[2]>0?n.push(i):delete t.pairs[e[s]];return n}}),r("jzUT1",function(t,e){/**
* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.
*
* @class Pairs
*/var i={};t.exports=i;var n=s("8lC3Z"),r=s("4tPKt");i._pairMaxIdleLife=1e3,/**
     * Creates a new pairs structure.
     * @method create
     * @param {object} options
     * @return {pairs} A new pairs structure
     */i.create=function(t){return r.extend({table:{},list:[],collisionStart:[],collisionActive:[],collisionEnd:[]},t)},/**
     * Updates pairs given a list of collisions.
     * @method update
     * @param {object} pairs
     * @param {collision[]} collisions
     * @param {number} timestamp
     */i.update=function(t,e,i){var s,r,o,a,h=t.list,l=t.table,u=t.collisionStart,c=t.collisionEnd,d=t.collisionActive;for(a=0,// clear collision state arrays, but maintain old reference
u.length=0,c.length=0,d.length=0;a<h.length;a++)h[a].confirmedActive=!1;for(a=0;a<e.length;a++)(s=e[a]).collided&&((o=l[r=n.id(s.bodyA,s.bodyB)])?(o.isActive?d.push(o):u.push(o),// update the pair
n.update(o,s,i),o.confirmedActive=!0):(// pair did not exist, create a new pair
o=n.create(s,i),l[r]=o,// push the new pair
u.push(o),h.push(o)));// deactivate previously active pairs that are now inactive
for(a=0;a<h.length;a++)(o=h[a]).isActive&&!o.confirmedActive&&(n.setActive(o,!1,i),c.push(o))},/**
     * Finds and removes pairs that have been inactive for a set amount of time.
     * @method removeOld
     * @param {object} pairs
     * @param {number} timestamp
     */i.removeOld=function(t,e){var n,s,r,o,a=t.list,h=t.table,l=[];for(o=0;o<a.length;o++){// never remove sleeping pairs
if((s=(n=a[o]).collision).bodyA.isSleeping||s.bodyB.isSleeping){n.timeUpdated=e;continue}// if pair is inactive for too long, mark it to be removed
e-n.timeUpdated>i._pairMaxIdleLife&&l.push(o)}// remove marked pairs
for(o=0;o<l.length;o++)n=a[r=l[o]-o],delete h[n.id],a.splice(r,1)},/**
     * Clears the given pairs structure.
     * @method clear
     * @param {pairs} pairs
     * @return {pairs} pairs
     */i.clear=function(t){return t.table={},t.list.length=0,t.collisionStart.length=0,t.collisionActive.length=0,t.collisionEnd.length=0,t}}),r("6qoEV",function(t,e){/**
* The `Matter.Query` module contains methods for performing collision queries.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Query
*/var i={};t.exports=i;var n=s("a7bN0"),r=s("4IHIa"),o=s("6V4ls"),a=s("gY9LZ"),h=s("laRjh");/**
     * Returns a list of collisions between `body` and `bodies`.
     * @method collides
     * @param {body} body
     * @param {body[]} bodies
     * @return {object[]} Collisions
     */i.collides=function(t,e){for(var i=[],n=0;n<e.length;n++){var s=e[n];//  Phaser addition - skip same body checks
if(t!==s&&o.overlaps(s.bounds,t.bounds))for(var a=1===s.parts.length?0:1;a<s.parts.length;a++){var h=s.parts[a];if(o.overlaps(h.bounds,t.bounds)){var l=r.collides(h,t);if(l.collided){i.push(l);break}}}}return i},/**
     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.
     * @method ray
     * @param {body[]} bodies
     * @param {vector} startPoint
     * @param {vector} endPoint
     * @param {number} [rayWidth]
     * @return {object[]} Collisions
     */i.ray=function(t,e,s,r){r=r||1e-100;for(var o=n.angle(e,s),h=n.magnitude(n.sub(e,s)),l=(s.x+e.x)*.5,u=(s.y+e.y)*.5,c=a.rectangle(l,u,h,r,{angle:o}),d=i.collides(c,t),f=0;f<d.length;f+=1){var p=d[f];p.body=p.bodyB=p.bodyA}return d},/**
     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.
     * @method region
     * @param {body[]} bodies
     * @param {bounds} bounds
     * @param {bool} [outside=false]
     * @return {body[]} The bodies matching the query
     */i.region=function(t,e,i){for(var n=[],s=0;s<t.length;s++){var r=t[s],a=o.overlaps(r.bounds,e);(a&&!i||!a&&i)&&n.push(r)}return n},/**
     * Returns all bodies whose vertices contain the given point, from the given set of bodies.
     * @method point
     * @param {body[]} bodies
     * @param {vector} point
     * @return {body[]} The bodies matching the query
     */i.point=function(t,e){for(var i=[],n=0;n<t.length;n++){var s=t[n];if(o.contains(s.bounds,e))for(var r=1===s.parts.length?0:1;r<s.parts.length;r++){var a=s.parts[r];if(o.contains(a.bounds,e)&&h.contains(a.vertices,e)){i.push(s);break}}}return i}}),r("cZK1I",function(t,e){/**
* The `Matter.Resolver` module contains methods for resolving collision pairs.
*
* @class Resolver
*/var i={};t.exports=i;var n=s("laRjh"),r=s("a7bN0"),o=s("4tPKt"),a=s("6V4ls");i._restingThresh=4,i._restingThreshTangent=6,i._positionDampen=.9,i._positionWarming=.8,i._frictionNormalMultiplier=5,/**
     * Prepare pairs for position solving.
     * @method preSolvePosition
     * @param {pair[]} pairs
     */i.preSolvePosition=function(t){var e,i,n;// find total contacts on each body
for(e=0;e<t.length;e++)(i=t[e]).isActive&&(n=i.activeContacts.length,i.collision.parentA.totalContacts+=n,i.collision.parentB.totalContacts+=n)},/**
     * Find a solution for pair positions.
     * @method solvePosition
     * @param {pair[]} pairs
     * @param {body[]} bodies
     * @param {number} timeScale
     */i.solvePosition=function(t,e,n){var s,r,o,a,h,l,u,c,d,f,p,g,v,m,y,x,w=n*i._positionDampen;for(s=0;s<e.length;s++){var T=e[s];T.previousPositionImpulse.x=T.positionImpulse.x,T.previousPositionImpulse.y=T.positionImpulse.y}// find impulses required to resolve penetration
for(s=0;s<t.length;s++)!(a=t[s]).isActive||a.isSensor||(l=(h=a.collision).parentA,u=h.parentB,c=h.normal,p=l.previousPositionImpulse,g=u.previousPositionImpulse,f=h.penetration,m=g.x-p.x+f.x,y=g.y-p.y+f.y,d=(r=c.x)*m+(o=c.y)*y,a.separation=d,x=(d-a.slop)*w,(l.isStatic||u.isStatic)&&(x*=2),l.isStatic||l.isSleeping||(v=x/l.totalContacts,l.positionImpulse.x+=r*v,l.positionImpulse.y+=o*v),u.isStatic||u.isSleeping||(v=x/u.totalContacts,u.positionImpulse.x-=r*v,u.positionImpulse.y-=o*v))},/**
     * Apply position resolution.
     * @method postSolvePosition
     * @param {body[]} bodies
     */i.postSolvePosition=function(t){for(var e=0;e<t.length;e++){var s=t[e];if(// reset contact count
s.totalContacts=0,0!==s.positionImpulse.x||0!==s.positionImpulse.y){// update body geometry
for(var o=0;o<s.parts.length;o++){var h=s.parts[o];n.translate(h.vertices,s.positionImpulse),a.update(h.bounds,h.vertices,s.velocity),h.position.x+=s.positionImpulse.x,h.position.y+=s.positionImpulse.y}// move the body without changing velocity
s.positionPrev.x+=s.positionImpulse.x,s.positionPrev.y+=s.positionImpulse.y,0>r.dot(s.positionImpulse,s.velocity)?(// reset cached impulse if the body has velocity along it
s.positionImpulse.x=0,s.positionImpulse.y=0):(// warm the next iteration
s.positionImpulse.x*=i._positionWarming,s.positionImpulse.y*=i._positionWarming)}}},/**
     * Prepare pairs for velocity solving.
     * @method preSolveVelocity
     * @param {pair[]} pairs
     */i.preSolveVelocity=function(t){var e,i,n,s,o,a,h,l,u,c,d,f,p,g,v=r._temp[0],m=r._temp[1];for(e=0;e<t.length;e++)if((n=t[e]).isActive&&!n.isSensor)// resolve each contact
for(i=0,s=n.activeContacts,a=(o=n.collision).parentA,h=o.parentB,l=o.normal,u=o.tangent;i<s.length;i++)d=(c=s[i]).vertex,f=c.normalImpulse,p=c.tangentImpulse,0===f&&0===p||(// total impulse from contact
v.x=l.x*f+u.x*p,v.y=l.y*f+u.y*p,a.isStatic||a.isSleeping||(g=r.sub(d,a.position,m),a.positionPrev.x+=v.x*a.inverseMass,a.positionPrev.y+=v.y*a.inverseMass,a.anglePrev+=r.cross(g,v)*a.inverseInertia),h.isStatic||h.isSleeping||(g=r.sub(d,h.position,m),h.positionPrev.x-=v.x*h.inverseMass,h.positionPrev.y-=v.y*h.inverseMass,h.anglePrev-=r.cross(g,v)*h.inverseInertia))},/**
     * Find a solution for pair velocities.
     * @method solveVelocity
     * @param {pair[]} pairs
     * @param {number} timeScale
     */i.solveVelocity=function(t,e){for(var n=e*e,s=r._temp[0],a=r._temp[1],h=r._temp[2],l=r._temp[3],u=r._temp[4],c=r._temp[5],d=0;d<t.length;d++){var f=t[d];if(f.isActive&&!f.isSensor){var p=f.collision,g=p.parentA,v=p.parentB,m=p.normal,y=p.tangent,x=f.activeContacts,w=1/x.length;// update body velocities
g.velocity.x=g.position.x-g.positionPrev.x,g.velocity.y=g.position.y-g.positionPrev.y,v.velocity.x=v.position.x-v.positionPrev.x,v.velocity.y=v.position.y-v.positionPrev.y,g.angularVelocity=g.angle-g.anglePrev,v.angularVelocity=v.angle-v.anglePrev;// resolve each contact
for(var T=0;T<x.length;T++){var b=x[T],S=b.vertex,A=r.sub(S,g.position,a),E=r.sub(S,v.position,h),_=r.add(g.velocity,r.mult(r.perp(A),g.angularVelocity),l),C=r.add(v.velocity,r.mult(r.perp(E),v.angularVelocity),u),M=r.sub(_,C,c),P=r.dot(m,M),O=r.dot(y,M),R=Math.abs(O),L=o.sign(O),k=(1+f.restitution)*P,D=o.clamp(f.separation+P,0,1)*i._frictionNormalMultiplier,F=O,I=1/0;R>f.friction*f.frictionStatic*D*n&&(I=R,F=o.clamp(f.friction*L*n,-I,I));// modify impulses accounting for mass, inertia and offset
var B=r.cross(A,m),N=r.cross(E,m),Y=w/(g.inverseMass+v.inverseMass+g.inverseInertia*B*B+v.inverseInertia*N*N);// handle high velocity and resting collisions separately
if(k*=Y,F*=Y,P<0&&P*P>i._restingThresh*n)b.normalImpulse=0;else{// solve resting collision constraints using Erin Catto's method (GDC08)
// impulse constraint tends to 0
var z=b.normalImpulse;b.normalImpulse=Math.min(b.normalImpulse+k,0),k=b.normalImpulse-z}// handle high velocity and resting collisions separately
if(O*O>i._restingThreshTangent*n)b.tangentImpulse=0;else{// solve resting collision constraints using Erin Catto's method (GDC08)
// tangent impulse tends to -tangentSpeed or +tangentSpeed
var j=b.tangentImpulse;b.tangentImpulse=o.clamp(b.tangentImpulse+F,-I,I),F=b.tangentImpulse-j}// total impulse from contact
s.x=m.x*k+y.x*F,s.y=m.y*k+y.y*F,g.isStatic||g.isSleeping||(g.positionPrev.x+=s.x*g.inverseMass,g.positionPrev.y+=s.y*g.inverseMass,g.anglePrev+=r.cross(A,s)*g.inverseInertia),v.isStatic||v.isSleeping||(v.positionPrev.x-=s.x*v.inverseMass,v.positionPrev.y-=s.y*v.inverseMass,v.anglePrev-=r.cross(E,s)*v.inverseInertia)}}}}}),r("d8Zzv",function(t,e){/**
* The `Matter.Engine` module contains methods for creating and manipulating engines.
* An engine is a controller that manages updating the simulation of the world.
* See `Matter.Runner` for an optional game loop utility.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Engine
*/var i={};t.exports=i;var n=s("koAaK"),r=s("azFoo"),o=s("cZK1I"),a=s("jzUT1"),h=s("aIltj"),l=s("7ki4D"),u=s("aKoE7"),c=s("in8Gg"),d=s("dmTql"),f=s("4tPKt"),p=s("lMiYr");/**
     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {engine} engine
     */i.create=function(t,e){// options may be passed as the first (and only) argument
e=f.isElement(t)?e:t,t=f.isElement(t)?t:null,e=e||{},(t||e.render)&&f.warn("Engine.create: engine.render is deprecated (see docs)");var i=f.extend({positionIterations:6,velocityIterations:4,constraintIterations:2,enableSleeping:!1,events:[],plugin:{},timing:{timestamp:0,timeScale:1},broadphase:{controller:l}},e);// @endif
return i.world=e.world||n.create(i.world),i.pairs=a.create(),i.broadphase=i.broadphase.controller.create(i.broadphase),i.metrics=i.metrics||{extended:!1},// @if DEBUG
i.metrics=h.create(i.metrics),i},/**
     * Moves the simulation forward in time by `delta` ms.
     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.
     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.
     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.
     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).
     * See the paper on <a href="http://lonesock.net/article/verlet.html">Time Corrected Verlet</a> for more information.
     *
     * Triggers `beforeUpdate` and `afterUpdate` events.
     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.
     * @method update
     * @param {engine} engine
     * @param {number} [delta=16.666]
     * @param {number} [correction=1]
     */i.update=function(t,e,n){e=e||1e3/60,n=n||1;var s,l=t.world,f=t.timing,p=t.broadphase,g=[];// increment timestamp
f.timestamp+=e*f.timeScale;// create an event object
var v={timestamp:f.timestamp};u.trigger(t,"beforeUpdate",v);// get lists of all bodies and constraints, no matter what composites they are in
var m=c.allBodies(l),y=c.allConstraints(l);for(// @if DEBUG
// reset metrics logging
h.reset(t.metrics),t.enableSleeping&&r.update(m,f.timeScale),// applies gravity to all bodies
i._bodiesApplyGravity(m,l.gravity),// update all body position and rotation by integration
i._bodiesUpdate(m,e,f.timeScale,n,l.bounds),// update all constraints (first pass)
d.preSolveAll(m),s=0;s<t.constraintIterations;s++)d.solveAll(y,f.timeScale);d.postSolveAll(m),p.controller?(l.isModified&&p.controller.clear(p),// update the grid buckets based on current bodies
p.controller.update(p,m,t,l.isModified),g=p.pairsList):g=m,l.isModified&&c.setModified(l,!1,!1,!0);// narrowphase pass: find actual collisions, then create or update collision pairs
var x=p.detector(g,t),w=t.pairs,T=f.timestamp;for(a.update(w,x,T),a.removeOld(w,T),t.enableSleeping&&r.afterCollisions(w.list,f.timeScale),w.collisionStart.length>0&&u.trigger(t,"collisionStart",{pairs:w.collisionStart}),// iteratively resolve position between collisions
o.preSolvePosition(w.list),s=0;s<t.positionIterations;s++)o.solvePosition(w.list,m,f.timeScale);for(o.postSolvePosition(m),// update all constraints (second pass)
d.preSolveAll(m),s=0;s<t.constraintIterations;s++)d.solveAll(y,f.timeScale);for(d.postSolveAll(m),// iteratively resolve velocity between collisions
o.preSolveVelocity(w.list),s=0;s<t.velocityIterations;s++)o.solveVelocity(w.list,f.timeScale);return w.collisionActive.length>0&&u.trigger(t,"collisionActive",{pairs:w.collisionActive}),w.collisionEnd.length>0&&u.trigger(t,"collisionEnd",{pairs:w.collisionEnd}),// @if DEBUG
// update metrics log
h.update(t.metrics,t),// @endif
// clear force buffers
i._bodiesClearForces(m),u.trigger(t,"afterUpdate",v),t},/**
     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.
     * @method merge
     * @param {engine} engineA
     * @param {engine} engineB
     */i.merge=function(t,e){if(f.extend(t,e),e.world){t.world=e.world,i.clear(t);for(var n=c.allBodies(t.world),s=0;s<n.length;s++){var o=n[s];r.set(o,!1),o.id=f.nextId()}}},/**
     * Clears the engine including the world, pairs and broadphase.
     * @method clear
     * @param {engine} engine
     */i.clear=function(t){var e=t.world;a.clear(t.pairs);var i=t.broadphase;if(i.controller){var n=c.allBodies(e);i.controller.clear(i),i.controller.update(i,n,t,!0)}},/**
     * Zeroes the `body.force` and `body.torque` force buffers.
     * @method _bodiesClearForces
     * @private
     * @param {body[]} bodies
     */i._bodiesClearForces=function(t){for(var e=0;e<t.length;e++){var i=t[e];// reset force buffers
i.force.x=0,i.force.y=0,i.torque=0}},/**
     * Applys a mass dependant force to all given bodies.
     * @method _bodiesApplyGravity
     * @private
     * @param {body[]} bodies
     * @param {vector} gravity
     */i._bodiesApplyGravity=function(t,e){var i=void 0!==e.scale?e.scale:.001;if((0!==e.x||0!==e.y)&&0!==i)for(var n=0;n<t.length;n++){var s=t[n];s.ignoreGravity||s.isStatic||s.isSleeping||(// apply gravity
s.force.x+=s.mass*e.x*i*s.gravityScale.x,s.force.y+=s.mass*e.y*i*s.gravityScale.y)}},/**
     * Applys `Body.update` to all given `bodies`.
     * @method _bodiesUpdate
     * @private
     * @param {body[]} bodies
     * @param {number} deltaTime 
     * The amount of time elapsed between updates
     * @param {number} timeScale
     * @param {number} correction 
     * The Verlet correction factor (deltaTime / lastDeltaTime)
     * @param {bounds} worldBounds
     */i._bodiesUpdate=function(t,e,i,n,s){for(var r=0;r<t.length;r++){var o=t[r];o.isStatic||o.isSleeping||p.update(o,e,i,n)}}}),r("aIltj",function(t,e){// @if DEBUG
/**
* _Internal Class_, not generally used outside of the engine's internals.
*
*/var i={};t.exports=i;var n=s("in8Gg"),r=s("4tPKt");/**
     * Creates a new metrics.
     * @method create
     * @private
     * @return {metrics} A new metrics
     */i.create=function(t){return r.extend({extended:!1,narrowDetections:0,narrowphaseTests:0,narrowReuse:0,narrowReuseCount:0,midphaseTests:0,broadphaseTests:0,narrowEff:1e-4,midEff:1e-4,broadEff:1e-4,collisions:0,buckets:0,bodies:0,pairs:0},!1,t)},/**
     * Resets metrics.
     * @method reset
     * @private
     * @param {metrics} metrics
     */i.reset=function(t){t.extended&&(t.narrowDetections=0,t.narrowphaseTests=0,t.narrowReuse=0,t.narrowReuseCount=0,t.midphaseTests=0,t.broadphaseTests=0,t.narrowEff=0,t.midEff=0,t.broadEff=0,t.collisions=0,t.buckets=0,t.pairs=0,t.bodies=0)},/**
     * Updates metrics.
     * @method update
     * @private
     * @param {metrics} metrics
     * @param {engine} engine
     */i.update=function(t,e){if(t.extended){var i=e.world,s=n.allBodies(i);t.collisions=t.narrowDetections,t.pairs=e.pairs.list.length,t.bodies=s.length,t.midEff=(t.narrowDetections/(t.midphaseTests||1)).toFixed(2),t.narrowEff=(t.narrowDetections/(t.narrowphaseTests||1)).toFixed(2),t.broadEff=(1-t.broadphaseTests/(s.length||1)).toFixed(2),t.narrowReuse=(t.narrowReuseCount/(t.narrowphaseTests||1)).toFixed(2);//var broadphase = engine.broadphase[engine.broadphase.current];
//if (broadphase.instance)
//    metrics.buckets = Common.keys(broadphase.instance.buckets).length;
}};// @endif
}),r("iIWxd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hPWXH"),n=s("hUjHB"),r=s("gY9LZ"),o=s("lMiYr"),a=s("kr4xd"),h=s("6V4ls"),l=s("jwj1g"),u=s("in8Gg"),c=s("cbd5m"),d=s("dmTql"),f=s("ldsg1"),p=s("bwLQh"),g=s("bImJl"),v=s("7BSWl"),m=s("5pMDk"),y=s("7ki4D"),x=s("lEvhv"),w=s("X2wk5"),T=s("kesQx"),b=s("8Z2vx"),S=s("awyQk"),A=s("8lC3Z"),E=s("jzUT1"),_=s("hw9TH"),C=s("7AzQW"),M=s("6qoEV"),P=s("cZK1I"),O=s("4IHIa"),R=s("4rtgc"),L=s("dmaXf"),k=s("a7bN0"),D=s("laRjh"),F=s("ilxnW"),I=new l({initialize:function(t){/**
         * The Phaser Scene that owns this Matter Physics instance
         *
         * @name Phaser.Physics.Matter.MatterPhysics#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * A reference to the Scene Systems that belong to the Scene owning this Matter Physics instance.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,/**
         * The parsed Matter Configuration object.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#config
         * @type {Phaser.Types.Physics.Matter.MatterWorldConfig}
         * @since 3.0.0
         */this.config=this.getConfig(),/**
         * An instance of the Matter World class. This class is responsible for the updating of the
         * Matter Physics world, as well as handling debug drawing functions.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#world
         * @type {Phaser.Physics.Matter.World}
         * @since 3.0.0
         */this.world,/**
         * An instance of the Matter Factory. This class provides lots of functions for creating a
         * wide variety of physics objects and adds them automatically to the Matter World.
         * 
         * You can use this class to cut-down on the amount of code required in your game, however,
         * use of the Factory is entirely optional and should be seen as a development aid. It's
         * perfectly possible to create and add components to the Matter world without using it.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#add
         * @type {Phaser.Physics.Matter.Factory}
         * @since 3.0.0
         */this.add,/**
         * An instance of the Body Bounds class. This class contains functions used for getting the
         * world position from various points around the bounds of a physics body.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#bodyBounds
         * @type {Phaser.Physics.Matter.BodyBounds}
         * @since 3.22.0
         */this.bodyBounds,//  Body
/**
         * A reference to the `Matter.Body` module.
         * 
         * The `Matter.Body` module contains methods for creating and manipulating body models.
         * A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
         * Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the `Bodies` module.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#body
         * @type {MatterJS.BodyFactory}
         * @since 3.18.0
         */this.body=o,/**
         * A reference to the `Matter.Composite` module.
         * 
         * The `Matter.Composite` module contains methods for creating and manipulating composite bodies.
         * A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.
         * It is important to use the functions in this module to modify composites, rather than directly modifying their properties.
         * Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#composite
         * @type {MatterJS.CompositeFactory}
         * @since 3.22.0
         */this.composite=u,//  Collision:
/**
         * A reference to the `Matter.Detector` module.
         * 
         * The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#detector
         * @type {MatterJS.DetectorFactory}
         * @since 3.22.0
         */this.detector=f,/**
         * A reference to the `Matter.Grid` module.
         * 
         * The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#grid
         * @type {MatterJS.GridFactory}
         * @since 3.22.0
         */this.grid=y,/**
         * A reference to the `Matter.Pair` module.
         * 
         * The `Matter.Pair` module contains methods for creating and manipulating collision pairs.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#pair
         * @type {MatterJS.PairFactory}
         * @since 3.22.0
         */this.pair=A,/**
         * A reference to the `Matter.Pairs` module.
         * 
         * The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#pairs
         * @type {MatterJS.PairsFactory}
         * @since 3.22.0
         */this.pairs=E,/**
         * A reference to the `Matter.Query` module.
         * 
         * The `Matter.Query` module contains methods for performing collision queries.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#query
         * @type {MatterJS.QueryFactory}
         * @since 3.22.0
         */this.query=M,/**
         * A reference to the `Matter.Resolver` module.
         * 
         * The `Matter.Resolver` module contains methods for resolving collision pairs.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#resolver
         * @type {MatterJS.ResolverFactory}
         * @since 3.22.0
         */this.resolver=P,/**
         * A reference to the `Matter.SAT` module.
         * 
         * The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#sat
         * @type {MatterJS.SATFactory}
         * @since 3.22.0
         */this.sat=O,//  Constraint
/**
         * A reference to the `Matter.Constraint` module.
         * 
         * The `Matter.Constraint` module contains methods for creating and manipulating constraints.
         * Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
         * The stiffness of constraints can be modified to create springs or elastic.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#constraint
         * @type {MatterJS.ConstraintFactory}
         * @since 3.22.0
         */this.constraint=d,//  Factory
/**
         * A reference to the `Matter.Bodies` module.
         * 
         * The `Matter.Bodies` module contains factory methods for creating rigid bodies
         * with commonly used body configurations (such as rectangles, circles and other polygons).
         *
         * @name Phaser.Physics.Matter.MatterPhysics#bodies
         * @type {MatterJS.BodiesFactory}
         * @since 3.18.0
         */this.bodies=r,/**
         * A reference to the `Matter.Composites` module.
         * 
         * The `Matter.Composites` module contains factory methods for creating composite bodies
         * with commonly used configurations (such as stacks and chains).
         *
         * @name Phaser.Physics.Matter.MatterPhysics#composites
         * @type {MatterJS.CompositesFactory}
         * @since 3.22.0
         */this.composites=c,//  Geometry
/**
         * A reference to the `Matter.Axes` module.
         * 
         * The `Matter.Axes` module contains methods for creating and manipulating sets of axes.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#axes
         * @type {MatterJS.AxesFactory}
         * @since 3.22.0
         */this.axes=n,/**
         * A reference to the `Matter.Bounds` module.
         * 
         * The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).
         *
         * @name Phaser.Physics.Matter.MatterPhysics#bounds
         * @type {MatterJS.BoundsFactory}
         * @since 3.22.0
         */this.bounds=h,/**
         * A reference to the `Matter.Svg` module.
         * 
         * The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.
         *
         * To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg
         *
         * @name Phaser.Physics.Matter.MatterPhysics#svg
         * @type {MatterJS.SvgFactory}
         * @since 3.22.0
         */this.svg=L,/**
         * A reference to the `Matter.Vector` module.
         * 
         * The `Matter.Vector` module contains methods for creating and manipulating vectors.
         * Vectors are the basis of all the geometry related operations in the engine.
         * A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#vector
         * @type {MatterJS.VectorFactory}
         * @since 3.22.0
         */this.vector=k,/**
         * A reference to the `Matter.Vertices` module.
         * 
         * The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
         * A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
         * A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
         *
         * @name Phaser.Physics.Matter.MatterPhysics#vertices
         * @type {MatterJS.VerticesFactory}
         * @since 3.22.0
         */this.vertices=D,/**
         * A reference to the `Matter.Vertices` module.
         * 
         * The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
         * A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
         * A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
         *
         * @name Phaser.Physics.Matter.MatterPhysics#verts
         * @type {MatterJS.VerticesFactory}
         * @since 3.14.0
         */this.verts=D,/**
         * An internal temp vector used for velocity and force calculations.
         *
         * @name Phaser.Physics.Matter.MatterPhysics#_tempVec2
         * @type {MatterJS.Vector}
         * @private
         * @since 3.22.0
         */this._tempVec2=k.create(),m(this.config,"plugins.collisionevents",!0)&&this.enableCollisionEventsPlugin(),m(this.config,"plugins.attractors",!1)&&this.enableAttractorPlugin(),m(this.config,"plugins.wrap",!1)&&this.enableWrapPlugin(),P._restingThresh=m(this.config,"restingThresh",4),P._restingThreshTangent=m(this.config,"restingThreshTangent",6),P._positionDampen=m(this.config,"positionDampen",.9),P._positionWarming=m(this.config,"positionWarming",.8),P._frictionNormalMultiplier=m(this.config,"frictionNormalMultiplier",5),t.sys.events.once(R.BOOT,this.boot,this),t.sys.events.on(R.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#boot
     * @private
     * @since 3.5.1
     */boot:function(){this.world=new F(this.scene,this.config),this.add=new g(this.world),this.bodyBounds=new a,this.systems.events.once(R.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#start
     * @private
     * @since 3.5.0
     */start:function(){this.world||(this.world=new F(this.scene,this.config),this.add=new g(this.world));var t=this.systems.events;t.on(R.UPDATE,this.world.update,this.world),t.on(R.POST_UPDATE,this.world.postUpdate,this.world),t.once(R.SHUTDOWN,this.shutdown,this)},/**
     * This internal method is called when this class starts and retrieves the final Matter World Config.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#getConfig
     * @since 3.0.0
     *
     * @return {Phaser.Types.Physics.Matter.MatterWorldConfig} The Matter World Config.
     */getConfig:function(){var t=this.systems.game.config.physics;return S(v(this.systems.settings.physics,"matter",{}),v(t,"matter",{}))},/**
     * Enables the Matter Attractors Plugin.
     * 
     * The attractors plugin that makes it easy to apply continual forces on bodies.
     * It's possible to simulate effects such as wind, gravity and magnetism.
     * 
     * https://github.com/liabru/matter-attractors
     * 
     * This method is called automatically if `plugins.attractors` is set in the Matter World Config.
     * However, you can also call it directly from within your game.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#enableAttractorPlugin
     * @since 3.0.0
     * 
     * @return {this} This Matter Physics instance.
     */enableAttractorPlugin:function(){return _.register(x),_.use(T,x),this},/**
     * Enables the Matter Wrap Plugin.
     * 
     * The coordinate wrapping plugin that automatically wraps the position of bodies such that they always stay
     * within the given bounds. Upon crossing a boundary the body will appear on the opposite side of the bounds,
     * while maintaining its velocity.
     * 
     * https://github.com/liabru/matter-wrap
     * 
     * This method is called automatically if `plugins.wrap` is set in the Matter World Config.
     * However, you can also call it directly from within your game.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#enableWrapPlugin
     * @since 3.0.0
     * 
     * @return {this} This Matter Physics instance.
     */enableWrapPlugin:function(){return _.register(b),_.use(T,b),this},/**
     * Enables the Matter Collision Events Plugin.
     * 
     * Note that this plugin is enabled by default. So you should only ever need to call this
     * method if you have specifically disabled the plugin in your Matter World Config.
     * You can disable it by setting `plugins.collisionevents: false` in your Matter World Config.
     * 
     * This plugin triggers three new events on Matter.Body:
     * 
     * 1. `onCollide`
     * 2. `onCollideEnd`
     * 3. `onCollideActive`
     * 
     * These events correspond to the Matter.js events `collisionStart`, `collisionActive` and `collisionEnd`, respectively.
     * You can listen to these events via Matter.Events or they will also be emitted from the Matter World.
     * 
     * This plugin also extends Matter.Body with three convenience functions:
     * 
     * `Matter.Body.setOnCollide(callback)`
     * `Matter.Body.setOnCollideEnd(callback)`
     * `Matter.Body.setOnCollideActive(callback)`
     * 
     * You can register event callbacks by providing a function of type (pair: Matter.Pair) => void
     * 
     * https://github.com/dxu/matter-collision-events
     *
     * @method Phaser.Physics.Matter.MatterPhysics#enableCollisionEventsPlugin
     * @since 3.22.0
     * 
     * @return {this} This Matter Physics instance.
     */enableCollisionEventsPlugin:function(){return _.register(w),_.use(T,w),this},/**
     * Pauses the Matter World instance and sets `enabled` to `false`.
     * 
     * A paused world will not run any simulations for the duration it is paused.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#pause
     * @fires Phaser.Physics.Matter.Events#PAUSE
     * @since 3.0.0
     *
     * @return {Phaser.Physics.Matter.World} The Matter World object.
     */pause:function(){return this.world.pause()},/**
     * Resumes this Matter World instance from a paused state and sets `enabled` to `true`.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#resume
     * @since 3.0.0
     *
     * @return {Phaser.Physics.Matter.World} The Matter World object.
     */resume:function(){return this.world.resume()},/**
     * Sets the Matter Engine to run at fixed timestep of 60Hz and enables `autoUpdate`.
     * If you have set a custom `getDelta` function then this will override it.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#set60Hz
     * @since 3.4.0
     *
     * @return {this} This Matter Physics instance.
     */set60Hz:function(){return this.world.getDelta=this.world.update60Hz,this.world.autoUpdate=!0,this},/**
     * Sets the Matter Engine to run at fixed timestep of 30Hz and enables `autoUpdate`.
     * If you have set a custom `getDelta` function then this will override it.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#set30Hz
     * @since 3.4.0
     *
     * @return {this} This Matter Physics instance.
     */set30Hz:function(){return this.world.getDelta=this.world.update30Hz,this.world.autoUpdate=!0,this},/**
     * Manually advances the physics simulation by one iteration.
     * 
     * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.
     * If undefined they use the Matter defaults of 60Hz and no correction.
     * 
     * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.
     * 
     * It also ignores any custom `getDelta` functions, as you should be passing the delta
     * value in to this call.
     *
     * You can adjust the number of iterations that Engine.update performs internally.
     * Use the Scene Matter Physics config object to set the following properties:
     *
     * positionIterations (defaults to 6)
     * velocityIterations (defaults to 4)
     * constraintIterations (defaults to 2)
     *
     * Adjusting these values can help performance in certain situations, depending on the physics requirements
     * of your game.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#step
     * @since 3.4.0
     *
     * @param {number} [delta=16.666] - The delta value.
     * @param {number} [correction=1] - Optional delta correction value.
     */step:function(t,e){this.world.step(t,e)},/**
     * Checks if the vertices of the given body, or an array of bodies, contains the given point, or not.
     * 
     * You can pass in either a single body, or an array of bodies to be checked. This method will
     * return `true` if _any_ of the bodies in the array contain the point. See the `intersectPoint` method if you need
     * to get a list of intersecting bodies.
     * 
     * The point should be transformed into the Matter World coordinate system in advance. This happens by
     * default with Input Pointers, but if you wish to use points from another system you may need to
     * transform them before passing them.
     * 
     * @method Phaser.Physics.Matter.MatterPhysics#containsPoint
     * @since 3.22.0
     *
     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} body - The body, or an array of bodies, to check against the point.
     * @param {number} x - The horizontal coordinate of the point.
     * @param {number} y - The vertical coordinate of the point.
     * 
     * @return {boolean} `true` if the point is within one of the bodies given, otherwise `false`.
     */containsPoint:function(t,e,i){t=this.getMatterBodies(t);var n=k.create(e,i);return M.point(t,n).length>0},/**
     * Checks the given coordinates to see if any vertices of the given bodies contain it.
     * 
     * If no bodies are provided it will search all bodies in the Matter World, including within Composites.
     * 
     * The coordinates should be transformed into the Matter World coordinate system in advance. This happens by
     * default with Input Pointers, but if you wish to use coordinates from another system you may need to
     * transform them before passing them.
     * 
     * @method Phaser.Physics.Matter.MatterPhysics#intersectPoint
     * @since 3.22.0
     *
     * @param {number} x - The horizontal coordinate of the point.
     * @param {number} y - The vertical coordinate of the point.
     * @param {Phaser.Types.Physics.Matter.MatterBody[]} [bodies] - An array of bodies to check. If not provided it will search all bodies in the world.
     * 
     * @return {Phaser.Types.Physics.Matter.MatterBody[]} An array of bodies which contain the given point.
     */intersectPoint:function(t,e,i){i=this.getMatterBodies(i);var n=k.create(t,e),s=[];return M.point(i,n).forEach(function(t){-1===s.indexOf(t)&&s.push(t)}),s},/**
     * Checks the given rectangular area to see if any vertices of the given bodies intersect with it.
     * Or, if the `outside` parameter is set to `true`, it checks to see which bodies do not
     * intersect with it.
     * 
     * If no bodies are provided it will search all bodies in the Matter World, including within Composites.
     * 
     * @method Phaser.Physics.Matter.MatterPhysics#intersectRect
     * @since 3.22.0
     *
     * @param {number} x - The horizontal coordinate of the top-left of the area.
     * @param {number} y - The vertical coordinate of the top-left of the area.
     * @param {number} width - The width of the area.
     * @param {number} height - The height of the area.
     * @param {boolean} [outside=false] - If `false` it checks for vertices inside the area, if `true` it checks for vertices outside the area.
     * @param {Phaser.Types.Physics.Matter.MatterBody[]} [bodies] - An array of bodies to check. If not provided it will search all bodies in the world.
     * 
     * @return {Phaser.Types.Physics.Matter.MatterBody[]} An array of bodies that intersect with the given area.
     */intersectRect:function(t,e,i,n,s,r){void 0===s&&(s=!1),r=this.getMatterBodies(r);var o=[];return M.region(r,{min:{x:t,y:e},max:{x:t+i,y:e+n}},s).forEach(function(t){-1===o.indexOf(t)&&o.push(t)}),o},/**
     * Checks the given ray segment to see if any vertices of the given bodies intersect with it.
     * 
     * If no bodies are provided it will search all bodies in the Matter World.
     * 
     * The width of the ray can be specified via the `rayWidth` parameter.
     * 
     * @method Phaser.Physics.Matter.MatterPhysics#intersectRay
     * @since 3.22.0
     *
     * @param {number} x1 - The horizontal coordinate of the start of the ray segment.
     * @param {number} y1 - The vertical coordinate of the start of the ray segment.
     * @param {number} x2 - The horizontal coordinate of the end of the ray segment.
     * @param {number} y2 - The vertical coordinate of the end of the ray segment.
     * @param {number} [rayWidth=1] - The width of the ray segment.
     * @param {Phaser.Types.Physics.Matter.MatterBody[]} [bodies] - An array of bodies to check. If not provided it will search all bodies in the world.
     * 
     * @return {Phaser.Types.Physics.Matter.MatterBody[]} An array of bodies whos vertices intersect with the ray segment.
     */intersectRay:function(t,e,i,n,s,r){void 0===s&&(s=1),r=this.getMatterBodies(r);for(var o=[],a=M.ray(r,k.create(t,e),k.create(i,n),s),h=0;h<a.length;h++)o.push(a[h].body);return o},/**
     * Checks the given Matter Body to see if it intersects with any of the given bodies.
     * 
     * If no bodies are provided it will check against all bodies in the Matter World.
     * 
     * @method Phaser.Physics.Matter.MatterPhysics#intersectBody
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The target body.
     * @param {Phaser.Types.Physics.Matter.MatterBody[]} [bodies] - An array of bodies to check the target body against. If not provided it will search all bodies in the world.
     * 
     * @return {Phaser.Types.Physics.Matter.MatterBody[]} An array of bodies whos vertices intersect with target body.
     */intersectBody:function(t,e){e=this.getMatterBodies(e);for(var i=[],n=M.collides(t,e),s=0;s<n.length;s++){var r=n[s];r.bodyA===t?i.push(r.bodyB):i.push(r.bodyA)}return i},/**
     * Checks to see if the target body, or an array of target bodies, intersects with any of the given bodies.
     * 
     * If intersection occurs this method will return `true` and, if provided, invoke the callbacks.
     * 
     * If no bodies are provided for the second parameter the target will check again all bodies in the Matter World.
     * 
     * Note that bodies can only overlap if they are in non-colliding collision groups or categories.
     * 
     * If you provide a `processCallback` then the two bodies that overlap are sent to it. This callback
     * must return a boolean and is used to allow you to perform additional processing tests before a final
     * outcome is decided. If it returns `true` then the bodies are finally passed to the `overlapCallback`, if set.
     * 
     * If you provide an `overlapCallback` then the matching pairs of overlapping bodies will be sent to it.
     * 
     * Both callbacks have the following signature: `function (bodyA, bodyB, collisionInfo)` where `bodyA` is always
     * the target body. The `collisionInfo` object contains additional data, such as the angle and depth of penetration.
     * 
     * @method Phaser.Physics.Matter.MatterPhysics#overlap
     * @since 3.22.0
     *
     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} target - The target body, or array of target bodies, to check.
     * @param {Phaser.Types.Physics.Matter.MatterBody[]} [bodies] - The second body, or array of bodies, to check. If falsey it will check against all bodies in the world.
     * @param {ArcadePhysicsCallback} [overlapCallback] - An optional callback function that is called if the bodies overlap.
     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two bodies if they overlap. If this is set then `overlapCallback` will only be invoked if this callback returns `true`.
     * @param {*} [callbackContext] - The context, or scope, in which to run the callbacks.
     * 
     * @return {boolean} `true` if the target body intersects with _any_ of the bodies given, otherwise `false`.
     */overlap:function(t,e,i,n,s){void 0===i&&(i=null),void 0===n&&(n=null),void 0===s&&(s=i),Array.isArray(t)||(t=[t]),t=this.getMatterBodies(t),e=this.getMatterBodies(e);for(var r=!1,o=0;o<t.length;o++)for(var a=t[o],h=M.collides(a,e),l=0;l<h.length;l++){var u=h[l],c=u.bodyA.id===a.id?u.bodyB:u.bodyA;if(!n||n.call(s,a,c,u)){if(r=!0,i)i.call(s,a,c,u);else if(!n)return!0}}return r},/**
     * Sets the collision filter category of all given Matter Bodies to the given value.
     * 
     * This number must be a power of two between 2^0 (= 1) and 2^31.
     * 
     * Bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision
     * categories are included in their collision masks (see {@link #setCollidesWith}).
     *
     * @method Phaser.Physics.Matter.MatterPhysics#setCollisionCategory
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody[]} bodies - An array of bodies to update. If falsey it will use all bodies in the world.
     * @param {number} value - Unique category bitfield.
     *
     * @return {this} This Matter Physics instance.
     */setCollisionCategory:function(t,e){return(t=this.getMatterBodies(t)).forEach(function(t){t.collisionFilter.category=e}),this},/**
     * Sets the collision filter group of all given Matter Bodies to the given value.
     * 
     * If the group value is zero, or if two Matter Bodies have different group values,
     * they will collide according to the usual collision filter rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).
     * 
     * If two Matter Bodies have the same positive group value, they will always collide;
     * if they have the same negative group value they will never collide.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#setCollisionGroup
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody[]} bodies - An array of bodies to update. If falsey it will use all bodies in the world.
     * @param {number} value - Unique group index.
     *
     * @return {this} This Matter Physics instance.
     */setCollisionGroup:function(t,e){return(t=this.getMatterBodies(t)).forEach(function(t){t.collisionFilter.group=e}),this},/**
     * Sets the collision filter mask of all given Matter Bodies to the given value.
     * 
     * Two Matter Bodies with different collision groups will only collide if each one includes the others
     * category in its mask based on a bitwise AND operation: `(categoryA & maskB) !== 0` and 
     * `(categoryB & maskA) !== 0` are both true.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#setCollidesWith
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody[]} bodies - An array of bodies to update. If falsey it will use all bodies in the world.
     * @param {(number|number[])} categories - A unique category bitfield, or an array of them.
     *
     * @return {this} This Matter Physics instance.
     */setCollidesWith:function(t,e){t=this.getMatterBodies(t);var i=0;if(Array.isArray(e))for(var n=0;n<e.length;n++)i|=e[n];else i=e;return t.forEach(function(t){t.collisionFilter.mask=i}),this},/**
     * Takes an array and returns a new array made from all of the Matter Bodies found in the original array.
     * 
     * For example, passing in Matter Game Objects, such as a bunch of Matter Sprites, to this method, would
     * return an array containing all of their native Matter Body objects.
     * 
     * If the `bodies` argument is falsey, it will return all bodies in the world.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#getMatterBodies
     * @since 3.22.0
     *
     * @param {array} [bodies] - An array of objects to extract the bodies from. If falsey, it will return all bodies in the world.
     *
     * @return {MatterJS.BodyType[]} An array of native Matter Body objects.
     */getMatterBodies:function(t){if(!t)return this.world.getAllBodies();Array.isArray(t)||(t=[t]);for(var e=[],i=0;i<t.length;i++){var n=t[i].hasOwnProperty("body")?t[i].body:t[i];e.push(n)}return e},/**
     * Sets both the horizontal and vertical linear velocity of the physics bodies.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#setVelocity
     * @since 3.22.0
     *
     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.
     * @param {number} x - The horizontal linear velocity value.
     * @param {number} y - The vertical linear velocity value.
     *
     * @return {this} This Matter Physics instance.
     */setVelocity:function(t,e,i){t=this.getMatterBodies(t);var n=this._tempVec2;return n.x=e,n.y=i,t.forEach(function(t){o.setVelocity(t,n)}),this},/**
     * Sets just the horizontal linear velocity of the physics bodies.
     * The vertical velocity of the body is unchanged.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#setVelocityX
     * @since 3.22.0
     *
     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.
     * @param {number} x - The horizontal linear velocity value.
     *
     * @return {this} This Matter Physics instance.
     */setVelocityX:function(t,e){t=this.getMatterBodies(t);var i=this._tempVec2;return i.x=e,t.forEach(function(t){i.y=t.velocity.y,o.setVelocity(t,i)}),this},/**
     * Sets just the vertical linear velocity of the physics bodies.
     * The horizontal velocity of the body is unchanged.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#setVelocityY
     * @since 3.22.0
     *
     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.
     * @param {number} y - The vertical linear velocity value.
     *
     * @return {this} This Matter Physics instance.
     */setVelocityY:function(t,e){t=this.getMatterBodies(t);var i=this._tempVec2;return i.y=e,t.forEach(function(t){i.x=t.velocity.x,o.setVelocity(t,i)}),this},/**
     * Sets the angular velocity of the bodies instantly.
     * Position, angle, force etc. are unchanged.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#setAngularVelocity
     * @since 3.22.0
     *
     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.
     * @param {number} value - The angular velocity.
     *
     * @return {this} This Matter Physics instance.
     */setAngularVelocity:function(t,e){return(t=this.getMatterBodies(t)).forEach(function(t){o.setAngularVelocity(t,e)}),this},/**
     * Applies a force to a body, at the bodies current position, including resulting torque.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#applyForce
     * @since 3.22.0
     *
     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.
     * @param {Phaser.Types.Math.Vector2Like} force - A Vector that specifies the force to apply.
     *
     * @return {this} This Matter Physics instance.
     */applyForce:function(t,e){t=this.getMatterBodies(t);var i=this._tempVec2;return t.forEach(function(t){i.x=t.position.x,i.y=t.position.y,o.applyForce(t,i,e)}),this},/**
     * Applies a force to a body, from the given world position, including resulting torque.
     * If no angle is given, the current body angle is used.
     * 
     * Use very small speed values, such as 0.1, depending on the mass and required velocity.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#applyForceFromPosition
     * @since 3.22.0
     *
     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.
     * @param {Phaser.Types.Math.Vector2Like} position - A Vector that specifies the world-space position to apply the force at.
     * @param {number} speed - A speed value to be applied to a directional force.
     * @param {number} [angle] - The angle, in radians, to apply the force from. Leave undefined to use the current body angle.
     *
     * @return {this} This Matter Physics instance.
     */applyForceFromPosition:function(t,e,i,n){t=this.getMatterBodies(t);var s=this._tempVec2;return t.forEach(function(t){void 0===n&&(n=t.angle),s.x=i*Math.cos(n),s.y=i*Math.sin(n),o.applyForce(t,e,s)}),this},/**
     * Apply a force to a body based on the given angle and speed.
     * If no angle is given, the current body angle is used.
     * 
     * Use very small speed values, such as 0.1, depending on the mass and required velocity.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#applyForceFromAngle
     * @since 3.22.0
     *
     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.
     * @param {number} speed - A speed value to be applied to a directional force.
     * @param {number} [angle] - The angle, in radians, to apply the force from. Leave undefined to use the current body angle.
     *
     * @return {this} This Matter Physics instance.
     */applyForceFromAngle:function(t,e,i){t=this.getMatterBodies(t);var n=this._tempVec2;return t.forEach(function(t){void 0===i&&(i=t.angle),n.x=e*Math.cos(i),n.y=e*Math.sin(i),o.applyForce(t,{x:t.position.x,y:t.position.y},n)}),this},/**
     * Returns the length of the given constraint, which is the distance between the two points.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#getConstraintLength
     * @since 3.22.0
     *
     * @param {MatterJS.ConstraintType} constraint - The constraint to get the length from.
     *
     * @return {number} The length of the constraint.
     */getConstraintLength:function(t){var e=t.pointA.x,i=t.pointA.y,n=t.pointB.x,s=t.pointB.y;return t.bodyA&&(e+=t.bodyA.position.x,i+=t.bodyA.position.y),t.bodyB&&(n+=t.bodyB.position.x,s+=t.bodyB.position.y),p(e,i,n,s)},/**
     * Aligns a Body, or Matter Game Object, against the given coordinates.
     * 
     * The alignment takes place using the body bounds, which take into consideration things
     * like body scale and rotation.
     * 
     * Although a Body has a `position` property, it is based on the center of mass for the body,
     * not a dimension based center. This makes aligning bodies difficult, especially if they have
     * rotated or scaled. This method will derive the correct position based on the body bounds and
     * its center of mass offset, in order to align the body with the given coordinate.
     * 
     * For example, if you wanted to align a body so it sat in the bottom-center of the
     * Scene, and the world was 800 x 600 in size:
     * 
     * ```javascript
     * this.matter.alignBody(body, 400, 600, Phaser.Display.Align.BOTTOM_CENTER);
     * ```
     * 
     * You pass in 400 for the x coordinate, because that is the center of the world, and 600 for
     * the y coordinate, as that is the base of the world.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#alignBody
     * @since 3.22.0
     *
     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to align.
     * @param {number} x - The horizontal position to align the body to.
     * @param {number} y - The vertical position to align the body to.
     * @param {integer} align - One of the `Phaser.Display.Align` constants, such as `Phaser.Display.Align.TOP_LEFT`.
     *
     * @return {this} This Matter Physics instance.
     */alignBody:function(t,e,n,s){var r;switch(t=t.hasOwnProperty("body")?t.body:t,s){case i.TOP_LEFT:case i.LEFT_TOP:r=this.bodyBounds.getTopLeft(t,e,n);break;case i.TOP_CENTER:r=this.bodyBounds.getTopCenter(t,e,n);break;case i.TOP_RIGHT:case i.RIGHT_TOP:r=this.bodyBounds.getTopRight(t,e,n);break;case i.LEFT_CENTER:r=this.bodyBounds.getLeftCenter(t,e,n);break;case i.CENTER:r=this.bodyBounds.getCenter(t,e,n);break;case i.RIGHT_CENTER:r=this.bodyBounds.getRightCenter(t,e,n);break;case i.LEFT_BOTTOM:case i.BOTTOM_LEFT:r=this.bodyBounds.getBottomLeft(t,e,n);break;case i.BOTTOM_CENTER:r=this.bodyBounds.getBottomCenter(t,e,n);break;case i.BOTTOM_RIGHT:case i.RIGHT_BOTTOM:r=this.bodyBounds.getBottomRight(t,e,n)}return r&&o.setPosition(t,r),this},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#shutdown
     * @private
     * @since 3.0.0
     */shutdown:function(){var t=this.systems.events;this.world&&(t.off(R.UPDATE,this.world.update,this.world),t.off(R.POST_UPDATE,this.world.postUpdate,this.world)),t.off(R.SHUTDOWN,this.shutdown,this),this.add&&this.add.destroy(),this.world&&this.world.destroy(),this.add=null,this.world=null},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.Physics.Matter.MatterPhysics#destroy
     * @private
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.scene.sys.events.off(R.START,this.start,this),this.scene=null,this.systems=null}});C.register("MatterPhysics",I,"matterPhysics"),t.exports=I}),r("lEvhv",function(t,e){var i=s("ln6QG"),n={// plugin meta
name:"matter-attractors",version:"0.1.7",for:"matter-js@^0.14.2",silent:!0,// installs the plugin where `base` is `Matter`
// you should not need to call this directly.
install:function(t){t.after("Body.create",function(){n.Body.init(this)}),t.before("Engine.update",function(t){n.Engine.update(t)})},Body:{/**
     * Initialises the `body` to support attractors.
     * This is called automatically by the plugin.
     * @function MatterAttractors.Body.init
     * @param {Matter.Body} body The body to init.
     * @returns {void} No return value.
     */init:function(t){t.plugin.attractors=t.plugin.attractors||[]}},Engine:{/**
     * Applies all attractors for all bodies in the `engine`.
     * This is called automatically by the plugin.
     * @function MatterAttractors.Engine.update
     * @param {Matter.Engine} engine The engine to update.
     * @returns {void} No return value.
     */update:function(t){for(var e=t.world,n=i.Composite.allBodies(e),s=0;s<n.length;s+=1){var r=n[s],o=r.plugin.attractors;if(o&&o.length>0)for(var a=s+1;a<n.length;a+=1)for(var h=n[a],l=0;l<o.length;l+=1){var u=o[l],c=u;i.Common.isFunction(u)&&(c=u(r,h)),c&&i.Body.applyForce(h,h.position,c)}}}},/**
   * Defines some useful common attractor functions that can be used
   * by pushing them to your body's `body.plugin.attractors` array.
   * @namespace MatterAttractors.Attractors
   * @property {number} gravityConstant The gravitational constant used by the gravity attractor.
   */Attractors:{gravityConstant:.001,/**
     * An attractor function that applies Newton's law of gravitation.
     * Use this by pushing `MatterAttractors.Attractors.gravity` to your body's `body.plugin.attractors` array.
     * The gravitational constant defaults to `0.001` which you can change
     * at `MatterAttractors.Attractors.gravityConstant`.
     * @function MatterAttractors.Attractors.gravity
     * @param {Matter.Body} bodyA The first body.
     * @param {Matter.Body} bodyB The second body.
     * @returns {void} No return value.
     */gravity:function(t,e){// use Newton's law of gravitation
var s=i.Vector.sub(e.position,t.position),r=i.Vector.magnitudeSquared(s)||1e-4,o=i.Vector.normalise(s),a=-n.Attractors.gravityConstant*(t.mass*e.mass/r),h=i.Vector.mult(o,a);// to apply forces to both bodies
i.Body.applyForce(t,t.position,i.Vector.neg(h)),i.Body.applyForce(e,e.position,h)}}};t.exports=n;/**
 * @namespace Matter.Body
 * @see http://brm.io/matter-js/docs/classes/Body.html
 *//**
 * This plugin adds a new property `body.plugin.attractors` to instances of `Matter.Body`.
 * This is an array of callback functions that will be called automatically
 * for every pair of bodies, on every engine update.
 * @property {Function[]} body.plugin.attractors
 * @memberof Matter.Body
 *//**
 * An attractor function calculates the force to be applied
 * to `bodyB`, it should either:
 * - return the force vector to be applied to `bodyB`
 * - or apply the force to the body(s) itself
 * @callback AttractorFunction
 * @param {Matter.Body} bodyA
 * @param {Matter.Body} bodyB
 * @returns {(Vector|undefined)} a force vector (optional)
 */}),r("X2wk5",function(t,e){t.exports={name:"matter-collision-events",version:"0.1.6",for:"matter-js@^0.14.2",silent:!0,install:function(t){t.after("Engine.create",function(){t.Events.on(this,"collisionStart",function(e){e.pairs.map(function(e){var i=e.bodyA,n=e.bodyB;i.gameObject&&i.gameObject.emit("collide",i,n,e),n.gameObject&&n.gameObject.emit("collide",n,i,e),t.Events.trigger(i,"onCollide",{pair:e}),t.Events.trigger(n,"onCollide",{pair:e}),i.onCollideCallback&&i.onCollideCallback(e),n.onCollideCallback&&n.onCollideCallback(e),i.onCollideWith[n.id]&&i.onCollideWith[n.id](n,e),n.onCollideWith[i.id]&&n.onCollideWith[i.id](i,e)})}),t.Events.on(this,"collisionActive",function(e){e.pairs.map(function(e){var i=e.bodyA,n=e.bodyB;i.gameObject&&i.gameObject.emit("collideActive",i,n,e),n.gameObject&&n.gameObject.emit("collideActive",n,i,e),t.Events.trigger(i,"onCollideActive",{pair:e}),t.Events.trigger(n,"onCollideActive",{pair:e}),i.onCollideActiveCallback&&i.onCollideActiveCallback(e),n.onCollideActiveCallback&&n.onCollideActiveCallback(e)})}),t.Events.on(this,"collisionEnd",function(e){e.pairs.map(function(e){var i=e.bodyA,n=e.bodyB;i.gameObject&&i.gameObject.emit("collideEnd",i,n,e),n.gameObject&&n.gameObject.emit("collideEnd",n,i,e),t.Events.trigger(i,"onCollideEnd",{pair:e}),t.Events.trigger(n,"onCollideEnd",{pair:e}),i.onCollideEndCallback&&i.onCollideEndCallback(e),n.onCollideEndCallback&&n.onCollideEndCallback(e)})})})}}}),r("8Z2vx",function(t,e){var i=s("ln6QG"),n={// plugin meta
name:"matter-wrap",version:"0.1.4",for:"matter-js@^0.14.2",silent:!0,// installs the plugin where `base` is `Matter`
// you should not need to call this directly.
install:function(t){t.after("Engine.update",function(){n.Engine.update(this)})},Engine:{/**
     * Updates the engine by wrapping bodies and composites inside `engine.world`.
     * This is called automatically by the plugin.
     * @function MatterWrap.Engine.update
     * @param {Matter.Engine} engine The engine to update.
     * @returns {void} No return value.
     */update:function(t){for(var e=t.world,s=i.Composite.allBodies(e),r=i.Composite.allComposites(e),o=0;o<s.length;o+=1){var a=s[o];a.plugin.wrap&&n.Body.wrap(a,a.plugin.wrap)}for(o=0;o<r.length;o+=1){var h=r[o];h.plugin.wrap&&n.Composite.wrap(h,h.plugin.wrap)}}},Bounds:{/**
     * Returns a translation vector that wraps the `objectBounds` inside the `bounds`.
     * @function MatterWrap.Bounds.wrap
     * @param {Matter.Bounds} objectBounds The bounds of the object to wrap inside the bounds.
     * @param {Matter.Bounds} bounds The bounds to wrap the body inside.
     * @returns {?Matter.Vector} A translation vector (only if wrapping is required).
     */wrap:function(t,e){var i=null,n=null;if(void 0!==e.min.x&&void 0!==e.max.x&&(t.min.x>e.max.x?i=e.min.x-t.max.x:t.max.x<e.min.x&&(i=e.max.x-t.min.x)),void 0!==e.min.y&&void 0!==e.max.y&&(t.min.y>e.max.y?n=e.min.y-t.max.y:t.max.y<e.min.y&&(n=e.max.y-t.min.y)),null!==i||null!==n)return{x:i||0,y:n||0}}},Body:{/**
     * Wraps the `body` position such that it always stays within the given bounds. 
     * Upon crossing a boundary the body will appear on the opposite side of the bounds, 
     * while maintaining its velocity.
     * This is called automatically by the plugin.
     * @function MatterWrap.Body.wrap
     * @param {Matter.Body} body The body to wrap.
     * @param {Matter.Bounds} bounds The bounds to wrap the body inside.
     * @returns {?Matter.Vector} The translation vector that was applied (only if wrapping was required).
     */wrap:function(t,e){var s=n.Bounds.wrap(t.bounds,e);return s&&i.Body.translate(t,s),s}},Composite:{/**
     * Returns the union of the bounds of all of the composite's bodies
     * (not accounting for constraints).
     * @function MatterWrap.Composite.bounds
     * @param {Matter.Composite} composite The composite.
     * @returns {Matter.Bounds} The composite bounds.
     */bounds:function(t){for(var e=i.Composite.allBodies(t),n=[],s=0;s<e.length;s+=1){var r=e[s];n.push(r.bounds.min,r.bounds.max)}return i.Bounds.create(n)},/**
     * Wraps the `composite` position such that it always stays within the given bounds. 
     * Upon crossing a boundary the composite will appear on the opposite side of the bounds, 
     * while maintaining its velocity.
     * This is called automatically by the plugin.
     * @function MatterWrap.Composite.wrap
     * @param {Matter.Composite} composite The composite to wrap.
     * @param {Matter.Bounds} bounds The bounds to wrap the composite inside.
     * @returns {?Matter.Vector} The translation vector that was applied (only if wrapping was required).
     */wrap:function(t,e){var s=n.Bounds.wrap(n.Composite.bounds(t),e);return s&&i.Composite.translate(t,s),s}}};t.exports=n;/**
 * @namespace Matter.Body
 * @see http://brm.io/matter-js/docs/classes/Body.html
 *//**
 * This plugin adds a new property `body.plugin.wrap` to instances of `Matter.Body`.  
 * This is a `Matter.Bounds` instance that specifies the wrapping region.
 * @property {Matter.Bounds} body.plugin.wrap
 * @memberof Matter.Body
 *//**
 * This plugin adds a new property `composite.plugin.wrap` to instances of `Matter.Composite`.  
 * This is a `Matter.Bounds` instance that specifies the wrapping region.
 * @property {Matter.Bounds} composite.plugin.wrap
 * @memberof Matter.Composite
 */}),r("ilxnW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gY9LZ"),n=s("lMiYr"),r=s("jwj1g"),o=s("4tPKt"),a=s("in8Gg"),h=s("d8Zzv"),l=s("3vRz3"),u=s("989p0"),c=s("7BSWl"),d=s("5pMDk"),n=s("lMiYr"),f=s("aKoE7"),p=s("cRMRu"),g=s("koAaK"),v=s("a7bN0"),m=new r({Extends:l,initialize:function(t,e){l.call(this),/**
         * The Scene to which this Matter World instance belongs.
         *
         * @name Phaser.Physics.Matter.World#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * An instance of the MatterJS Engine.
         *
         * @name Phaser.Physics.Matter.World#engine
         * @type {MatterJS.Engine}
         * @since 3.0.0
         */this.engine=h.create(e),/**
         * A `World` composite object that will contain all simulated bodies and constraints.
         *
         * @name Phaser.Physics.Matter.World#localWorld
         * @type {MatterJS.World}
         * @since 3.0.0
         */this.localWorld=this.engine.world;var i=d(e,"gravity",null);i?this.setGravity(i.x,i.y,i.scale):!1===i&&this.setGravity(0,0,0),/**
         * An object containing the 4 wall bodies that bound the physics world.
         *
         * @name Phaser.Physics.Matter.World#walls
         * @type {object}
         * @since 3.0.0
         */this.walls={left:null,right:null,top:null,bottom:null},/**
         * A flag that toggles if the world is enabled or not.
         *
         * @name Phaser.Physics.Matter.World#enabled
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.enabled=d(e,"enabled",!0),/**
         * The correction argument is an optional Number that specifies the time correction factor to apply to the update.
         * This can help improve the accuracy of the simulation in cases where delta is changing between updates.
         * The value of correction is defined as delta / lastDelta, i.e. the percentage change of delta over the last step.
         * Therefore the value is always 1 (no correction) when delta is constant (or when no correction is desired, which is the default).
         * See the paper on Time Corrected Verlet for more information.
         *
         * @name Phaser.Physics.Matter.World#correction
         * @type {number}
         * @default 1
         * @since 3.4.0
         */this.correction=d(e,"correction",1),/**
         * This function is called every time the core game loop steps, which is bound to the
         * Request Animation Frame frequency unless otherwise modified.
         * 
         * The function is passed two values: `time` and `delta`, both of which come from the game step values.
         * 
         * It must return a number. This number is used as the delta value passed to Matter.Engine.update.
         * 
         * You can override this function with your own to define your own timestep.
         * 
         * If you need to update the Engine multiple times in a single game step then call
         * `World.update` as many times as required. Each call will trigger the `getDelta` function.
         * If you wish to have full control over when the Engine updates then see the property `autoUpdate`.
         *
         * You can also adjust the number of iterations that Engine.update performs.
         * Use the Scene Matter Physics config object to set the following properties:
         *
         * positionIterations (defaults to 6)
         * velocityIterations (defaults to 4)
         * constraintIterations (defaults to 2)
         *
         * Adjusting these values can help performance in certain situations, depending on the physics requirements
         * of your game.
         *
         * @name Phaser.Physics.Matter.World#getDelta
         * @type {function}
         * @since 3.4.0
         */this.getDelta=d(e,"getDelta",this.update60Hz);var n=c(e,"runner",{}),s=c(n,"fps",!1),r=c(n,"fps",60),o=c(n,"delta",1e3/r),a=c(n,"deltaMin",1e3/r),u=c(n,"deltaMax",1e3/(.5*r));s||(r=1e3/o),/**
         * The Matter JS Runner Configuration object.
         * 
         * This object is populated via the Matter Configuration object's `runner` property and is
         * updated constantly during the game step.
         *
         * @name Phaser.Physics.Matter.World#runner
         * @type {Phaser.Types.Physics.Matter.MatterRunnerConfig}
         * @since 3.22.0
         */this.runner={fps:r,correction:c(n,"correction",1),deltaSampleSize:c(n,"deltaSampleSize",60),counterTimestamp:0,frameCounter:0,deltaHistory:[],timePrev:null,timeScalePrev:1,frameRequestId:null,isFixed:c(n,"isFixed",!1),delta:o,deltaMin:a,deltaMax:u},/**
         * Automatically call Engine.update every time the game steps.
         * If you disable this then you are responsible for calling `World.step` directly from your game.
         * If you call `set60Hz` or `set30Hz` then `autoUpdate` is reset to `true`.
         *
         * @name Phaser.Physics.Matter.World#autoUpdate
         * @type {boolean}
         * @default true
         * @since 3.4.0
         */this.autoUpdate=d(e,"autoUpdate",!0);var f=d(e,"debug",!1);//  Create the walls
if(/**
         * A flag that controls if the debug graphics will be drawn to or not.
         *
         * @name Phaser.Physics.Matter.World#drawDebug
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.drawDebug="object"==typeof f||f,/**
         * An instance of the Graphics object the debug bodies are drawn to, if enabled.
         *
         * @name Phaser.Physics.Matter.World#debugGraphic
         * @type {Phaser.GameObjects.Graphics}
         * @since 3.0.0
         */this.debugGraphic,/**
         * The debug configuration object.
         * 
         * The values stored in this object are read from the Matter World Config `debug` property.
         * 
         * When a new Body or Constraint is _added to the World_, they are given the values stored in this object,
         * unless they have their own `render` object set that will override them.
         * 
         * Note that while you can modify the values of properties in this object at run-time, it will not change
         * any of the Matter objects _already added_. It will only impact objects newly added to the world, or one
         * that is removed and then re-added at a later time.
         *
         * @name Phaser.Physics.Matter.World#debugConfig
         * @type {Phaser.Types.Physics.Matter.MatterDebugConfig}
         * @since 3.22.0
         */this.debugConfig={showAxes:c(f,"showAxes",!1),showAngleIndicator:c(f,"showAngleIndicator",!1),angleColor:c(f,"angleColor",15208787),showBroadphase:c(f,"showBroadphase",!1),broadphaseColor:c(f,"broadphaseColor",16757760),showBounds:c(f,"showBounds",!1),boundsColor:c(f,"boundsColor",16777215),showVelocity:c(f,"showVelocity",!1),velocityColor:c(f,"velocityColor",44783),showCollisions:c(f,"showCollisions",!1),collisionColor:c(f,"collisionColor",16094476),showSeparations:c(f,"showSeparations",!1),separationColor:c(f,"separationColor",16753920),showBody:c(f,"showBody",!0),showStaticBody:c(f,"showStaticBody",!0),showInternalEdges:c(f,"showInternalEdges",!1),renderFill:c(f,"renderFill",!1),renderLine:c(f,"renderLine",!0),fillColor:c(f,"fillColor",1075465),fillOpacity:c(f,"fillOpacity",1),lineColor:c(f,"lineColor",2678297),lineOpacity:c(f,"lineOpacity",1),lineThickness:c(f,"lineThickness",1),staticFillColor:c(f,"staticFillColor",857979),staticLineColor:c(f,"staticLineColor",1255396),showSleeping:c(f,"showSleeping",!1),staticBodySleepOpacity:c(f,"staticBodySleepOpacity",.7),sleepFillColor:c(f,"sleepFillColor",4605510),sleepLineColor:c(f,"sleepLineColor",10066585),showSensors:c(f,"showSensors",!0),sensorFillColor:c(f,"sensorFillColor",857979),sensorLineColor:c(f,"sensorLineColor",1255396),showPositions:c(f,"showPositions",!0),positionSize:c(f,"positionSize",4),positionColor:c(f,"positionColor",14697178),showJoint:c(f,"showJoint",!0),jointColor:c(f,"jointColor",14737474),jointLineOpacity:c(f,"jointLineOpacity",1),jointLineThickness:c(f,"jointLineThickness",2),pinSize:c(f,"pinSize",4),pinColor:c(f,"pinColor",4382944),springColor:c(f,"springColor",14697184),anchorColor:c(f,"anchorColor",15724527),anchorSize:c(f,"anchorSize",4),showConvexHulls:c(f,"showConvexHulls",!1),hullColor:c(f,"hullColor",14091216)},this.drawDebug&&this.createDebugGraphic(),this.setEventsProxy(),c(e,"setBounds",!1)){var p=e.setBounds;if("boolean"==typeof p)this.setBounds();else{var g=c(p,"x",0),v=c(p,"y",0),m=c(p,"width",t.sys.scale.width),y=c(p,"height",t.sys.scale.height),x=c(p,"thickness",64),w=c(p,"left",!0),T=c(p,"right",!0),b=c(p,"top",!0),S=c(p,"bottom",!0);this.setBounds(g,v,m,y,x,w,T,b,S)}}},/**
     * Sets the debug render style for the children of the given Matter Composite.
     * 
     * Composites themselves do not render, but they can contain bodies, constraints and other composites that may do.
     * So the children of this composite are passed to the `setBodyRenderStyle`, `setCompositeRenderStyle` and
     * `setConstraintRenderStyle` methods accordingly.
     * 
     * @method Phaser.Physics.Matter.World#setCompositeRenderStyle
     * @since 3.22.0
     *
     * @param {MatterJS.CompositeType} composite - The Matter Composite to set the render style on.
     * 
     * @return {this} This Matter World instance for method chaining.
     */setCompositeRenderStyle:function(t){var e,i,n,s=t.bodies,r=t.constraints,o=t.composites;for(e=0;e<s.length;e++)n=(i=s[e]).render,this.setBodyRenderStyle(i,n.lineColor,n.lineOpacity,n.lineThickness,n.fillColor,n.fillOpacity);for(e=0;e<r.length;e++)n=(i=r[e]).render,this.setConstraintRenderStyle(i,n.lineColor,n.lineOpacity,n.lineThickness,n.pinSize,n.anchorColor,n.anchorSize);for(e=0;e<o.length;e++)i=o[e],this.setCompositeRenderStyle(i);return this},/**
     * Sets the debug render style for the given Matter Body.
     * 
     * If you are using this on a Phaser Game Object, such as a Matter Sprite, then pass in the body property
     * to this method, not the Game Object itself.
     * 
     * If you wish to skip a parameter, so it retains its current value, pass `false` for it.
     * 
     * If you wish to reset the Body render colors to the defaults found in the World Debug Config, then call
     * this method with just the `body` parameter provided and no others.
     * 
     * @method Phaser.Physics.Matter.World#setBodyRenderStyle
     * @since 3.22.0
     *
     * @param {MatterJS.BodyType} body - The Matter Body to set the render style on.
     * @param {number} [lineColor] - The line color. If `null` it will use the World Debug Config value.
     * @param {number} [lineOpacity] - The line opacity, between 0 and 1. If `null` it will use the World Debug Config value.
     * @param {number} [lineThickness] - The line thickness. If `null` it will use the World Debug Config value.
     * @param {number} [fillColor] - The fill color. If `null` it will use the World Debug Config value.
     * @param {number} [fillOpacity] - The fill opacity, between 0 and 1. If `null` it will use the World Debug Config value.
     * 
     * @return {this} This Matter World instance for method chaining.
     */setBodyRenderStyle:function(t,e,i,n,s,r){var o=t.render,a=this.debugConfig;return o&&(null==e&&(e=t.isStatic?a.staticLineColor:a.lineColor),null==i&&(i=a.lineOpacity),null==n&&(n=a.lineThickness),null==s&&(s=t.isStatic?a.staticFillColor:a.fillColor),null==r&&(r=a.fillOpacity),!1!==e&&(o.lineColor=e),!1!==i&&(o.lineOpacity=i),!1!==n&&(o.lineThickness=n),!1!==s&&(o.fillColor=s),!1!==r&&(o.fillOpacity=r)),this},/**
     * Sets the debug render style for the given Matter Constraint.
     * 
     * If you are using this on a Phaser Game Object, then pass in the body property
     * to this method, not the Game Object itself.
     * 
     * If you wish to skip a parameter, so it retains its current value, pass `false` for it.
     * 
     * If you wish to reset the Constraint render colors to the defaults found in the World Debug Config, then call
     * this method with just the `constraint` parameter provided and no others.
     * 
     * @method Phaser.Physics.Matter.World#setConstraintRenderStyle
     * @since 3.22.0
     *
     * @param {MatterJS.ConstraintType} constraint - The Matter Constraint to set the render style on.
     * @param {number} [lineColor] - The line color. If `null` it will use the World Debug Config value.
     * @param {number} [lineOpacity] - The line opacity, between 0 and 1. If `null` it will use the World Debug Config value.
     * @param {number} [lineThickness] - The line thickness. If `null` it will use the World Debug Config value.
     * @param {number} [pinSize] - If this constraint is a pin, this sets the size of the pin circle. If `null` it will use the World Debug Config value.
     * @param {number} [anchorColor] - The color used when rendering this constraints anchors.  If `null` it will use the World Debug Config value.
     * @param {number} [anchorSize] - The size of the anchor circle, if this constraint has anchors. If `null` it will use the World Debug Config value.
     * 
     * @return {this} This Matter World instance for method chaining.
     */setConstraintRenderStyle:function(t,e,i,n,s,r,o){var a=t.render,h=this.debugConfig;if(!a)return this;//  Reset them
if(null==e){var l=a.type;"line"===l?e=h.jointColor:"pin"===l?e=h.pinColor:"spring"===l&&(e=h.springColor)}return null==i&&(i=h.jointLineOpacity),null==n&&(n=h.jointLineThickness),null==s&&(s=h.pinSize),null==r&&(r=h.anchorColor),null==o&&(o=h.anchorSize),!1!==e&&(a.lineColor=e),!1!==i&&(a.lineOpacity=i),!1!==n&&(a.lineThickness=n),!1!==s&&(a.pinSize=s),!1!==r&&(a.anchorColor=r),!1!==o&&(a.anchorSize=o),this},/**
     * This internal method acts as a proxy between all of the Matter JS events and then re-emits them
     * via this class.
     *
     * @method Phaser.Physics.Matter.World#setEventsProxy
     * @since 3.0.0
     */setEventsProxy:function(){var t=this,e=this.engine,i=this.localWorld;this.drawDebug&&(f.on(i,"compositeModified",function(e){t.setCompositeRenderStyle(e)}),f.on(i,"beforeAdd",function(e){for(var i=[].concat(e.object),n=0;n<i.length;n++){var s=i[n],r=s.render;"body"===s.type?t.setBodyRenderStyle(s,r.lineColor,r.lineOpacity,r.lineThickness,r.fillColor,r.fillOpacity):"composite"===s.type?t.setCompositeRenderStyle(s):"constraint"===s.type&&t.setConstraintRenderStyle(s,r.lineColor,r.lineOpacity,r.lineThickness,r.pinSize,r.anchorColor,r.anchorSize)}})),f.on(i,"beforeAdd",function(e){t.emit(u.BEFORE_ADD,e)}),f.on(i,"afterAdd",function(e){t.emit(u.AFTER_ADD,e)}),f.on(i,"beforeRemove",function(e){t.emit(u.BEFORE_REMOVE,e)}),f.on(i,"afterRemove",function(e){t.emit(u.AFTER_REMOVE,e)}),f.on(e,"beforeUpdate",function(e){t.emit(u.BEFORE_UPDATE,e)}),f.on(e,"afterUpdate",function(e){t.emit(u.AFTER_UPDATE,e)}),f.on(e,"collisionStart",function(e){var i,n,s=e.pairs;s.length>0&&(i=s[0].bodyA,n=s[0].bodyB),t.emit(u.COLLISION_START,e,i,n)}),f.on(e,"collisionActive",function(e){var i,n,s=e.pairs;s.length>0&&(i=s[0].bodyA,n=s[0].bodyB),t.emit(u.COLLISION_ACTIVE,e,i,n)}),f.on(e,"collisionEnd",function(e){var i,n,s=e.pairs;s.length>0&&(i=s[0].bodyA,n=s[0].bodyB),t.emit(u.COLLISION_END,e,i,n)})},/**
     * Sets the bounds of the Physics world to match the given world pixel dimensions.
     * You can optionally set which 'walls' to create: left, right, top or bottom.
     * If none of the walls are given it will default to use the walls settings it had previously.
     * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size
     * the newly created bounds will also not have the left and right walls.
     * Explicitly state them in the parameters to override this.
     *
     * @method Phaser.Physics.Matter.World#setBounds
     * @since 3.0.0
     *
     * @param {number} [x=0] - The x coordinate of the top-left corner of the bounds.
     * @param {number} [y=0] - The y coordinate of the top-left corner of the bounds.
     * @param {number} [width] - The width of the bounds.
     * @param {number} [height] - The height of the bounds.
     * @param {number} [thickness=64] - The thickness of each wall, in pixels.
     * @param {boolean} [left=true] - If true will create the left bounds wall.
     * @param {boolean} [right=true] - If true will create the right bounds wall.
     * @param {boolean} [top=true] - If true will create the top bounds wall.
     * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.
     *
     * @return {Phaser.Physics.Matter.World} This Matter World object.
     */setBounds:function(t,e,i,n,s,r,o,a,h){return void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=this.scene.sys.scale.width),void 0===n&&(n=this.scene.sys.scale.height),void 0===s&&(s=64),void 0===r&&(r=!0),void 0===o&&(o=!0),void 0===a&&(a=!0),void 0===h&&(h=!0),this.updateWall(r,"left",t-s,e-s,s,n+2*s),this.updateWall(o,"right",t+i,e-s,s,n+2*s),this.updateWall(a,"top",t,e-s,i,s),this.updateWall(h,"bottom",t,e+n,i,s),this},/**
     * Updates the 4 rectangle bodies that were created, if `setBounds` was set in the Matter config, to use
     * the new positions and sizes. This method is usually only called internally via the `setBounds` method.
     *
     * @method Phaser.Physics.Matter.World#updateWall
     * @since 3.0.0
     *
     * @param {boolean} add - `true` if the walls are being added or updated, `false` to remove them from the world.
     * @param {string} [position] - Either `left`, `right`, `top` or `bottom`. Only optional if `add` is `false`.
     * @param {number} [x] - The horizontal position to place the walls at. Only optional if `add` is `false`.
     * @param {number} [y] - The vertical position to place the walls at. Only optional if `add` is `false`.
     * @param {number} [width] - The width of the walls, in pixels. Only optional if `add` is `false`.
     * @param {number} [height] - The height of the walls, in pixels. Only optional if `add` is `false`.
     */updateWall:function(t,e,i,n,s,r){var o=this.walls[e];t?(o&&g.remove(this.localWorld,o),//  adjust center
i+=s/2,n+=r/2,this.walls[e]=this.create(i,n,s,r,{isStatic:!0,friction:0,frictionStatic:0})):(o&&g.remove(this.localWorld,o),this.walls[e]=null)},/**
     * Creates a Phaser.GameObjects.Graphics object that is used to render all of the debug bodies and joints to.
     * 
     * This method is called automatically by the constructor, if debugging has been enabled.
     * 
     * The created Graphics object is automatically added to the Scene at 0x0 and given a depth of `Number.MAX_VALUE`,
     * so it renders above all else in the Scene.
     * 
     * The Graphics object is assigned to the `debugGraphic` property of this class and `drawDebug` is enabled.
     *
     * @method Phaser.Physics.Matter.World#createDebugGraphic
     * @since 3.0.0
     *
     * @return {Phaser.GameObjects.Graphics} The newly created Graphics object.
     */createDebugGraphic:function(){var t=this.scene.sys.add.graphics({x:0,y:0});return t.setDepth(Number.MAX_VALUE),this.debugGraphic=t,this.drawDebug=!0,t},/**
     * Sets the world gravity and gravity scale to 0.
     *
     * @method Phaser.Physics.Matter.World#disableGravity
     * @since 3.0.0
     *
     * @return {this} This Matter World object.
     */disableGravity:function(){return this.localWorld.gravity.x=0,this.localWorld.gravity.y=0,this.localWorld.gravity.scale=0,this},/**
     * Sets the worlds gravity to the values given.
     * 
     * Gravity effects all bodies in the world, unless they have the `ignoreGravity` flag set.
     *
     * @method Phaser.Physics.Matter.World#setGravity
     * @since 3.0.0
     *
     * @param {number} [x=0] - The world gravity x component.
     * @param {number} [y=1] - The world gravity y component.
     * @param {number} [scale=0.001] - The gravity scale factor.
     *
     * @return {this} This Matter World object.
     */setGravity:function(t,e,i){return void 0===t&&(t=0),void 0===e&&(e=1),this.localWorld.gravity.x=t,this.localWorld.gravity.y=e,void 0!==i&&(this.localWorld.gravity.scale=i),this},/**
     * Creates a rectangle Matter body and adds it to the world.
     *
     * @method Phaser.Physics.Matter.World#create
     * @since 3.0.0
     *
     * @param {number} x - The horizontal position of the body in the world.
     * @param {number} y - The vertical position of the body in the world.
     * @param {number} width - The width of the body.
     * @param {number} height - The height of the body.
     * @param {object} options - Optional Matter configuration object.
     *
     * @return {MatterJS.BodyType} The Matter.js body that was created.
     */create:function(t,e,n,s,r){var o=i.rectangle(t,e,n,s,r);return g.add(this.localWorld,o),o},/**
     * Adds a Matter JS object, or array of objects, to the world.
     * 
     * The objects should be valid Matter JS entities, such as a Body, Composite or Constraint.
     * 
     * Triggers `beforeAdd` and `afterAdd` events.
     *
     * @method Phaser.Physics.Matter.World#add
     * @since 3.0.0
     *
     * @param {(object|object[])} object - Can be single object, or an array, and can be a body, composite or constraint.
     *
     * @return {this} This Matter World object.
     */add:function(t){return g.add(this.localWorld,t),this},/**
     * Removes a Matter JS object, or array of objects, from the world.
     * 
     * The objects should be valid Matter JS entities, such as a Body, Composite or Constraint.
     * 
     * Triggers `beforeRemove` and `afterRemove` events.
     *
     * @method Phaser.Physics.Matter.World#remove
     * @since 3.0.0
     *
     * @param {(object|object[])} object - Can be single object, or an array, and can be a body, composite or constraint.
     * @param {boolean} [deep=false] - Optionally search the objects children and recursively remove those as well.
     *
     * @return {this} This Matter World object.
     */remove:function(t,e){Array.isArray(t)||(t=[t]);for(var i=0;i<t.length;i++){var n=t[i],s=n.body?n.body:n;a.remove(this.localWorld,s,e)}return this},/**
     * Removes a Matter JS constraint, or array of constraints, from the world.
     * 
     * Triggers `beforeRemove` and `afterRemove` events.
     *
     * @method Phaser.Physics.Matter.World#removeConstraint
     * @since 3.0.0
     *
     * @param {(MatterJS.ConstraintType|MatterJS.ConstraintType[])} constraint - A Matter JS Constraint, or an array of constraints, to be removed.
     * @param {boolean} [deep=false] - Optionally search the objects children and recursively remove those as well.
     *
     * @return {this} This Matter World object.
     */removeConstraint:function(t,e){return a.remove(this.localWorld,t,e),this},/**
     * Adds `MatterTileBody` instances for all the colliding tiles within the given tilemap layer.
     * 
     * Set the appropriate tiles in your layer to collide before calling this method!
     *
     * @method Phaser.Physics.Matter.World#convertTilemapLayer
     * @since 3.0.0
     *
     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer -
     * An array of tiles.
     * @param {object} [options] - Options to be passed to the MatterTileBody constructor. {@see Phaser.Physics.Matter.TileBody}
     *
     * @return {this} This Matter World object.
     */convertTilemapLayer:function(t,e){var i=t.layer,n=t.getTilesWithin(0,0,i.width,i.height,{isColliding:!0});return this.convertTiles(n,e),this},/**
     * Adds `MatterTileBody` instances for the given tiles. This adds bodies regardless of whether the
     * tiles are set to collide or not.
     *
     * @method Phaser.Physics.Matter.World#convertTiles
     * @since 3.0.0
     *
     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of tiles.
     * @param {object} [options] - Options to be passed to the MatterTileBody constructor. {@see Phaser.Physics.Matter.TileBody}
     *
     * @return {this} This Matter World object.
     */convertTiles:function(t,e){if(0===t.length)return this;for(var i=0;i<t.length;i++)new p(this,t[i],e);return this},/**
     * Returns the next unique group index for which bodies will collide.
     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will not collide.
     *
     * @method Phaser.Physics.Matter.World#nextGroup
     * @since 3.0.0
     *
     * @param {boolean} [isNonColliding=false] - If `true`, returns the next unique group index for which bodies will _not_ collide.
     *
     * @return {number} Unique category bitfield
     */nextGroup:function(t){return n.nextGroup(t)},/**
     * Returns the next unique category bitfield (starting after the initial default category 0x0001).
     * There are 32 available.
     *
     * @method Phaser.Physics.Matter.World#nextCategory
     * @since 3.0.0
     *
     * @return {number} Unique category bitfield
     */nextCategory:function(){return n.nextCategory()},/**
     * Pauses this Matter World instance and sets `enabled` to `false`.
     * 
     * A paused world will not run any simulations for the duration it is paused.
     *
     * @method Phaser.Physics.Matter.World#pause
     * @fires Phaser.Physics.Matter.Events#PAUSE
     * @since 3.0.0
     *
     * @return {this} This Matter World object.
     */pause:function(){return this.enabled=!1,this.emit(u.PAUSE),this},/**
     * Resumes this Matter World instance from a paused state and sets `enabled` to `true`.
     *
     * @method Phaser.Physics.Matter.World#resume
     * @fires Phaser.Physics.Matter.Events#RESUME
     * @since 3.0.0
     *
     * @return {this} This Matter World object.
     */resume:function(){return this.enabled=!0,this.emit(u.RESUME),this},/**
     * The internal update method. This is called automatically by the parent Scene.
     * 
     * Moves the simulation forward in time by delta ms. Uses `World.correction` value as an optional number that
     * specifies the time correction factor to apply to the update. This can help improve the accuracy of the
     * simulation in cases where delta is changing between updates. The value of correction is defined as `delta / lastDelta`,
     * i.e. the percentage change of delta over the last step. Therefore the value is always 1 (no correction) when
     * delta is constant (or when no correction is desired, which is the default).
     * See the paper on Time Corrected Verlet for more information.
     * 
     * Triggers `beforeUpdate` and `afterUpdate` events. Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.
     * 
     * If the World is paused, `update` is still run, but exits early and does not update the Matter Engine.
     *
     * @method Phaser.Physics.Matter.World#update
     * @since 3.0.0
     *
     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     */update:function(t,e){if(this.enabled&&this.autoUpdate){var i=this.engine,n=this.runner,s=i.timing,r=this.correction;n.isFixed?e=this.getDelta(t,e):(//  dynamic timestep based on wall clock between calls
e=t-n.timePrev||n.delta,n.timePrev=t,// optimistically filter delta over a few frames, to improve stability
n.deltaHistory.push(e),n.deltaHistory=n.deltaHistory.slice(-n.deltaSampleSize),// correction for delta
r=(e=// limit delta
(e=(e=Math.min.apply(null,n.deltaHistory))<n.deltaMin?n.deltaMin:e)>n.deltaMax?n.deltaMax:e)/n.delta,// update engine timing object
n.delta=e),0!==n.timeScalePrev&&(r*=s.timeScale/n.timeScalePrev),0===s.timeScale&&(r=0),n.timeScalePrev=s.timeScale,n.correction=r,// fps counter
n.frameCounter+=1,t-n.counterTimestamp>=1e3&&(n.fps=n.frameCounter*((t-n.counterTimestamp)/1e3),n.counterTimestamp=t,n.frameCounter=0),h.update(i,e,r)}},/**
     * Manually advances the physics simulation by one iteration.
     * 
     * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.
     * If undefined they use the Matter defaults of 60Hz and no correction.
     * 
     * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.
     * 
     * It also ignores any custom `getDelta` functions, as you should be passing the delta
     * value in to this call.
     *
     * You can adjust the number of iterations that Engine.update performs internally.
     * Use the Scene Matter Physics config object to set the following properties:
     *
     * positionIterations (defaults to 6)
     * velocityIterations (defaults to 4)
     * constraintIterations (defaults to 2)
     *
     * Adjusting these values can help performance in certain situations, depending on the physics requirements
     * of your game.
     *
     * @method Phaser.Physics.Matter.World#step
     * @since 3.4.0
     *
     * @param {number} [delta=16.666] - The delta value.
     * @param {number} [correction=1] - Optional delta correction value.
     */step:function(t,e){h.update(this.engine,t,e)},/**
     * Runs the Matter Engine.update at a fixed timestep of 60Hz.
     *
     * @method Phaser.Physics.Matter.World#update60Hz
     * @since 3.4.0
     *
     * @return {number} The delta value to be passed to Engine.update.
     */update60Hz:function(){return 1e3/60},/**
     * Runs the Matter Engine.update at a fixed timestep of 30Hz.
     *
     * @method Phaser.Physics.Matter.World#update30Hz
     * @since 3.4.0
     *
     * @return {number} The delta value to be passed to Engine.update.
     */update30Hz:function(){return 1e3/30},/**
     * Returns `true` if the given body can be found within the World.
     *
     * @method Phaser.Physics.Matter.World#has
     * @since 3.22.0
     * 
     * @param {(MatterJS.Body|Phaser.GameObjects.GameObject)} body - The Matter Body, or Game Object, to search for within the world.
     * 
     * @return {MatterJS.BodyType[]} An array of all the Matter JS Bodies in this World.
     */has:function(t){var e=t.hasOwnProperty("body")?t.body:t;return null!==a.get(this.localWorld,e.id,e.type)},/**
     * Returns all the bodies in the Matter World, including all bodies in children, recursively.
     *
     * @method Phaser.Physics.Matter.World#getAllBodies
     * @since 3.22.0
     * 
     * @return {MatterJS.BodyType[]} An array of all the Matter JS Bodies in this World.
     */getAllBodies:function(){return a.allBodies(this.localWorld)},/**
     * Returns all the constraints in the Matter World, including all constraints in children, recursively.
     *
     * @method Phaser.Physics.Matter.World#getAllConstraints
     * @since 3.22.0
     * 
     * @return {MatterJS.ConstraintType[]} An array of all the Matter JS Constraints in this World.
     */getAllConstraints:function(){return a.allConstraints(this.localWorld)},/**
     * Returns all the composites in the Matter World, including all composites in children, recursively.
     *
     * @method Phaser.Physics.Matter.World#getAllComposites
     * @since 3.22.0
     * 
     * @return {MatterJS.CompositeType[]} An array of all the Matter JS Composites in this World.
     */getAllComposites:function(){return a.allComposites(this.localWorld)},/**
     * Handles the rendering of bodies and debug information to the debug Graphics object, if enabled.
     * 
     * This method is called automatically by the Scene after all processing has taken place.
     *
     * @method Phaser.Physics.Matter.World#postUpdate
     * @private
     * @since 3.0.0
     */postUpdate:function(){if(this.drawDebug){var t=this.debugConfig,e=this.engine,i=this.debugGraphic,n=a.allBodies(this.localWorld);this.debugGraphic.clear(),t.showBroadphase&&e.broadphase.controller&&this.renderGrid(e.broadphase,i,t.broadphaseColor,.5),t.showBounds&&this.renderBodyBounds(n,i,t.boundsColor,.5),(t.showBody||t.showStaticBody)&&this.renderBodies(n),t.showJoint&&this.renderJoints(),(t.showAxes||t.showAngleIndicator)&&this.renderBodyAxes(n,i,t.showAxes,t.angleColor,.5),t.showVelocity&&this.renderBodyVelocity(n,i,t.velocityColor,1,2),t.showSeparations&&this.renderSeparations(e.pairs.list,i,t.separationColor),t.showCollisions&&this.renderCollisions(e.pairs.list,i,t.collisionColor)}},/**
     * Renders the Engine Broadphase Controller Grid to the given Graphics instance.
     * 
     * The debug renderer calls this method if the `showBroadphase` config value is set.
     * 
     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should
     * you wish to render the Grid to your own Graphics instance.
     * 
     * @method Phaser.Physics.Matter.World#renderGrid
     * @since 3.22.0
     * 
     * @param {MatterJS.Grid} grid - The Matter Grid to be rendered.
     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.
     * @param {number} lineColor - The line color.
     * @param {number} lineOpacity - The line opacity, between 0 and 1.
     * 
     * @return {this} This Matter World instance for method chaining.
     */renderGrid:function(t,e,i,n){e.lineStyle(1,i,n);for(var s=o.keys(t.buckets),r=0;r<s.length;r++){var a=s[r];if(!(t.buckets[a].length<2)){var h=a.split(/C|R/);e.strokeRect(parseInt(h[1],10)*t.bucketWidth,parseInt(h[2],10)*t.bucketHeight,t.bucketWidth,t.bucketHeight)}}return this},/**
     * Renders the list of Pair separations to the given Graphics instance.
     * 
     * The debug renderer calls this method if the `showSeparations` config value is set.
     * 
     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should
     * you wish to render the Grid to your own Graphics instance.
     * 
     * @method Phaser.Physics.Matter.World#renderSeparations
     * @since 3.22.0
     * 
     * @param {MatterJS.Pair[]} pairs - An array of Matter Pairs to be rendered.
     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.
     * @param {number} lineColor - The line color.
     * 
     * @return {this} This Matter World instance for method chaining.
     */renderSeparations:function(t,e,i){e.lineStyle(1,i,1);for(var n=0;n<t.length;n++){var s=t[n];if(s.isActive){var r=s.collision,o=r.bodyA,a=r.bodyB,h=o.position,l=a.position,u=r.penetration,c=o.isStatic||a.isStatic?1:4;a.isStatic&&(c=0),e.lineBetween(l.x,l.y,l.x-u.x*c,l.y-u.y*c),c=o.isStatic||a.isStatic?1:4,o.isStatic&&(c=0),e.lineBetween(h.x,h.y,h.x-u.x*c,h.y-u.y*c)}}return this},/**
     * Renders the list of collision points and normals to the given Graphics instance.
     * 
     * The debug renderer calls this method if the `showCollisions` config value is set.
     * 
     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should
     * you wish to render the Grid to your own Graphics instance.
     * 
     * @method Phaser.Physics.Matter.World#renderCollisions
     * @since 3.22.0
     * 
     * @param {MatterJS.Pair[]} pairs - An array of Matter Pairs to be rendered.
     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.
     * @param {number} lineColor - The line color.
     * 
     * @return {this} This Matter World instance for method chaining.
     */renderCollisions:function(t,e,i){//  Collision Positions
for(e.lineStyle(1,i,.5),e.fillStyle(i,1),n=0;n<t.length;n++)if((s=t[n]).isActive)for(var n,s,r=0;r<s.activeContacts.length;r++){var o=s.activeContacts[r].vertex;e.fillRect(o.x-2,o.y-2,5,5)}//  Collision Normals
for(n=0;n<t.length;n++)if((s=t[n]).isActive){var a=s.collision,h=s.activeContacts;if(h.length>0){var l=h[0].vertex.x,u=h[0].vertex.y;2===h.length&&(l=(h[0].vertex.x+h[1].vertex.x)/2,u=(h[0].vertex.y+h[1].vertex.y)/2),a.bodyB===a.supports[0].body||a.bodyA.isStatic?e.lineBetween(l-8*a.normal.x,u-8*a.normal.y,l,u):e.lineBetween(l+8*a.normal.x,u+8*a.normal.y,l,u)}}return this},/**
     * Renders the bounds of an array of Bodies to the given Graphics instance.
     * 
     * If the body is a compound body, it will render the bounds for the parent compound.
     * 
     * The debug renderer calls this method if the `showBounds` config value is set.
     * 
     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should
     * you wish to render bounds to your own Graphics instance.
     *
     * @method Phaser.Physics.Matter.World#renderBodyBounds
     * @since 3.22.0
     * 
     * @param {array} bodies - An array of bodies from the localWorld.
     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.
     * @param {number} lineColor - The line color.
     * @param {number} lineOpacity - The line opacity, between 0 and 1.
     */renderBodyBounds:function(t,e,i,n){e.lineStyle(1,i,n);for(var s=0;s<t.length;s++){var r=t[s];//  1) Don't show invisible bodies
if(r.render.visible){var o=r.bounds;if(o)e.strokeRect(o.min.x,o.min.y,o.max.x-o.min.x,o.max.y-o.min.y);else for(var a=r.parts,h=a.length>1?1:0;h<a.length;h++){var l=a[h];e.strokeRect(l.bounds.min.x,l.bounds.min.y,l.bounds.max.x-l.bounds.min.x,l.bounds.max.y-l.bounds.min.y)}}}return this},/**
     * Renders either all axes, or a single axis indicator, for an array of Bodies, to the given Graphics instance.
     * 
     * The debug renderer calls this method if the `showAxes` or `showAngleIndicator` config values are set.
     * 
     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should
     * you wish to render bounds to your own Graphics instance.
     *
     * @method Phaser.Physics.Matter.World#renderBodyAxes
     * @since 3.22.0
     * 
     * @param {array} bodies - An array of bodies from the localWorld.
     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.
     * @param {boolean} showAxes - If `true` it will render all body axes. If `false` it will render a single axis indicator.
     * @param {number} lineColor - The line color.
     * @param {number} lineOpacity - The line opacity, between 0 and 1.
     */renderBodyAxes:function(t,e,i,n,s){e.lineStyle(1,n,s);for(var r=0;r<t.length;r++){var o,a,h,l=t[r],u=l.parts;//  1) Don't show invisible bodies
if(l.render.visible){if(i)for(a=u.length>1?1:0;a<u.length;a++)for(h=0,o=u[a];h<o.axes.length;h++){var c=o.axes[h];e.lineBetween(o.position.x,o.position.y,o.position.x+20*c.x,o.position.y+20*c.y)}else for(a=u.length>1?1:0;a<u.length;a++)for(h=0,o=u[a];h<o.axes.length;h++)e.lineBetween(o.position.x,o.position.y,(o.vertices[0].x+o.vertices[o.vertices.length-1].x)/2,(o.vertices[0].y+o.vertices[o.vertices.length-1].y)/2)}}return this},/**
     * Renders a velocity indicator for an array of Bodies, to the given Graphics instance.
     * 
     * The debug renderer calls this method if the `showVelocity` config value is set.
     * 
     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should
     * you wish to render bounds to your own Graphics instance.
     *
     * @method Phaser.Physics.Matter.World#renderBodyVelocity
     * @since 3.22.0
     * 
     * @param {array} bodies - An array of bodies from the localWorld.
     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.
     * @param {number} lineColor - The line color.
     * @param {number} lineOpacity - The line opacity, between 0 and 1.
     * @param {number} lineThickness - The line thickness.
     */renderBodyVelocity:function(t,e,i,n,s){e.lineStyle(s,i,n);for(var r=0;r<t.length;r++){var o=t[r];//  1) Don't show invisible bodies
o.render.visible&&e.lineBetween(o.position.x,o.position.y,o.position.x+(o.position.x-o.positionPrev.x)*2,o.position.y+(o.position.y-o.positionPrev.y)*2)}return this},/**
     * Renders the given array of Bodies to the debug graphics instance.
     * 
     * Called automatically by the `postUpdate` method.
     *
     * @method Phaser.Physics.Matter.World#renderBodies
     * @private
     * @since 3.14.0
     * 
     * @param {array} bodies - An array of bodies from the localWorld.
     */renderBodies:function(t){for(var e=this.debugGraphic,i=this.debugConfig,n=i.showBody,s=i.showStaticBody,r=i.showSleeping,o=i.showInternalEdges,a=i.showConvexHulls,h=i.renderFill,l=i.renderLine,u=i.staticBodySleepOpacity,c=i.sleepFillColor,d=i.sleepLineColor,f=i.hullColor,p=0;p<t.length;p++){var g=t[p];//  1) Don't show invisible bodies
if(g.render.visible&&(s||!g.isStatic)&&(n||g.isStatic)){var v=g.render.lineColor,m=g.render.lineOpacity,y=g.render.lineThickness,x=g.render.fillColor,w=g.render.fillOpacity;r&&g.isSleeping&&(g.isStatic?(m*=u,w*=u):(v=d,x=c)),h||(x=null),l||(v=null),this.renderBody(g,e,o,v,m,y,x,w);var T=g.parts.length;a&&T>1&&this.renderConvexHull(g,e,f,y)}}},/**
     * Renders a single Matter Body to the given Phaser Graphics Game Object.
     * 
     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should
     * you wish to render a Body to your own Graphics instance.
     * 
     * If you don't wish to render a line around the body, set the `lineColor` parameter to `null`.
     * Equally, if you don't wish to render a fill, set the `fillColor` parameter to `null`.
     * 
     * @method Phaser.Physics.Matter.World#renderBody
     * @since 3.22.0
     * 
     * @param {MatterJS.BodyType} body - The Matter Body to be rendered.
     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.
     * @param {boolean} showInternalEdges - Render internal edges of the polygon?
     * @param {number} [lineColor] - The line color.
     * @param {number} [lineOpacity] - The line opacity, between 0 and 1.
     * @param {number} [lineThickness=1] - The line thickness.
     * @param {number} [fillColor] - The fill color.
     * @param {number} [fillOpacity] - The fill opacity, between 0 and 1.
     * 
     * @return {this} This Matter World instance for method chaining.
     */renderBody:function(t,e,i,n,s,r,o,a){void 0===n&&(n=null),void 0===s&&(s=null),void 0===r&&(r=1),void 0===o&&(o=null),void 0===a&&(a=null);for(var h=this.debugConfig,l=h.sensorFillColor,u=h.sensorLineColor,c=t.parts,d=c.length,f=d>1?1:0;f<d;f++){var p=c[f],g=p.render,v=g.opacity;if(g.visible&&0!==v&&(!p.isSensor||h.showSensors)){//  Part polygon
var m=p.circleRadius;if(e.beginPath(),p.isSensor?(null!==o&&e.fillStyle(l,a*v),null!==n&&e.lineStyle(r,u,s*v)):(null!==o&&e.fillStyle(o,a*v),null!==n&&e.lineStyle(r,n,s*v)),m)e.arc(p.position.x,p.position.y,m,0,2*Math.PI);else{var y=p.vertices,x=y.length;e.moveTo(y[0].x,y[0].y);for(var w=1;w<x;w++){var T=y[w];if(!y[w-1].isInternal||i?e.lineTo(T.x,T.y):e.moveTo(T.x,T.y),w<x&&T.isInternal&&!i){var b=(w+1)%x;e.moveTo(y[b].x,y[b].y)}}e.closePath()}null!==o&&e.fillPath(),null!==n&&e.strokePath()}}if(h.showPositions&&!t.isStatic){var S=t.position.x,A=t.position.y,E=Math.ceil(h.positionSize/2);e.fillStyle(h.positionColor,1),e.fillRect(S-E,A-E,h.positionSize,h.positionSize)}return this},/**
     * Renders the Convex Hull for a single Matter Body to the given Phaser Graphics Game Object.
     * 
     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should
     * you wish to render a Body hull to your own Graphics instance.
     * 
     * @method Phaser.Physics.Matter.World#renderConvexHull
     * @since 3.22.0
     * 
     * @param {MatterJS.BodyType} body - The Matter Body to be rendered.
     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.
     * @param {number} hullColor - The color used to render the hull.
     * @param {number} [lineThickness=1] - The hull line thickness.
     * 
     * @return {this} This Matter World instance for method chaining.
     */renderConvexHull:function(t,e,i,n){//  Render Convex Hulls
if(void 0===n&&(n=1),t.parts.length>1){var s=t.vertices;e.lineStyle(n,i),e.beginPath(),e.moveTo(s[0].x,s[0].y);for(var r=1;r<s.length;r++)e.lineTo(s[r].x,s[r].y);e.lineTo(s[0].x,s[0].y),e.strokePath()}return this},/**
     * Renders all of the constraints in the world (unless they are specifically set to invisible).
     * 
     * Called automatically by the `postUpdate` method.
     *
     * @method Phaser.Physics.Matter.World#renderJoints
     * @private
     * @since 3.14.0
     */renderJoints:function(){for(var t=this.debugGraphic,e=a.allConstraints(this.localWorld),i=0;i<e.length;i++){var n=e[i].render,s=n.lineColor,r=n.lineOpacity,o=n.lineThickness,h=n.pinSize,l=n.anchorColor,u=n.anchorSize;this.renderConstraint(e[i],t,s,r,o,h,l,u)}},/**
     * Renders a single Matter Constraint, such as a Pin or a Spring, to the given Phaser Graphics Game Object.
     * 
     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should
     * you wish to render a Constraint to your own Graphics instance.
     * 
     * @method Phaser.Physics.Matter.World#renderConstraint
     * @since 3.22.0
     * 
     * @param {MatterJS.ConstraintType} constraint - The Matter Constraint to render.
     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.
     * @param {number} lineColor - The line color.
     * @param {number} lineOpacity - The line opacity, between 0 and 1.
     * @param {number} lineThickness - The line thickness.
     * @param {number} pinSize - If this constraint is a pin, this sets the size of the pin circle.
     * @param {number} anchorColor - The color used when rendering this constraints anchors. Set to `null` to not render anchors.
     * @param {number} anchorSize - The size of the anchor circle, if this constraint has anchors and is rendering them.
     * 
     * @return {this} This Matter World instance for method chaining.
     */renderConstraint:function(t,e,i,n,s,r,a,h){var l=t.render;if(!l.visible||!t.pointA||!t.pointB)return this;e.lineStyle(s,i,n);var u=t.bodyA,c=t.bodyB;if(d=u?v.add(u.position,t.pointA):t.pointA,"pin"===l.type)e.strokeCircle(d.x,d.y,r);else{if(f=c?v.add(c.position,t.pointB):t.pointB,e.beginPath(),e.moveTo(d.x,d.y),"spring"===l.type)for(var d,f,p,g=v.sub(f,d),m=v.perp(v.normalise(g)),y=Math.ceil(o.clamp(t.length/5,12,20)),x=1;x<y;x+=1)p=x%2==0?1:-1,e.lineTo(d.x+g.x*(x/y)+m.x*p*4,d.y+g.y*(x/y)+m.y*p*4);e.lineTo(f.x,f.y)}return e.strokePath(),l.anchors&&h>0&&(e.fillStyle(a),e.fillCircle(d.x,d.y,h),e.fillCircle(f.x,f.y,h)),this},/**
     * Resets the internal collision IDs that Matter.JS uses for Body collision groups.
     * 
     * You should call this before destroying your game if you need to restart the game
     * again on the same page, without first reloading the page. Or, if you wish to
     * consistently destroy a Scene that contains Matter.js and then run it again
     * later in the same game.
     *
     * @method Phaser.Physics.Matter.World#resetCollisionIDs
     * @since 3.17.0
     */resetCollisionIDs:function(){return n._nextCollidingGroupId=1,n._nextNonCollidingGroupId=-1,n._nextCategory=1,this},/**
     * Will remove all Matter physics event listeners and clear the matter physics world,
     * engine and any debug graphics, if any.
     *
     * @method Phaser.Physics.Matter.World#shutdown
     * @since 3.0.0
     */shutdown:function(){f.off(this.engine),this.removeAllListeners(),g.clear(this.localWorld,!1),h.clear(this.engine),this.drawDebug&&this.debugGraphic.destroy()},/**
     * Will remove all Matter physics event listeners and clear the matter physics world,
     * engine and any debug graphics, if any.
     *
     * After destroying the world it cannot be re-used again.
     *
     * @method Phaser.Physics.Matter.World#destroy
     * @since 3.0.0
     */destroy:function(){this.shutdown()}});t.exports=m}),r("UoAVD",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Plugins
 */t.exports={BasePlugin:s("bAukD"),DefaultPlugins:s("488fh"),PluginCache:s("7AzQW"),PluginManager:s("brulE"),ScenePlugin:s("dJiiW")}}),r("bAukD",function(t,e){/**
 * @classdesc
 * A Global Plugin is installed just once into the Game owned Plugin Manager.
 * It can listen for Game events and respond to them.
 *
 * @class BasePlugin
 * @memberof Phaser.Plugins
 * @constructor
 * @since 3.8.0
 *
 * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Plugin Manager.
 */var i=new(s("jwj1g"))({initialize:function(t){/**
         * A handy reference to the Plugin Manager that is responsible for this plugin.
         * Can be used as a route to gain access to game systems and  events.
         *
         * @name Phaser.Plugins.BasePlugin#pluginManager
         * @type {Phaser.Plugins.PluginManager}
         * @protected
         * @since 3.8.0
         */this.pluginManager=t,/**
         * A reference to the Game instance this plugin is running under.
         *
         * @name Phaser.Plugins.BasePlugin#game
         * @type {Phaser.Game}
         * @protected
         * @since 3.8.0
         */this.game=t.game},/**
     * The PluginManager calls this method on a Global Plugin when the plugin is first instantiated.
     * It will never be called again on this instance.
     * In here you can set-up whatever you need for this plugin to run.
     * If a plugin is set to automatically start then `BasePlugin.start` will be called immediately after this.
     * On a Scene Plugin, this method is never called. Use {@link Phaser.Plugins.ScenePlugin#boot} instead.
     *
     * @method Phaser.Plugins.BasePlugin#init
     * @since 3.8.0
     *
     * @param {?any} [data] - A value specified by the user, if any, from the `data` property of the plugin's configuration object (if started at game boot) or passed in the PluginManager's `install` method (if started manually).
     */init:function(){},/**
     * The PluginManager calls this method on a Global Plugin when the plugin is started.
     * If a plugin is stopped, and then started again, this will get called again.
     * Typically called immediately after `BasePlugin.init`.
     * On a Scene Plugin, this method is never called.
     *
     * @method Phaser.Plugins.BasePlugin#start
     * @since 3.8.0
     */start:function(){//  Here are the game-level events you can listen to.
//  At the very least you should offer a destroy handler for when the game closes down.
// var eventEmitter = this.game.events;
// eventEmitter.once('destroy', this.gameDestroy, this);
// eventEmitter.on('pause', this.gamePause, this);
// eventEmitter.on('resume', this.gameResume, this);
// eventEmitter.on('resize', this.gameResize, this);
// eventEmitter.on('prestep', this.gamePreStep, this);
// eventEmitter.on('step', this.gameStep, this);
// eventEmitter.on('poststep', this.gamePostStep, this);
// eventEmitter.on('prerender', this.gamePreRender, this);
// eventEmitter.on('postrender', this.gamePostRender, this);
},/**
     * The PluginManager calls this method on a Global Plugin when the plugin is stopped.
     * The game code has requested that your plugin stop doing whatever it does.
     * It is now considered as 'inactive' by the PluginManager.
     * Handle that process here (i.e. stop listening for events, etc)
     * If the plugin is started again then `BasePlugin.start` will be called again.
     * On a Scene Plugin, this method is never called.
     *
     * @method Phaser.Plugins.BasePlugin#stop
     * @since 3.8.0
     */stop:function(){},/**
     * Game instance has been destroyed.
     * You must release everything in here, all references, all objects, free it all up.
     *
     * @method Phaser.Plugins.BasePlugin#destroy
     * @since 3.8.0
     */destroy:function(){this.pluginManager=null,this.game=null,this.scene=null,this.systems=null}});t.exports=i}),r("dJiiW",function(t,e){/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2020 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
*/var i=s("bAukD"),n=s("jwj1g"),r=s("4rtgc"),o=new n({Extends:i,initialize:function(t,e){i.call(this,e),/**
         * A reference to the Scene that has installed this plugin.
         * Only set if it's a Scene Plugin, otherwise `null`.
         * This property is only set when the plugin is instantiated and added to the Scene, not before.
         * You can use it during the `boot` method.
         *
         * @name Phaser.Plugins.ScenePlugin#scene
         * @type {?Phaser.Scene}
         * @protected
         * @since 3.8.0
         */this.scene=t,/**
         * A reference to the Scene Systems of the Scene that has installed this plugin.
         * Only set if it's a Scene Plugin, otherwise `null`.
         * This property is only set when the plugin is instantiated and added to the Scene, not before.
         * You can use it during the `boot` method.
         *
         * @name Phaser.Plugins.ScenePlugin#systems
         * @type {?Phaser.Scenes.Systems}
         * @protected
         * @since 3.8.0
         */this.systems=t.sys,t.sys.events.once(r.BOOT,this.boot,this)},/**
     * This method is called when the Scene boots. It is only ever called once.
     *
     * By this point the plugin properties `scene` and `systems` will have already been set.
     *
     * In here you can listen for {@link Phaser.Scenes.Events Scene events} and set-up whatever you need for this plugin to run.
     * Here are the Scene events you can listen to:
     *
     * - start
     * - ready
     * - preupdate
     * - update
     * - postupdate
     * - resize
     * - pause
     * - resume
     * - sleep
     * - wake
     * - transitioninit
     * - transitionstart
     * - transitioncomplete
     * - transitionout
     * - shutdown
     * - destroy
     *
     * At the very least you should offer a destroy handler for when the Scene closes down, i.e:
     *
     * ```javascript
     * var eventEmitter = this.systems.events;
     * eventEmitter.once('destroy', this.sceneDestroy, this);
     * ```
     *
     * @method Phaser.Plugins.ScenePlugin#boot
     * @since 3.8.0
     */boot:function(){},/**
     * Game instance has been destroyed.
     * 
     * You must release everything in here, all references, all objects, free it all up.
     *
     * @method Phaser.Plugins.ScenePlugin#destroy
     * @since 3.8.0
     */destroy:function(){this.pluginManager=null,this.game=null,this.scene=null,this.systems=null}});t.exports=o}),r("28d72",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Renderer
 *//**
 * @namespace Phaser.Types.Renderer
 */t.exports={Canvas:s("2iMCO"),Snapshot:s("cWQV6"),WebGL:s("liq0E")}}),r("2iMCO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Renderer.Canvas
 */t.exports={CanvasRenderer:s("b2B4m"),GetBlendModes:s("3M7Hx"),SetTransform:s("csLaZ")}}),r("cWQV6",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Renderer.Snapshot
 */t.exports={Canvas:s("feofd"),WebGL:s("65D27")}}),r("liq0E",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Renderer.WebGL
 */t.exports={Utils:s("gaO4e"),WebGLPipeline:s("AbdBB"),WebGLRenderer:s("aPphQ"),Pipelines:s("boxXf"),// Constants
BYTE:0,SHORT:1,UNSIGNED_BYTE:2,UNSIGNED_SHORT:3,FLOAT:4}}),r("boxXf",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Renderer.WebGL.Pipelines
 */t.exports={BitmapMaskPipeline:s("84zIv"),ForwardDiffuseLightPipeline:s("lOOAG"),TextureTintPipeline:s("jnBZP"),TextureTintStripPipeline:s("eBujp"),ModelViewProjection:s("g1JCF")}}),r("59R71",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hVk4C"),n=s("dlsVr"),r={Center:s("9tm7z"),Events:s("jPI3B"),Orientation:s("8cRWJ"),ScaleManager:s("861Bh"),ScaleModes:s("1mQJz"),Zoom:s("9l9Tb")};r=i(!1,r,n.CENTER),r=i(!1,r,n.ORIENTATION),r=i(!1,r,n.SCALE_MODE),r=i(!1,r,n.ZOOM),t.exports=r}),r("kULhB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("anFCw"),n=s("hVk4C"),r={Events:s("4rtgc"),SceneManager:s("TOZF7"),ScenePlugin:s("4Saom"),Settings:s("i9d1I"),Systems:s("jgSN1")};//   Merge in the consts
r=n(!1,r,i),t.exports=r}),r("4Saom",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("iEUUO"),n=s("jwj1g"),r=s("4rtgc"),o=s("7BSWl"),a=s("7AzQW"),h=new n({initialize:function(t){/**
         * The Scene that this ScenePlugin belongs to.
         *
         * @name Phaser.Scenes.ScenePlugin#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * The Scene Systems instance of the Scene that this ScenePlugin belongs to.
         *
         * @name Phaser.Scenes.ScenePlugin#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,/**
         * The settings of the Scene this ScenePlugin belongs to.
         *
         * @name Phaser.Scenes.ScenePlugin#settings
         * @type {Phaser.Types.Scenes.SettingsObject}
         * @since 3.0.0
         */this.settings=t.sys.settings,/**
         * The key of the Scene this ScenePlugin belongs to.
         *
         * @name Phaser.Scenes.ScenePlugin#key
         * @type {string}
         * @since 3.0.0
         */this.key=t.sys.settings.key,/**
         * The Game's SceneManager.
         *
         * @name Phaser.Scenes.ScenePlugin#manager
         * @type {Phaser.Scenes.SceneManager}
         * @since 3.0.0
         */this.manager=t.sys.game.scene,/**
         * If this Scene is currently transitioning to another, this holds
         * the current percentage of the transition progress, between 0 and 1.
         *
         * @name Phaser.Scenes.ScenePlugin#transitionProgress
         * @type {number}
         * @since 3.5.0
         */this.transitionProgress=0,/**
         * Transition elapsed timer.
         *
         * @name Phaser.Scenes.ScenePlugin#_elapsed
         * @type {integer}
         * @private
         * @since 3.5.0
         */this._elapsed=0,/**
         * Transition elapsed timer.
         *
         * @name Phaser.Scenes.ScenePlugin#_target
         * @type {?Phaser.Scenes.Scene}
         * @private
         * @since 3.5.0
         */this._target=null,/**
         * Transition duration.
         *
         * @name Phaser.Scenes.ScenePlugin#_duration
         * @type {integer}
         * @private
         * @since 3.5.0
         */this._duration=0,/**
         * Transition callback.
         *
         * @name Phaser.Scenes.ScenePlugin#_onUpdate
         * @type {function}
         * @private
         * @since 3.5.0
         */this._onUpdate,/**
         * Transition callback scope.
         *
         * @name Phaser.Scenes.ScenePlugin#_onUpdateScope
         * @type {object}
         * @private
         * @since 3.5.0
         */this._onUpdateScope,/**
         * Will this Scene sleep (true) after the transition, or stop (false)
         *
         * @name Phaser.Scenes.ScenePlugin#_willSleep
         * @type {boolean}
         * @private
         * @since 3.5.0
         */this._willSleep=!1,/**
         * Will this Scene be removed from the Scene Manager after the transition completes?
         *
         * @name Phaser.Scenes.ScenePlugin#_willRemove
         * @type {boolean}
         * @private
         * @since 3.5.0
         */this._willRemove=!1,t.sys.events.once(r.BOOT,this.boot,this),t.sys.events.on(r.START,this.pluginStart,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.Scenes.ScenePlugin#boot
     * @private
     * @since 3.0.0
     */boot:function(){this.systems.events.once(r.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.Scenes.ScenePlugin#pluginStart
     * @private
     * @since 3.5.0
     */pluginStart:function(){this._target=null,this.systems.events.once(r.SHUTDOWN,this.shutdown,this)},/**
     * Shutdown this Scene and run the given one.
     *
     * This will happen at the next Scene Manager update, not immediately.
     *
     * @method Phaser.Scenes.ScenePlugin#start
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to start.
     * @param {object} [data] - The Scene data.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */start:function(t,e){return void 0===t&&(t=this.key),this.manager.queueOp("stop",this.key),this.manager.queueOp("start",t,e),this},/**
     * Restarts this Scene.
     *
     * This will happen at the next Scene Manager update, not immediately.
     *
     * @method Phaser.Scenes.ScenePlugin#restart
     * @since 3.4.0
     *
     * @param {object} [data] - The Scene data.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */restart:function(t){var e=this.key;return this.manager.queueOp("stop",e),this.manager.queueOp("start",e,t),this},/**
     * This will start a transition from the current Scene to the target Scene given.
     *
     * The transition will last for the duration specified in milliseconds.
     *
     * You can have the target Scene moved above or below this one in the display list.
     *
     * You can specify an update callback. This callback will be invoked _every frame_ for the duration
     * of the transition.
     *
     * This Scene can either be sent to sleep at the end of the transition, or stopped. The default is to stop.
     *
     * There are also 5 transition related events: This scene will emit the event `transitionout` when
     * the transition begins, which is typically the frame after calling this method.
     *
     * The target Scene will emit the event `transitioninit` when that Scene's `init` method is called.
     * It will then emit the event `transitionstart` when its `create` method is called.
     * If the Scene was sleeping and has been woken up, it will emit the event `transitionwake` instead of these two,
     * as the Scenes `init` and `create` methods are not invoked when a Scene wakes up.
     *
     * When the duration of the transition has elapsed it will emit the event `transitioncomplete`.
     * These events are cleared of all listeners when the Scene shuts down, but not if it is sent to sleep.
     *
     * It's important to understand that the duration of the transition begins the moment you call this method.
     * If the Scene you are transitioning to includes delayed processes, such as waiting for files to load, the
     * time still counts down even while that is happening. If the game itself pauses, or something else causes
     * this Scenes update loop to stop, then the transition will also pause for that duration. There are
     * checks in place to prevent you accidentally stopping a transitioning Scene but if you've got code to
     * override this understand that until the target Scene completes it might never be unlocked for input events.
     *
     * @method Phaser.Scenes.ScenePlugin#transition
     * @fires Phaser.Scenes.Events#TRANSITION_OUT
     * @since 3.5.0
     *
     * @param {Phaser.Types.Scenes.SceneTransitionConfig} config - The transition configuration object.
     *
     * @return {boolean} `true` is the transition was started, otherwise `false`.
     */transition:function(t){void 0===t&&(t={});var e=o(t,"target",!1),i=this.manager.getScene(e);if(!e||!this.checkValidTransition(i))return!1;var n=o(t,"duration",1e3);this._elapsed=0,this._target=i,this._duration=n,this._willSleep=o(t,"sleep",!1),this._willRemove=o(t,"remove",!1);var s=o(t,"onUpdate",null);s&&(this._onUpdate=s,this._onUpdateScope=o(t,"onUpdateScope",this.scene));var a=o(t,"allowInput",!1);this.settings.transitionAllowInput=a;var h=i.sys.settings;return h.isTransition=!0,h.transitionFrom=this.scene,h.transitionDuration=n,h.transitionAllowInput=a,o(t,"moveAbove",!1)?this.manager.moveAbove(this.key,e):o(t,"moveBelow",!1)&&this.manager.moveBelow(this.key,e),i.sys.isSleeping()?i.sys.wake(o(t,"data")):this.manager.start(e,o(t,"data")),this.systems.events.emit(r.TRANSITION_OUT,i,n),this.systems.events.on(r.UPDATE,this.step,this),!0},/**
     * Checks to see if this Scene can transition to the target Scene or not.
     *
     * @method Phaser.Scenes.ScenePlugin#checkValidTransition
     * @private
     * @since 3.5.0
     *
     * @param {Phaser.Scene} target - The Scene to test against.
     *
     * @return {boolean} `true` if this Scene can transition, otherwise `false`.
     */checkValidTransition:function(t){return!(!t||t.sys.isActive()||t.sys.isTransitioning()||t===this.scene||this.systems.isTransitioning())},/**
     * A single game step. This is only called if the parent Scene is transitioning
     * out to another Scene.
     *
     * @method Phaser.Scenes.ScenePlugin#step
     * @private
     * @since 3.5.0
     *
     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     */step:function(t,e){this._elapsed+=e,this.transitionProgress=i(this._elapsed/this._duration,0,1),this._onUpdate&&this._onUpdate.call(this._onUpdateScope,this.transitionProgress),this._elapsed>=this._duration&&this.transitionComplete()},/**
     * Called by `step` when the transition out of this scene to another is over.
     *
     * @method Phaser.Scenes.ScenePlugin#transitionComplete
     * @private
     * @fires Phaser.Scenes.Events#TRANSITION_COMPLETE
     * @since 3.5.0
     */transitionComplete:function(){var t=this._target.sys,e=this._target.sys.settings;//  Stop the step
this.systems.events.off(r.UPDATE,this.step,this),//  Notify target scene
t.events.emit(r.TRANSITION_COMPLETE,this.scene),//  Clear target scene settings
e.isTransition=!1,e.transitionFrom=null,//  Clear local settings
this._duration=0,this._target=null,this._onUpdate=null,this._onUpdateScope=null,this._willRemove?this.manager.remove(this.key):this._willSleep?this.systems.sleep():this.manager.stop(this.key)},/**
     * Add the Scene into the Scene Manager and start it if 'autoStart' is true or the Scene config 'active' property is set.
     *
     * @method Phaser.Scenes.ScenePlugin#add
     * @since 3.0.0
     *
     * @param {string} key - The Scene key.
     * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig|function)} sceneConfig - The config for the Scene.
     * @param {boolean} autoStart - Whether to start the Scene after it's added.
     * @param {object} [data] - Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.
     *
     * @return {Phaser.Scene} An instance of the Scene that was added to the Scene Manager.
     */add:function(t,e,i,n){return this.manager.add(t,e,i,n)},/**
     * Launch the given Scene and run it in parallel with this one.
     *
     * This will happen at the next Scene Manager update, not immediately.
     *
     * @method Phaser.Scenes.ScenePlugin#launch
     * @since 3.0.0
     *
     * @param {string} key - The Scene to launch.
     * @param {object} [data] - The Scene data.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */launch:function(t,e){return t&&t!==this.key&&this.manager.queueOp("start",t,e),this},/**
     * Runs the given Scene, but does not change the state of this Scene.
     *
     * This will happen at the next Scene Manager update, not immediately.
     *
     * If the given Scene is paused, it will resume it. If sleeping, it will wake it.
     * If not running at all, it will be started.
     *
     * Use this if you wish to open a modal Scene by calling `pause` on the current
     * Scene, then `run` on the modal Scene.
     *
     * @method Phaser.Scenes.ScenePlugin#run
     * @since 3.10.0
     *
     * @param {string} key - The Scene to run.
     * @param {object} [data] - A data object that will be passed to the Scene and emitted in its ready, wake, or resume events.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */run:function(t,e){return t&&t!==this.key&&this.manager.queueOp("run",t,e),this},/**
     * Pause the Scene - this stops the update step from happening but it still renders.
     *
     * This will happen at the next Scene Manager update, not immediately.
     *
     * @method Phaser.Scenes.ScenePlugin#pause
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to pause.
     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its pause event.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */pause:function(t,e){return void 0===t&&(t=this.key),this.manager.queueOp("pause",t,e),this},/**
     * Resume the Scene - starts the update loop again.
     *
     * This will happen at the next Scene Manager update, not immediately.
     *
     * @method Phaser.Scenes.ScenePlugin#resume
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to resume.
     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its resume event.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */resume:function(t,e){return void 0===t&&(t=this.key),this.manager.queueOp("resume",t,e),this},/**
     * Makes the Scene sleep (no update, no render) but doesn't shutdown.
     *
     * This will happen at the next Scene Manager update, not immediately.
     *
     * @method Phaser.Scenes.ScenePlugin#sleep
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to put to sleep.
     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its sleep event.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */sleep:function(t,e){return void 0===t&&(t=this.key),this.manager.queueOp("sleep",t,e),this},/**
     * Makes the Scene wake-up (starts update and render)
     *
     * This will happen at the next Scene Manager update, not immediately.
     *
     * @method Phaser.Scenes.ScenePlugin#wake
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to wake up.
     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its wake event.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */wake:function(t,e){return void 0===t&&(t=this.key),this.manager.queueOp("wake",t,e),this},/**
     * Makes this Scene sleep then starts the Scene given.
     *
     * This will happen at the next Scene Manager update, not immediately.
     *
     * @method Phaser.Scenes.ScenePlugin#switch
     * @since 3.0.0
     *
     * @param {string} key - The Scene to start.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */switch:function(t){return t!==this.key&&this.manager.queueOp("switch",this.key,t),this},/**
     * Shutdown the Scene, clearing display list, timers, etc.
     *
     * This happens at the next Scene Manager update, not immediately.
     *
     * @method Phaser.Scenes.ScenePlugin#stop
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to stop.
     * @param {any} [data] - Optional data object to pass to Scene.Systems.shutdown.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */stop:function(t,e){return void 0===t&&(t=this.key),this.manager.queueOp("stop",t,e),this},/**
     * Sets the active state of the given Scene.
     *
     * @method Phaser.Scenes.ScenePlugin#setActive
     * @since 3.0.0
     *
     * @param {boolean} value - If `true` the Scene will be resumed. If `false` it will be paused.
     * @param {string} [key] - The Scene to set the active state of.
     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted with its events.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */setActive:function(t,e,i){void 0===e&&(e=this.key);var n=this.manager.getScene(e);return n&&n.sys.setActive(t,i),this},/**
     * Sets the visible state of the given Scene.
     *
     * @method Phaser.Scenes.ScenePlugin#setVisible
     * @since 3.0.0
     *
     * @param {boolean} value - The visible value.
     * @param {string} [key] - The Scene to set the visible state for.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */setVisible:function(t,e){void 0===e&&(e=this.key);var i=this.manager.getScene(e);return i&&i.sys.setVisible(t),this},/**
     * Checks if the given Scene is sleeping or not?
     *
     * @method Phaser.Scenes.ScenePlugin#isSleeping
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to check.
     *
     * @return {boolean} Whether the Scene is sleeping.
     */isSleeping:function(t){return void 0===t&&(t=this.key),this.manager.isSleeping(t)},/**
     * Checks if the given Scene is running or not?
     *
     * @method Phaser.Scenes.ScenePlugin#isActive
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to check.
     *
     * @return {boolean} Whether the Scene is running.
     */isActive:function(t){return void 0===t&&(t=this.key),this.manager.isActive(t)},/**
     * Checks if the given Scene is paused or not?
     *
     * @method Phaser.Scenes.ScenePlugin#isPaused
     * @since 3.17.0
     *
     * @param {string} [key] - The Scene to check.
     *
     * @return {boolean} Whether the Scene is paused.
     */isPaused:function(t){return void 0===t&&(t=this.key),this.manager.isPaused(t)},/**
     * Checks if the given Scene is visible or not?
     *
     * @method Phaser.Scenes.ScenePlugin#isVisible
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to check.
     *
     * @return {boolean} Whether the Scene is visible.
     */isVisible:function(t){return void 0===t&&(t=this.key),this.manager.isVisible(t)},/**
     * Swaps the position of two scenes in the Scenes list.
     *
     * This controls the order in which they are rendered and updated.
     *
     * @method Phaser.Scenes.ScenePlugin#swapPosition
     * @since 3.2.0
     *
     * @param {string} keyA - The first Scene to swap.
     * @param {string} [keyB] - The second Scene to swap. If none is given it defaults to this Scene.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */swapPosition:function(t,e){return void 0===e&&(e=this.key),t!==e&&this.manager.swapPosition(t,e),this},/**
     * Swaps the position of two scenes in the Scenes list, so that Scene B is directly above Scene A.
     *
     * This controls the order in which they are rendered and updated.
     *
     * @method Phaser.Scenes.ScenePlugin#moveAbove
     * @since 3.2.0
     *
     * @param {string} keyA - The Scene that Scene B will be moved to be above.
     * @param {string} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */moveAbove:function(t,e){return void 0===e&&(e=this.key),t!==e&&this.manager.moveAbove(t,e),this},/**
     * Swaps the position of two scenes in the Scenes list, so that Scene B is directly below Scene A.
     *
     * This controls the order in which they are rendered and updated.
     *
     * @method Phaser.Scenes.ScenePlugin#moveBelow
     * @since 3.2.0
     *
     * @param {string} keyA - The Scene that Scene B will be moved to be below.
     * @param {string} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */moveBelow:function(t,e){return void 0===e&&(e=this.key),t!==e&&this.manager.moveBelow(t,e),this},/**
     * Removes a Scene from the SceneManager.
     *
     * The Scene is removed from the local scenes array, it's key is cleared from the keys
     * cache and Scene.Systems.destroy is then called on it.
     *
     * If the SceneManager is processing the Scenes when this method is called it will
     * queue the operation for the next update sequence.
     *
     * @method Phaser.Scenes.ScenePlugin#remove
     * @since 3.2.0
     *
     * @param {(string|Phaser.Scene)} [key] - The Scene to be removed.
     *
     * @return {Phaser.Scenes.SceneManager} This SceneManager.
     */remove:function(t){return void 0===t&&(t=this.key),this.manager.remove(t),this},/**
     * Moves a Scene up one position in the Scenes list.
     *
     * @method Phaser.Scenes.ScenePlugin#moveUp
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to move.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */moveUp:function(t){return void 0===t&&(t=this.key),this.manager.moveUp(t),this},/**
     * Moves a Scene down one position in the Scenes list.
     *
     * @method Phaser.Scenes.ScenePlugin#moveDown
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to move.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */moveDown:function(t){return void 0===t&&(t=this.key),this.manager.moveDown(t),this},/**
     * Brings a Scene to the top of the Scenes list.
     *
     * This means it will render above all other Scenes.
     *
     * @method Phaser.Scenes.ScenePlugin#bringToTop
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to move.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */bringToTop:function(t){return void 0===t&&(t=this.key),this.manager.bringToTop(t),this},/**
     * Sends a Scene to the back of the Scenes list.
     *
     * This means it will render below all other Scenes.
     *
     * @method Phaser.Scenes.ScenePlugin#sendToBack
     * @since 3.0.0
     *
     * @param {string} [key] - The Scene to move.
     *
     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.
     */sendToBack:function(t){return void 0===t&&(t=this.key),this.manager.sendToBack(t),this},/**
     * Retrieve a Scene.
     *
     * @method Phaser.Scenes.ScenePlugin#get
     * @since 3.0.0
     *
     * @param {string} key - The Scene to retrieve.
     *
     * @return {Phaser.Scene} The Scene.
     */get:function(t){return this.manager.getScene(t)},/**
     * Retrieves the numeric index of a Scene in the Scenes list.
     *
     * @method Phaser.Scenes.ScenePlugin#getIndex
     * @since 3.7.0
     *
     * @param {(string|Phaser.Scene)} [key] - The Scene to get the index of.
     *
     * @return {integer} The index of the Scene.
     */getIndex:function(t){return void 0===t&&(t=this.key),this.manager.getIndex(t)},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.Scenes.ScenePlugin#shutdown
     * @private
     * @since 3.0.0
     */shutdown:function(){var t=this.systems.events;t.off(r.SHUTDOWN,this.shutdown,this),t.off(r.POST_UPDATE,this.step,this),t.off(r.TRANSITION_OUT)},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.Scenes.ScenePlugin#destroy
     * @private
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.scene.sys.events.off(r.START,this.start,this),this.scene=null,this.systems=null,this.settings=null,this.manager=null}});a.register("ScenePlugin",h,"scenePlugin"),t.exports=h}),r("i2sgM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Structs
 */t.exports={List:s("aqhsx"),Map:s("ddl2W"),ProcessQueue:s("gz3ML"),RTree:s("aVlAx"),Set:s("lxxnL"),Size:s("ehRgb")}}),r("rZmIK",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hVk4C"),n=s("hwy5T"),r={CanvasTexture:s("demvd"),Events:s("6R4Pe"),FilterMode:n,Frame:s("7O4PF"),Parsers:s("jx0HO"),Texture:s("cCQL0"),TextureManager:s("5QcEl"),TextureSource:s("k25Vv")};r=i(!1,r,n),t.exports=r}),r("hwy5T",function(t,e){t.exports={/**
     * Linear filter type.
     * 
     * @name Phaser.Textures.FilterMode.LINEAR
     * @type {integer}
     * @const
     * @since 3.0.0
     */LINEAR:0,/**
     * Nearest neighbor filter type.
     * 
     * @name Phaser.Textures.FilterMode.NEAREST
     * @type {integer}
     * @const
     * @since 3.0.0
     */NEAREST:1}}),r("s5oWw",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Tilemaps
 */t.exports={Components:s("hequO"),Parsers:s("2mw6B"),Formats:s("au4z0"),ImageCollection:s("65en1"),ParseToTilemap:s("6SHSh"),Tile:s("1uZwx"),Tilemap:s("l3bIA"),TilemapCreator:s("28rGO"),TilemapFactory:s("17YuE"),Tileset:s("eZOmW"),LayerData:s("5wtVg"),MapData:s("5Jvnl"),ObjectLayer:s("egj22"),DynamicTilemapLayer:s("3DUwP"),StaticTilemapLayer:s("ehIU5")}}),r("hequO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Tilemaps.Components
 */t.exports={CalculateFacesAt:s("9gNi2"),CalculateFacesWithin:s("inaFS"),Copy:s("b0DHi"),CreateFromTiles:s("4Rbvi"),CullTiles:s("1oJ5J"),Fill:s("4YarZ"),FilterTiles:s("fjtyV"),FindByIndex:s("jF8Rm"),FindTile:s("f6NxX"),ForEachTile:s("7Oi2Q"),GetTileAt:s("6gsOs"),GetTileAtWorldXY:s("jbtNO"),GetTilesWithin:s("eJlg2"),GetTilesWithinShape:s("czPKZ"),GetTilesWithinWorldXY:s("k4TZC"),HasTileAt:s("9jA5f"),HasTileAtWorldXY:s("g4CAW"),IsInLayerBounds:s("3UG6O"),PutTileAt:s("64x6H"),PutTileAtWorldXY:s("9toet"),PutTilesAt:s("jVpX9"),Randomize:s("4VMg3"),RemoveTileAt:s("fX9li"),RemoveTileAtWorldXY:s("ibjim"),RenderDebug:s("4YYIg"),ReplaceByIndex:s("jQ9G3"),SetCollision:s("jAcLl"),SetCollisionBetween:s("gpdMb"),SetCollisionByExclusion:s("8C01B"),SetCollisionByProperty:s("i03zR"),SetCollisionFromCollisionGroup:s("8oy5E"),SetTileIndexCallback:s("5p4Io"),SetTileLocationCallback:s("4wqRe"),Shuffle:s("bdoRX"),SwapByIndex:s("N9ezU"),TileToWorldX:s("DeoMl"),TileToWorldXY:s("5oCuI"),TileToWorldY:s("3t1Uc"),WeightedRandomize:s("gv9XM"),WorldToTileX:s("jJuPw"),WorldToTileXY:s("afyKE"),WorldToTileY:s("jWCaM")}}),r("9gNi2",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6gsOs");t.exports=function(t,e,n){var s=i(t,e,!0,n),r=i(t,e-1,!0,n),o=i(t,e+1,!0,n),a=i(t-1,e,!0,n),h=i(t+1,e,!0,n),l=s&&s.collides;return l&&(s.faceTop=!0,s.faceBottom=!0,s.faceLeft=!0,s.faceRight=!0),r&&r.collides&&(l&&(s.faceTop=!1),r.faceBottom=!l),o&&o.collides&&(l&&(s.faceBottom=!1),o.faceTop=!l),a&&a.collides&&(l&&(s.faceLeft=!1),a.faceRight=!l),h&&h.collides&&(l&&(s.faceRight=!1),h.faceLeft=!l),s&&!s.collides&&s.resetFaces(),s}}),r("6gsOs",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("3UG6O");t.exports=function(t,e,n,s){if(void 0===n&&(n=!1),!i(t,e,s))return null;var r=s.data[e][t]||null;return null===r?null:-1===r.index?n?r:null:r}}),r("3UG6O",function(t,e){t.exports=function(t,e,i){return t>=0&&t<i.width&&e>=0&&e<i.height}}),r("inaFS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6gsOs"),n=s("eJlg2");t.exports=function(t,e,s,r,o){for(var a=null,h=null,l=null,u=null,c=n(t,e,s,r,null,o),d=0;d<c.length;d++){var f=c[d];f&&(f.collides?(a=i(f.x,f.y-1,!0,o),h=i(f.x,f.y+1,!0,o),l=i(f.x-1,f.y,!0,o),u=i(f.x+1,f.y,!0,o),f.faceTop=!a||!a.collides,f.faceBottom=!h||!h.collides,f.faceLeft=!l||!l.collides,f.faceRight=!u||!u.collides):f.resetFaces())}}}),r("eJlg2",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7BSWl");t.exports=function(t,e,n,s,r,o){void 0===t&&(t=0),void 0===e&&(e=0),void 0===n&&(n=o.width),void 0===s&&(s=o.height);var a=i(r,"isNotEmpty",!1),h=i(r,"isColliding",!1),l=i(r,"hasInterestingFace",!1);t<0&&(n+=t,t=0),e<0&&(s+=e,e=0),t+n>o.width&&(n=Math.max(o.width-t,0)),e+s>o.height&&(s=Math.max(o.height-e,0));for(var u=[],c=e;c<e+s;c++)for(var d=t;d<t+n;d++){var f=o.data[c][d];if(null!==f){if(a&&-1===f.index||h&&!f.collides||l&&!f.hasInterestingFace)continue;u.push(f)}}return u}}),r("b0DHi",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2"),n=s("inaFS");t.exports=function(t,e,s,r,o,a,h,l){t<0&&(t=0),e<0&&(e=0),void 0===h&&(h=!0);for(var u=i(t,e,s,r,null,l),c=o-t,d=a-e,f=0;f<u.length;f++){var p=u[f].x+c,g=u[f].y+d;p>=0&&p<l.width&&g>=0&&g<l.height&&l.data[g][p]&&l.data[g][p].copy(u[f])}h&&n(o-1,a-1,s+2,r+2,l)}}),r("4Rbvi",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("DeoMl"),n=s("3t1Uc"),r=s("eJlg2"),o=s("jQ9G3");t.exports=function(t,e,s,a,h,l){void 0===s&&(s={}),Array.isArray(t)||(t=[t]);var u,c=l.tilemapLayer;void 0===a&&(a=c.scene),void 0===h&&(h=a.cameras.main);var d=r(0,0,l.width,l.height,null,l),f=[];for(u=0;u<d.length;u++){var p=d[u];if(-1!==t.indexOf(p.index)){s.x=i(p.x,h,l),s.y=n(p.y,h,l);var g=a.make.sprite(s);f.push(g)}}if("number"==typeof e)for(u=0;u<t.length;u++)o(t[u],e,0,0,l.width,l.height,l);else if(Array.isArray(e))for(u=0;u<t.length;u++)o(t[u],e[u],0,0,l.width,l.height,l);return f}}),r("DeoMl",function(t,e){t.exports=function(t,e,i){var n=i.baseTileWidth,s=i.tilemapLayer,r=0;return s&&(void 0===e&&(e=s.scene.cameras.main),r=s.x+e.scrollX*(1-s.scrollFactorX),n*=s.scaleX),r+t*n}}),r("3t1Uc",function(t,e){t.exports=function(t,e,i){var n=i.baseTileHeight,s=i.tilemapLayer,r=0;return s&&(void 0===e&&(e=s.scene.cameras.main),r=s.y+e.scrollY*(1-s.scrollFactorY),n*=s.scaleY),r+t*n}}),r("jQ9G3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2");t.exports=function(t,e,n,s,r,o,a){for(var h=i(n,s,r,o,null,a),l=0;l<h.length;l++)h[l]&&h[l].index===t&&(h[l].index=e)}}),r("1oJ5J",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jcIaO"),n=s("lpfsR");t.exports=function(t,e,s,r){void 0===s&&(s=[]),void 0===r&&(r=0),s.length=0;var o,a,h,l=t.tilemapLayer.tilemap,u=t.tilemapLayer,c=t.data,d=t.width,f=t.height,p=Math.floor(l.tileWidth*u.scaleX),g=Math.floor(l.tileHeight*u.scaleY),v=0,m=d,y=0,x=f;if(!u.skipCull&&1===u.scrollFactorX&&1===u.scrollFactorY){//  Camera world view bounds, snapped for scaled tile size
//  Cull Padding values are given in tiles, not pixels
var w=i(e.worldView.x-u.x,p,0,!0)-u.cullPaddingX,T=n(e.worldView.right-u.x,p,0,!0)+u.cullPaddingX,b=i(e.worldView.y-u.y,g,0,!0)-u.cullPaddingY,S=n(e.worldView.bottom-u.y,g,0,!0)+u.cullPaddingY;v=Math.max(0,w),m=Math.min(d,T),y=Math.max(0,b),x=Math.min(f,S)}if(0===r)//  right-down
for(a=y;a<x;a++)for(o=v;c[a]&&o<m;o++)(h=c[a][o])&&-1!==h.index&&h.visible&&0!==h.alpha&&s.push(h);else if(1===r)//  left-down
for(a=y;a<x;a++)for(o=m;c[a]&&o>=v;o--)(h=c[a][o])&&-1!==h.index&&h.visible&&0!==h.alpha&&s.push(h);else if(2===r)//  right-up
for(a=x;a>=y;a--)for(o=v;c[a]&&o<m;o++)(h=c[a][o])&&-1!==h.index&&h.visible&&0!==h.alpha&&s.push(h);else if(3===r)//  left-up
for(a=x;a>=y;a--)for(o=m;c[a]&&o>=v;o--)(h=c[a][o])&&-1!==h.index&&h.visible&&0!==h.alpha&&s.push(h);return u.tilesDrawn=s.length,u.tilesTotal=d*f,s}}),r("4YarZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2"),n=s("inaFS"),r=s("6Hyw7");t.exports=function(t,e,s,o,a,h,l){for(var u=-1!==l.collideIndexes.indexOf(t),c=i(e,s,o,a,null,l),d=0;d<c.length;d++)c[d].index=t,r(c[d],u);h&&n(e-1,s-1,o+2,a+2,l)}}),r("6Hyw7",function(t,e){t.exports=function(t,e){e?t.setCollision(!0,!0,!0,!0,!1):t.resetCollision(!1)}}),r("fjtyV",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2");t.exports=function(t,e,n,s,r,o,a,h){return i(n,s,r,o,a,h).filter(t,e)}}),r("jF8Rm",function(t,e){t.exports=function(t,e,i,n){void 0===e&&(e=0),void 0===i&&(i=!1);var s,r,o,a=0;if(i){for(r=n.height-1;r>=0;r--)for(s=n.width-1;s>=0;s--)if((o=n.data[r][s])&&o.index===t){if(a===e)return o;a+=1}}else for(r=0;r<n.height;r++)for(s=0;s<n.width;s++)if((o=n.data[r][s])&&o.index===t){if(a===e)return o;a+=1}return null}}),r("f6NxX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2");t.exports=function(t,e,n,s,r,o,a,h){return i(n,s,r,o,a,h).find(t,e)||null}}),r("7Oi2Q",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2");t.exports=function(t,e,n,s,r,o,a,h){i(n,s,r,o,a,h).forEach(t,e)}}),r("jbtNO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6gsOs"),n=s("jJuPw"),r=s("jWCaM");t.exports=function(t,e,s,o,a){return i(n(t,!0,o,a),r(e,!0,o,a),s,a)}}),r("jJuPw",function(t,e){t.exports=function(t,e,i,n){void 0===e&&(e=!0);var s=n.baseTileWidth,r=n.tilemapLayer;return r&&(void 0===i&&(i=r.scene.cameras.main),// Find the world position relative to the static or dynamic layer's top left origin,
// factoring in the camera's horizontal scroll
t-=r.x+i.scrollX*(1-r.scrollFactorX),s*=r.scaleX),e?Math.floor(t/s):t/s}}),r("jWCaM",function(t,e){t.exports=function(t,e,i,n){void 0===e&&(e=!0);var s=n.baseTileHeight,r=n.tilemapLayer;return r&&(void 0===i&&(i=r.scene.cameras.main),// Find the world position relative to the static or dynamic layer's top left origin,
// factoring in the camera's vertical scroll
t-=r.y+i.scrollY*(1-r.scrollFactorY),s*=r.scaleY),e?Math.floor(t/s):t/s}}),r("czPKZ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kNZrp"),n=s("eJlg2"),r=s("6Lcv1"),o=s("13GYA"),a=s("DeoMl"),h=s("3t1Uc"),l=s("jJuPw"),u=s("jWCaM"),c=function(t,e){return r.RectangleToTriangle(e,t)};t.exports=function(t,e,s,d){if(void 0===t)return[];// intersectTest is a function with parameters: shape, rect
var f=o;t instanceof i.Circle?f=r.CircleToRectangle:t instanceof i.Rectangle?f=r.RectangleToRectangle:t instanceof i.Triangle?f=c:t instanceof i.Line&&(f=r.LineToRectangle);// Top left corner of the shapes's bounding box, rounded down to include partial tiles
var p=l(t.left,!0,s,d),g=u(t.top,!0,s,d),v=Math.ceil(l(t.right,!1,s,d)),m=Math.ceil(u(t.bottom,!1,s,d)),y=Math.max(v-p,1),x=Math.max(m-g,1),w=n(p,g,y,x,e,d),T=d.tileWidth,b=d.tileHeight;d.tilemapLayer&&(T*=d.tilemapLayer.scaleX,b*=d.tilemapLayer.scaleY);for(var S=[],A=new i.Rectangle(0,0,T,b),E=0;E<w.length;E++){var _=w[E];A.x=a(_.x,s,d),A.y=h(_.y,s,d),f(t,A)&&S.push(_)}return S}}),r("k4TZC",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2"),n=s("jJuPw"),r=s("jWCaM");t.exports=function(t,e,s,o,a,h,l){// Top left corner of the rect, rounded down to include partial tiles
var u=n(t,!0,h,l),c=r(e,!0,h,l);return i(u,c,Math.ceil(n(t+s,!1,h,l))-u,Math.ceil(r(e+o,!1,h,l))-c,a,l)}}),r("9jA5f",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("3UG6O");t.exports=function(t,e,n){if(!i(t,e,n))return!1;var s=n.data[e][t];return null!==s&&s.index>-1}}),r("g4CAW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("9jA5f"),n=s("jJuPw"),r=s("jWCaM");t.exports=function(t,e,s,o){return i(n(t,!0,s,o),r(e,!0,s,o),o)}}),r("64x6H",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1uZwx"),n=s("3UG6O"),r=s("9gNi2"),o=s("6Hyw7");t.exports=function(t,e,s,a,h){if(!n(e,s,h))return null;void 0===a&&(a=!0);var l=h.data[s][e],u=l&&l.collides;t instanceof i?(null===h.data[s][e]&&(h.data[s][e]=new i(h,t.index,e,s,t.width,t.height)),h.data[s][e].copy(t)):null===h.data[s][e]?h.data[s][e]=new i(h,t,e,s,h.tileWidth,h.tileHeight):h.data[s][e].index=t;// Updating colliding flag on the new tile
var c=h.data[s][e],d=-1!==h.collideIndexes.indexOf(c.index);return o(c,d),a&&u!==c.collides&&r(e,s,h),c}}),r("1uZwx",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("baGGN"),o=new i({Mixins:[n.Alpha,n.Flip,n.Visible],initialize:function(t,e,i,n,s,r,o,a){/**
         * The LayerData in the Tilemap data that this tile belongs to.
         *
         * @name Phaser.Tilemaps.Tile#layer
         * @type {Phaser.Tilemaps.LayerData}
         * @since 3.0.0
         */this.layer=t,/**
         * The index of this tile within the map data corresponding to the tileset, or -1 if this
         * represents a blank tile.
         *
         * @name Phaser.Tilemaps.Tile#index
         * @type {integer}
         * @since 3.0.0
         */this.index=e,/**
         * The x map coordinate of this tile in tile units.
         *
         * @name Phaser.Tilemaps.Tile#x
         * @type {integer}
         * @since 3.0.0
         */this.x=i,/**
         * The y map coordinate of this tile in tile units.
         *
         * @name Phaser.Tilemaps.Tile#y
         * @type {integer}
         * @since 3.0.0
         */this.y=n,/**
         * The width of the tile in pixels.
         *
         * @name Phaser.Tilemaps.Tile#width
         * @type {integer}
         * @since 3.0.0
         */this.width=s,/**
         * The height of the tile in pixels.
         *
         * @name Phaser.Tilemaps.Tile#height
         * @type {integer}
         * @since 3.0.0
         */this.height=r,/**
         * The map's base width of a tile in pixels. Tiled maps support multiple tileset sizes
         * within one map, but they are still placed at intervals of the base tile size.
         *
         * @name Phaser.Tilemaps.Tile#baseWidth
         * @type {integer}
         * @since 3.0.0
         */this.baseWidth=void 0!==o?o:s,/**
         * The map's base height of a tile in pixels. Tiled maps support multiple tileset sizes
         * within one map, but they are still placed at intervals of the base tile size.
         *
         * @name Phaser.Tilemaps.Tile#baseHeight
         * @type {integer}
         * @since 3.0.0
         */this.baseHeight=void 0!==a?a:r,/**
         * The x coordinate of the top left of this tile in pixels. This is relative to the top left
         * of the layer this tile is being rendered within. This property does NOT factor in camera
         * scroll, layer scale or layer position.
         *
         * @name Phaser.Tilemaps.Tile#pixelX
         * @type {number}
         * @since 3.0.0
         */this.pixelX=0,/**
         * The y coordinate of the top left of this tile in pixels. This is relative to the top left
         * of the layer this tile is being rendered within. This property does NOT factor in camera
         * scroll, layer scale or layer position.
         *
         * @name Phaser.Tilemaps.Tile#pixelY
         * @type {number}
         * @since 3.0.0
         */this.pixelY=0,this.updatePixelXY(),/**
         * Tile specific properties. These usually come from Tiled.
         *
         * @name Phaser.Tilemaps.Tile#properties
         * @type {any}
         * @since 3.0.0
         */this.properties={},/**
         * The rotation angle of this tile.
         *
         * @name Phaser.Tilemaps.Tile#rotation
         * @type {number}
         * @since 3.0.0
         */this.rotation=0,/**
         * Whether the tile should collide with any object on the left side.
         *
         * @name Phaser.Tilemaps.Tile#collideLeft
         * @type {boolean}
         * @since 3.0.0
         */this.collideLeft=!1,/**
         * Whether the tile should collide with any object on the right side.
         *
         * @name Phaser.Tilemaps.Tile#collideRight
         * @type {boolean}
         * @since 3.0.0
         */this.collideRight=!1,/**
         * Whether the tile should collide with any object on the top side.
         *
         * @name Phaser.Tilemaps.Tile#collideUp
         * @type {boolean}
         * @since 3.0.0
         */this.collideUp=!1,/**
         * Whether the tile should collide with any object on the bottom side.
         *
         * @name Phaser.Tilemaps.Tile#collideDown
         * @type {boolean}
         * @since 3.0.0
         */this.collideDown=!1,/**
         * Whether the tile's left edge is interesting for collisions.
         *
         * @name Phaser.Tilemaps.Tile#faceLeft
         * @type {boolean}
         * @since 3.0.0
         */this.faceLeft=!1,/**
         * Whether the tile's right edge is interesting for collisions.
         *
         * @name Phaser.Tilemaps.Tile#faceRight
         * @type {boolean}
         * @since 3.0.0
         */this.faceRight=!1,/**
         * Whether the tile's top edge is interesting for collisions.
         *
         * @name Phaser.Tilemaps.Tile#faceTop
         * @type {boolean}
         * @since 3.0.0
         */this.faceTop=!1,/**
         * Whether the tile's bottom edge is interesting for collisions.
         *
         * @name Phaser.Tilemaps.Tile#faceBottom
         * @type {boolean}
         * @since 3.0.0
         */this.faceBottom=!1,/**
         * Tile collision callback.
         *
         * @name Phaser.Tilemaps.Tile#collisionCallback
         * @type {function}
         * @since 3.0.0
         */this.collisionCallback=null,/**
         * The context in which the collision callback will be called.
         *
         * @name Phaser.Tilemaps.Tile#collisionCallbackContext
         * @type {object}
         * @since 3.0.0
         */this.collisionCallbackContext=this,/**
         * The tint to apply to this tile. Note: tint is currently a single color value instead of
         * the 4 corner tint component on other GameObjects.
         *
         * @name Phaser.Tilemaps.Tile#tint
         * @type {number}
         * @default
         * @since 3.0.0
         */this.tint=16777215,/**
         * An empty object where physics-engine specific information (e.g. bodies) may be stored.
         *
         * @name Phaser.Tilemaps.Tile#physics
         * @type {object}
         * @since 3.0.0
         */this.physics={}},/**
     * Check if the given x and y world coordinates are within this Tile. This does not factor in
     * camera scroll, layer scale or layer position.
     *
     * @method Phaser.Tilemaps.Tile#containsPoint
     * @since 3.0.0
     *
     * @param {number} x - The x coordinate to test.
     * @param {number} y - The y coordinate to test.
     *
     * @return {boolean} True if the coordinates are within this Tile, otherwise false.
     */containsPoint:function(t,e){return!(t<this.pixelX||e<this.pixelY||t>this.right||e>this.bottom)},/**
     * Copies the tile data & properties from the given tile to this tile. This copies everything
     * except for position and interesting faces.
     *
     * @method Phaser.Tilemaps.Tile#copy
     * @since 3.0.0
     *
     * @param {Phaser.Tilemaps.Tile} tile - The tile to copy from.
     *
     * @return {Phaser.Tilemaps.Tile} This Tile object.
     */copy:function(t){return this.index=t.index,this.alpha=t.alpha,this.properties=t.properties,this.visible=t.visible,this.setFlip(t.flipX,t.flipY),this.tint=t.tint,this.rotation=t.rotation,this.collideUp=t.collideUp,this.collideDown=t.collideDown,this.collideLeft=t.collideLeft,this.collideRight=t.collideRight,this.collisionCallback=t.collisionCallback,this.collisionCallbackContext=t.collisionCallbackContext,this},/**
     * The collision group for this Tile, defined within the Tileset. This returns a reference to
     * the collision group stored within the Tileset, so any modification of the returned object
     * will impact all tiles that have the same index as this tile.
     *
     * @method Phaser.Tilemaps.Tile#getCollisionGroup
     * @since 3.0.0
     *
     * @return {?object} tileset
     */getCollisionGroup:function(){return this.tileset?this.tileset.getTileCollisionGroup(this.index):null},/**
     * The tile data for this Tile, defined within the Tileset. This typically contains Tiled
     * collision data, tile animations and terrain information. This returns a reference to the tile
     * data stored within the Tileset, so any modification of the returned object will impact all
     * tiles that have the same index as this tile.
     *
     * @method Phaser.Tilemaps.Tile#getTileData
     * @since 3.0.0
     *
     * @return {?object} tileset
     */getTileData:function(){return this.tileset?this.tileset.getTileData(this.index):null},/**
     * Gets the world X position of the left side of the tile, factoring in the layers position,
     * scale and scroll.
     *
     * @method Phaser.Tilemaps.Tile#getLeft
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.
     *
     * @return {number}
     */getLeft:function(t){var e=this.tilemapLayer;return e?e.tileToWorldX(this.x,t):this.x*this.baseWidth},/**
     * Gets the world X position of the right side of the tile, factoring in the layer's position,
     * scale and scroll.
     *
     * @method Phaser.Tilemaps.Tile#getRight
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.
     *
     * @return {number}
     */getRight:function(t){var e=this.tilemapLayer;return e?this.getLeft(t)+this.width*e.scaleX:this.getLeft(t)+this.width},/**
     * Gets the world Y position of the top side of the tile, factoring in the layer's position,
     * scale and scroll.
     *
     * @method Phaser.Tilemaps.Tile#getTop
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.
     *
     * @return {number}
     */getTop:function(t){var e=this.tilemapLayer;// Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile in grid
// units is the bottom left, so the y coordinate needs to be adjusted by the difference
// between the base size and this tile's size.
return e?e.tileToWorldY(this.y,t)-(this.height-this.baseHeight)*e.scaleY:this.y*this.baseHeight-(this.height-this.baseHeight)},/**
     * Gets the world Y position of the bottom side of the tile, factoring in the layer's position,
     * scale and scroll.

     * @method Phaser.Tilemaps.Tile#getBottom
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.
     *
     * @return {number}
     */getBottom:function(t){var e=this.tilemapLayer;return e?this.getTop(t)+this.height*e.scaleY:this.getTop(t)+this.height},/**
     * Gets the world rectangle bounding box for the tile, factoring in the layers position,
     * scale and scroll.
     *
     * @method Phaser.Tilemaps.Tile#getBounds
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.
     * @param {Phaser.Geom.Rectangle} [output] - Optional Rectangle object to store the results in.
     *
     * @return {(Phaser.Geom.Rectangle|object)}
     */getBounds:function(t,e){return void 0===e&&(e=new r),e.x=this.getLeft(),e.y=this.getTop(),e.width=this.getRight()-e.x,e.height=this.getBottom()-e.y,e},/**
     * Gets the world X position of the center of the tile, factoring in the layer's position,
     * scale and scroll.
     *
     * @method Phaser.Tilemaps.Tile#getCenterX
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.
     *
     * @return {number}
     */getCenterX:function(t){return(this.getLeft(t)+this.getRight(t))/2},/**
     * Gets the world Y position of the center of the tile, factoring in the layer's position,
     * scale and scroll.
     *
     * @method Phaser.Tilemaps.Tile#getCenterY
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.
     *
     * @return {number}
     */getCenterY:function(t){return(this.getTop(t)+this.getBottom(t))/2},/**
     * Clean up memory.
     *
     * @method Phaser.Tilemaps.Tile#destroy
     * @since 3.0.0
     */destroy:function(){this.collisionCallback=void 0,this.collisionCallbackContext=void 0,this.properties=void 0},/**
     * Check for intersection with this tile. This does not factor in camera scroll, layer scale or
     * layer position.
     *
     * @method Phaser.Tilemaps.Tile#intersects
     * @since 3.0.0
     *
     * @param {number} x - The x axis in pixels.
     * @param {number} y - The y axis in pixels.
     * @param {number} right - The right point.
     * @param {number} bottom - The bottom point.
     *
     * @return {boolean}
     */intersects:function(t,e,i,n){return!(i<=this.pixelX||n<=this.pixelY||t>=this.right||e>=this.bottom)},/**
     * Checks if the tile is interesting.
     *
     * @method Phaser.Tilemaps.Tile#isInteresting
     * @since 3.0.0
     *
     * @param {boolean} collides - If true, will consider the tile interesting if it collides on any side.
     * @param {boolean} faces - If true, will consider the tile interesting if it has an interesting face.
     *
     * @return {boolean} True if the Tile is interesting, otherwise false.
     */isInteresting:function(t,e){return t&&e?this.canCollide||this.hasInterestingFace:t?this.collides:!!e&&this.hasInterestingFace},/**
     * Reset collision status flags.
     *
     * @method Phaser.Tilemaps.Tile#resetCollision
     * @since 3.0.0
     *
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces for this tile and its neighbors.
     *
     * @return {Phaser.Tilemaps.Tile} This Tile object.
     */resetCollision:function(t){return void 0===t&&(t=!0),this.collideLeft=!1,this.collideRight=!1,this.collideUp=!1,this.collideDown=!1,this.faceTop=!1,this.faceBottom=!1,this.faceLeft=!1,this.faceRight=!1,t&&this.tilemapLayer&&this.tilemapLayer.calculateFacesAt(this.x,this.y),this},/**
     * Reset faces.
     *
     * @method Phaser.Tilemaps.Tile#resetFaces
     * @since 3.0.0
     *
     * @return {Phaser.Tilemaps.Tile} This Tile object.
     */resetFaces:function(){return this.faceTop=!1,this.faceBottom=!1,this.faceLeft=!1,this.faceRight=!1,this},/**
     * Sets the collision flags for each side of this tile and updates the interesting faces list.
     *
     * @method Phaser.Tilemaps.Tile#setCollision
     * @since 3.0.0
     *
     * @param {boolean} left - Indicating collide with any object on the left.
     * @param {boolean} [right] - Indicating collide with any object on the right.
     * @param {boolean} [up] - Indicating collide with any object on the top.
     * @param {boolean} [down] - Indicating collide with any object on the bottom.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces
     * for this tile and its neighbors.
     *
     * @return {Phaser.Tilemaps.Tile} This Tile object.
     */setCollision:function(t,e,i,n,s){return void 0===e&&(e=t),void 0===i&&(i=t),void 0===n&&(n=t),void 0===s&&(s=!0),this.collideLeft=t,this.collideRight=e,this.collideUp=i,this.collideDown=n,this.faceLeft=t,this.faceRight=e,this.faceTop=i,this.faceBottom=n,s&&this.tilemapLayer&&this.tilemapLayer.calculateFacesAt(this.x,this.y),this},/**
     * Set a callback to be called when this tile is hit by an object. The callback must true for
     * collision processing to take place.
     *
     * @method Phaser.Tilemaps.Tile#setCollisionCallback
     * @since 3.0.0
     *
     * @param {function} callback - Callback function.
     * @param {object} context - Callback will be called within this context.
     *
     * @return {Phaser.Tilemaps.Tile} This Tile object.
     */setCollisionCallback:function(t,e){return null===t?(this.collisionCallback=void 0,this.collisionCallbackContext=void 0):(this.collisionCallback=t,this.collisionCallbackContext=e),this},/**
     * Sets the size of the tile and updates its pixelX and pixelY.
     *
     * @method Phaser.Tilemaps.Tile#setSize
     * @since 3.0.0
     *
     * @param {integer} tileWidth - The width of the tile in pixels.
     * @param {integer} tileHeight - The height of the tile in pixels.
     * @param {integer} baseWidth - The base width a tile in the map (in pixels).
     * @param {integer} baseHeight - The base height of the tile in pixels (in pixels).
     *
     * @return {Phaser.Tilemaps.Tile} This Tile object.
     */setSize:function(t,e,i,n){return void 0!==t&&(this.width=t),void 0!==e&&(this.height=e),void 0!==i&&(this.baseWidth=i),void 0!==n&&(this.baseHeight=n),this.updatePixelXY(),this},/**
     * Used internally. Updates the tile's world XY position based on the current tile size.
     *
     * @method Phaser.Tilemaps.Tile#updatePixelXY
     * @since 3.0.0
     *
     * @return {Phaser.Tilemaps.Tile} This Tile object.
     */updatePixelXY:function(){// this.pixelY = this.y * this.baseHeight - (this.height - this.baseHeight);
return(// Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile is the
// bottom left, while the Phaser renderer assumes the origin is the top left. The y
// coordinate needs to be adjusted by the difference.
this.pixelX=this.x*this.baseWidth,this.pixelY=this.y*this.baseHeight,this)},/**
     * True if this tile can collide on any of its faces or has a collision callback set.
     *
     * @name Phaser.Tilemaps.Tile#canCollide
     * @type {boolean}
     * @readonly
     * @since 3.0.0
     */canCollide:{get:function(){return this.collideLeft||this.collideRight||this.collideUp||this.collideDown||this.collisionCallback}},/**
     * True if this tile can collide on any of its faces.
     *
     * @name Phaser.Tilemaps.Tile#collides
     * @type {boolean}
     * @readonly
     * @since 3.0.0
     */collides:{get:function(){return this.collideLeft||this.collideRight||this.collideUp||this.collideDown}},/**
     * True if this tile has any interesting faces.
     *
     * @name Phaser.Tilemaps.Tile#hasInterestingFace
     * @type {boolean}
     * @readonly
     * @since 3.0.0
     */hasInterestingFace:{get:function(){return this.faceTop||this.faceBottom||this.faceLeft||this.faceRight}},/**
     * The tileset that contains this Tile. This is null if accessed from a LayerData instance
     * before the tile is placed in a StaticTilemapLayer or DynamicTilemapLayer, or if the tile has
     * an index that doesn't correspond to any of the map's tilesets.
     *
     * @name Phaser.Tilemaps.Tile#tileset
     * @type {?Phaser.Tilemaps.Tileset}
     * @readonly
     * @since 3.0.0
     */tileset:{get:function(){var t=this.layer.tilemapLayer;if(t){var e=t.gidMap[this.index];if(e)return e}return null}},/**
     * The tilemap layer that contains this Tile. This will only return null if accessed from a
     * LayerData instance before the tile is placed within a StaticTilemapLayer or
     * DynamicTilemapLayer.
     *
     * @name Phaser.Tilemaps.Tile#tilemapLayer
     * @type {?Phaser.Tilemaps.StaticTilemapLayer|Phaser.Tilemaps.DynamicTilemapLayer}
     * @readonly
     * @since 3.0.0
     */tilemapLayer:{get:function(){return this.layer.tilemapLayer}},/**
     * The tilemap that contains this Tile. This will only return null if accessed from a LayerData
     * instance before the tile is placed within a StaticTilemapLayer or DynamicTilemapLayer.
     *
     * @name Phaser.Tilemaps.Tile#tilemap
     * @type {?Phaser.Tilemaps.Tilemap}
     * @readonly
     * @since 3.0.0
     */tilemap:{get:function(){var t=this.tilemapLayer;return t?t.tilemap:null}}});t.exports=o}),r("9toet",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("64x6H"),n=s("jJuPw"),r=s("jWCaM");t.exports=function(t,e,s,o,a,h){return i(t,n(e,!0,a,h),r(s,!0,a,h),o,h)}}),r("jVpX9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("inaFS"),n=s("64x6H");t.exports=function(t,e,s,r,o){if(!Array.isArray(t))return null;void 0===r&&(r=!0),Array.isArray(t[0])||(t=[t]);for(var a=t.length,h=t[0].length,l=0;l<a;l++)for(var u=0;u<h;u++)n(t[l][u],e+u,s+l,!1,o);r&&i(e-1,s-1,h+2,a+2,o)}}),r("4VMg3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2"),n=s("5H1qm");t.exports=function(t,e,s,r,o,a){var h,l=i(t,e,s,r,null,a);// If no indices are given, then find all the unique indexes within the specified region
if(void 0===o)for(h=0,o=[];h<l.length;h++)-1===o.indexOf(l[h].index)&&o.push(l[h].index);for(h=0;h<l.length;h++)l[h].index=n(o)}}),r("fX9li",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("1uZwx"),n=s("3UG6O"),r=s("9gNi2");t.exports=function(t,e,s,o,a){if(void 0===s&&(s=!1),void 0===o&&(o=!0),!n(t,e,a))return null;var h=a.data[e][t];return h?(a.data[e][t]=s?null:new i(a,-1,t,e,h.width,h.height),o&&h&&h.collides&&r(t,e,a),h):null}}),r("ibjim",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("fX9li"),n=s("jJuPw"),r=s("jWCaM");t.exports=function(t,e,s,o,a,h){return i(n(t,!0,a,h),r(e,!0,a,h),s,o,h)}}),r("4YYIg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2"),n=s("dqWRJ"),r=new n(105,210,231,150),o=new n(243,134,48,200),a=new n(40,39,37,150);t.exports=function(t,e,n){void 0===e&&(e={});// Default colors without needlessly creating Color objects
var s=void 0!==e.tileColor?e.tileColor:r,h=void 0!==e.collidingTileColor?e.collidingTileColor:o,l=void 0!==e.faceColor?e.faceColor:a,u=i(0,0,n.width,n.height,null,n);t.translateCanvas(n.tilemapLayer.x,n.tilemapLayer.y),t.scaleCanvas(n.tilemapLayer.scaleX,n.tilemapLayer.scaleY);for(var c=0;c<u.length;c++){var d=u[c],f=d.width,p=d.height,g=d.pixelX,v=d.pixelY,m=d.collides?h:s;null!==m&&(t.fillStyle(m.color,m.alpha/255),t.fillRect(g,v,f,p)),// Inset the face line to prevent neighboring tile's lines from overlapping
g+=1,v+=1,f-=2,p-=2,null!==l&&(t.lineStyle(1,l.color,l.alpha/255),d.faceTop&&t.lineBetween(g,v,g+f,v),d.faceRight&&t.lineBetween(g+f,v,g+f,v+p),d.faceBottom&&t.lineBetween(g,v+p,g+f,v+p),d.faceLeft&&t.lineBetween(g,v,g,v+p))}}}),r("jAcLl",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6Hyw7"),n=s("inaFS"),r=s("7PKfY");t.exports=function(t,e,s,o,a){void 0===e&&(e=!0),void 0===s&&(s=!0),Array.isArray(t)||(t=[t]),void 0===a&&(a=!0);// Update the array of colliding indexes
for(var h=0;h<t.length;h++)r(t[h],e,o);// Update the tiles
if(a)for(var l=0;l<o.height;l++)for(var u=0;u<o.width;u++){var c=o.data[l][u];c&&-1!==t.indexOf(c.index)&&i(c,e)}s&&n(0,0,o.width,o.height,o)}}),r("7PKfY",function(t,e){t.exports=function(t,e,i){var n=i.collideIndexes.indexOf(t);e&&-1===n?i.collideIndexes.push(t):e||-1===n||i.collideIndexes.splice(n,1)}}),r("gpdMb",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6Hyw7"),n=s("inaFS"),r=s("7PKfY");t.exports=function(t,e,s,o,a,h){if(void 0===s&&(s=!0),void 0===o&&(o=!0),void 0===h&&(h=!0),!(t>e)){// Update the array of colliding indexes
for(var l=t;l<=e;l++)r(l,s,a);// Update the tiles
if(h)for(var u=0;u<a.height;u++)for(var c=0;c<a.width;c++){var d=a.data[u][c];d&&d.index>=t&&d.index<=e&&i(d,s)}o&&n(0,0,a.width,a.height,a)}}}),r("8C01B",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6Hyw7"),n=s("inaFS"),r=s("7PKfY");t.exports=function(t,e,s,o){void 0===e&&(e=!0),void 0===s&&(s=!0),Array.isArray(t)||(t=[t]);// Note: this only updates layer.collideIndexes for tile indexes found currently in the layer
for(var a=0;a<o.height;a++)for(var h=0;h<o.width;h++){var l=o.data[a][h];l&&-1===t.indexOf(l.index)&&(i(l,e),r(l.index,e,o))}s&&n(0,0,o.width,o.height,o)}}),r("i03zR",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6Hyw7"),n=s("inaFS"),r=s("evjs6");t.exports=function(t,e,s,o){void 0===e&&(e=!0),void 0===s&&(s=!0);for(var a=0;a<o.height;a++)for(var h=0;h<o.width;h++){var l=o.data[a][h];if(l){for(var u in t)if(r(l.properties,u)){var c=t[u];Array.isArray(c)||(c=[c]);for(var d=0;d<c.length;d++)l.properties[u]===c[d]&&i(l,e)}}}s&&n(0,0,o.width,o.height,o)}}),r("8oy5E",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6Hyw7"),n=s("inaFS");t.exports=function(t,e,s){void 0===t&&(t=!0),void 0===e&&(e=!0);for(var r=0;r<s.height;r++)for(var o=0;o<s.width;o++){var a=s.data[r][o];if(a){var h=a.getCollisionGroup();// It's possible in Tiled to have a collision group without any shapes, e.g. create a
// shape and then delete the shape.
h&&h.objects&&h.objects.length>0&&i(a,t)}}e&&n(0,0,s.width,s.height,s)}}),r("5p4Io",function(t,e){t.exports=function(t,e,i,n){if("number"==typeof t)n.callbacks[t]=null!==e?{callback:e,callbackContext:i}:void 0;else for(var s=0,r=t.length;s<r;s++)n.callbacks[t[s]]=null!==e?{callback:e,callbackContext:i}:void 0}}),r("4wqRe",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2");t.exports=function(t,e,n,s,r,o,a){for(var h=i(t,e,n,s,null,a),l=0;l<h.length;l++)h[l].setCollisionCallback(r,o)}}),r("bdoRX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2"),n=s("Na5BX");t.exports=function(t,e,s,r,o){var a=i(t,e,s,r,null,o),h=a.map(function(t){return t.index});n(h);for(var l=0;l<a.length;l++)a[l].index=h[l]}}),r("N9ezU",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2");t.exports=function(t,e,n,s,r,o,a){for(var h=i(n,s,r,o,null,a),l=0;l<h.length;l++)h[l]&&(h[l].index===t?h[l].index=e:h[l].index===e&&(h[l].index=t))}}),r("5oCuI",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("DeoMl"),n=s("3t1Uc"),r=s("7SBSk");t.exports=function(t,e,s,o,a){return void 0===s&&(s=new r(0,0)),s.x=i(t,o,a),s.y=n(e,o,a),s}}),r("gv9XM",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eJlg2");t.exports=function(t,e,n,s,r,o){if(void 0!==r){var a,h=i(t,e,n,s,null,o),l=0;for(a=0;a<r.length;a++)l+=r[a].weight;if(!(l<=0))for(a=0;a<h.length;a++){for(var u=Math.random()*l,c=0,d=-1,f=0;f<r.length;f++)if(u<=(c+=r[f].weight)){var p=r[f].index;d=Array.isArray(p)?p[Math.floor(Math.random()*p.length)]:p;break}h[a].index=d}}}}),r("afyKE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jJuPw"),n=s("jWCaM"),r=s("7SBSk");t.exports=function(t,e,s,o,a,h){return void 0===o&&(o=new r(0,0)),o.x=i(t,s,a,h),o.y=n(e,s,a,h),o}}),r("2mw6B",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Tilemaps.Parsers
 */t.exports={Parse:s("idVMS"),Parse2DArray:s("cSbR8"),ParseCSV:s("fK4S3"),Impact:s("9P34u"),Tiled:s("76DPJ")}}),r("idVMS",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("au4z0"),n=s("cSbR8"),r=s("fK4S3"),o=s("8YPQy"),a=s("7A8Vq");t.exports=function(t,e,s,h,l,u){var c;switch(e){case i.ARRAY_2D:c=n(t,s,h,l,u);break;case i.CSV:c=r(t,s,h,l,u);break;case i.TILED_JSON:c=o(t,s,u);break;case i.WELTMEISTER:c=a(t,s,u);break;default:console.warn("Unrecognized tilemap data format: "+e),c=null}return c}}),r("cSbR8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("au4z0"),n=s("5wtVg"),r=s("5Jvnl"),o=s("1uZwx");t.exports=function(t,e,s,a,h){for(var l=new n({tileWidth:s,tileHeight:a}),u=new r({name:t,tileWidth:s,tileHeight:a,format:i.ARRAY_2D,layers:[l]}),c=[],d=e.length,f=0,p=0;p<e.length;p++){c[p]=[];for(var g=e[p],v=0;v<g.length;v++){var m=parseInt(g[v],10);isNaN(m)||-1===m?c[p][v]=h?null:new o(l,-1,v,p,s,a):c[p][v]=new o(l,m,v,p,s,a)}0===f&&(f=g.length)}return u.width=l.width=f,u.height=l.height=d,u.widthInPixels=l.widthInPixels=f*s,u.heightInPixels=l.heightInPixels=d*a,l.data=c,u}}),r("5wtVg",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7BSWl"),r=new i({initialize:function(t){void 0===t&&(t={}),/**
         * The name of the layer, if specified in Tiled.
         *
         * @name Phaser.Tilemaps.LayerData#name
         * @type {string}
         * @since 3.0.0
         */this.name=n(t,"name","layer"),/**
         * The x offset of where to draw from the top left.
         *
         * @name Phaser.Tilemaps.LayerData#x
         * @type {number}
         * @since 3.0.0
         */this.x=n(t,"x",0),/**
         * The y offset of where to draw from the top left.
         *
         * @name Phaser.Tilemaps.LayerData#y
         * @type {number}
         * @since 3.0.0
         */this.y=n(t,"y",0),/**
         * The width of the layer in tiles.
         *
         * @name Phaser.Tilemaps.LayerData#width
         * @type {number}
         * @since 3.0.0
         */this.width=n(t,"width",0),/**
         * The height of the layer in tiles.
         *
         * @name Phaser.Tilemaps.LayerData#height
         * @type {number}
         * @since 3.0.0
         */this.height=n(t,"height",0),/**
         * The pixel width of the tiles.
         *
         * @name Phaser.Tilemaps.LayerData#tileWidth
         * @type {number}
         * @since 3.0.0
         */this.tileWidth=n(t,"tileWidth",0),/**
         * The pixel height of the tiles.
         *
         * @name Phaser.Tilemaps.LayerData#tileHeight
         * @type {number}
         * @since 3.0.0
         */this.tileHeight=n(t,"tileHeight",0),/**
         * The base tile width.
         *
         * @name Phaser.Tilemaps.LayerData#baseTileWidth
         * @type {number}
         * @since 3.0.0
         */this.baseTileWidth=n(t,"baseTileWidth",this.tileWidth),/**
         * The base tile height.
         *
         * @name Phaser.Tilemaps.LayerData#baseTileHeight
         * @type {number}
         * @since 3.0.0
         */this.baseTileHeight=n(t,"baseTileHeight",this.tileHeight),/**
         * The width in pixels of the entire layer.
         *
         * @name Phaser.Tilemaps.LayerData#widthInPixels
         * @type {number}
         * @since 3.0.0
         */this.widthInPixels=n(t,"widthInPixels",this.width*this.baseTileWidth),/**
         * The height in pixels of the entire layer.
         *
         * @name Phaser.Tilemaps.LayerData#heightInPixels
         * @type {number}
         * @since 3.0.0
         */this.heightInPixels=n(t,"heightInPixels",this.height*this.baseTileHeight),/**
         * The alpha value of the layer.
         *
         * @name Phaser.Tilemaps.LayerData#alpha
         * @type {number}
         * @since 3.0.0
         */this.alpha=n(t,"alpha",1),/**
         * Is the layer visible or not?
         *
         * @name Phaser.Tilemaps.LayerData#visible
         * @type {boolean}
         * @since 3.0.0
         */this.visible=n(t,"visible",!0),/**
         * Layer specific properties (can be specified in Tiled)
         *
         * @name Phaser.Tilemaps.LayerData#properties
         * @type {object[]}
         * @since 3.0.0
         */this.properties=n(t,"properties",[]),/**
         * Tile ID index map.
         *
         * @name Phaser.Tilemaps.LayerData#indexes
         * @type {array}
         * @since 3.0.0
         */this.indexes=n(t,"indexes",[]),/**
         * Tile Collision ID index map.
         *
         * @name Phaser.Tilemaps.LayerData#collideIndexes
         * @type {array}
         * @since 3.0.0
         */this.collideIndexes=n(t,"collideIndexes",[]),/**
         * An array of callbacks.
         *
         * @name Phaser.Tilemaps.LayerData#callbacks
         * @type {array}
         * @since 3.0.0
         */this.callbacks=n(t,"callbacks",[]),/**
         * An array of physics bodies.
         *
         * @name Phaser.Tilemaps.LayerData#bodies
         * @type {array}
         * @since 3.0.0
         */this.bodies=n(t,"bodies",[]),/**
         * An array of the tile data indexes.
         *
         * @name Phaser.Tilemaps.LayerData#data
         * @type {Phaser.Tilemaps.Tile[][]}
         * @since 3.0.0
         */this.data=n(t,"data",[]),/**
         * A reference to the Tilemap layer that owns this data.
         *
         * @name Phaser.Tilemaps.LayerData#tilemapLayer
         * @type {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)}
         * @since 3.0.0
         */this.tilemapLayer=n(t,"tilemapLayer",null)}});t.exports=r}),r("5Jvnl",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7BSWl"),r=new i({initialize:function(t){void 0===t&&(t={}),/**
         * The key in the Phaser cache that corresponds to the loaded tilemap data.
         * 
         * @name Phaser.Tilemaps.MapData#name
         * @type {string}
         * @since 3.0.0
         */this.name=n(t,"name","map"),/**
         * The width of the entire tilemap.
         * 
         * @name Phaser.Tilemaps.MapData#width
         * @type {number}
         * @since 3.0.0
         */this.width=n(t,"width",0),/**
         * The height of the entire tilemap.
         * 
         * @name Phaser.Tilemaps.MapData#height
         * @type {number}
         * @since 3.0.0
         */this.height=n(t,"height",0),/**
         * If the map is infinite or not.
         *
         * @name Phaser.Tilemaps.MapData#infinite
         * @type {boolean}
         * @since 3.17.0
         */this.infinite=n(t,"infinite",!1),/**
         * The width of the tiles.
         * 
         * @name Phaser.Tilemaps.MapData#tileWidth
         * @type {number}
         * @since 3.0.0
         */this.tileWidth=n(t,"tileWidth",0),/**
         * The height of the tiles.
         * 
         * @name Phaser.Tilemaps.MapData#tileHeight
         * @type {number}
         * @since 3.0.0
         */this.tileHeight=n(t,"tileHeight",0),/**
         * The width in pixels of the entire tilemap.
         * 
         * @name Phaser.Tilemaps.MapData#widthInPixels
         * @type {number}
         * @since 3.0.0
         */this.widthInPixels=n(t,"widthInPixels",this.width*this.tileWidth),/**
         * The height in pixels of the entire tilemap.
         * 
         * @name Phaser.Tilemaps.MapData#heightInPixels
         * @type {number}
         * @since 3.0.0
         */this.heightInPixels=n(t,"heightInPixels",this.height*this.tileHeight),/**
         * The format of the map data.
         * 
         * @name Phaser.Tilemaps.MapData#format
         * @type {integer}
         * @since 3.0.0
         */this.format=n(t,"format",null),/**
         * The orientation of the map data (i.e. orthogonal, isometric, hexagonal), default 'orthogonal'.
         * 
         * @name Phaser.Tilemaps.MapData#orientation
         * @type {string}
         * @since 3.0.0
         */this.orientation=n(t,"orientation","orthogonal"),/**
         * Determines the draw order of tilemap. Default is right-down
         * 
         * 0, or 'right-down'
         * 1, or 'left-down'
         * 2, or 'right-up'
         * 3, or 'left-up'
         * 
         * @name Phaser.Tilemaps.MapData#renderOrder
         * @type {string}
         * @since 3.12.0
         */this.renderOrder=n(t,"renderOrder","right-down"),/**
         * The version of the map data (as specified in Tiled).
         * 
         * @name Phaser.Tilemaps.MapData#version
         * @type {string}
         * @since 3.0.0
         */this.version=n(t,"version","1"),/**
         * Map specific properties (can be specified in Tiled)
         * 
         * @name Phaser.Tilemaps.MapData#properties
         * @type {object}
         * @since 3.0.0
         */this.properties=n(t,"properties",{}),/**
         * An array with all the layers configured to the MapData.
         * 
         * @name Phaser.Tilemaps.MapData#layers
         * @type {(Phaser.Tilemaps.LayerData[]|Phaser.Tilemaps.ObjectLayer)}
         * @since 3.0.0
         */this.layers=n(t,"layers",[]),/**
         * An array of Tiled Image Layers.
         * 
         * @name Phaser.Tilemaps.MapData#images
         * @type {array}
         * @since 3.0.0
         */this.images=n(t,"images",[]),/**
         * An object of Tiled Object Layers.
         * 
         * @name Phaser.Tilemaps.MapData#objects
         * @type {object}
         * @since 3.0.0
         */this.objects=n(t,"objects",{}),/**
          * An object of collision data. Must be created as physics object or will return undefined.
         * 
         * @name Phaser.Tilemaps.MapData#collision
         * @type {object}
         * @since 3.0.0
         */this.collision=n(t,"collision",{}),/**
         * An array of Tilesets.
         * 
         * @name Phaser.Tilemaps.MapData#tilesets
         * @type {Phaser.Tilemaps.Tileset[]}
         * @since 3.0.0
         */this.tilesets=n(t,"tilesets",[]),/**
         * The collection of images the map uses(specified in Tiled)
         * 
         * @name Phaser.Tilemaps.MapData#imageCollections
         * @type {array}
         * @since 3.0.0
         */this.imageCollections=n(t,"imageCollections",[]),/**
         * An array of tile instances.
         * 
         * @name Phaser.Tilemaps.MapData#tiles
         * @type {array}
         * @since 3.0.0
         */this.tiles=n(t,"tiles",[])}});t.exports=r}),r("fK4S3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("au4z0"),n=s("cSbR8");t.exports=function(t,e,s,r,o){var a=n(t,e.trim().split("\n").map(function(t){return t.split(",")}),s,r,o);return a.format=i.CSV,a}}),r("8YPQy",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("au4z0"),n=s("5Jvnl"),r=s("jldtL"),o=s("2NaOj"),a=s("dw6Ty"),h=s("fUwNw"),l=s("aqDox"),u=s("fNydI");t.exports=function(t,e,s){if("orthogonal"!==e.orientation)return console.warn("Only orthogonal map types are supported in this version of Phaser"),null;//  Map data will consist of: layers, objects, images, tilesets, sizes
var c=new n({width:e.width,height:e.height,name:t,tileWidth:e.tilewidth,tileHeight:e.tileheight,orientation:e.orientation,format:i.TILED_JSON,version:e.version,properties:e.properties,renderOrder:e.renderorder,infinite:e.infinite});c.layers=r(e,s),c.images=o(e);var d=a(e);return c.tilesets=d.tilesets,c.imageCollections=d.imageCollections,c.objects=h(e),c.tiles=l(c),u(c),c}}),r("jldtL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jPMWH"),n=s("7BSWl"),r=s("5wtVg"),o=s("d0ux1"),a=s("1uZwx"),h=s("cedNs");t.exports=function(t,e){for(var s=n(t,"infinite",!1),l=[],u=[],c=h(t);c.i<c.layers.length||u.length>0;){if(c.i>=c.layers.length){// Ensure recursion stack is not empty first
if(u.length<1){console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");break}// Return to previous recursive state
c=u.pop();continue}var d,f,p,g,v=c.layers[c.i];if(c.i++,"tilelayer"!==v.type){if("group"===v.type){// Compute next state inherited from group
var m=h(t,v,c);// Preserve current state before recursing
u.push(c),c=m}continue}// Base64 decode data if necessary. NOTE: uncompressed base64 only.
if(v.compression){console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '"+v.name+"'");continue}if(v.encoding&&"base64"===v.encoding){// Chunks for an infinite map
if(v.chunks)for(var y=0;y<v.chunks.length;y++)v.chunks[y].data=i(v.chunks[y].data);v.data&&(v.data=i(v.data)),delete v.encoding}var x=[],w=0;if(s){var T=n(v,"startx",0)+v.x,b=n(v,"starty",0)+v.y;d=new r({name:c.name+v.name,x:c.x+n(v,"offsetx",0)+T*t.tilewidth,y:c.y+n(v,"offsety",0)+b*t.tileheight,width:v.width,height:v.height,tileWidth:t.tilewidth,tileHeight:t.tileheight,alpha:c.opacity*v.opacity,visible:c.visible&&v.visible,properties:n(v,"properties",[])});for(var S=0;S<v.height;S++){x.push([null]);for(var A=0;A<v.width;A++)x[S][A]=null}for(S=0,F=v.chunks.length;S<F;S++)for(var E=v.chunks[S],_=E.x-T,C=E.y-b,M=0,P=0,O=E.data.length;P<O;P++){var R=w+_,L=M+C;(f=o(E.data[P])).gid>0?(// Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal
// propeties into flipX, flipY and rotation
(p=new a(d,f.gid,R,L,t.tilewidth,t.tileheight)).rotation=f.rotation,p.flipX=f.flipped,x[L][R]=p):(g=e?null:new a(d,-1,R,L,t.tilewidth,t.tileheight),x[L][R]=g),++w===E.width&&(M++,w=0)}}else{d=new r({name:c.name+v.name,x:c.x+n(v,"offsetx",0)+v.x,y:c.y+n(v,"offsety",0)+v.y,width:v.width,height:v.height,tileWidth:t.tilewidth,tileHeight:t.tileheight,alpha:c.opacity*v.opacity,visible:c.visible&&v.visible,properties:n(v,"properties",[])});//  Loop through the data field in the JSON.
for(var k=[],D=0,F=v.data.length;D<F;D++)(f=o(v.data[D])).gid>0?(// Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal
// propeties into flipX, flipY and rotation
(p=new a(d,f.gid,w,x.length,t.tilewidth,t.tileheight)).rotation=f.rotation,p.flipX=f.flipped,k.push(p)):(g=e?null:new a(d,-1,w,x.length,t.tilewidth,t.tileheight),k.push(g)),++w===v.width&&(x.push(k),w=0,k=[])}d.data=x,l.push(d)}return l}}),r("jPMWH",function(t,e){t.exports=function(t){// Interpret binaryString as an array of bytes representing little-endian encoded uint32 values.
for(var e=window.atob(t),i=e.length,n=Array(i/4),s=0;s<i;s+=4)n[s/4]=(e.charCodeAt(s)|e.charCodeAt(s+1)<<8|e.charCodeAt(s+2)<<16|e.charCodeAt(s+3)<<24)>>>0;return n}}),r("d0ux1",function(t,e){t.exports=function(t){var e=!!(2147483648&t),i=!!(1073741824&t),n=!!(536870912&t);t&=536870911;// Parse the flip flags into something Phaser can use
var s=0,r=!1;return e&&i&&n?(s=Math.PI/2,r=!0):e&&i&&!n?(s=Math.PI,r=!1):e&&!i&&n?(s=Math.PI/2,r=!1):!e||i||n?!e&&i&&n?(s=3*Math.PI/2,r=!1):e||!i||n?e||i||!n?e||i||n||(s=0,r=!1):(s=3*Math.PI/2,r=!0):(s=Math.PI,r=!0):(s=0,r=!0),{gid:t,flippedHorizontal:e,flippedVertical:i,flippedAntiDiagonal:n,rotation:s,flipped:r}}}),r("cedNs",function(t,e){/**
 * @author       Seth Berrier <berriers@uwstout.edu>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7BSWl");t.exports=function(t,e,n){if(!e)return{i:0,layers:t.layers,// Values inherited from parent group
name:"",opacity:1,visible:!0,x:0,y:0};// Compute group layer x, y
var s=e.x+i(e,"startx",0)*t.tilewidth+i(e,"offsetx",0),r=e.y+i(e,"starty",0)*t.tileheight+i(e,"offsety",0);// Compute next state inherited from group
return{i:0,layers:e.layers,name:n.name+e.name+"/",opacity:n.opacity*e.opacity,visible:n.visible&&e.visible,x:n.x+s,y:n.y+r}}}),r("2NaOj",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7BSWl"),n=s("cedNs");t.exports=function(t){for(var e=[],s=[],r=n(t);r.i<r.layers.length||s.length>0;){if(r.i>=r.layers.length){// Ensure recursion stack is not empty first
if(s.length<1){console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");break}// Return to previous recursive state
r=s.pop();continue}// Get current layer and advance iterator
var o=r.layers[r.i];if(r.i++,"imagelayer"!==o.type){if("group"===o.type){// Compute next state inherited from group
var a=n(t,o,r);// Preserve current state before recursing
s.push(r),r=a}continue}var h=i(o,"offsetx",0)+i(o,"startx",0),l=i(o,"offsety",0)+i(o,"starty",0);e.push({name:r.name+o.name,image:o.image,x:r.x+h+o.x,y:r.y+l+o.y,alpha:r.opacity*o.opacity,visible:r.visible&&o.visible,properties:i(o,"properties",{})})}return e}}),r("dw6Ty",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eZOmW"),n=s("65en1"),r=s("cKtBa");t.exports=function(t){for(var e,s=[],o=[],a=null,h=0;h<t.tilesets.length;h++){//  name, firstgid, width, height, margin, spacing, properties
var l=t.tilesets[h];if(l.source)console.warn("Phaser can't load external tilesets. Use the Embed Tileset button and then export the map again.");else if(l.image){var u=new i(l.name,l.firstgid,l.tilewidth,l.tileheight,l.margin,l.spacing);if(t.version>1){if(Array.isArray(l.tiles)){for(var c={},d={},f=0;f<l.tiles.length;f++){var p=l.tiles[f];//  Convert tileproperties
if(p.properties){var g={};p.properties.forEach(function(t){g[t.name]=t.value}),d[p.id]=g}//  Convert objectgroup
if(p.objectgroup&&(c[p.id]={objectgroup:p.objectgroup},p.objectgroup.objects)){var v=p.objectgroup.objects.map(function(t){return r(t)});c[p.id].objectgroup.objects=v}// Copy animation data
p.animation&&(c.hasOwnProperty(p.id)?c[p.id].animation=p.animation:c[p.id]={animation:p.animation})}u.tileData=c,u.tileProperties=d}}else // Object & terrain shapes stored per-tile in object with string indexes starting at "0"
if(l.tileproperties&&(u.tileProperties=l.tileproperties),l.tiles)// Parse the objects into Phaser format to match handling of other Tiled objects
for(e in u.tileData=l.tiles,u.tileData){var m=u.tileData[e].objectgroup;if(m&&m.objects){var y=m.objects.map(function(t){return r(t)});u.tileData[e].objectgroup.objects=y}}// For a normal sliced tileset the row/count/size information is computed when updated.
// This is done (again) after the image is set.
u.updateTileData(l.imagewidth,l.imageheight),s.push(u)}else{var x=new n(l.name,l.firstgid,l.tilewidth,l.tileheight,l.margin,l.spacing,l.properties);for(e in l.tiles){var w=l.tiles[e].image,T=l.firstgid+parseInt(e,10);x.addImage(T,w)}o.push(x)}a&&(a.lastgid=l.firstgid-1),a=l}return{tilesets:s,imageCollections:o}}}),r("eZOmW",function(t,e){/**
 * @classdesc
 * A Tileset is a combination of an image containing the tiles and a container for data about
 * each tile.
 *
 * @class Tileset
 * @memberof Phaser.Tilemaps
 * @constructor
 * @since 3.0.0
 *
 * @param {string} name - The name of the tileset in the map data.
 * @param {integer} firstgid - The first tile index this tileset contains.
 * @param {integer} [tileWidth=32] - Width of each tile (in pixels).
 * @param {integer} [tileHeight=32] - Height of each tile (in pixels).
 * @param {integer} [tileMargin=0] - The margin around all tiles in the sheet (in pixels).
 * @param {integer} [tileSpacing=0] - The spacing between each tile in the sheet (in pixels).
 * @param {object} [tileProperties={}] - Custom properties defined per tile in the Tileset.
 * These typically are custom properties created in Tiled when editing a tileset.
 * @param {object} [tileData={}] - Data stored per tile. These typically are created in Tiled
 * when editing a tileset, e.g. from Tiled's tile collision editor or terrain editor.
 */var i=new(s("jwj1g"))({initialize:function(t,e,i,n,s,r,o,a){(void 0===i||i<=0)&&(i=32),(void 0===n||n<=0)&&(n=32),void 0===s&&(s=0),void 0===r&&(r=0),void 0===o&&(o={}),void 0===a&&(a={}),/**
         * The name of the Tileset.
         *
         * @name Phaser.Tilemaps.Tileset#name
         * @type {string}
         * @since 3.0.0
         */this.name=t,/**
         * The starting index of the first tile index this Tileset contains.
         *
         * @name Phaser.Tilemaps.Tileset#firstgid
         * @type {integer}
         * @since 3.0.0
         */this.firstgid=e,/**
         * The width of each tile (in pixels). Use setTileSize to change.
         *
         * @name Phaser.Tilemaps.Tileset#tileWidth
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.tileWidth=i,/**
         * The height of each tile (in pixels). Use setTileSize to change.
         *
         * @name Phaser.Tilemaps.Tileset#tileHeight
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.tileHeight=n,/**
         * The margin around the tiles in the sheet (in pixels). Use `setSpacing` to change.
         *
         * @name Phaser.Tilemaps.Tileset#tileMargin
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.tileMargin=s,/**
         * The spacing between each the tile in the sheet (in pixels). Use `setSpacing` to change.
         *
         * @name Phaser.Tilemaps.Tileset#tileSpacing
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.tileSpacing=r,/**
         * Tileset-specific properties per tile that are typically defined in the Tiled editor in the
         * Tileset editor.
         *
         * @name Phaser.Tilemaps.Tileset#tileProperties
         * @type {object}
         * @since 3.0.0
         */this.tileProperties=o,/**
         * Tileset-specific data per tile that are typically defined in the Tiled editor, e.g. within
         * the Tileset collision editor. This is where collision objects and terrain are stored.
         *
         * @name Phaser.Tilemaps.Tileset#tileData
         * @type {object}
         * @since 3.0.0
         */this.tileData=a,/**
         * The cached image that contains the individual tiles. Use setImage to set.
         *
         * @name Phaser.Tilemaps.Tileset#image
         * @type {?Phaser.Textures.Texture}
         * @readonly
         * @since 3.0.0
         */this.image=null,/**
         * The gl texture used by the WebGL renderer.
         *
         * @name Phaser.Tilemaps.Tileset#glTexture
         * @type {?WebGLTexture}
         * @readonly
         * @since 3.11.0
         */this.glTexture=null,/**
         * The number of tile rows in the the tileset.
         *
         * @name Phaser.Tilemaps.Tileset#rows
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.rows=0,/**
         * The number of tile columns in the tileset.
         *
         * @name Phaser.Tilemaps.Tileset#columns
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.columns=0,/**
         * The total number of tiles in the tileset.
         *
         * @name Phaser.Tilemaps.Tileset#total
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.total=0,/**
         * The look-up table to specific tile image texture coordinates (UV in pixels). Each element
         * contains the coordinates for a tile in an object of the form {x, y}.
         *
         * @name Phaser.Tilemaps.Tileset#texCoordinates
         * @type {object[]}
         * @readonly
         * @since 3.0.0
        */this.texCoordinates=[]},/**
     * Get a tiles properties that are stored in the Tileset. Returns null if tile index is not
     * contained in this Tileset. This is typically defined in Tiled under the Tileset editor.
     *
     * @method Phaser.Tilemaps.Tileset#getTileProperties
     * @since 3.0.0
     *
     * @param {integer} tileIndex - The unique id of the tile across all tilesets in the map.
     *
     * @return {?(object|undefined)}
     */getTileProperties:function(t){return this.containsTileIndex(t)?this.tileProperties[t-this.firstgid]:null},/**
     * Get a tile's data that is stored in the Tileset. Returns null if tile index is not contained
     * in this Tileset. This is typically defined in Tiled and will contain both Tileset collision
     * info and terrain mapping.
     *
     * @method Phaser.Tilemaps.Tileset#getTileData
     * @since 3.0.0
     *
     * @param {integer} tileIndex - The unique id of the tile across all tilesets in the map.
     *
     * @return {?object|undefined}
     */getTileData:function(t){return this.containsTileIndex(t)?this.tileData[t-this.firstgid]:null},/**
     * Get a tile's collision group that is stored in the Tileset. Returns null if tile index is not
     * contained in this Tileset. This is typically defined within Tiled's tileset collision editor.
     *
     * @method Phaser.Tilemaps.Tileset#getTileCollisionGroup
     * @since 3.0.0
     *
     * @param {integer} tileIndex - The unique id of the tile across all tilesets in the map.
     *
     * @return {?object}
     */getTileCollisionGroup:function(t){var e=this.getTileData(t);return e&&e.objectgroup?e.objectgroup:null},/**
     * Returns true if and only if this Tileset contains the given tile index.
     *
     * @method Phaser.Tilemaps.Tileset#containsTileIndex
     * @since 3.0.0
     *
     * @param {integer} tileIndex - The unique id of the tile across all tilesets in the map.
     *
     * @return {boolean}
     */containsTileIndex:function(t){return t>=this.firstgid&&t<this.firstgid+this.total},/**
     * Returns the texture coordinates (UV in pixels) in the Tileset image for the given tile index.
     * Returns null if tile index is not contained in this Tileset.
     *
     * @method Phaser.Tilemaps.Tileset#getTileTextureCoordinates
     * @since 3.0.0
     *
     * @param {integer} tileIndex - The unique id of the tile across all tilesets in the map.
     *
     * @return {?object} Object in the form { x, y } representing the top-left UV coordinate
     * within the Tileset image.
     */getTileTextureCoordinates:function(t){return this.containsTileIndex(t)?this.texCoordinates[t-this.firstgid]:null},/**
     * Sets the image associated with this Tileset and updates the tile data (rows, columns, etc.).
     *
     * @method Phaser.Tilemaps.Tileset#setImage
     * @since 3.0.0
     *
     * @param {Phaser.Textures.Texture} texture - The image that contains the tiles.
     *
     * @return {Phaser.Tilemaps.Tileset} This Tileset object.
     */setImage:function(t){return this.image=t,this.glTexture=t.get().source.glTexture,this.updateTileData(this.image.source[0].width,this.image.source[0].height),this},/**
     * Sets the tile width & height and updates the tile data (rows, columns, etc.).
     *
     * @method Phaser.Tilemaps.Tileset#setTileSize
     * @since 3.0.0
     *
     * @param {integer} [tileWidth] - The width of a tile in pixels.
     * @param {integer} [tileHeight] - The height of a tile in pixels.
     *
     * @return {Phaser.Tilemaps.Tileset} This Tileset object.
     */setTileSize:function(t,e){return void 0!==t&&(this.tileWidth=t),void 0!==e&&(this.tileHeight=e),this.image&&this.updateTileData(this.image.source[0].width,this.image.source[0].height),this},/**
     * Sets the tile margin & spacing and updates the tile data (rows, columns, etc.).
     *
     * @method Phaser.Tilemaps.Tileset#setSpacing
     * @since 3.0.0
     *
     * @param {integer} [margin] - The margin around the tiles in the sheet (in pixels).
     * @param {integer} [spacing] - The spacing between the tiles in the sheet (in pixels).
     *
     * @return {Phaser.Tilemaps.Tileset} This Tileset object.
     */setSpacing:function(t,e){return void 0!==t&&(this.tileMargin=t),void 0!==e&&(this.tileSpacing=e),this.image&&this.updateTileData(this.image.source[0].width,this.image.source[0].height),this},/**
     * Updates tile texture coordinates and tileset data.
     *
     * @method Phaser.Tilemaps.Tileset#updateTileData
     * @since 3.0.0
     *
     * @param {integer} imageWidth - The (expected) width of the image to slice.
     * @param {integer} imageHeight - The (expected) height of the image to slice.
     *
     * @return {Phaser.Tilemaps.Tileset} This Tileset object.
     */updateTileData:function(t,e){var i=(e-2*this.tileMargin+this.tileSpacing)/(this.tileHeight+this.tileSpacing),n=(t-2*this.tileMargin+this.tileSpacing)/(this.tileWidth+this.tileSpacing);(i%1!=0||n%1!=0)&&console.warn("Image tile area not tile size multiple in: "+this.name),// In Tiled a tileset image that is not an even multiple of the tile dimensions is truncated
// - hence the floor when calculating the rows/columns.
i=Math.floor(i),n=Math.floor(n),this.rows=i,this.columns=n,// In Tiled, "empty" spaces in a tileset count as tiles and hence count towards the gid
this.total=i*n,this.texCoordinates.length=0;for(var s=this.tileMargin,r=this.tileMargin,o=0;o<this.rows;o++){for(var a=0;a<this.columns;a++)this.texCoordinates.push({x:s,y:r}),s+=this.tileWidth+this.tileSpacing;s=this.tileMargin,r+=this.tileHeight+this.tileSpacing}return this}});t.exports=i}),r("65en1",function(t,e){/**
 * @classdesc
 * An Image Collection is a special Tile Set containing multiple images, with no slicing into each image.
 *
 * Image Collections are normally created automatically when Tiled data is loaded.
 *
 * @class ImageCollection
 * @memberof Phaser.Tilemaps
 * @constructor
 * @since 3.0.0
 * 
 * @param {string} name - The name of the image collection in the map data.
 * @param {integer} firstgid - The first image index this image collection contains.
 * @param {integer} [width=32] - Width of widest image (in pixels).
 * @param {integer} [height=32] - Height of tallest image (in pixels).
 * @param {integer} [margin=0] - The margin around all images in the collection (in pixels).
 * @param {integer} [spacing=0] - The spacing between each image in the collection (in pixels).
 * @param {object} [properties={}] - Custom Image Collection properties.
 */var i=new(s("jwj1g"))({initialize:function(t,e,i,n,s,r,o){(void 0===i||i<=0)&&(i=32),(void 0===n||n<=0)&&(n=32),void 0===s&&(s=0),void 0===r&&(r=0),/**
         * The name of the Image Collection.
         * 
         * @name Phaser.Tilemaps.ImageCollection#name
         * @type {string}
         * @since 3.0.0
        */this.name=t,/**
         * The Tiled firstgid value.
         * This is the starting index of the first image index this Image Collection contains.
         * 
         * @name Phaser.Tilemaps.ImageCollection#firstgid
         * @type {integer}
         * @since 3.0.0
         */this.firstgid=0|e,/**
         * The width of the widest image (in pixels).
         * 
         * @name Phaser.Tilemaps.ImageCollection#imageWidth
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.imageWidth=0|i,/**
         * The height of the tallest image (in pixels).
         * 
         * @name Phaser.Tilemaps.ImageCollection#imageHeight
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.imageHeight=0|n,/**
         * The margin around the images in the collection (in pixels).
         * Use `setSpacing` to change.
         * 
         * @name Phaser.Tilemaps.ImageCollection#imageMarge
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.imageMargin=0|s,/**
         * The spacing between each image in the collection (in pixels).
         * Use `setSpacing` to change.
         * 
         * @name Phaser.Tilemaps.ImageCollection#imageSpacing
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.imageSpacing=0|r,/**
         * Image Collection-specific properties that are typically defined in the Tiled editor.
         * 
         * @name Phaser.Tilemaps.ImageCollection#properties
         * @type {object}
         * @since 3.0.0
         */this.properties=o||{},/**
         * The cached images that are a part of this collection.
         * 
         * @name Phaser.Tilemaps.ImageCollection#images
         * @type {array}
         * @readonly
         * @since 3.0.0
         */this.images=[],/**
         * The total number of images in the image collection.
         * 
         * @name Phaser.Tilemaps.ImageCollection#total
         * @type {integer}
         * @readonly
         * @since 3.0.0
         */this.total=0},/**
     * Returns true if and only if this image collection contains the given image index.
     *
     * @method Phaser.Tilemaps.ImageCollection#containsImageIndex
     * @since 3.0.0
     * 
     * @param {integer} imageIndex - The image index to search for.
     * 
     * @return {boolean} True if this Image Collection contains the given index.
     */containsImageIndex:function(t){return t>=this.firstgid&&t<this.firstgid+this.total},/**
     * Add an image to this Image Collection.
     *
     * @method Phaser.Tilemaps.ImageCollection#addImage
     * @since 3.0.0
     * 
     * @param {integer} gid - The gid of the image in the Image Collection.
     * @param {string} image - The the key of the image in the Image Collection and in the cache.
     *
     * @return {Phaser.Tilemaps.ImageCollection} This ImageCollection object.
     */addImage:function(t,e){return this.images.push({gid:t,image:e}),this.total++,this}});t.exports=i}),r("cKtBa",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("Ljig0"),n=s("d0ux1"),r=function(t){return{x:t.x,y:t.y}},o=["id","name","type","rotation","properties","visible","x","y","width","height"];t.exports=function(t,e,s){void 0===e&&(e=0),void 0===s&&(s=0);var a=i(t,o);if(a.x+=e,a.y+=s,t.gid){//  Object tiles
var h=n(t.gid);a.gid=h.gid,a.flippedHorizontal=h.flippedHorizontal,a.flippedVertical=h.flippedVertical,a.flippedAntiDiagonal=h.flippedAntiDiagonal}else t.polyline?a.polyline=t.polyline.map(r):t.polygon?a.polygon=t.polygon.map(r):t.ellipse?a.ellipse=t.ellipse:t.text?a.text=t.text:t.point?a.point=!0:a.rectangle=!0;return a}}),r("Ljig0",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("evjs6");t.exports=function(t,e){for(var n={},s=0;s<e.length;s++){var r=e[s];i(t,r)&&(n[r]=t[r])}return n}}),r("fUwNw",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7BSWl"),n=s("cKtBa"),r=s("egj22"),o=s("cedNs");t.exports=function(t){for(var e=[],s=[],a=o(t);a.i<a.layers.length||s.length>0;){if(a.i>=a.layers.length){// Ensure recursion stack is not empty first
if(s.length<1){console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");break}// Return to previous recursive state
a=s.pop();continue}// Get current layer and advance iterator
var h=a.layers[a.i];if(a.i++,// Modify inherited properties
h.opacity*=a.opacity,h.visible=a.visible&&h.visible,"objectgroup"!==h.type){if("group"===h.type){// Compute next state inherited from group
var l=o(t,h,a);// Preserve current state before recursing
s.push(a),a=l}continue}h.name=a.name+h.name;for(var u=a.x+i(h,"startx",0)+i(h,"offsetx",0),c=a.y+i(h,"starty",0)+i(h,"offsety",0),d=[],f=0;f<h.objects.length;f++){var p=n(h.objects[f],u,c);d.push(p)}var g=new r(h);g.objects=d,e.push(g)}return e}}),r("egj22",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7BSWl"),r=new i({initialize:function(t){void 0===t&&(t={}),/**
         * The name of the Object Layer.
         *
         * @name Phaser.Tilemaps.ObjectLayer#name
         * @type {string}
         * @since 3.0.0
         */this.name=n(t,"name","object layer"),/**
         * The opacity of the layer, between 0 and 1.
         *
         * @name Phaser.Tilemaps.ObjectLayer#opacity
         * @type {number}
         * @since 3.0.0
         */this.opacity=n(t,"opacity",1),/**
         * The custom properties defined on the Object Layer, keyed by their name.
         *
         * @name Phaser.Tilemaps.ObjectLayer#properties
         * @type {object}
         * @since 3.0.0
         */this.properties=n(t,"properties",{}),/**
         * The type of each custom property defined on the Object Layer, keyed by its name.
         *
         * @name Phaser.Tilemaps.ObjectLayer#propertyTypes
         * @type {object}
         * @since 3.0.0
         */this.propertyTypes=n(t,"propertytypes",{}),/**
         * The type of the layer, which should be `objectgroup`.
         *
         * @name Phaser.Tilemaps.ObjectLayer#type
         * @type {string}
         * @since 3.0.0
         */this.type=n(t,"type","objectgroup"),/**
         * Whether the layer is shown (`true`) or hidden (`false`).
         *
         * @name Phaser.Tilemaps.ObjectLayer#visible
         * @type {boolean}
         * @since 3.0.0
         */this.visible=n(t,"visible",!0),/**
         * An array of all objects on this Object Layer.
         *
         * Each Tiled object corresponds to a JavaScript object in this array. It has an `id` (unique),
         * `name` (as assigned in Tiled), `type` (as assigned in Tiled), `rotation` (in clockwise degrees),
         * `properties` (if any), `visible` state (`true` if visible, `false` otherwise),
         * `x` and `y` coordinates (in pixels, relative to the tilemap), and a `width` and `height` (in pixels).
         *
         * An object tile has a `gid` property (GID of the represented tile), a `flippedHorizontal` property,
         * a `flippedVertical` property, and `flippedAntiDiagonal` property.
         * The {@link http://docs.mapeditor.org/en/latest/reference/tmx-map-format/|Tiled documentation} contains
         * information on flipping and rotation.
         *
         * Polylines have a `polyline` property, which is an array of objects corresponding to points,
         * where each point has an `x` property and a `y` property. Polygons have an identically structured
         * array in their `polygon` property. Text objects have a `text` property with the text's properties.
         *
         * Rectangles and ellipses have a `rectangle` or `ellipse` property set to `true`.
         *
         * @name Phaser.Tilemaps.ObjectLayer#objects
         * @type {Phaser.Types.Tilemaps.TiledObject[]}
         * @since 3.0.0
         */this.objects=n(t,"objects",[])}});t.exports=r}),r("aqDox",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eZOmW");t.exports=function(t){var e,n,s=[];for(e=0;e<t.imageCollections.length;e++)for(var r=t.imageCollections[e],o=r.images,a=0;a<o.length;a++){var h=o[a];(n=new i(h.image,h.gid,r.imageWidth,r.imageHeight,0,0)).updateTileData(r.imageWidth,r.imageHeight),t.tilesets.push(n)}for(e=0;e<t.tilesets.length;e++)for(var l=(n=t.tilesets[e]).tileMargin,u=n.tileMargin,c=0,d=0,f=0,p=n.firstgid;p<n.firstgid+n.total&&(//  Can add extra properties here as needed
s[p]=[l,u,e],l+=n.tileWidth+n.tileSpacing,++c!==n.total&&(++d!==n.columns||(l=n.tileMargin,u+=n.tileHeight+n.tileSpacing,d=0,++f!==n.rows)));p++);return s}}),r("fNydI",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("hVk4C");t.exports=function(t){// go through each of the map data layers
for(var e,n,s,r,o,a=0;a<t.layers.length;a++){e=t.layers[a],r=null;// rows of tiles
for(var h=0;h<e.data.length;h++){o=e.data[h];// individual tiles
for(var l=0;l<o.length;l++)null!==(n=o[l])&&!(n.index<0)&&(// find the relevant tileset
s=t.tiles[n.index][2],r=t.tilesets[s],// Ensure that a tile's size matches its tileset
n.width=r.tileWidth,n.height=r.tileHeight,r.tileProperties&&r.tileProperties[n.index-r.firstgid]&&(n.properties=i(n.properties,r.tileProperties[n.index-r.firstgid])))}}}}),r("7A8Vq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("au4z0"),n=s("5Jvnl"),r=s("2zjpJ"),o=s("9MTJv");t.exports=function(t,e,s){if(0===e.layer.length)return console.warn("No layers found in the Weltmeister map: "+t),null;for(var a=0,h=0,l=0;l<e.layer.length;l++)e.layer[l].width>a&&(a=e.layer[l].width),e.layer[l].height>h&&(h=e.layer[l].height);var u=new n({width:a,height:h,name:t,tileWidth:e.layer[0].tilesize,tileHeight:e.layer[0].tilesize,format:i.WELTMEISTER});return u.layers=r(e,s),u.tilesets=o(e),u}}),r("2zjpJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5wtVg"),n=s("1uZwx");t.exports=function(t,e){for(var s=[],r=0;r<t.layer.length;r++){//  Loop through the data field in the JSON. This is a 2D array containing the tile indexes,
//  one after the other. The indexes are relative to the tileset that contains the tile.
for(var o=t.layer[r],a=new i({name:o.name,width:o.width,height:o.height,tileWidth:o.tilesize,tileHeight:o.tilesize,visible:1===o.visible}),h=[],l=[],u=0;u<o.data.length;u++){for(var c=0;c<o.data[u].length;c++){// In Weltmeister, 0 = no tile, but the Tilemap API expects -1 = no tile.
var d,f=o.data[u][c]-1;d=f>-1?new n(a,f,c,u,o.tilesize,o.tilesize):e?null:new n(a,-1,c,u,o.tilesize,o.tilesize),h.push(d)}l.push(h),h=[]}a.data=l,s.push(a)}return s}}),r("9MTJv",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("eZOmW");t.exports=function(t){for(var e=[],n=[],s=0;s<t.layer.length;s++){var r=t.layer[s],o=r.tilesetName;// Only add unique tilesets that have a valid name. Collision layers will have a blank name.
""!==o&&-1===n.indexOf(o)&&(n.push(o),// Tiles are stored with an ID relative to the tileset, rather than a globally unique ID
// across all tilesets. Also, tilesets in Weltmeister have no margin or padding.
e.push(new i(o,0,r.tilesize,r.tilesize,0,0)))}return e}}),r("9P34u",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Tilemaps.Parsers.Impact
 */t.exports={ParseTileLayers:s("2zjpJ"),ParseTilesets:s("9MTJv"),ParseWeltmeister:s("7A8Vq")}}),r("76DPJ",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Tilemaps.Parsers.Tiled
 */t.exports={AssignTileProperties:s("fNydI"),Base64Decode:s("jPMWH"),BuildTilesetIndex:s("aqDox"),ParseGID:s("d0ux1"),ParseImageLayers:s("2NaOj"),ParseJSONTiled:s("8YPQy"),ParseObject:s("cKtBa"),ParseObjectLayers:s("fUwNw"),ParseTileLayers:s("jldtL"),ParseTilesets:s("dw6Ty")}}),r("6SHSh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("au4z0"),n=s("5Jvnl"),r=s("idVMS"),o=s("l3bIA");t.exports=function(t,e,s,a,h,l,u,c){void 0===s&&(s=32),void 0===a&&(a=32),void 0===h&&(h=10),void 0===l&&(l=10),void 0===c&&(c=!1);var d=null;if(Array.isArray(u))d=r(void 0!==e?e:"map",i.ARRAY_2D,u,s,a,c);else if(void 0!==e){var f=t.cache.tilemap.get(e);f?d=r(e,f.format,f.data,s,a,c):console.warn("No map data found for key "+e)}return null===d&&(d=new n({tileWidth:s,tileHeight:a,width:h,height:l})),new o(t,d)}}),r("l3bIA",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("2zqSA"),r=s("3DUwP"),o=s("hVk4C"),a=s("au4z0"),h=s("5wtVg"),l=s("kaMwv"),u=s("eOqX8"),c=s("ehIU5"),d=s("1uZwx"),f=s("hequO"),p=s("eZOmW"),g=new i({initialize:function(t,e){/**
         * @name Phaser.Tilemaps.Tilemap#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * The base width of a tile in pixels. Note that individual layers may have a different tile
         * width.
         *
         * @name Phaser.Tilemaps.Tilemap#tileWidth
         * @type {integer}
         * @since 3.0.0
         */this.tileWidth=e.tileWidth,/**
         * The base height of a tile in pixels. Note that individual layers may have a different
         * tile height.
         *
         * @name Phaser.Tilemaps.Tilemap#tileHeight
         * @type {integer}
         * @since 3.0.0
         */this.tileHeight=e.tileHeight,/**
         * The width of the map (in tiles).
         *
         * @name Phaser.Tilemaps.Tilemap#width
         * @type {number}
         * @since 3.0.0
         */this.width=e.width,/**
         * The height of the map (in tiles).
         *
         * @name Phaser.Tilemaps.Tilemap#height
         * @type {number}
         * @since 3.0.0
         */this.height=e.height,/**
         * The orientation of the map data (as specified in Tiled), usually 'orthogonal'.
         *
         * @name Phaser.Tilemaps.Tilemap#orientation
         * @type {string}
         * @since 3.0.0
         */this.orientation=e.orientation,/**
         * The render (draw) order of the map data (as specified in Tiled), usually 'right-down'.
         *
         * The draw orders are:
         *
         * right-down
         * left-down
         * right-up
         * left-up
         *
         * This can be changed via the `setRenderOrder` method.
         *
         * @name Phaser.Tilemaps.Tilemap#renderOrder
         * @type {string}
         * @since 3.12.0
         */this.renderOrder=e.renderOrder,/**
         * The format of the map data.
         *
         * @name Phaser.Tilemaps.Tilemap#format
         * @type {number}
         * @since 3.0.0
         */this.format=e.format,/**
         * The version of the map data (as specified in Tiled, usually 1).
         *
         * @name Phaser.Tilemaps.Tilemap#version
         * @type {number}
         * @since 3.0.0
         */this.version=e.version,/**
         * Map specific properties as specified in Tiled.
         *
         * @name Phaser.Tilemaps.Tilemap#properties
         * @type {object}
         * @since 3.0.0
         */this.properties=e.properties,/**
         * The width of the map in pixels based on width * tileWidth.
         *
         * @name Phaser.Tilemaps.Tilemap#widthInPixels
         * @type {number}
         * @since 3.0.0
         */this.widthInPixels=e.widthInPixels,/**
         * The height of the map in pixels based on height * tileHeight.
         *
         * @name Phaser.Tilemaps.Tilemap#heightInPixels
         * @type {number}
         * @since 3.0.0
         */this.heightInPixels=e.heightInPixels,/**
         *
         * @name Phaser.Tilemaps.Tilemap#imageCollections
         * @type {Phaser.Tilemaps.ImageCollection[]}
         * @since 3.0.0
         */this.imageCollections=e.imageCollections,/**
         * An array of Tiled Image Layers.
         *
         * @name Phaser.Tilemaps.Tilemap#images
         * @type {array}
         * @since 3.0.0
         */this.images=e.images,/**
         * An array of Tilemap layer data.
         *
         * @name Phaser.Tilemaps.Tilemap#layers
         * @type {Phaser.Tilemaps.LayerData[]}
         * @since 3.0.0
         */this.layers=e.layers,/**
         * An array of Tilesets used in the map.
         *
         * @name Phaser.Tilemaps.Tilemap#tilesets
         * @type {Phaser.Tilemaps.Tileset[]}
         * @since 3.0.0
         */this.tilesets=e.tilesets,/**
         * An array of ObjectLayer instances parsed from Tiled object layers.
         *
         * @name Phaser.Tilemaps.Tilemap#objects
         * @type {Phaser.Tilemaps.ObjectLayer[]}
         * @since 3.0.0
         */this.objects=e.objects,/**
         * The index of the currently selected LayerData object.
         *
         * @name Phaser.Tilemaps.Tilemap#currentLayerIndex
         * @type {integer}
         * @since 3.0.0
         */this.currentLayerIndex=0},/**
     * Sets the rendering (draw) order of the tiles in this map.
     *
     * The default is 'right-down', meaning it will order the tiles starting from the top-left,
     * drawing to the right and then moving down to the next row.
     *
     * The draw orders are:
     *
     * 0 = right-down
     * 1 = left-down
     * 2 = right-up
     * 3 = left-up
     *
     * Setting the render order does not change the tiles or how they are stored in the layer,
     * it purely impacts the order in which they are rendered.
     *
     * You can provide either an integer (0 to 3), or the string version of the order.
     *
     * Calling this method _after_ creating Static or Dynamic Tilemap Layers will **not** automatically
     * update them to use the new render order. If you call this method after creating layers, use their
     * own `setRenderOrder` methods to change them as needed.
     *
     * @method Phaser.Tilemaps.Tilemap#setRenderOrder
     * @since 3.12.0
     *
     * @param {(integer|string)} renderOrder - The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.
     *
     * @return {this} This Tilemap object.
     */setRenderOrder:function(t){var e=["right-down","left-down","right-up","left-up"];return"number"==typeof t&&(t=e[t]),e.indexOf(t)>-1&&(this.renderOrder=t),this},/**
     * Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.
     * Note that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled
     * editor.
     *
     * @method Phaser.Tilemaps.Tilemap#addTilesetImage
     * @since 3.0.0
     *
     * @param {string} tilesetName - The name of the tileset as specified in the map data.
     * @param {string} [key] - The key of the Phaser.Cache image used for this tileset. If
     * `undefined` or `null` it will look for an image with a key matching the tilesetName parameter.
     * @param {integer} [tileWidth] - The width of the tile (in pixels) in the Tileset Image. If not
     * given it will default to the map's tileWidth value, or the tileWidth specified in the Tiled
     * JSON file.
     * @param {integer} [tileHeight] - The height of the tiles (in pixels) in the Tileset Image. If
     * not given it will default to the map's tileHeight value, or the tileHeight specified in the
     * Tiled JSON file.
     * @param {integer} [tileMargin] - The margin around the tiles in the sheet (in pixels). If not
     * specified, it will default to 0 or the value specified in the Tiled JSON file.
     * @param {integer} [tileSpacing] - The spacing between each the tile in the sheet (in pixels).
     * If not specified, it will default to 0 or the value specified in the Tiled JSON file.
     * @param {integer} [gid=0] - If adding multiple tilesets to a blank map, specify the starting
     * GID this set will use here.
     *
     * @return {?Phaser.Tilemaps.Tileset} Returns the Tileset object that was created or updated, or null if it
     * failed.
     */addTilesetImage:function(t,e,i,n,s,r,o){if(void 0===t)return null;if(null==e&&(e=t),!this.scene.sys.textures.exists(e))return console.warn("Invalid Tileset Image: "+e),null;var h=this.scene.sys.textures.get(e),l=this.getTilesetIndex(t);if(null===l&&this.format===a.TILED_JSON)return console.warn("No data found for Tileset: "+t),null;var u=this.tilesets[l];return u?(u.setTileSize(i,n),u.setSpacing(s,r),u.setImage(h)):(void 0===i&&(i=this.tileWidth),void 0===n&&(n=this.tileHeight),void 0===s&&(s=0),void 0===r&&(r=0),void 0===o&&(o=0),(u=new p(t,o,i,n,s,r)).setImage(h),this.tilesets.push(u)),u},/**
     * Turns the DynamicTilemapLayer associated with the given layer into a StaticTilemapLayer. If
     * no layer specified, the map's current layer is used. This is useful if you want to manipulate
     * a map at the start of a scene, but then make it non-manipulable and optimize it for speed.
     * Note: the DynamicTilemapLayer passed in is destroyed, so make sure to store the value
     * returned from this method if you want to manipulate the new StaticTilemapLayer.
     *
     * @method Phaser.Tilemaps.Tilemap#convertLayerToStatic
     * @since 3.0.0
     *
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer)} [layer] - The name of the layer from Tiled, the
     * index of the layer in the map, or a DynamicTilemapLayer.
     *
     * @return {?Phaser.Tilemaps.StaticTilemapLayer} Returns the new layer that was created, or null if it
     * failed.
     */convertLayerToStatic:function(t){if(null===(t=this.getLayer(t)))return null;var e=t.tilemapLayer;if(!e||!(e instanceof r))return null;var i=new c(e.scene,e.tilemap,e.layerIndex,e.tileset,e.x,e.y);return this.scene.sys.displayList.add(i),e.destroy(),i},/**
     * Copies the tiles in the source rectangular area to a new destination (all specified in tile
     * coordinates) within the layer. This copies all tile properties & recalculates collision
     * information in the destination region.
     *
     * If no layer specified, the map's current layer is used. This cannot be applied to StaticTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#copy
     * @since 3.0.0
     *
     * @param {integer} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.
     * @param {integer} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.
     * @param {integer} width - The width of the area to copy, in tiles, not pixels.
     * @param {integer} height - The height of the area to copy, in tiles, not pixels.
     * @param {integer} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.
     * @param {integer} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.
     */copy:function(t,e,i,n,s,r,o,a){return(a=this.getLayer(a),this._isStaticCall(a,"copy"))?this:null!==a?(f.Copy(t,e,i,n,s,r,o,a),this):null},/**
     * Creates a new and empty DynamicTilemapLayer. The currently selected layer in the map is set to this new layer.
     *
     * @method Phaser.Tilemaps.Tilemap#createBlankDynamicLayer
     * @since 3.0.0
     *
     * @param {string} name - The name of this layer. Must be unique within the map.
     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.
     * @param {number} [x=0] - The world x position where the top left of this layer will be placed.
     * @param {number} [y=0] - The world y position where the top left of this layer will be placed.
     * @param {integer} [width] - The width of the layer in tiles. If not specified, it will default to the map's width.
     * @param {integer} [height] - The height of the layer in tiles. If not specified, it will default to the map's height.
     * @param {integer} [tileWidth] - The width of the tiles the layer uses for calculations. If not specified, it will default to the map's tileWidth.
     * @param {integer} [tileHeight] - The height of the tiles the layer uses for calculations. If not specified, it will default to the map's tileHeight.
     *
     * @return {?Phaser.Tilemaps.DynamicTilemapLayer} Returns the new layer that was created, or `null` if it failed.
     */createBlankDynamicLayer:function(t,e,i,n,s,o,a,l){if(void 0===i&&(i=0),void 0===n&&(n=0),void 0===s&&(s=this.width),void 0===o&&(o=this.height),void 0===a&&(a=this.tileWidth),void 0===l&&(l=this.tileHeight),null!==this.getLayerIndex(t))return console.warn("Invalid Tilemap Layer ID: "+t),null;for(var u,c=new h({name:t,tileWidth:a,tileHeight:l,width:s,height:o}),f=0;f<o;f++){u=[];for(var p=0;p<s;p++)u.push(new d(c,-1,p,f,a,l,this.tileWidth,this.tileHeight));c.data.push(u)}this.layers.push(c),this.currentLayerIndex=this.layers.length-1;var g=new r(this.scene,this,this.currentLayerIndex,e,i,n);return g.setRenderOrder(this.renderOrder),this.scene.sys.displayList.add(g),g},/**
     * Creates a new DynamicTilemapLayer that renders the LayerData associated with the given
     * `layerID`. The currently selected layer in the map is set to this new layer.
     *
     * The `layerID` is important. If you've created your map in Tiled then you can get this by
     * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and
     * look at the layers[].name value. Either way it must match.
     *
     * Unlike a static layer, a dynamic layer can be modified. See DynamicTilemapLayer for more
     * information.
     *
     * @method Phaser.Tilemaps.Tilemap#createDynamicLayer
     * @since 3.0.0
     *
     * @param {(integer|string)} layerID - The layer array index value, or if a string is given, the layer name from Tiled.
     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.
     * @param {number} [x=0] - The x position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.
     * @param {number} [y=0] - The y position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.
     *
     * @return {?Phaser.Tilemaps.DynamicTilemapLayer} Returns the new layer was created, or null if it failed.
     */createDynamicLayer:function(t,e,i,n){var s=this.getLayerIndex(t);if(null===s)return console.warn("Invalid Tilemap Layer ID: "+t),"string"==typeof t&&console.warn("Valid tilelayer names:\n	"+this.getTileLayerNames().join(",\n	")),null;var o=this.layers[s];// Check for an associated static or dynamic tilemap layer
if(o.tilemapLayer)return console.warn("Tilemap Layer ID already exists:"+t),null;this.currentLayerIndex=s,void 0===i&&(i=o.x),void 0===n&&(n=o.y);var a=new r(this.scene,this,s,e,i,n);return a.setRenderOrder(this.renderOrder),this.scene.sys.displayList.add(a),a},/**
     * Creates a Sprite for every object matching the given gid in the map data. All properties from
     * the map data objectgroup are copied into the `spriteConfig`, so you can use this as an easy
     * way to configure Sprite properties from within the map editor. For example giving an object a
     * property of alpha: 0.5 in the map editor will duplicate that when the Sprite is created.
     *
     * Custom object properties not sharing names with the Sprite's own properties are copied to the
     * Sprite's {@link Phaser.GameObjects.Sprite#data data store}.
     *
     * @method Phaser.Tilemaps.Tilemap#createFromObjects
     * @since 3.0.0
     *
     * @param {string} name - The name of the object layer (from Tiled) to create Sprites from.
     * @param {(integer|string)} id - Either the id (object), gid (tile object) or name (object or
     * tile object) from Tiled. Ids are unique in Tiled, but a gid is shared by all tile objects
     * with the same graphic. The same name can be used on multiple objects.
     * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e.
     * scene.make.sprite).
     * @param {Phaser.Scene} [scene=the scene the map is within] - The Scene to create the Sprites within.
     *
     * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.
     */createFromObjects:function(t,e,i,s){void 0===i&&(i={}),void 0===s&&(s=this.scene);var r=this.getObjectLayer(t);if(!r)return console.warn("Cannot create from object. Invalid objectgroup name given: "+t),"string"==typeof layerID&&console.warn("Valid objectgroup names:\n	"+this.getObjectLayerNames().join(",\n	")),null;for(var a=r.objects,h=[],u=0;u<a.length;u++){var c=!1,d=a[u];if((void 0!==d.gid&&"number"==typeof e&&d.gid===e||void 0!==d.id&&"number"==typeof e&&d.id===e||void 0!==d.name&&"string"==typeof e&&d.name===e)&&(c=!0),c){var f=o({},i,d.properties);f.x=d.x,f.y=d.y;var p=s.make.sprite(f);p.name=d.name,d.width&&(p.displayWidth=d.width),d.height&&(p.displayHeight=d.height);// Origin is (0, 1) in Tiled, so find the offset that matches the Sprite's origin.
// Do not offset objects with zero dimensions (e.g. points).
var g={x:p.originX*d.width,y:(p.originY-1)*d.height};// If the object is rotated, then the origin offset also needs to be rotated.
if(d.rotation){var v=n(d.rotation);l(g,v),p.rotation=v}for(var m in p.x+=g.x,p.y+=g.y,(void 0!==d.flippedHorizontal||void 0!==d.flippedVertical)&&p.setFlip(d.flippedHorizontal,d.flippedVertical),d.visible||(p.visible=!1),d.properties)p.hasOwnProperty(m)||p.setData(m,d.properties[m]);h.push(p)}}return h},/**
     * Creates a Sprite for every object matching the given tile indexes in the layer. You can
     * optionally specify if each tile will be replaced with a new tile after the Sprite has been
     * created. This is useful if you want to lay down special tiles in a level that are converted to
     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.
     *
     * @method Phaser.Tilemaps.Tilemap#createFromTiles
     * @since 3.0.0
     *
     * @param {(integer|array)} indexes - The tile index, or array of indexes, to create Sprites from.
     * @param {(integer|array)} replacements - The tile index, or array of indexes, to change a converted
     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a
     * one-to-one mapping with the indexes array.
     * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e. scene.make.sprite).
     * @param {Phaser.Scene} [scene=scene the map is within] - The Scene to create the Sprites within.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.GameObjects.Sprite[]} Returns an array of Tiles, or null if the layer given was invalid.
     */createFromTiles:function(t,e,i,n,s,r){return null===(r=this.getLayer(r))?null:f.CreateFromTiles(t,e,i,n,s,r)},/**
     * Creates a new StaticTilemapLayer that renders the LayerData associated with the given
     * `layerID`. The currently selected layer in the map is set to this new layer.
     *
     * The `layerID` is important. If you've created your map in Tiled then you can get this by
     * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and
     * look at the layers[].name value. Either way it must match.
     *
     * It's important to remember that a static layer cannot be modified. See StaticTilemapLayer for
     * more information.
     *
     * @method Phaser.Tilemaps.Tilemap#createStaticLayer
     * @since 3.0.0
     *
     * @param {(integer|string)} layerID - The layer array index value, or if a string is given, the layer name from Tiled.
     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.
     * @param {number} [x=0] - The x position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.
     * @param {number} [y=0] - The y position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.
     *
     * @return {?Phaser.Tilemaps.StaticTilemapLayer} Returns the new layer was created, or null if it failed.
     */createStaticLayer:function(t,e,i,n){var s=this.getLayerIndex(t);if(null===s)return console.warn("Invalid Tilemap Layer ID: "+t),"string"==typeof t&&console.warn("Valid tilelayer names:\n	"+this.getTileLayerNames().join(",\n	")),null;//  Check for an associated static or dynamic tilemap layer
if(this.layers[s].tilemapLayer)return console.warn("Tilemap Layer ID already exists:"+t),null;this.currentLayerIndex=s,void 0===i&&this.layers[s].x&&(i=this.layers[s].x),void 0===n&&this.layers[s].y&&(n=this.layers[s].y);var r=new c(this.scene,this,s,e,i,n);return r.setRenderOrder(this.renderOrder),this.scene.sys.displayList.add(r),r},/**
     * Removes all layer data from this Tilemap and nulls the scene reference. This will destroy any
     * StaticTilemapLayers or DynamicTilemapLayers that have been linked to LayerData.
     *
     * @method Phaser.Tilemaps.Tilemap#destroy
     * @since 3.0.0
     */destroy:function(){this.removeAllLayers(),this.tilesets.length=0,this.objects.length=0,this.scene=void 0},/**
     * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the
     * specified index. Tiles will be set to collide if the given index is a colliding index.
     * Collision information in the region will be recalculated.
     *
     * If no layer specified, the map's current layer is used.
     * This cannot be applied to StaticTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#fill
     * @since 3.0.0
     *
     * @param {integer} index - The tile index to fill the area with.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.
     */fill:function(t,e,i,n,s,r,o){return null===(o=this.getLayer(o))?null:(this._isStaticCall(o,"fill")||f.Fill(t,e,i,n,s,r,o),this)},/**
     * For each object in the given object layer, run the given filter callback function. Any
     * objects that pass the filter test (i.e. where the callback returns true) will returned as a
     * new array. Similar to Array.prototype.Filter in vanilla JS.
     *
     * @method Phaser.Tilemaps.Tilemap#filterObjects
     * @since 3.0.0
     *
     * @param {(Phaser.Tilemaps.ObjectLayer|string)} objectLayer - The name of an object layer (from Tiled) or an ObjectLayer instance.
     * @param {TilemapFilterCallback} callback - The callback. Each object in the given area will be passed to this callback as the first and only parameter.
     * @param {object} [context] - The context under which the callback should be run.
     *
     * @return {?Phaser.GameObjects.GameObject[]} An array of object that match the search, or null if the objectLayer given was invalid.
     */filterObjects:function(t,e,i){if("string"==typeof t){var n=t;if(!(t=this.getObjectLayer(t)))return console.warn("No object layer found with the name: "+n),null}return t.objects.filter(e,i)},/**
     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns
     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#filterTiles
     * @since 3.0.0
     *
     * @param {function} callback - The callback. Each tile in the given area will be passed to this
     * callback as the first and only parameter. The callback should return true for tiles that pass the
     * filter.
     * @param {object} [context] - The context under which the callback should be run.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to filter.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area to filter.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.
     */filterTiles:function(t,e,i,n,s,r,o,a){return null===(a=this.getLayer(a))?null:f.FilterTiles(t,e,i,n,s,r,o,a)},/**
     * Searches the entire map layer for the first tile matching the given index, then returns that Tile
     * object. If no match is found, it returns null. The search starts from the top-left tile and
     * continues horizontally until it hits the end of the row, then it drops down to the next column.
     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to
     * the top-left.
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#findByIndex
     * @since 3.0.0
     *
     * @param {integer} index - The tile index value to search for.
     * @param {integer} [skip=0] - The number of times to skip a matching tile before returning.
     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.
     */findByIndex:function(t,e,i,n){return null===(n=this.getLayer(n))?null:f.FindByIndex(t,e,i,n)},/**
     * Find the first object in the given object layer that satisfies the provided testing function.
     * I.e. finds the first object for which `callback` returns true. Similar to
     * Array.prototype.find in vanilla JS.
     *
     * @method Phaser.Tilemaps.Tilemap#findObject
     * @since 3.0.0
     *
     * @param {(Phaser.Tilemaps.ObjectLayer|string)} objectLayer - The name of an object layer (from Tiled) or an ObjectLayer instance.
     * @param {TilemapFindCallback} callback - The callback. Each object in the given area will be passed to this callback as the first and only parameter.
     * @param {object} [context] - The context under which the callback should be run.
     *
     * @return {?Phaser.GameObjects.GameObject} An object that matches the search, or null if no object found.
     */findObject:function(t,e,i){if("string"==typeof t){var n=t;if(!(t=this.getObjectLayer(t)))return console.warn("No object layer found with the name: "+n),null}return t.objects.find(e,i)||null},/**
     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that
     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns
     * true. Similar to Array.prototype.find in vanilla JS.
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#findTile
     * @since 3.0.0
     *
     * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.
     * @param {object} [context] - The context under which the callback should be run.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to search.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area to search.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The Tile layer to run the search on. If not provided will use the current layer.
     *
     * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.
     */findTile:function(t,e,i,n,s,r,o,a){return null===(a=this.getLayer(a))?null:f.FindTile(t,e,i,n,s,r,o,a)},/**
     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
     * callback. Similar to Array.prototype.forEach in vanilla JS.
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#forEachTile
     * @since 3.0.0
     *
     * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.
     * @param {object} [context] - The context under which the callback should be run.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to search.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area to search.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The Tile layer to run the search on. If not provided will use the current layer.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.
     */forEachTile:function(t,e,i,n,s,r,o,a){return null===(a=this.getLayer(a))?null:(f.ForEachTile(t,e,i,n,s,r,o,a),this)},/**
     * Gets the image layer index based on its name.
     *
     * @method Phaser.Tilemaps.Tilemap#getImageIndex
     * @since 3.0.0
     *
     * @param {string} name - The name of the image to get.
     *
     * @return {integer} The index of the image in this tilemap, or null if not found.
     */getImageIndex:function(t){return this.getIndex(this.images,t)},/**
     * Return a list of all valid imagelayer names loaded in this Tilemap.
     *
     * @method Phaser.Tilemaps.Tilemap#getImageLayerNames
     * @since 3.21.0
     *
     * @return {string[]} Array of valid imagelayer names / IDs loaded into this Tilemap.
     */getImageLayerNames:function(){return this.images&&Array.isArray(this.images)?this.images.map(function(t){return t.name}):[]},/**
     * Internally used. Returns the index of the object in one of the Tilemaps arrays whose name
     * property matches the given `name`.
     *
     * @method Phaser.Tilemaps.Tilemap#getIndex
     * @since 3.0.0
     *
     * @param {array} location - The Tilemap array to search.
     * @param {string} name - The name of the array element to get.
     *
     * @return {number} The index of the element in the array, or null if not found.
     */getIndex:function(t,e){for(var i=0;i<t.length;i++)if(t[i].name===e)return i;return null},/**
     * Gets the LayerData from this.layers that is associated with `layer`, or null if an invalid
     * `layer` is given.
     *
     * @method Phaser.Tilemaps.Tilemap#getLayer
     * @since 3.0.0
     *
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the
     * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a
     * StaticTilemapLayer. If not given will default to the maps current layer index.
     *
     * @return {Phaser.Tilemaps.LayerData} The corresponding LayerData within this.layers.
     */getLayer:function(t){var e=this.getLayerIndex(t);return null!==e?this.layers[e]:null},/**
     * Gets the ObjectLayer from this.objects that has the given `name`, or null if no ObjectLayer
     * is found with that name.
     *
     * @method Phaser.Tilemaps.Tilemap#getObjectLayer
     * @since 3.0.0
     *
     * @param {string} [name] - The name of the object layer from Tiled.
     *
     * @return {?Phaser.Tilemaps.ObjectLayer} The corresponding ObjectLayer within this.objects or null.
     */getObjectLayer:function(t){var e=this.getIndex(this.objects,t);return null!==e?this.objects[e]:null},/**
     * Return a list of all valid objectgroup names loaded in this Tilemap.
     *
     * @method Phaser.Tilemaps.Tilemap#getObjectLayerNames
     * @since 3.21.0
     *
     * @return {string[]} Array of valid objectgroup names / IDs loaded into this Tilemap.
     */getObjectLayerNames:function(){return this.objects&&Array.isArray(this.objects)?this.objects.map(function(t){return t.name}):[]},/**
     * Gets the LayerData index of the given `layer` within this.layers, or null if an invalid
     * `layer` is given.
     *
     * @method Phaser.Tilemaps.Tilemap#getLayerIndex
     * @since 3.0.0
     *
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the
     * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a
     * StaticTilemapLayer. If not given will default to the map's current layer index.
     *
     * @return {integer} The LayerData index within this.layers.
     */getLayerIndex:function(t){return void 0===t?this.currentLayerIndex:"string"==typeof t?this.getLayerIndexByName(t):"number"==typeof t&&t<this.layers.length?t:t instanceof c||t instanceof r?t.layerIndex:null},/**
     * Gets the index of the LayerData within this.layers that has the given `name`, or null if an
     * invalid `name` is given.
     *
     * @method Phaser.Tilemaps.Tilemap#getLayerIndexByName
     * @since 3.0.0
     *
     * @param {string} name - The name of the layer to get.
     *
     * @return {integer} The LayerData index within this.layers.
     */getLayerIndexByName:function(t){return this.getIndex(this.layers,t)},/**
     * Gets a tile at the given tile coordinates from the given layer.
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#getTileAt
     * @since 3.0.0
     *
     * @param {integer} tileX - X position to get the tile from (given in tile units, not pixels).
     * @param {integer} tileY - Y position to get the tile from (given in tile units, not pixels).
     * @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.
     */getTileAt:function(t,e,i,n){return null===(n=this.getLayer(n))?null:f.GetTileAt(t,e,i,n)},/**
     * Gets a tile at the given world coordinates from the given layer.
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#getTileAtWorldXY
     * @since 3.0.0
     *
     * @param {number} worldX - X position to get the tile from (given in pixels)
     * @param {number} worldY - Y position to get the tile from (given in pixels)
     * @param {boolean} [nonNull=false] - If true, function won't return null for empty tiles, but a Tile object with an index of -1.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.
     */getTileAtWorldXY:function(t,e,i,n,s){return null===(s=this.getLayer(s))?null:f.GetTileAtWorldXY(t,e,i,n,s)},/**
     * Return a list of all valid tilelayer names loaded in this Tilemap.
     *
     * @method Phaser.Tilemaps.Tilemap#getTileLayerNames
     * @since 3.21.0
     *
     * @return {string[]} Array of valid tilelayer names / IDs loaded into this Tilemap.
     */getTileLayerNames:function(){return this.layers&&Array.isArray(this.layers)?this.layers.map(function(t){return t.name}):[]},/**
     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#getTilesWithin
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.
     */getTilesWithin:function(t,e,i,n,s,r){return null===(r=this.getLayer(r))?null:f.GetTilesWithin(t,e,i,n,s,r)},/**
     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,
     * Line, Rectangle or Triangle. The shape should be in world coordinates.
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#getTilesWithinShape
     * @since 3.0.0
     *
     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.
     */getTilesWithinShape:function(t,e,i,n){return null===(n=this.getLayer(n))?null:f.GetTilesWithinShape(t,e,i,n)},/**
     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#getTilesWithinWorldXY
     * @since 3.0.0
     *
     * @param {number} worldX - The world x coordinate for the top-left of the area.
     * @param {number} worldY - The world y coordinate for the top-left of the area.
     * @param {number} width - The width of the area.
     * @param {number} height - The height of the area.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.
     */getTilesWithinWorldXY:function(t,e,i,n,s,r,o){return null===(o=this.getLayer(o))?null:f.GetTilesWithinWorldXY(t,e,i,n,s,r,o)},/**
     * Gets the Tileset that has the given `name`, or null if an invalid `name` is given.
     *
     * @method Phaser.Tilemaps.Tilemap#getTileset
     * @since 3.14.0
     *
     * @param {string} name - The name of the Tileset to get.
     *
     * @return {?Phaser.Tilemaps.Tileset} The Tileset, or `null` if no matching named tileset was found.
     */getTileset:function(t){var e=this.getIndex(this.tilesets,t);return null!==e?this.tilesets[e]:null},/**
     * Gets the index of the Tileset within this.tilesets that has the given `name`, or null if an
     * invalid `name` is given.
     *
     * @method Phaser.Tilemaps.Tilemap#getTilesetIndex
     * @since 3.0.0
     *
     * @param {string} name - The name of the Tileset to get.
     *
     * @return {integer} The Tileset index within this.tilesets.
     */getTilesetIndex:function(t){return this.getIndex(this.tilesets,t)},/**
     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns
     * false if there is no tile or if the tile at that location has an index of -1.
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#hasTileAt
     * @since 3.0.0
     *
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?boolean} Returns a boolean, or null if the layer given was invalid.
     */hasTileAt:function(t,e,i){return null===(i=this.getLayer(i))?null:f.HasTileAt(t,e,i)},/**
     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns
     * false if there is no tile or if the tile at that location has an index of -1.
     *
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#hasTileAtWorldXY
     * @since 3.0.0
     *
     * @param {number} worldX - The x coordinate, in pixels.
     * @param {number} worldY - The y coordinate, in pixels.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?boolean} Returns a boolean, or null if the layer given was invalid.
     */hasTileAtWorldXY:function(t,e,i,n){return null===(n=this.getLayer(n))?null:f.HasTileAtWorldXY(t,e,i,n)},/**
     * The LayerData object that is currently selected in the map. You can set this property using
     * any type supported by setLayer.
     *
     * @name Phaser.Tilemaps.Tilemap#layer
     * @type {Phaser.Tilemaps.LayerData}
     * @since 3.0.0
     */layer:{get:function(){return this.layers[this.currentLayerIndex]},set:function(t){this.setLayer(t)}},/**
     * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index
     * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified
     * location. If you pass in an index, only the index at the specified location will be changed.
     * Collision information will be recalculated at the specified location.
     *
     * If no layer specified, the maps current layer is used.
     *
     * This cannot be applied to StaticTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#putTileAt
     * @since 3.0.0
     *
     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid or the coordinates were out of bounds.
     */putTileAt:function(t,e,i,n,s){return(s=this.getLayer(s),this._isStaticCall(s,"putTileAt")||null===s)?null:f.PutTileAt(t,e,i,n,s)},/**
     * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either
     * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the
     * specified location. If you pass in an index, only the index at the specified location will be
     * changed. Collision information will be recalculated at the specified location.
     *
     * If no layer specified, the maps current layer is used. This
     * cannot be applied to StaticTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#putTileAtWorldXY
     * @since 3.0.0
     *
     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.
     * @param {number} worldX - The x coordinate, in pixels.
     * @param {number} worldY - The y coordinate, in pixels.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.
     */putTileAtWorldXY:function(t,e,i,n,s,r){return(r=this.getLayer(r),this._isStaticCall(r,"putTileAtWorldXY")||null===r)?null:f.PutTileAtWorldXY(t,e,i,n,s,r)},/**
     * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified
     * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,
     * all attributes will be copied over to the specified location. If you pass in an index, only the
     * index at the specified location will be changed. Collision information will be recalculated
     * within the region tiles were changed.
     *
     * If no layer specified, the maps current layer is used.
     * This cannot be applied to StaticTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#putTilesAt
     * @since 3.0.0
     *
     * @param {(integer[]|integer[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.
     */putTilesAt:function(t,e,i,n,s){return(s=this.getLayer(s),this._isStaticCall(s,"putTilesAt"))?this:null===s?null:(f.PutTilesAt(t,e,i,n,s),this)},/**
     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the
     * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then
     * those will be used for randomly assigning new tile indexes. If an array is not provided, the
     * indexes found within the region (excluding -1) will be used for randomly assigning new tile
     * indexes. This method only modifies tile indexes and does not change collision information.
     *
     * If no layer specified, the maps current layer is used.
     * This cannot be applied to StaticTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#randomize
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {integer[]} [indexes] - An array of indexes to randomly draw from during randomization.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.
     */randomize:function(t,e,i,n,s,r){return(r=this.getLayer(r),this._isStaticCall(r,"randomize"))?this:null===r?null:(f.Randomize(t,e,i,n,s,r),this)},/**
     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting
     * faces are used internally for optimizing collisions against tiles. This method is mostly used
     * internally to optimize recalculating faces when only one tile has been changed.
     *
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#calculateFacesAt
     * @since 3.0.0
     *
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.
     */calculateFacesAt:function(t,e,i){return null===(i=this.getLayer(i))?null:(f.CalculateFacesAt(t,e,i),this)},/**
     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the
     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method
     * is mostly used internally.
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#calculateFacesWithin
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.
     */calculateFacesWithin:function(t,e,i,n,s){return null===(s=this.getLayer(s))?null:(f.CalculateFacesWithin(t,e,i,n,s),this)},/**
     * Removes the given TilemapLayer from this Tilemap without destroying it.
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#removeLayer
     * @since 3.17.0
     *
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to be removed.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.
     */removeLayer:function(t){var e=this.getLayerIndex(t);if(null===e)return null;u(this.layers,e);for(var i=e;i<this.layers.length;i++)this.layers[i].tilemapLayer&&this.layers[i].tilemapLayer.layerIndex--;return this.currentLayerIndex===e&&(this.currentLayerIndex=0),this},/**
     * Destroys the given TilemapLayer and removes it from this Tilemap.
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#destroyLayer
     * @since 3.17.0
     *
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to be destroyed.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.
     */destroyLayer:function(t){var e=this.getLayerIndex(t);return null!==e?((t=this.layers[e]).destroy(),u(this.layers,e),this.currentLayerIndex===e&&(this.currentLayerIndex=0),this):null},/**
     * Removes all layers from this Tilemap and destroys any associated StaticTilemapLayers or
     * DynamicTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#removeAllLayers
     * @since 3.0.0
     *
     * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.
     */removeAllLayers:function(){// Destroy any StaticTilemapLayers or DynamicTilemapLayers that are stored in LayerData
for(var t=this.layers,e=0;e<t.length;e++)t[e].tilemapLayer&&t[e].tilemapLayer.destroy(!1);return t.length=0,this.currentLayerIndex=0,this},/**
     * Removes the given Tile, or an array of Tiles, from the layer to which they belong,
     * and optionally recalculates the collision information.
     *
     * This cannot be applied to Tiles that belong to Static Tilemap Layers.
     *
     * @method Phaser.Tilemaps.Tilemap#removeTile
     * @since 3.17.0
     *
     * @param {(Phaser.Tilemaps.Tile|Phaser.Tilemaps.Tile[])} tiles - The Tile to remove, or an array of Tiles.
     * @param {integer} [replaceIndex=-1] - After removing the Tile, insert a brand new Tile into its location with the given index. Leave as -1 to just remove the tile.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     *
     * @return {Phaser.Tilemaps.Tile[]} Returns an array of Tiles that were removed.
     */removeTile:function(t,e,i){void 0===e&&(e=-1),void 0===i&&(i=!0);var n=[];Array.isArray(t)||(t=[t]);for(var s=0;s<t.length;s++){var r=t[s];n.push(this.removeTileAt(r.x,r.y,!0,i,r.tilemapLayer)),e>-1&&this.putTileAt(e,r.x,r.y,i,r.tilemapLayer)}return n},/**
     * Removes the tile at the given tile coordinates in the specified layer and updates the layer's
     * collision information.
     *
     * If no layer specified, the maps current layer is used.
     * This cannot be applied to StaticTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#removeTileAt
     * @since 3.0.0
     *
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tile} Returns the Tile that was removed, or null if the layer given was invalid.
     */removeTileAt:function(t,e,i,n,s){return(s=this.getLayer(s),this._isStaticCall(s,"removeTileAt")||null===s)?null:f.RemoveTileAt(t,e,i,n,s)},/**
     * Removes the tile at the given world coordinates in the specified layer and updates the layer's
     * collision information.
     *
     * If no layer specified, the maps current layer is used.
     * This cannot be applied to StaticTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#removeTileAtWorldXY
     * @since 3.0.0
     *
     * @param {number} worldX - The x coordinate, in pixels.
     * @param {number} worldY - The y coordinate, in pixels.
     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.
     */removeTileAtWorldXY:function(t,e,i,n,s,r){return(r=this.getLayer(r),this._isStaticCall(r,"removeTileAtWorldXY")||null===r)?null:f.RemoveTileAtWorldXY(t,e,i,n,s,r)},/**
     * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to
     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles
     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation
     * wherever you want on the screen.
     *
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#renderDebug
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.
     * @param {Phaser.Types.Tilemaps.StyleConfig} styleConfig - An object specifying the colors to use for the debug drawing.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */renderDebug:function(t,e,i){return null===(i=this.getLayer(i))?null:(f.RenderDebug(t,e,i),this)},/**
     * Draws a debug representation of all layers within this Tilemap to the given Graphics object.
     *
     * This is helpful when you want to get a quick idea of which of your tiles are colliding and which
     * have interesting faces. The tiles are drawn starting at (0, 0) in the Graphics, allowing you to
     * place the debug representation wherever you want on the screen.
     *
     * @method Phaser.Tilemaps.Tilemap#renderDebugFull
     * @since 3.17.0
     *
     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.
     * @param {Phaser.Types.Tilemaps.StyleConfig} styleConfig - An object specifying the colors to use for the debug drawing.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */renderDebugFull:function(t,e){// Destroy any StaticTilemapLayers or DynamicTilemapLayers that are stored in LayerData
for(var i=this.layers,n=0;n<i.length;n++)f.RenderDebug(t,e,i[n]);return this},/**
     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching
     * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does
     * not change collision information.
     *
     * If no layer specified, the maps current layer is used.
     * This cannot be applied to StaticTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#replaceByIndex
     * @since 3.0.0
     *
     * @param {integer} findIndex - The index of the tile to search for.
     * @param {integer} newIndex - The index of the tile to replace it with.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */replaceByIndex:function(t,e,i,n,s,r,o){return(o=this.getLayer(o),this._isStaticCall(o,"replaceByIndex"))?this:null===o?null:(f.ReplaceByIndex(t,e,i,n,s,r,o),this)},/**
     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a
     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if
     * collision will be enabled (true) or disabled (false).
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#setCollision
     * @since 3.0.0
     *
     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes.
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */setCollision:function(t,e,i,n,s){return null===(n=this.getLayer(n))?null:(f.SetCollision(t,e,i,n,s),this)},/**
     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and
     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set
     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be
     * enabled (true) or disabled (false).
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#setCollisionBetween
     * @since 3.0.0
     *
     * @param {integer} start - The first index of the tile to be set for collision.
     * @param {integer} stop - The last index of the tile to be set for collision.
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */setCollisionBetween:function(t,e,i,n,s){return null===(s=this.getLayer(s))?null:(f.SetCollisionBetween(t,e,i,n,s),this)},/**
     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property
     * that matches the given properties object, its collision flag will be set. The `collides`
     * parameter controls if collision will be enabled (true) or disabled (false). Passing in
     * `{ collides: true }` would update the collision flag on any tiles with a "collides" property that
     * has a value of true. Any tile that doesn't have "collides" set to true will be ignored. You can
     * also use an array of values, e.g. `{ types: ["stone", "lava", "sand" ] }`. If a tile has a
     * "types" property that matches any of those values, its collision flag will be updated.
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#setCollisionByProperty
     * @since 3.0.0
     *
     * @param {object} properties - An object with tile properties and corresponding values that should be checked.
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */setCollisionByProperty:function(t,e,i,n){return null===(n=this.getLayer(n))?null:(f.SetCollisionByProperty(t,e,i,n),this)},/**
     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in
     * the given array. The `collides` parameter controls if collision will be enabled (true) or
     * disabled (false).
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#setCollisionByExclusion
     * @since 3.0.0
     *
     * @param {integer[]} indexes - An array of the tile indexes to not be counted for collision.
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */setCollisionByExclusion:function(t,e,i,n){return null===(n=this.getLayer(n))?null:(f.SetCollisionByExclusion(t,e,i,n),this)},/**
     * Sets collision on the tiles within a layer by checking each tile's collision group data
     * (typically defined in Tiled within the tileset collision editor). If any objects are found within
     * a tile's collision group, the tile's colliding information will be set. The `collides` parameter
     * controls if collision will be enabled (true) or disabled (false).
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#setCollisionFromCollisionGroup
     * @since 3.0.0
     *
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */setCollisionFromCollisionGroup:function(t,e,i){return null===(i=this.getLayer(i))?null:(f.SetCollisionFromCollisionGroup(t,e,i),this)},/**
     * Sets a global collision callback for the given tile index within the layer. This will affect all
     * tiles on this layer that have the same index. If a callback is already set for the tile index it
     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile
     * at a specific location on the map then see setTileLocationCallback.
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#setTileIndexCallback
     * @since 3.0.0
     *
     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for.
     * @param {function} callback - The callback that will be invoked when the tile is collided with.
     * @param {object} callbackContext - The context under which the callback is called.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */setTileIndexCallback:function(t,e,i,n){return null===(n=this.getLayer(n))?null:(f.SetTileIndexCallback(t,e,i,n),this)},/**
     * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.
     * If a callback is already set for the tile index it will be replaced. Set the callback to null to
     * remove it.
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#setTileLocationCallback
     * @since 3.0.0
     *
     * @param {integer} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} width - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} height - How many tiles tall from the `tileY` index the area will be.
     * @param {function} callback - The callback that will be invoked when the tile is collided with.
     * @param {object} [callbackContext] - The context under which the callback is called.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */setTileLocationCallback:function(t,e,i,n,s,r,o){return null===(o=this.getLayer(o))?null:(f.SetTileLocationCallback(t,e,i,n,s,r,o),this)},/**
     * Sets the current layer to the LayerData associated with `layer`.
     *
     * @method Phaser.Tilemaps.Tilemap#setLayer
     * @since 3.0.0
     *
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the
     * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a
     * StaticTilemapLayer. If not given will default to the map's current layer index.
     *
     * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.
     */setLayer:function(t){var e=this.getLayerIndex(t);return null!==e&&(this.currentLayerIndex=e),this},/**
     * Sets the base tile size for the map. Note: this does not necessarily match the tileWidth and
     * tileHeight for all layers. This also updates the base size on all tiles across all layers.
     *
     * @method Phaser.Tilemaps.Tilemap#setBaseTileSize
     * @since 3.0.0
     *
     * @param {integer} tileWidth - The width of the tiles the map uses for calculations.
     * @param {integer} tileHeight - The height of the tiles the map uses for calculations.
     *
     * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.
     */setBaseTileSize:function(t,e){this.tileWidth=t,this.tileHeight=e,this.widthInPixels=this.width*t,this.heightInPixels=this.height*e;// Update the base tile size on all layers & tiles
for(var i=0;i<this.layers.length;i++){this.layers[i].baseTileWidth=t,this.layers[i].baseTileHeight=e;for(var n=this.layers[i].data,s=this.layers[i].width,r=this.layers[i].height,o=0;o<r;o++)for(var a=0;a<s;a++){var h=n[o][a];null!==h&&h.setSize(void 0,void 0,t,e)}}return this},/**
     * Sets the tile size for a specific `layer`. Note: this does not necessarily match the map's
     * tileWidth and tileHeight for all layers. This will set the tile size for the layer and any
     * tiles the layer has.
     *
     * @method Phaser.Tilemaps.Tilemap#setLayerTileSize
     * @since 3.0.0
     *
     * @param {integer} tileWidth - The width of the tiles (in pixels) in the layer.
     * @param {integer} tileHeight - The height of the tiles (in pixels) in the layer.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the
     * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a
     * StaticTilemapLayer. If not given will default to the map's current layer index.
     *
     * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.
     */setLayerTileSize:function(t,e,i){if(null===(i=this.getLayer(i)))return this;i.tileWidth=t,i.tileHeight=e;for(var n=i.data,s=i.width,r=i.height,o=0;o<r;o++)for(var a=0;a<s;a++){var h=n[o][a];null!==h&&h.setSize(t,e)}return this},/**
     * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given
     * layer. It will only randomize the tiles in that area, so if they're all the same nothing will
     * appear to have changed! This method only modifies tile indexes and does not change collision
     * information.
     *
     * If no layer specified, the maps current layer is used.
     * This cannot be applied to StaticTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#shuffle
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */shuffle:function(t,e,i,n,s){return(s=this.getLayer(s),this._isStaticCall(s,"shuffle"))?this:null===s?null:(f.Shuffle(t,e,i,n,s),this)},/**
     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching
     * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision
     * information.
     *
     * If no layer specified, the maps current layer is used.
     * This cannot be applied to StaticTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#swapByIndex
     * @since 3.0.0
     *
     * @param {integer} tileA - First tile index.
     * @param {integer} tileB - Second tile index.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */swapByIndex:function(t,e,i,n,s,r,o){return(o=this.getLayer(o),this._isStaticCall(o,"swapByIndex"))?this:null===o?null:(f.SwapByIndex(t,e,i,n,s,r,o),this)},/**
     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the
     * layers position, scale and scroll.
     *
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#tileToWorldX
     * @since 3.0.0
     *
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?number} Returns a number, or null if the layer given was invalid.
     */tileToWorldX:function(t,e,i){return null===(i=this.getLayer(i))?null:f.TileToWorldX(t,e,i)},/**
     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the
     * layers position, scale and scroll.
     *
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#tileToWorldY
     * @since 3.0.0
     *
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer
     * to use. If not given the current layer is used.
     *
     * @return {?number} Returns a number, or null if the layer given was invalid.
     */tileToWorldY:function(t,e,i){return null===(i=this.getLayer(i))?null:f.TileToWorldY(t,e,i)},/**
     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the
     * layers position, scale and scroll. This will return a new Vector2 object or update the given
     * `point` object.
     *
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#tileToWorldXY
     * @since 3.0.0
     *
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Math.Vector2} Returns a point, or null if the layer given was invalid.
     */tileToWorldXY:function(t,e,i,n,s){return null===(s=this.getLayer(s))?null:f.TileToWorldXY(t,e,i,n,s)},/**
     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the
     * specified layer. Each tile will receive a new index. New indexes are drawn from the given
     * weightedIndexes array. An example weighted array:
     *
     * [
     *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8
     *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8
     *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8
     *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8
     * ]
     *
     * The probability of any index being choose is (the index's weight) / (sum of all weights). This
     * method only modifies tile indexes and does not change collision information.
     *
     * If no layer specified, the map's current layer is used. This
     * cannot be applied to StaticTilemapLayers.
     *
     * @method Phaser.Tilemaps.Tilemap#weightedRandomize
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {object[]} [weightedIndexes] - An array of objects to randomly draw from during
     * randomization. They should be in the form: { index: 0, weight: 4 } or
     * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */weightedRandomize:function(t,e,i,n,s,r){return(r=this.getLayer(r),this._isStaticCall(r,"weightedRandomize"))?this:null===r?null:(f.WeightedRandomize(t,e,i,n,s,r),this)},/**
     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the
     * layers position, scale and scroll.
     *
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#worldToTileX
     * @since 3.0.0
     *
     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.
     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the nearest integer.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer
     * to use. If not given the current layer is used.
     *
     * @return {?number} Returns a number, or null if the layer given was invalid.
     */worldToTileX:function(t,e,i,n){return null===(n=this.getLayer(n))?null:f.WorldToTileX(t,e,i,n)},/**
     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the
     * layers position, scale and scroll.
     *
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#worldToTileY
     * @since 3.0.0
     *
     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.
     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the nearest integer.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?number} Returns a number, or null if the layer given was invalid.
     */worldToTileY:function(t,e,i,n){return null===(n=this.getLayer(n))?null:f.WorldToTileY(t,e,i,n)},/**
     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the
     * layers position, scale and scroll. This will return a new Vector2 object or update the given
     * `point` object.
     *
     * If no layer specified, the maps current layer is used.
     *
     * @method Phaser.Tilemaps.Tilemap#worldToTileXY
     * @since 3.0.0
     *
     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.
     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.
     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the nearest integer.
     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.
     *
     * @return {?Phaser.Math.Vector2} Returns a point, or null if the layer given was invalid.
     */worldToTileXY:function(t,e,i,n,s,r){return null===(r=this.getLayer(r))?null:f.WorldToTileXY(t,e,i,n,s,r)},/**
     * Used internally to check if a layer is static and prints out a warning.
     *
     * @method Phaser.Tilemaps.Tilemap#_isStaticCall
     * @private
     * @since 3.0.0
     *
     * @return {boolean}
     */_isStaticCall:function(t,e){return t.tilemapLayer instanceof c&&(console.warn(e+": You cannot change the tiles in a static tilemap layer"),!0)}});t.exports=g}),r("3DUwP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("bit0e"),o=s("1zqlR"),a=s("hequO"),h=new i({Extends:o,Mixins:[n.Alpha,n.BlendMode,n.ComputedSize,n.Depth,n.Flip,n.GetBounds,n.Origin,n.Pipeline,n.Transform,n.Visible,n.ScrollFactor,r],initialize:function(t,e,i,n,s,r){o.call(this,t,"DynamicTilemapLayer"),/**
         * Used internally by physics system to perform fast type checks.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#isTilemap
         * @type {boolean}
         * @readonly
         * @since 3.0.0
         */this.isTilemap=!0,/**
         * The Tilemap that this layer is a part of.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#tilemap
         * @type {Phaser.Tilemaps.Tilemap}
         * @since 3.0.0
         */this.tilemap=e,/**
         * The index of the LayerData associated with this layer.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#layerIndex
         * @type {integer}
         * @since 3.0.0
         */this.layerIndex=i,/**
         * The LayerData associated with this layer. LayerData can only be associated with one
         * tilemap layer.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#layer
         * @type {Phaser.Tilemaps.LayerData}
         * @since 3.0.0
         */this.layer=e.layers[i],// Link the LayerData with this static tilemap layer
this.layer.tilemapLayer=this,/**
         * The Tileset/s associated with this layer.
         * 
         * As of Phaser 3.14 this property is now an array of Tileset objects, previously it was a single reference.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#tileset
         * @type {Phaser.Tilemaps.Tileset[]}
         * @since 3.0.0
         */this.tileset=[],/**
         * Used internally with the canvas render. This holds the tiles that are visible within the
         * camera.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#culledTiles
         * @type {array}
         * @since 3.0.0
         */this.culledTiles=[],/**
         * You can control if the Cameras should cull tiles before rendering them or not.
         * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.
         *
         * However, there are some instances when you may wish to disable this, and toggling this flag allows
         * you to do so. Also see `setSkipCull` for a chainable method that does the same thing.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#skipCull
         * @type {boolean}
         * @since 3.11.0
         */this.skipCull=!1,/**
         * The total number of tiles drawn by the renderer in the last frame.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#tilesDrawn
         * @type {integer}
         * @readonly
         * @since 3.11.0
         */this.tilesDrawn=0,/**
         * The total number of tiles in this layer. Updated every frame.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#tilesTotal
         * @type {integer}
         * @readonly
         * @since 3.11.0
         */this.tilesTotal=this.layer.width*this.layer.height,/**
         * The amount of extra tiles to add into the cull rectangle when calculating its horizontal size.
         *
         * See the method `setCullPadding` for more details.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#cullPaddingX
         * @type {integer}
         * @default 1
         * @since 3.11.0
         */this.cullPaddingX=1,/**
         * The amount of extra tiles to add into the cull rectangle when calculating its vertical size.
         *
         * See the method `setCullPadding` for more details.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#cullPaddingY
         * @type {integer}
         * @default 1
         * @since 3.11.0
         */this.cullPaddingY=1,/**
         * The callback that is invoked when the tiles are culled.
         *
         * By default it will call `TilemapComponents.CullTiles` but you can override this to call any function you like.
         *
         * It will be sent 3 arguments:
         *
         * 1. The Phaser.Tilemaps.LayerData object for this Layer
         * 2. The Camera that is culling the layer. You can check its `dirty` property to see if it has changed since the last cull.
         * 3. A reference to the `culledTiles` array, which should be used to store the tiles you want rendered.
         *
         * See the `TilemapComponents.CullTiles` source code for details on implementing your own culling system.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#cullCallback
         * @type {function}
         * @since 3.11.0
         */this.cullCallback=a.CullTiles,/**
         * The rendering (draw) order of the tiles in this layer.
         * 
         * The default is 0 which is 'right-down', meaning it will draw the tiles starting from the top-left,
         * drawing to the right and then moving down to the next row.
         * 
         * The draw orders are:
         * 
         * 0 = right-down
         * 1 = left-down
         * 2 = right-up
         * 3 = left-up
         * 
         * This can be changed via the `setRenderOrder` method.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#_renderOrder
         * @type {integer}
         * @default 0
         * @private
         * @since 3.12.0
         */this._renderOrder=0,/**
         * An array holding the mapping between the tile indexes and the tileset they belong to.
         *
         * @name Phaser.Tilemaps.DynamicTilemapLayer#gidMap
         * @type {Phaser.Tilemaps.Tileset[]}
         * @since 3.14.0
         */this.gidMap=[],this.setTilesets(n),this.setAlpha(this.layer.alpha),this.setPosition(s,r),this.setOrigin(),this.setSize(e.tileWidth*this.layer.width,e.tileHeight*this.layer.height),this.initPipeline("TextureTintPipeline")},/**
     * Populates the internal `tileset` array with the Tileset references this Layer requires for rendering.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#setTilesets
     * @private
     * @since 3.14.0
     * 
     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.
     */setTilesets:function(t){var e=[],i=[],n=this.tilemap;Array.isArray(t)||(t=[t]);for(var s=0;s<t.length;s++){var r=t[s];if("string"==typeof r&&(r=n.getTileset(r)),r){i.push(r);for(var o=r.firstgid,a=0;a<r.total;a++)e[o+a]=r}}this.gidMap=e,this.tileset=i},/**
     * Sets the rendering (draw) order of the tiles in this layer.
     * 
     * The default is 'right-down', meaning it will order the tiles starting from the top-left,
     * drawing to the right and then moving down to the next row.
     * 
     * The draw orders are:
     * 
     * 0 = right-down
     * 1 = left-down
     * 2 = right-up
     * 3 = left-up
     * 
     * Setting the render order does not change the tiles or how they are stored in the layer,
     * it purely impacts the order in which they are rendered.
     * 
     * You can provide either an integer (0 to 3), or the string version of the order.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#setRenderOrder
     * @since 3.12.0
     *
     * @param {(integer|string)} renderOrder - The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.
     *
     * @return {this} This Tilemap Layer object.
     */setRenderOrder:function(t){return"string"==typeof t&&(t=["right-down","left-down","right-up","left-up"].indexOf(t)),t>=0&&t<4&&(this._renderOrder=t),this},/**
     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting
     * faces are used internally for optimizing collisions against tiles. This method is mostly used
     * internally to optimize recalculating faces when only one tile has been changed.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#calculateFacesAt
     * @since 3.0.0
     *
     * @param {integer} tileX - The x coordinate.
     * @param {integer} tileY - The y coordinate.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */calculateFacesAt:function(t,e){return a.CalculateFacesAt(t,e,this.layer),this},/**
     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the
     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method
     * is mostly used internally.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#calculateFacesWithin
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */calculateFacesWithin:function(t,e,i,n){return a.CalculateFacesWithin(t,e,i,n,this.layer),this},/**
     * Creates a Sprite for every object matching the given tile indexes in the layer. You can
     * optionally specify if each tile will be replaced with a new tile after the Sprite has been
     * created. This is useful if you want to lay down special tiles in a level that are converted to
     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#createFromTiles
     * @since 3.0.0
     *
     * @param {(integer|array)} indexes - The tile index, or array of indexes, to create Sprites from.
     * @param {(integer|array)} replacements - The tile index, or array of indexes, to change a converted
     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a
     * one-to-one mapping with the indexes array.
     * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e.
     * scene.make.sprite).
     * @param {Phaser.Scene} [scene=scene the map is within] - The Scene to create the Sprites within.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when determining the world XY
     *
     * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.
     */createFromTiles:function(t,e,i,n,s){return a.CreateFromTiles(t,e,i,n,s,this.layer)},/**
     * Returns the tiles in the given layer that are within the cameras viewport.
     * This is used internally.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#cull
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.
     *
     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.
     */cull:function(t){return this.cullCallback(this.layer,t,this.culledTiles,this._renderOrder)},/**
     * Copies the tiles in the source rectangular area to a new destination (all specified in tile
     * coordinates) within the layer. This copies all tile properties & recalculates collision
     * information in the destination region.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#copy
     * @since 3.0.0
     *
     * @param {integer} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.
     * @param {integer} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.
     * @param {integer} width - The width of the area to copy, in tiles, not pixels.
     * @param {integer} height - The height of the area to copy, in tiles, not pixels.
     * @param {integer} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.
     * @param {integer} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */copy:function(t,e,i,n,s,r,o){return a.Copy(t,e,i,n,s,r,o,this.layer),this},/**
     * Destroys this DynamicTilemapLayer and removes its link to the associated LayerData.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#destroy
     * @since 3.0.0
     * 
     * @param {boolean} [removeFromTilemap=true] - Remove this layer from the parent Tilemap?
     */destroy:function(t){void 0===t&&(t=!0),this.tilemap&&(this.layer.tilemapLayer===this&&(this.layer.tilemapLayer=void 0),t&&this.tilemap.removeLayer(this),this.tilemap=void 0,this.layer=void 0,this.culledTiles.length=0,this.cullCallback=null,this.gidMap=[],this.tileset=[],o.prototype.destroy.call(this))},/**
     * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the
     * specified index. Tiles will be set to collide if the given index is a colliding index.
     * Collision information in the region will be recalculated.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#fill
     * @since 3.0.0
     *
     * @param {integer} index - The tile index to fill the area with.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */fill:function(t,e,i,n,s,r){return a.Fill(t,e,i,n,s,r,this.layer),this},/**
     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns
     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#filterTiles
     * @since 3.0.0
     *
     * @param {function} callback - The callback. Each tile in the given area will be passed to this
     * callback as the first and only parameter. The callback should return true for tiles that pass the
     * filter.
     * @param {object} [context] - The context under which the callback should be run.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to filter.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area to filter.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     *
     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.
     */filterTiles:function(t,e,i,n,s,r,o){return a.FilterTiles(t,e,i,n,s,r,o,this.layer)},/**
     * Searches the entire map layer for the first tile matching the given index, then returns that Tile
     * object. If no match is found, it returns null. The search starts from the top-left tile and
     * continues horizontally until it hits the end of the row, then it drops down to the next column.
     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to
     * the top-left.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#findByIndex
     * @since 3.0.0
     *
     * @param {integer} index - The tile index value to search for.
     * @param {integer} [skip=0] - The number of times to skip a matching tile before returning.
     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the
     * bottom-right. Otherwise it scans from the top-left.
     *
     * @return {Phaser.Tilemaps.Tile} A Tile object.
     */findByIndex:function(t,e,i){return a.FindByIndex(t,e,i,this.layer)},/**
     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that
     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns
     * true. Similar to Array.prototype.find in vanilla JS.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#findTile
     * @since 3.0.0
     *
     * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.
     * @param {object} [context] - The context under which the callback should be run.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to search.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area to search.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     *
     * @return {?Phaser.Tilemaps.Tile}
     */findTile:function(t,e,i,n,s,r,o){return a.FindTile(t,e,i,n,s,r,o,this.layer)},/**
     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
     * callback. Similar to Array.prototype.forEach in vanilla JS.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#forEachTile
     * @since 3.0.0
     *
     * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.
     * @param {object} [context] - The context under which the callback should be run.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to search.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area to search.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */forEachTile:function(t,e,i,n,s,r,o){return a.ForEachTile(t,e,i,n,s,r,o,this.layer),this},/**
     * Gets a tile at the given tile coordinates from the given layer.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#getTileAt
     * @since 3.0.0
     *
     * @param {integer} tileX - X position to get the tile from (given in tile units, not pixels).
     * @param {integer} tileY - Y position to get the tile from (given in tile units, not pixels).
     * @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.
     *
     * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.
     */getTileAt:function(t,e,i){return a.GetTileAt(t,e,i,this.layer)},/**
     * Gets a tile at the given world coordinates from the given layer.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#getTileAtWorldXY
     * @since 3.0.0
     *
     * @param {number} worldX - X position to get the tile from (given in pixels)
     * @param {number} worldY - Y position to get the tile from (given in pixels)
     * @param {boolean} [nonNull=false] - If true, function won't return null for empty tiles, but a Tile object with an index of -1.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates
     * were invalid.
     */getTileAtWorldXY:function(t,e,i,n){return a.GetTileAtWorldXY(t,e,i,n,this.layer)},/**
     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#getTilesWithin
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     *
     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.
     */getTilesWithin:function(t,e,i,n,s){return a.GetTilesWithin(t,e,i,n,s,this.layer)},/**
     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,
     * Line, Rectangle or Triangle. The shape should be in world coordinates.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#getTilesWithinShape
     * @since 3.0.0
     *
     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.
     *
     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.
     */getTilesWithinShape:function(t,e,i){return a.GetTilesWithinShape(t,e,i,this.layer)},/**
     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#getTilesWithinWorldXY
     * @since 3.0.0
     *
     * @param {number} worldX - The world x coordinate for the top-left of the area.
     * @param {number} worldY - The world y coordinate for the top-left of the area.
     * @param {number} width - The width of the area.
     * @param {number} height - The height of the area.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.
     *
     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.
     */getTilesWithinWorldXY:function(t,e,i,n,s,r){return a.GetTilesWithinWorldXY(t,e,i,n,s,r,this.layer)},/**
     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns
     * false if there is no tile or if the tile at that location has an index of -1.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#hasTileAt
     * @since 3.0.0
     *
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     *
     * @return {boolean} `true` if a tile was found at the given location, otherwise `false`.
     */hasTileAt:function(t,e){return a.HasTileAt(t,e,this.layer)},/**
     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns
     * false if there is no tile or if the tile at that location has an index of -1.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#hasTileAtWorldXY
     * @since 3.0.0
     *
     * @param {number} worldX - The x coordinate, in pixels.
     * @param {number} worldY - The y coordinate, in pixels.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.
     *
     * @return {boolean} `true` if a tile was found at the given location, otherwise `false`.
     */hasTileAtWorldXY:function(t,e,i){return a.HasTileAtWorldXY(t,e,i,this.layer)},/**
     * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index
     * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified
     * location. If you pass in an index, only the index at the specified location will be changed.
     * Collision information will be recalculated at the specified location.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#putTileAt
     * @since 3.0.0
     *
     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     *
     * @return {Phaser.Tilemaps.Tile} A Tile object.
     */putTileAt:function(t,e,i,n){return a.PutTileAt(t,e,i,n,this.layer)},/**
     * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either
     * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the
     * specified location. If you pass in an index, only the index at the specified location will be
     * changed. Collision information will be recalculated at the specified location.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#putTileAtWorldXY
     * @since 3.0.0
     *
     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.
     * @param {number} worldX - The x coordinate, in pixels.
     * @param {number} worldY - The y coordinate, in pixels.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {Phaser.Tilemaps.Tile} A Tile object.
     */putTileAtWorldXY:function(t,e,i,n,s){return a.PutTileAtWorldXY(t,e,i,n,s,this.layer)},/**
     * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified
     * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,
     * all attributes will be copied over to the specified location. If you pass in an index, only the
     * index at the specified location will be changed. Collision information will be recalculated
     * within the region tiles were changed.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#putTilesAt
     * @since 3.0.0
     *
     * @param {(integer[]|integer[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */putTilesAt:function(t,e,i,n){return a.PutTilesAt(t,e,i,n,this.layer),this},/**
     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the
     * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then
     * those will be used for randomly assigning new tile indexes. If an array is not provided, the
     * indexes found within the region (excluding -1) will be used for randomly assigning new tile
     * indexes. This method only modifies tile indexes and does not change collision information.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#randomize
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {integer[]} [indexes] - An array of indexes to randomly draw from during randomization.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */randomize:function(t,e,i,n,s){return a.Randomize(t,e,i,n,s,this.layer),this},/**
     * Removes the tile at the given tile coordinates in the specified layer and updates the layer's
     * collision information.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#removeTileAt
     * @since 3.0.0
     *
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     *
     * @return {Phaser.Tilemaps.Tile} A Tile object.
     */removeTileAt:function(t,e,i,n){return a.RemoveTileAt(t,e,i,n,this.layer)},/**
     * Removes the tile at the given world coordinates in the specified layer and updates the layer's
     * collision information.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#removeTileAtWorldXY
     * @since 3.0.0
     *
     * @param {number} worldX - The x coordinate, in pixels.
     * @param {number} worldY - The y coordinate, in pixels.
     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.
     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {Phaser.Tilemaps.Tile} A Tile object.
     */removeTileAtWorldXY:function(t,e,i,n,s){return a.RemoveTileAtWorldXY(t,e,i,n,s,this.layer)},/**
     * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to
     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles
     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation
     * wherever you want on the screen.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#renderDebug
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.
     * @param {Phaser.Types.Tilemaps.StyleConfig} styleConfig - An object specifying the colors to use for the debug drawing.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */renderDebug:function(t,e){return a.RenderDebug(t,e,this.layer),this},/**
     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching
     * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does
     * not change collision information.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#replaceByIndex
     * @since 3.0.0
     *
     * @param {integer} findIndex - The index of the tile to search for.
     * @param {integer} newIndex - The index of the tile to replace it with.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */replaceByIndex:function(t,e,i,n,s,r){return a.ReplaceByIndex(t,e,i,n,s,r,this.layer),this},/**
     * You can control if the Cameras should cull tiles before rendering them or not.
     * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.
     *
     * However, there are some instances when you may wish to disable this.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#setSkipCull
     * @since 3.11.0
     *
     * @param {boolean} [value=true] - Set to `true` to stop culling tiles. Set to `false` to enable culling again.
     *
     * @return {this} This Tilemap Layer object.
     */setSkipCull:function(t){return void 0===t&&(t=!0),this.skipCull=t,this},/**
     * When a Camera culls the tiles in this layer it does so using its view into the world, building up a
     * rectangle inside which the tiles must exist or they will be culled. Sometimes you may need to expand the size
     * of this 'cull rectangle', especially if you plan on rotating the Camera viewing the layer. Do so
     * by providing the padding values. The values given are in tiles, not pixels. So if the tile width was 32px
     * and you set `paddingX` to be 4, it would add 32px x 4 to the cull rectangle (adjusted for scale)
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#setCullPadding
     * @since 3.11.0
     *
     * @param {integer} [paddingX=1] - The amount of extra horizontal tiles to add to the cull check padding.
     * @param {integer} [paddingY=1] - The amount of extra vertical tiles to add to the cull check padding.
     *
     * @return {this} This Tilemap Layer object.
     */setCullPadding:function(t,e){return void 0===t&&(t=1),void 0===e&&(e=1),this.cullPaddingX=t,this.cullPaddingY=e,this},/**
     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a
     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if
     * collision will be enabled (true) or disabled (false).
     *
     * If no layer specified, the map's current layer is used.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#setCollision
     * @since 3.0.0
     *
     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes.
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.
     * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to
     * false if no tiles have been placed for significant performance boost.
     *
     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.
     */setCollision:function(t,e,i,n){return a.SetCollision(t,e,i,this.layer,n),this},/**
     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and
     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set
     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be
     * enabled (true) or disabled (false).
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#setCollisionBetween
     * @since 3.0.0
     *
     * @param {integer} start - The first index of the tile to be set for collision.
     * @param {integer} stop - The last index of the tile to be set for collision.
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */setCollisionBetween:function(t,e,i,n){return a.SetCollisionBetween(t,e,i,n,this.layer),this},/**
     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property
     * that matches the given properties object, its collision flag will be set. The `collides`
     * parameter controls if collision will be enabled (true) or disabled (false). Passing in
     * `{ collides: true }` would update the collision flag on any tiles with a "collides" property that
     * has a value of true. Any tile that doesn't have "collides" set to true will be ignored. You can
     * also use an array of values, e.g. `{ types: ["stone", "lava", "sand" ] }`. If a tile has a
     * "types" property that matches any of those values, its collision flag will be updated.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#setCollisionByProperty
     * @since 3.0.0
     *
     * @param {object} properties - An object with tile properties and corresponding values that should be checked.
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */setCollisionByProperty:function(t,e,i){return a.SetCollisionByProperty(t,e,i,this.layer),this},/**
     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in
     * the given array. The `collides` parameter controls if collision will be enabled (true) or
     * disabled (false).
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#setCollisionByExclusion
     * @since 3.0.0
     *
     * @param {integer[]} indexes - An array of the tile indexes to not be counted for collision.
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */setCollisionByExclusion:function(t,e,i){return a.SetCollisionByExclusion(t,e,i,this.layer),this},/**
     * Sets collision on the tiles within a layer by checking each tiles collision group data
     * (typically defined in Tiled within the tileset collision editor). If any objects are found within
     * a tiles collision group, the tile's colliding information will be set. The `collides` parameter
     * controls if collision will be enabled (true) or disabled (false).
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#setCollisionFromCollisionGroup
     * @since 3.0.0
     *
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */setCollisionFromCollisionGroup:function(t,e){return a.SetCollisionFromCollisionGroup(t,e,this.layer),this},/**
     * Sets a global collision callback for the given tile index within the layer. This will affect all
     * tiles on this layer that have the same index. If a callback is already set for the tile index it
     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile
     * at a specific location on the map then see setTileLocationCallback.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#setTileIndexCallback
     * @since 3.0.0
     *
     * @param {(integer|integer[])} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for.
     * @param {function} callback - The callback that will be invoked when the tile is collided with.
     * @param {object} callbackContext - The context under which the callback is called.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */setTileIndexCallback:function(t,e,i){return a.SetTileIndexCallback(t,e,i,this.layer),this},/**
     * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.
     * If a callback is already set for the tile index it will be replaced. Set the callback to null to
     * remove it.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#setTileLocationCallback
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {function} [callback] - The callback that will be invoked when the tile is collided with.
     * @param {object} [callbackContext] - The context under which the callback is called.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */setTileLocationCallback:function(t,e,i,n,s,r){return a.SetTileLocationCallback(t,e,i,n,s,r,this.layer),this},/**
     * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given
     * layer. It will only randomize the tiles in that area, so if they're all the same nothing will
     * appear to have changed! This method only modifies tile indexes and does not change collision
     * information.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#shuffle
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */shuffle:function(t,e,i,n){return a.Shuffle(t,e,i,n,this.layer),this},/**
     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching
     * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision
     * information.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#swapByIndex
     * @since 3.0.0
     *
     * @param {integer} tileA - First tile index.
     * @param {integer} tileB - Second tile index.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */swapByIndex:function(t,e,i,n,s,r){return a.SwapByIndex(t,e,i,n,s,r,this.layer),this},/**
     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the
     * layers position, scale and scroll.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#tileToWorldX
     * @since 3.0.0
     *
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {number}
     */tileToWorldX:function(t,e){return a.TileToWorldX(t,e,this.layer)},/**
     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the
     * layers position, scale and scroll.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#tileToWorldY
     * @since 3.0.0
     *
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {number}
     */tileToWorldY:function(t,e){return a.TileToWorldY(t,e,this.layer)},/**
     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the
     * layers position, scale and scroll. This will return a new Vector2 object or update the given
     * `point` object.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#tileToWorldXY
     * @since 3.0.0
     *
     * @param {integer} tileX - The x coordinate, in tiles, not pixels.
     * @param {integer} tileY - The y coordinate, in tiles, not pixels.
     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {Phaser.Math.Vector2}
     */tileToWorldXY:function(t,e,i,n){return a.TileToWorldXY(t,e,i,n,this.layer)},/**
     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the
     * specified layer. Each tile will receive a new index. New indexes are drawn from the given
     * weightedIndexes array. An example weighted array:
     *
     * [
     *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8
     *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8
     *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8
     *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8
     * ]
     *
     * The probability of any index being choose is (the index's weight) / (sum of all weights). This
     * method only modifies tile indexes and does not change collision information.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#weightedRandomize
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {object[]} [weightedIndexes] - An array of objects to randomly draw from during
     * randomization. They should be in the form: { index: 0, weight: 4 } or
     * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.
     *
     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.
     */weightedRandomize:function(t,e,i,n,s){return a.WeightedRandomize(t,e,i,n,s,this.layer),this},/**
     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the
     * layers position, scale and scroll.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#worldToTileX
     * @since 3.0.0
     *
     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.
     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the nearest integer.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {number}
     */worldToTileX:function(t,e,i){return a.WorldToTileX(t,e,i,this.layer)},/**
     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the
     * layers position, scale and scroll.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#worldToTileY
     * @since 3.0.0
     *
     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.
     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the nearest integer.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {number}
     */worldToTileY:function(t,e,i){return a.WorldToTileY(t,e,i,this.layer)},/**
     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the
     * layers position, scale and scroll. This will return a new Vector2 object or update the given
     * `point` object.
     *
     * @method Phaser.Tilemaps.DynamicTilemapLayer#worldToTileXY
     * @since 3.0.0
     *
     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.
     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.
     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the nearest integer.
     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {Phaser.Math.Vector2}
     */worldToTileXY:function(t,e,i,n,s){return a.WorldToTileXY(t,e,i,n,s,this.layer)}});t.exports=h}),r("bit0e",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("9LsPB"),r=s("2tjae"),t.exports={renderWebGL:n,renderCanvas:r}}),r("9LsPB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("gaO4e");t.exports=function(t,e,n,s){e.cull(s);var r=e.culledTiles,o=r.length,a=s.alpha*e.alpha;if(0!==o&&!(a<=0))//  Loop through each tileset in this layer, drawing just the tiles that are in that set each time
//  Doing it this way around allows us to batch tiles using the same tileset
for(var h=e.gidMap,l=e.pipeline,u=i.getTintAppendFloatAlphaAndSwap,c=e.scrollFactorX,d=e.scrollFactorY,f=e.x,p=e.y,g=e.scaleX,v=e.scaleY,m=e.tileset,y=0;y<m.length;y++)for(var x=m[y],w=x.glTexture,T=0;T<o;T++){var b=r[T],S=h[b.index];if(S===x){var A=S.getTileTextureCoordinates(b.index);if(null!==A){var E=b.width,_=b.height,C=A.x,M=A.y,P=.5*b.width,O=.5*b.height,R=u(b.tint,a*b.alpha);l.batchTexture(e,w,w.width,w.height,f+(P+b.pixelX)*g,p+(O+b.pixelY)*v,b.width,b.height,g,v,b.rotation,b.flipX,b.flipY,c,d,P,O,C,M,E,_,R,R,R,R,!1,0,0,s,null,!0)}}}}}),r("2tjae",function(t,e){t.exports=function(t,e,i,n,s){e.cull(n);var r=e.culledTiles,o=r.length;if(0!==o){var a=t._tempMatrix1,h=t._tempMatrix2,l=t._tempMatrix3;h.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),a.copyFrom(n.matrix);var u=t.currentContext,c=e.gidMap;u.save(),s?(//  Multiply the camera by the parent matrix
a.multiplyWithOffset(s,-n.scrollX*e.scrollFactorX,-n.scrollY*e.scrollFactorY),//  Undo the camera scroll
h.e=e.x,h.f=e.y,//  Multiply by the Sprite matrix, store result in calcMatrix
a.multiply(h,l),l.copyToContext(u)):(h.e-=n.scrollX*e.scrollFactorX,h.f-=n.scrollY*e.scrollFactorY,h.copyToContext(u));var d=n.alpha*e.alpha;(!t.antialias||e.scaleX>1||e.scaleY>1)&&(u.imageSmoothingEnabled=!1);for(var f=0;f<o;f++){var p=r[f],g=c[p.index];if(g){var v=g.image.getSourceImage(),m=g.getTileTextureCoordinates(p.index);if(m){var y=p.width/2,x=p.height/2;u.save(),u.translate(p.pixelX+y,p.pixelY+x),0!==p.rotation&&u.rotate(p.rotation),(p.flipX||p.flipY)&&u.scale(p.flipX?-1:1,p.flipY?-1:1),u.globalAlpha=d*p.alpha,u.drawImage(v,m.x,m.y,p.width,p.height,-y,-x,p.width,p.height),u.restore()}}}u.restore()}}}),r("ehIU5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("4FF1v"),r=s("aqcI1"),o=s("1zqlR"),a=s("i9Ud5"),h=s("hequO"),l=s("azs1m"),u=s("gaO4e"),c=new i({Extends:o,Mixins:[n.Alpha,n.BlendMode,n.ComputedSize,n.Depth,n.Flip,n.GetBounds,n.Origin,n.Pipeline,n.Transform,n.Visible,n.ScrollFactor,a],initialize:function(t,e,i,n,s,a){o.call(this,t,"StaticTilemapLayer"),/**
         * Used internally by physics system to perform fast type checks.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#isTilemap
         * @type {boolean}
         * @readonly
         * @since 3.0.0
         */this.isTilemap=!0,/**
         * The Tilemap that this layer is a part of.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#tilemap
         * @type {Phaser.Tilemaps.Tilemap}
         * @since 3.0.0
         */this.tilemap=e,/**
         * The index of the LayerData associated with this layer.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#layerIndex
         * @type {integer}
         * @since 3.0.0
         */this.layerIndex=i,/**
         * The LayerData associated with this layer. LayerData can only be associated with one
         * tilemap layer.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#layer
         * @type {Phaser.Tilemaps.LayerData}
         * @since 3.0.0
         */this.layer=e.layers[i],// Link the LayerData with this static tilemap layer
this.layer.tilemapLayer=this,/**
         * The Tileset/s associated with this layer.
         * 
         * As of Phaser 3.14 this property is now an array of Tileset objects, previously it was a single reference.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#tileset
         * @type {Phaser.Tilemaps.Tileset[]}
         * @since 3.0.0
         */this.tileset=[],/**
         * Used internally by the Canvas renderer.
         * This holds the tiles that are visible within the camera in the last frame.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#culledTiles
         * @type {array}
         * @since 3.0.0
         */this.culledTiles=[],/**
         * Canvas only.
         * 
         * You can control if the Cameras should cull tiles before rendering them or not.
         * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.
         *
         * However, there are some instances when you may wish to disable this, and toggling this flag allows
         * you to do so. Also see `setSkipCull` for a chainable method that does the same thing.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#skipCull
         * @type {boolean}
         * @since 3.12.0
         */this.skipCull=!1,/**
         * Canvas only.
         * 
         * The total number of tiles drawn by the renderer in the last frame.
         * 
         * This only works when rending with Canvas.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#tilesDrawn
         * @type {integer}
         * @readonly
         * @since 3.12.0
         */this.tilesDrawn=0,/**
         * Canvas only.
         * 
         * The total number of tiles in this layer. Updated every frame.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#tilesTotal
         * @type {integer}
         * @readonly
         * @since 3.12.0
         */this.tilesTotal=this.layer.width*this.layer.height,/**
         * Canvas only.
         * 
         * The amount of extra tiles to add into the cull rectangle when calculating its horizontal size.
         *
         * See the method `setCullPadding` for more details.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#cullPaddingX
         * @type {integer}
         * @default 1
         * @since 3.12.0
         */this.cullPaddingX=1,/**
         * Canvas only.
         * 
         * The amount of extra tiles to add into the cull rectangle when calculating its vertical size.
         *
         * See the method `setCullPadding` for more details.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#cullPaddingY
         * @type {integer}
         * @default 1
         * @since 3.12.0
         */this.cullPaddingY=1,/**
         * Canvas only.
         * 
         * The callback that is invoked when the tiles are culled.
         *
         * By default it will call `TilemapComponents.CullTiles` but you can override this to call any function you like.
         *
         * It will be sent 3 arguments:
         *
         * 1. The Phaser.Tilemaps.LayerData object for this Layer
         * 2. The Camera that is culling the layer. You can check its `dirty` property to see if it has changed since the last cull.
         * 3. A reference to the `culledTiles` array, which should be used to store the tiles you want rendered.
         *
         * See the `TilemapComponents.CullTiles` source code for details on implementing your own culling system.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#cullCallback
         * @type {function}
         * @since 3.12.0
         */this.cullCallback=h.CullTiles,/**
         * A reference to the renderer.
         * 
         * @name Phaser.Tilemaps.StaticTilemapLayer#renderer
         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}
         * @private
         * @since 3.0.0
         */this.renderer=t.sys.game.renderer,/**
         * An array of vertex buffer objects, used by the WebGL renderer.
         * 
         * As of Phaser 3.14 this property is now an array, where each element maps to a Tileset instance. Previously it was a single instance.
         * 
         * @name Phaser.Tilemaps.StaticTilemapLayer#vertexBuffer
         * @type {WebGLBuffer[]}
         * @private
         * @since 3.0.0
         */this.vertexBuffer=[],/**
         * An array of ArrayBuffer objects, used by the WebGL renderer.
         * 
         * As of Phaser 3.14 this property is now an array, where each element maps to a Tileset instance. Previously it was a single instance.
         * 
         * @name Phaser.Tilemaps.StaticTilemapLayer#bufferData
         * @type {ArrayBuffer[]}
         * @private
         * @since 3.0.0
         */this.bufferData=[],/**
         * An array of Float32 Array objects, used by the WebGL renderer.
         * 
         * As of Phaser 3.14 this property is now an array, where each element maps to a Tileset instance. Previously it was a single instance.
         * 
         * @name Phaser.Tilemaps.StaticTilemapLayer#vertexViewF32
         * @type {Float32Array[]}
         * @private
         * @since 3.0.0
         */this.vertexViewF32=[],/**
         * An array of Uint32 Array objects, used by the WebGL renderer.
         * 
         * As of Phaser 3.14 this property is now an array, where each element maps to a Tileset instance. Previously it was a single instance.
         * 
         * @name Phaser.Tilemaps.StaticTilemapLayer#vertexViewU32
         * @type {Uint32Array[]}
         * @private
         * @since 3.0.0
         */this.vertexViewU32=[],/**
         * An array of booleans, used by the WebGL renderer.
         * 
         * As of Phaser 3.14 this property is now an array, where each element maps to a Tileset instance. Previously it was a single boolean.
         * 
         * @name Phaser.Tilemaps.StaticTilemapLayer#dirty
         * @type {boolean[]}
         * @private
         * @since 3.0.0
         */this.dirty=[],/**
         * An array of integers, used by the WebGL renderer.
         * 
         * As of Phaser 3.14 this property is now an array, where each element maps to a Tileset instance. Previously it was a single integer.
         * 
         * @name Phaser.Tilemaps.StaticTilemapLayer#vertexCount
         * @type {integer[]}
         * @private
         * @since 3.0.0
         */this.vertexCount=[],/**
         * The rendering (draw) order of the tiles in this layer.
         * 
         * The default is 0 which is 'right-down', meaning it will draw the tiles starting from the top-left,
         * drawing to the right and then moving down to the next row.
         * 
         * The draw orders are:
         * 
         * 0 = right-down
         * 1 = left-down
         * 2 = right-up
         * 3 = left-up
         * 
         * This can be changed via the `setRenderOrder` method.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#_renderOrder
         * @type {integer}
         * @default 0
         * @private
         * @since 3.12.0
         */this._renderOrder=0,/**
         * A temporary Transform Matrix, re-used internally during batching.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#_tempMatrix
         * @private
         * @type {Phaser.GameObjects.Components.TransformMatrix}
         * @since 3.14.0
         */this._tempMatrix=new l,/**
         * An array holding the mapping between the tile indexes and the tileset they belong to.
         *
         * @name Phaser.Tilemaps.StaticTilemapLayer#gidMap
         * @type {Phaser.Tilemaps.Tileset[]}
         * @since 3.14.0
         */this.gidMap=[],this.setTilesets(n),this.setAlpha(this.layer.alpha),this.setPosition(s,a),this.setOrigin(),this.setSize(e.tileWidth*this.layer.width,e.tileHeight*this.layer.height),this.updateVBOData(),this.initPipeline("TextureTintPipeline"),t.sys.game.events.on(r.CONTEXT_RESTORED,function(){this.updateVBOData()},this)},/**
     * Populates the internal `tileset` array with the Tileset references this Layer requires for rendering.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#setTilesets
     * @private
     * @since 3.14.0
     * 
     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.
     */setTilesets:function(t){var e=[],i=[],n=this.tilemap;Array.isArray(t)||(t=[t]);for(var s=0;s<t.length;s++){var r=t[s];if("string"==typeof r&&(r=n.getTileset(r)),r){i.push(r);for(var o=r.firstgid,a=0;a<r.total;a++)e[o+a]=r}}this.gidMap=e,this.tileset=i},/**
     * Prepares the VBO data arrays for population by the `upload` method.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#updateVBOData
     * @private
     * @since 3.14.0
     *
     * @return {this} This Tilemap Layer object.
     */updateVBOData:function(){for(var t=0;t<this.tileset.length;t++)this.dirty[t]=!0,this.vertexCount[t]=0,this.vertexBuffer[t]=null,this.bufferData[t]=null,this.vertexViewF32[t]=null,this.vertexViewU32[t]=null;return this},/**
     * Upload the tile data to a VBO.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#upload
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera to render to.
     * @param {integer} tilesetIndex - The tileset index.
     *
     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.
     */upload:function(t,e){var i=this.renderer,n=i.gl,s=i.pipelines.TextureTintPipeline;if(this.dirty[e]){var r,o,a,h=this.tileset[e],l=this.layer.width,u=this.layer.height,c=h.image.source[0].width,d=h.image.source[0].height,f=this.layer.data,p=this._renderOrder,g=h.firstgid,v=h.firstgid+h.total,m=this.vertexBuffer[e],y=this.bufferData[e],x=-1,w=l*u*s.vertexSize*6;if(this.vertexCount[e]=0,null===y&&(y=new ArrayBuffer(w),this.bufferData[e]=y,this.vertexViewF32[e]=new Float32Array(y),this.vertexViewU32[e]=new Uint32Array(y)),0===p)//  right-down
for(o=0;o<u;o++)for(a=0;a<l;a++)(r=f[o][a])&&!(r.index<g)&&!(r.index>v)&&r.visible&&(x=this.batchTile(x,r,h,c,d,t,e));else if(1===p)//  left-down
for(o=0;o<u;o++)for(a=l-1;a>=0;a--)(r=f[o][a])&&!(r.index<g)&&!(r.index>v)&&r.visible&&(x=this.batchTile(x,r,h,c,d,t,e));else if(2===p)//  right-up
for(o=u-1;o>=0;o--)for(a=0;a<l;a++)(r=f[o][a])&&!(r.index<g)&&!(r.index>v)&&r.visible&&(x=this.batchTile(x,r,h,c,d,t,e));else if(3===p)//  left-up
for(o=u-1;o>=0;o--)for(a=l-1;a>=0;a--)(r=f[o][a])&&!(r.index<g)&&!(r.index>v)&&r.visible&&(x=this.batchTile(x,r,h,c,d,t,e));this.dirty[e]=!1,null===m?(m=i.createVertexBuffer(y,n.STATIC_DRAW),this.vertexBuffer[e]=m):(i.setVertexBuffer(m),n.bufferSubData(n.ARRAY_BUFFER,0,y))}return this},/**
     * Add a single tile into the batch.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#batchTile
     * @private
     * @since 3.12.0
     *
     * @param {integer} vOffset - The vertex offset.
     * @param {any} tile - The tile being rendered.
     * @param {any} tileset - The tileset being used for rendering.
     * @param {integer} width - The width of the tileset image in pixels.
     * @param {integer} height - The height of the tileset image in pixels.
     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the layer is being rendered with.
     * @param {integer} tilesetIndex - The tileset index.
     *
     * @return {integer} The new vOffset value.
     */batchTile:function(t,e,i,n,s,r,o){var a=i.getTileTextureCoordinates(e.index);if(!a)return t;var h=i.tileWidth,l=i.tileHeight,c=h/2,d=l/2,f=a.x/n,p=a.y/s,g=(a.x+h)/n,v=(a.y+l)/s,m=this._tempMatrix,y=-c,x=-d;e.flipX&&(h*=-1,y+=i.tileWidth),e.flipY&&(l*=-1,x+=i.tileHeight);var w=y+h,T=x+l;m.applyITRS(c+e.pixelX,d+e.pixelY,e.rotation,1,1);var b=u.getTintAppendFloatAlpha(16777215,r.alpha*this.alpha*e.alpha),S=m.getX(y,x),A=m.getY(y,x),E=m.getX(y,T),_=m.getY(y,T),C=m.getX(w,T),M=m.getY(w,T),P=m.getX(w,x),O=m.getY(w,x);r.roundPixels&&(S=Math.round(S),A=Math.round(A),E=Math.round(E),_=Math.round(_),C=Math.round(C),M=Math.round(M),P=Math.round(P),O=Math.round(O));var R=this.vertexViewF32[o],L=this.vertexViewU32[o];return R[++t]=S,R[++t]=A,R[++t]=f,R[++t]=p,R[++t]=0,L[++t]=b,R[++t]=E,R[++t]=_,R[++t]=f,R[++t]=v,R[++t]=0,L[++t]=b,R[++t]=C,R[++t]=M,R[++t]=g,R[++t]=v,R[++t]=0,L[++t]=b,R[++t]=S,R[++t]=A,R[++t]=f,R[++t]=p,R[++t]=0,L[++t]=b,R[++t]=C,R[++t]=M,R[++t]=g,R[++t]=v,R[++t]=0,L[++t]=b,R[++t]=P,R[++t]=O,R[++t]=g,R[++t]=p,R[++t]=0,L[++t]=b,this.vertexCount[o]+=6,t},/**
     * Sets the rendering (draw) order of the tiles in this layer.
     * 
     * The default is 'right-down', meaning it will order the tiles starting from the top-left,
     * drawing to the right and then moving down to the next row.
     * 
     * The draw orders are:
     * 
     * 0 = right-down
     * 1 = left-down
     * 2 = right-up
     * 3 = left-up
     * 
     * Setting the render order does not change the tiles or how they are stored in the layer,
     * it purely impacts the order in which they are rendered.
     * 
     * You can provide either an integer (0 to 3), or the string version of the order.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#setRenderOrder
     * @since 3.12.0
     *
     * @param {(integer|string)} renderOrder - The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.
     *
     * @return {this} This Tilemap Layer object.
     */setRenderOrder:function(t){if("string"==typeof t&&(t=["right-down","left-down","right-up","left-up"].indexOf(t)),t>=0&&t<4){this._renderOrder=t;for(var e=0;e<this.tileset.length;e++)this.dirty[e]=!0}return this},/**
     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting
     * faces are used internally for optimizing collisions against tiles. This method is mostly used
     * internally to optimize recalculating faces when only one tile has been changed.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#calculateFacesAt
     * @since 3.0.0
     *
     * @param {integer} tileX - The x coordinate.
     * @param {integer} tileY - The y coordinate.
     *
     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.
     */calculateFacesAt:function(t,e){return h.CalculateFacesAt(t,e,this.layer),this},/**
     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the
     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method
     * is mostly used internally.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#calculateFacesWithin
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     *
     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.
     */calculateFacesWithin:function(t,e,i,n){return h.CalculateFacesWithin(t,e,i,n,this.layer),this},/**
     * Creates a Sprite for every object matching the given tile indexes in the layer. You can
     * optionally specify if each tile will be replaced with a new tile after the Sprite has been
     * created. This is useful if you want to lay down special tiles in a level that are converted to
     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#createFromTiles
     * @since 3.0.0
     *
     * @param {(integer|array)} indexes - The tile index, or array of indexes, to create Sprites from.
     * @param {(integer|array)} replacements - The tile index, or array of indexes, to change a converted
     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a
     * one-to-one mapping with the indexes array.
     * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e.
     * scene.make.sprite).
     * @param {Phaser.Scene} [scene=scene the map is within] - The Scene to create the Sprites within.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when determining the world XY
     *
     * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.
     */createFromTiles:function(t,e,i,n,s){return h.CreateFromTiles(t,e,i,n,s,this.layer)},/**
     * Returns the tiles in the given layer that are within the cameras viewport.
     * This is used internally.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#cull
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.
     *
     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.
     */cull:function(t){return this.cullCallback(this.layer,t,this.culledTiles)},/**
     * Canvas only.
     * 
     * You can control if the Cameras should cull tiles before rendering them or not.
     * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.
     *
     * However, there are some instances when you may wish to disable this.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#setSkipCull
     * @since 3.12.0
     *
     * @param {boolean} [value=true] - Set to `true` to stop culling tiles. Set to `false` to enable culling again.
     *
     * @return {this} This Tilemap Layer object.
     */setSkipCull:function(t){return void 0===t&&(t=!0),this.skipCull=t,this},/**
     * Canvas only.
     * 
     * When a Camera culls the tiles in this layer it does so using its view into the world, building up a
     * rectangle inside which the tiles must exist or they will be culled. Sometimes you may need to expand the size
     * of this 'cull rectangle', especially if you plan on rotating the Camera viewing the layer. Do so
     * by providing the padding values. The values given are in tiles, not pixels. So if the tile width was 32px
     * and you set `paddingX` to be 4, it would add 32px x 4 to the cull rectangle (adjusted for scale)
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#setCullPadding
     * @since 3.12.0
     *
     * @param {integer} [paddingX=1] - The amount of extra horizontal tiles to add to the cull check padding.
     * @param {integer} [paddingY=1] - The amount of extra vertical tiles to add to the cull check padding.
     *
     * @return {this} This Tilemap Layer object.
     */setCullPadding:function(t,e){return void 0===t&&(t=1),void 0===e&&(e=1),this.cullPaddingX=t,this.cullPaddingY=e,this},/**
     * Searches the entire map layer for the first tile matching the given index, then returns that Tile
     * object. If no match is found, it returns null. The search starts from the top-left tile and
     * continues horizontally until it hits the end of the row, then it drops down to the next column.
     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to
     * the top-left.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#findByIndex
     * @since 3.0.0
     *
     * @param {integer} index - The tile index value to search for.
     * @param {integer} [skip=0] - The number of times to skip a matching tile before returning.
     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the
     * bottom-right. Otherwise it scans from the top-left.
     *
     * @return {Phaser.Tilemaps.Tile} A Tile object.
     */findByIndex:function(t,e,i){return h.FindByIndex(t,e,i,this.layer)},/**
     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that
     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns
     * true. Similar to Array.prototype.find in vanilla JS.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#findTile
     * @since 3.0.0
     *
     * @param {function} callback - The callback. Each tile in the given area will be passed to this
     * callback as the first and only parameter.
     * @param {object} [context] - The context under which the callback should be run.
     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to filter.
     * @param {integer} [tileY=0] - The topmost tile index (in tile coordinates) to use as the origin of the area to filter.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     *
     * @return {?Phaser.Tilemaps.Tile}
     */findTile:function(t,e,i,n,s,r,o){return h.FindTile(t,e,i,n,s,r,o,this.layer)},/**
     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns
     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#filterTiles
     * @since 3.0.0
     *
     * @param {function} callback - The callback. Each tile in the given area will be passed to this
     * callback as the first and only parameter. The callback should return true for tiles that pass the
     * filter.
     * @param {object} [context] - The context under which the callback should be run.
     * @param {integer} [tileX=0] - The leftmost tile index (in tile coordinates) to use as the origin of the area to filter.
     * @param {integer} [tileY=0] - The topmost tile index (in tile coordinates) to use as the origin of the area to filter.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     *
     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.
     */filterTiles:function(t,e,i,n,s,r,o){return h.FilterTiles(t,e,i,n,s,r,o,this.layer)},/**
     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
     * callback. Similar to Array.prototype.forEach in vanilla JS.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#forEachTile
     * @since 3.0.0
     *
     * @param {function} callback - The callback. Each tile in the given area will be passed to this
     * callback as the first and only parameter.
     * @param {object} [context] - The context under which the callback should be run.
     * @param {integer} [tileX=0] - The leftmost tile index (in tile coordinates) to use as the origin of the area to filter.
     * @param {integer} [tileY=0] - The topmost tile index (in tile coordinates) to use as the origin of the area to filter.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     *
     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.
     */forEachTile:function(t,e,i,n,s,r,o){return h.ForEachTile(t,e,i,n,s,r,o,this.layer),this},/**
     * Gets a tile at the given tile coordinates from the given layer.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#getTileAt
     * @since 3.0.0
     *
     * @param {integer} tileX - X position to get the tile from (given in tile units, not pixels).
     * @param {integer} tileY - Y position to get the tile from (given in tile units, not pixels).
     * @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles, but a Tile
     * object with an index of -1.
     *
     * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.
     */getTileAt:function(t,e,i){return h.GetTileAt(t,e,i,this.layer)},/**
     * Gets a tile at the given world coordinates from the given layer.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#getTileAtWorldXY
     * @since 3.0.0
     *
     * @param {number} worldX - X position to get the tile from (given in pixels)
     * @param {number} worldY - Y position to get the tile from (given in pixels)
     * @param {boolean} [nonNull=false] - If true, function won't return null for empty tiles, but a Tile
     * object with an index of -1.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates
     * were invalid.
     */getTileAtWorldXY:function(t,e,i,n){return h.GetTileAtWorldXY(t,e,i,n,this.layer)},/**
     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#getTilesWithin
     * @since 3.0.0
     *
     * @param {integer} [tileX=0] - The leftmost tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [tileY=0] - The topmost tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     *
     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.
     */getTilesWithin:function(t,e,i,n,s){return h.GetTilesWithin(t,e,i,n,s,this.layer)},/**
     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#getTilesWithinWorldXY
     * @since 3.0.0
     *
     * @param {number} worldX - The leftmost tile index (in tile coordinates) to use as the origin of the area to filter.
     * @param {number} worldY - The topmost tile index (in tile coordinates) to use as the origin of the area to filter.
     * @param {number} width - How many tiles wide from the `tileX` index the area will be.
     * @param {number} height - How many tiles high from the `tileY` index the area will be.
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.
     *
     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.
     */getTilesWithinWorldXY:function(t,e,i,n,s,r){return h.GetTilesWithinWorldXY(t,e,i,n,s,r,this.layer)},/**
     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,
     * Line, Rectangle or Triangle. The shape should be in world coordinates.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#getTilesWithinShape
     * @since 3.0.0
     *
     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates
     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.
     */getTilesWithinShape:function(t,e,i){return h.GetTilesWithinShape(t,e,i,this.layer)},/**
     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns
     * false if there is no tile or if the tile at that location has an index of -1.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#hasTileAt
     * @since 3.0.0
     *
     * @param {integer} tileX - X position to get the tile from in tile coordinates.
     * @param {integer} tileY - Y position to get the tile from in tile coordinates.
     *
     * @return {boolean}
     */hasTileAt:function(t,e){return h.HasTileAt(t,e,this.layer)},/**
     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns
     * false if there is no tile or if the tile at that location has an index of -1.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#hasTileAtWorldXY
     * @since 3.0.0
     *
     * @param {number} worldX - The X coordinate of the world position.
     * @param {number} worldY - The Y coordinate of the world position.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {boolean}
     */hasTileAtWorldXY:function(t,e,i){return h.HasTileAtWorldXY(t,e,i,this.layer)},/**
     * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to
     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles
     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation
     * wherever you want on the screen.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#renderDebug
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.
     * @param {Phaser.Types.Tilemaps.StyleConfig} styleConfig - An object specifying the colors to use for the debug drawing.
     *
     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.
     */renderDebug:function(t,e){return h.RenderDebug(t,e,this.layer),this},/**
     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a
     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if
     * collision will be enabled (true) or disabled (false).
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#setCollision
     * @since 3.0.0
     *
     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes.
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear
     * collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the
     * update.
     * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to
     * false if no tiles have been placed for significant performance boost.
     *
     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.
     */setCollision:function(t,e,i,n){return h.SetCollision(t,e,i,this.layer,n),this},/**
     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and
     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set
     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be
     * enabled (true) or disabled (false).
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#setCollisionBetween
     * @since 3.0.0
     *
     * @param {integer} start - The first index of the tile to be set for collision.
     * @param {integer} stop - The last index of the tile to be set for collision.
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear
     * collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the
     * update.
     *
     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.
     */setCollisionBetween:function(t,e,i,n){return h.SetCollisionBetween(t,e,i,n,this.layer),this},/**
     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property
     * that matches the given properties object, its collision flag will be set. The `collides`
     * parameter controls if collision will be enabled (true) or disabled (false). Passing in
     * `{ collides: true }` would update the collision flag on any tiles with a "collides" property that
     * has a value of true. Any tile that doesn't have "collides" set to true will be ignored. You can
     * also use an array of values, e.g. `{ types: ["stone", "lava", "sand" ] }`. If a tile has a
     * "types" property that matches any of those values, its collision flag will be updated.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#setCollisionByProperty
     * @since 3.0.0
     *
     * @param {object} properties - An object with tile properties and corresponding values that should
     * be checked.
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear
     * collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the
     * update.
     *
     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.
     */setCollisionByProperty:function(t,e,i){return h.SetCollisionByProperty(t,e,i,this.layer),this},/**
     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in
     * the given array. The `collides` parameter controls if collision will be enabled (true) or
     * disabled (false).
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#setCollisionByExclusion
     * @since 3.0.0
     *
     * @param {integer[]} indexes - An array of the tile indexes to not be counted for collision.
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear
     * collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the
     * update.
     *
     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.
     */setCollisionByExclusion:function(t,e,i){return h.SetCollisionByExclusion(t,e,i,this.layer),this},/**
     * Sets a global collision callback for the given tile index within the layer. This will affect all
     * tiles on this layer that have the same index. If a callback is already set for the tile index it
     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile
     * at a specific location on the map then see setTileLocationCallback.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#setTileIndexCallback
     * @since 3.0.0
     *
     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes to have a
     * collision callback set for.
     * @param {function} callback - The callback that will be invoked when the tile is collided with.
     * @param {object} callbackContext - The context under which the callback is called.
     *
     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.
     */setTileIndexCallback:function(t,e,i){return h.SetTileIndexCallback(t,e,i,this.layer),this},/**
     * Sets collision on the tiles within a layer by checking each tiles collision group data
     * (typically defined in Tiled within the tileset collision editor). If any objects are found within
     * a tiles collision group, the tile's colliding information will be set. The `collides` parameter
     * controls if collision will be enabled (true) or disabled (false).
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#setCollisionFromCollisionGroup
     * @since 3.0.0
     *
     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear
     * collision.
     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the
     * update.
     *
     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.
     */setCollisionFromCollisionGroup:function(t,e){return h.SetCollisionFromCollisionGroup(t,e,this.layer),this},/**
     * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.
     * If a callback is already set for the tile index it will be replaced. Set the callback to null to
     * remove it.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#setTileLocationCallback
     * @since 3.0.0
     *
     * @param {integer} tileX - The leftmost tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} tileY - The topmost tile index (in tile coordinates) to use as the origin of the area.
     * @param {integer} width - How many tiles wide from the `tileX` index the area will be.
     * @param {integer} height - How many tiles tall from the `tileY` index the area will be.
     * @param {function} callback - The callback that will be invoked when the tile is collided with.
     * @param {object} [callbackContext] - The context under which the callback is called.
     *
     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.
     */setTileLocationCallback:function(t,e,i,n,s,r){return h.SetTileLocationCallback(t,e,i,n,s,r,this.layer),this},/**
     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the
     * layers position, scale and scroll.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#tileToWorldX
     * @since 3.0.0
     *
     * @param {integer} tileX - The X coordinate, in tile coordinates.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the world values from the tile index.
     *
     * @return {number}
     */tileToWorldX:function(t,e){return h.TileToWorldX(t,e,this.layer)},/**
     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the
     * layers position, scale and scroll.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#tileToWorldY
     * @since 3.0.0
     *
     * @param {integer} tileY - The Y coordinate, in tile coordinates.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the world values from the tile index.
     *
     * @return {number}
     */tileToWorldY:function(t,e){return h.TileToWorldY(t,e,this.layer)},/**
     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the
     * layers position, scale and scroll. This will return a new Vector2 object or update the given
     * `point` object.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#tileToWorldXY
     * @since 3.0.0
     *
     * @param {integer} tileX - The X coordinate, in tile coordinates.
     * @param {integer} tileY - The Y coordinate, in tile coordinates.
     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given, a new Vector2 is created.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the world values from the tile index.
     *
     * @return {Phaser.Math.Vector2}
     */tileToWorldXY:function(t,e,i,n){return h.TileToWorldXY(t,e,i,n,this.layer)},/**
     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the
     * layers position, scale and scroll.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#worldToTileX
     * @since 3.0.0
     *
     * @param {number} worldX - The X coordinate, in world pixels.
     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the
     * nearest integer.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.]
     *
     * @return {number}
     */worldToTileX:function(t,e,i){return h.WorldToTileX(t,e,i,this.layer)},/**
     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the
     * layers position, scale and scroll.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#worldToTileY
     * @since 3.0.0
     *
     * @param {number} worldY - The Y coordinate, in world pixels.
     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the
     * nearest integer.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {number}
     */worldToTileY:function(t,e,i){return h.WorldToTileY(t,e,i,this.layer)},/**
     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the
     * layers position, scale and scroll. This will return a new Vector2 object or update the given
     * `point` object.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#worldToTileXY
     * @since 3.0.0
     *
     * @param {number} worldX - The X coordinate, in world pixels.
     * @param {number} worldY - The Y coordinate, in world pixels.
     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the
     * nearest integer.
     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given, a new Vector2 is created.
     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.
     *
     * @return {Phaser.Math.Vector2}
     */worldToTileXY:function(t,e,i,n,s){return h.WorldToTileXY(t,e,i,n,s,this.layer)},/**
     * Destroys this StaticTilemapLayer and removes its link to the associated LayerData.
     *
     * @method Phaser.Tilemaps.StaticTilemapLayer#destroy
     * @since 3.0.0
     * 
     * @param {boolean} [removeFromTilemap=true] - Remove this layer from the parent Tilemap?
     */destroy:function(t){if(void 0===t&&(t=!0),this.tilemap){this.layer.tilemapLayer===this&&(this.layer.tilemapLayer=void 0),t&&this.tilemap.removeLayer(this),this.tilemap=void 0,this.layer=void 0,this.culledTiles.length=0,this.cullCallback=null;for(var e=0;e<this.tileset.length;e++)this.dirty[e]=!0,this.vertexCount[e]=0,this.vertexBuffer[e]=null,this.bufferData[e]=null,this.vertexViewF32[e]=null,this.vertexViewU32[e]=null;this.gidMap=[],this.tileset=[],o.prototype.destroy.call(this)}}});t.exports=c}),r("i9Ud5",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("13GYA"),n=i,i=s("13GYA"),r=i;n=s("28KIw"),r=s("p90KK"),t.exports={renderWebGL:n,renderCanvas:r}}),r("28KIw",function(t,e){t.exports=function(t,e,i,n){var s=e.tileset,r=e.pipeline,o=r.vertexBuffer;t.setPipeline(r),r.modelIdentity(),r.modelTranslate(e.x-n.scrollX*e.scrollFactorX,e.y-n.scrollY*e.scrollFactorY,0),r.modelScale(e.scaleX,e.scaleY,1),r.viewLoad2D(n.matrix.matrix);for(var a=0;a<s.length;a++)e.upload(n,a),e.vertexCount[a]>0&&(t.currentPipeline&&t.currentPipeline.vertexCount>0&&t.flush(),r.vertexBuffer=e.vertexBuffer[a],t.setPipeline(r),t.setTexture2D(s[a].glTexture,0),t.gl.drawArrays(r.topology,0,e.vertexCount[a]));//  Restore the pipeline
r.vertexBuffer=o,r.viewIdentity(),r.modelIdentity()}}),r("p90KK",function(t,e){t.exports=function(t,e,i,n,s){e.cull(n);var r=e.culledTiles,o=r.length;if(0!==o){var a=t._tempMatrix1,h=t._tempMatrix2,l=t._tempMatrix3;h.applyITRS(e.x,e.y,e.rotation,e.scaleX,e.scaleY),a.copyFrom(n.matrix);var u=t.currentContext,c=e.gidMap;u.save(),s?(//  Multiply the camera by the parent matrix
a.multiplyWithOffset(s,-n.scrollX*e.scrollFactorX,-n.scrollY*e.scrollFactorY),//  Undo the camera scroll
h.e=e.x,h.f=e.y,a.multiply(h,l),l.copyToContext(u)):(//  Undo the camera scroll
h.e-=n.scrollX*e.scrollFactorX,h.f-=n.scrollY*e.scrollFactorY,h.copyToContext(u));var d=n.alpha*e.alpha;(!t.antialias||e.scaleX>1||e.scaleY>1)&&(u.imageSmoothingEnabled=!1);for(var f=0;f<o;f++){var p=r[f],g=c[p.index];if(g){var v=g.image.getSourceImage(),m=g.getTileTextureCoordinates(p.index);if(m){var y=g.tileWidth,x=g.tileHeight,w=y/2,T=x/2;u.save(),u.translate(p.pixelX+w,p.pixelY+T),0!==p.rotation&&u.rotate(p.rotation),(p.flipX||p.flipY)&&u.scale(p.flipX?-1:1,p.flipY?-1:1),u.globalAlpha=d*p.alpha,u.drawImage(v,m.x,m.y,y,x,-w,-T,y,x),u.restore()}}}u.restore()}}}),r("28rGO",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("ebQQp"),n=s("6SHSh");/**
 * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.
 * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing
 * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map
 * data. For an empty map, you should specify tileWidth, tileHeight, width & height.
 *
 * @method Phaser.GameObjects.GameObjectCreator#tilemap
 * @since 3.0.0
 * 
 * @param {Phaser.Types.Tilemaps.TilemapConfig} [config] - The config options for the Tilemap.
 * 
 * @return {Phaser.Tilemaps.Tilemap}
 */i.register("tilemap",function(t){// Defaults are applied in ParseToTilemap
var e=void 0!==t?t:{};return n(this.scene,e.key,e.tileWidth,e.tileHeight,e.width,e.height,e.data,e.insertNull)})}),r("17YuE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("kge7H"),n=s("6SHSh");/**
 * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.
 * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing
 * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map
 * data. For an empty map, you should specify tileWidth, tileHeight, width & height.
 *
 * @method Phaser.GameObjects.GameObjectFactory#tilemap
 * @since 3.0.0
 *
 * @param {string} [key] - The key in the Phaser cache that corresponds to the loaded tilemap data.
 * @param {integer} [tileWidth=32] - The width of a tile in pixels. Pass in `null` to leave as the
 * default.
 * @param {integer} [tileHeight=32] - The height of a tile in pixels. Pass in `null` to leave as the
 * default.
 * @param {integer} [width=10] - The width of the map in tiles. Pass in `null` to leave as the
 * default.
 * @param {integer} [height=10] - The height of the map in tiles. Pass in `null` to leave as the
 * default.
 * @param {integer[][]} [data] - Instead of loading from the cache, you can also load directly from
 * a 2D array of tile indexes. Pass in `null` for no data.
 * @param {boolean} [insertNull=false] - Controls how empty tiles, tiles with an index of -1, in the
 * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
 * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
 * the tile data doesn't need to change then setting this value to `true` will help with memory
 * consumption. However if your map is small or you need to update the tiles dynamically, then leave
 * the default value set.
 * 
 * @return {Phaser.Tilemaps.Tilemap}
 */i.register("tilemap",function(t,e,i,s,r,o,a){return null===t&&(t=void 0),null===e&&(e=void 0),null===i&&(i=void 0),null===s&&(s=void 0),null===r&&(r=void 0),n(this.scene,t,e,i,s,r,o,a)});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("4Tb60",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Time
 */t.exports={Clock:s("kLefh"),TimerEvent:s("dD9E9")}}),r("kLefh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7AzQW"),r=s("4rtgc"),o=s("dD9E9"),a=new i({initialize:function(t){/**
         * The Scene which owns this Clock.
         *
         * @name Phaser.Time.Clock#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * The Scene Systems object of the Scene which owns this Clock.
         *
         * @name Phaser.Time.Clock#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,/**
         * The current time of the Clock, in milliseconds.
         *
         * If accessed externally, this is equivalent to the `time` parameter normally passed to a Scene's `update` method.
         *
         * @name Phaser.Time.Clock#now
         * @type {number}
         * @since 3.0.0
         */this.now=0,//  Scale the delta time coming into the Clock by this factor
//  which then influences anything using this Clock for calculations, like TimerEvents
/**
         * The scale of the Clock's time delta.
         * 
         * The time delta is the time elapsed between two consecutive frames and influences the speed of time for this Clock and anything which uses it, such as its Timer Events. Values higher than 1 increase the speed of time, while values smaller than 1 decrease it. A value of 0 freezes time and is effectively equivalent to pausing the Clock.
         *
         * @name Phaser.Time.Clock#timeScale
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.timeScale=1,/**
         * Whether the Clock is paused (`true`) or active (`false`).
         *
         * When paused, the Clock will not update any of its Timer Events, thus freezing time.
         *
         * @name Phaser.Time.Clock#paused
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.paused=!1,/**
         * An array of all Timer Events whose delays haven't expired - these are actively updating Timer Events.
         *
         * @name Phaser.Time.Clock#_active
         * @type {Phaser.Time.TimerEvent[]}
         * @private
         * @default []
         * @since 3.0.0
         */this._active=[],/**
         * An array of all Timer Events which will be added to the Clock at the start of the frame.
         *
         * @name Phaser.Time.Clock#_pendingInsertion
         * @type {Phaser.Time.TimerEvent[]}
         * @private
         * @default []
         * @since 3.0.0
         */this._pendingInsertion=[],/**
         * An array of all Timer Events which will be removed from the Clock at the start of the frame.
         *
         * @name Phaser.Time.Clock#_pendingRemoval
         * @type {Phaser.Time.TimerEvent[]}
         * @private
         * @default []
         * @since 3.0.0
         */this._pendingRemoval=[],t.sys.events.once(r.BOOT,this.boot,this),t.sys.events.on(r.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.Time.Clock#boot
     * @private
     * @since 3.5.1
     */boot:function(){//  Sync with the TimeStep
this.now=this.systems.game.loop.time,this.systems.events.once(r.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.Time.Clock#start
     * @private
     * @since 3.5.0
     */start:function(){var t=this.systems.events;t.on(r.PRE_UPDATE,this.preUpdate,this),t.on(r.UPDATE,this.update,this),t.once(r.SHUTDOWN,this.shutdown,this)},/**
     * Creates a Timer Event and adds it to the Clock at the start of the frame.
     *
     * @method Phaser.Time.Clock#addEvent
     * @since 3.0.0
     *
     * @param {Phaser.Types.Time.TimerEventConfig} config - The configuration for the Timer Event.
     *
     * @return {Phaser.Time.TimerEvent} The Timer Event which was created.
     */addEvent:function(t){var e=new o(t);return this._pendingInsertion.push(e),e},/**
     * Creates a Timer Event and adds it to the Clock at the start of the frame.
     *
     * This is a shortcut for {@link #addEvent} which can be shorter and is compatible with the syntax of the GreenSock Animation Platform (GSAP).
     *
     * @method Phaser.Time.Clock#delayedCall
     * @since 3.0.0
     *
     * @param {number} delay - The delay of the function call, in milliseconds.
     * @param {function} callback - The function to call after the delay expires.
     * @param {Array.<*>} [args] - The arguments to call the function with.
     * @param {*} [callbackScope] - The scope (`this` object) to call the function with.
     *
     * @return {Phaser.Time.TimerEvent} The Timer Event which was created.
     */delayedCall:function(t,e,i,n){return this.addEvent({delay:t,callback:e,args:i,callbackScope:n})},/**
     * Clears and recreates the array of pending Timer Events.
     *
     * @method Phaser.Time.Clock#clearPendingEvents
     * @since 3.0.0
     *
     * @return {Phaser.Time.Clock} This Clock object.
     */clearPendingEvents:function(){return this._pendingInsertion=[],this},/**
     * Schedules all active Timer Events for removal at the start of the frame.
     *
     * @method Phaser.Time.Clock#removeAllEvents
     * @since 3.0.0
     *
     * @return {Phaser.Time.Clock} This Clock object.
     */removeAllEvents:function(){return this._pendingRemoval=this._pendingRemoval.concat(this._active),this},/**
     * Updates the arrays of active and pending Timer Events. Called at the start of the frame.
     *
     * @method Phaser.Time.Clock#preUpdate
     * @since 3.0.0
     *
     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     */preUpdate:function(){var t,e,i=this._pendingRemoval.length,n=this._pendingInsertion.length;if(0!==i||0!==n){//  Delete old events
for(t=0;t<i;t++){e=this._pendingRemoval[t];var s=this._active.indexOf(e);s>-1&&this._active.splice(s,1),//  Pool them?
e.destroy()}for(t=0;t<n;t++)e=this._pendingInsertion[t],this._active.push(e);//  Clear the lists
this._pendingRemoval.length=0,this._pendingInsertion.length=0}},/**
     * Updates the Clock's internal time and all of its Timer Events.
     *
     * @method Phaser.Time.Clock#update
     * @since 3.0.0
     *
     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     */update:function(t,e){if(this.now=t,!this.paused){e*=this.timeScale;for(var i=0;i<this._active.length;i++){var n=this._active[i];if(!n.paused&&(//  Use delta time to increase elapsed.
//  Avoids needing to adjust for pause / resume.
//  Automatically smoothed by TimeStep class.
//  In testing accurate to +- 1ms!
n.elapsed+=e*n.timeScale,n.elapsed>=n.delay)){var s=n.elapsed-n.delay;//  Limit it, in case it's checked in the callback
n.elapsed=n.delay,!n.hasDispatched&&n.callback&&(n.hasDispatched=!0,n.callback.apply(n.callbackScope,n.args)),n.repeatCount>0?(n.repeatCount--,n.elapsed=s,n.hasDispatched=!1):this._pendingRemoval.push(n)}}}},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.Time.Clock#shutdown
     * @private
     * @since 3.0.0
     */shutdown:function(){for(t=0;t<this._pendingInsertion.length;t++)this._pendingInsertion[t].destroy();for(t=0;t<this._active.length;t++)this._active[t].destroy();for(t=0;t<this._pendingRemoval.length;t++)this._pendingRemoval[t].destroy();this._active.length=0,this._pendingRemoval.length=0,this._pendingInsertion.length=0;var t,e=this.systems.events;e.off(r.PRE_UPDATE,this.preUpdate,this),e.off(r.UPDATE,this.update,this),e.off(r.SHUTDOWN,this.shutdown,this)},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.Time.Clock#destroy
     * @private
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.scene.sys.events.off(r.START,this.start,this),this.scene=null,this.systems=null}});n.register("Clock",a,"time"),t.exports=a}),r("dD9E9",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("7BSWl"),r=new i({initialize:function(t){/**
         * The delay in ms at which this TimerEvent fires.
         *
         * @name Phaser.Time.TimerEvent#delay
         * @type {number}
         * @default 0
         * @readonly
         * @since 3.0.0
         */this.delay=0,/**
         * The total number of times this TimerEvent will repeat before finishing.
         *
         * @name Phaser.Time.TimerEvent#repeat
         * @type {number}
         * @default 0
         * @readonly
         * @since 3.0.0
         */this.repeat=0,/**
         * If repeating this contains the current repeat count.
         *
         * @name Phaser.Time.TimerEvent#repeatCount
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.repeatCount=0,/**
         * True if this TimerEvent loops, otherwise false.
         *
         * @name Phaser.Time.TimerEvent#loop
         * @type {boolean}
         * @default false
         * @readonly
         * @since 3.0.0
         */this.loop=!1,/**
         * The callback that will be called when the TimerEvent occurs.
         *
         * @name Phaser.Time.TimerEvent#callback
         * @type {function}
         * @since 3.0.0
         */this.callback,/**
         * The scope in which the callback will be called.
         *
         * @name Phaser.Time.TimerEvent#callbackScope
         * @type {object}
         * @since 3.0.0
         */this.callbackScope,/**
         * Additional arguments to be passed to the callback.
         *
         * @name Phaser.Time.TimerEvent#args
         * @type {array}
         * @since 3.0.0
         */this.args,/**
         * Scale the time causing this TimerEvent to update.
         *
         * @name Phaser.Time.TimerEvent#timeScale
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.timeScale=1,/**
         * Start this many MS into the elapsed (useful if you want a long duration with repeat, but for the first loop to fire quickly)
         *
         * @name Phaser.Time.TimerEvent#startAt
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.startAt=0,/**
         * The time in milliseconds which has elapsed since the Timer Event's creation.
         *
         * This value is local for the Timer Event and is relative to its Clock. As such, it's influenced by the Clock's time scale and paused state, the Timer Event's initial {@link #startAt} property, and the Timer Event's {@link #timeScale} and {@link #paused} state.
         *
         * @name Phaser.Time.TimerEvent#elapsed
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.elapsed=0,/**
         * Whether or not this timer is paused.
         *
         * @name Phaser.Time.TimerEvent#paused
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.paused=!1,/**
         * Whether the Timer Event's function has been called.
         *
         * When the Timer Event fires, this property will be set to `true` before the callback function is invoked and will be reset immediately afterward if the Timer Event should repeat. The value of this property does not directly influence whether the Timer Event will be removed from its Clock, but can prevent it from firing.
         *
         * @name Phaser.Time.TimerEvent#hasDispatched
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.hasDispatched=!1,this.reset(t)},/**
     * Completely reinitializes the Timer Event, regardless of its current state, according to a configuration object.
     *
     * @method Phaser.Time.TimerEvent#reset
     * @since 3.0.0
     *
     * @param {Phaser.Types.Time.TimerEventConfig} config - The new state for the Timer Event.
     *
     * @return {Phaser.Time.TimerEvent} This TimerEvent object.
     */reset:function(t){return this.delay=n(t,"delay",0),//  Can also be set to -1 for an infinite loop (same as setting loop: true)
this.repeat=n(t,"repeat",0),this.loop=n(t,"loop",!1),this.callback=n(t,"callback",void 0),this.callbackScope=n(t,"callbackScope",this.callback),this.args=n(t,"args",[]),this.timeScale=n(t,"timeScale",1),this.startAt=n(t,"startAt",0),this.paused=n(t,"paused",!1),this.elapsed=this.startAt,this.hasDispatched=!1,this.repeatCount=-1===this.repeat||this.loop?999999999999:this.repeat,this},/**
     * Gets the progress of the current iteration, not factoring in repeats.
     *
     * @method Phaser.Time.TimerEvent#getProgress
     * @since 3.0.0
     *
     * @return {number} A number between 0 and 1 representing the current progress.
     */getProgress:function(){return this.elapsed/this.delay},/**
     * Gets the progress of the timer overall, factoring in repeats.
     *
     * @method Phaser.Time.TimerEvent#getOverallProgress
     * @since 3.0.0
     *
     * @return {number} The overall progress of the Timer Event, between 0 and 1.
     */getOverallProgress:function(){if(!(this.repeat>0))return this.getProgress();var t=this.delay+this.delay*this.repeat;return(this.elapsed+this.delay*(this.repeat-this.repeatCount))/t},/**
     * Returns the number of times this Timer Event will repeat before finishing.
     *
     * This should not be confused with the number of times the Timer Event will fire before finishing. A return value of 0 doesn't indicate that the Timer Event has finished running - it indicates that it will not repeat after the next time it fires.
     *
     * @method Phaser.Time.TimerEvent#getRepeatCount
     * @since 3.0.0
     *
     * @return {number} How many times the Timer Event will repeat.
     */getRepeatCount:function(){return this.repeatCount},/**
     * Returns the local elapsed time for the current iteration of the Timer Event.
     *
     * @method Phaser.Time.TimerEvent#getElapsed
     * @since 3.0.0
     *
     * @return {number} The local elapsed time in milliseconds.
     */getElapsed:function(){return this.elapsed},/**
     * Returns the local elapsed time for the current iteration of the Timer Event in seconds.
     *
     * @method Phaser.Time.TimerEvent#getElapsedSeconds
     * @since 3.0.0
     *
     * @return {number} The local elapsed time in seconds.
     */getElapsedSeconds:function(){return .001*this.elapsed},/**
     * Forces the Timer Event to immediately expire, thus scheduling its removal in the next frame.
     *
     * @method Phaser.Time.TimerEvent#remove
     * @since 3.0.0
     *
     * @param {boolean} [dispatchCallback=false] - If `true`, the function of the Timer Event will be called before its removal.
     */remove:function(t){void 0===t&&(t=!1),this.elapsed=this.delay,this.hasDispatched=!t,this.repeatCount=0},/**
     * Destroys all object references in the Timer Event, i.e. its callback, scope, and arguments.
     *
     * Normally, this method is only called by the Clock when it shuts down. As such, it doesn't stop the Timer Event. If called manually, the Timer Event will still be updated by the Clock, but it won't do anything when it fires.
     *
     * @method Phaser.Time.TimerEvent#destroy
     * @since 3.0.0
     */destroy:function(){this.callback=void 0,this.callbackScope=void 0,this.args=[]}});t.exports=r}),r("145t6",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("7lENH"),n=s("hVk4C"),r={Builders:s("lMVig"),Events:s("gkXcN"),TweenManager:s("dA6JL"),Tween:s("9JoMY"),TweenData:s("b70cP"),Timeline:s("haSds")};//   Merge in the consts
r=n(!1,r,i),t.exports=r}),r("lMVig",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Tweens.Builders
 */t.exports={GetBoolean:s("iuXOO"),GetEaseFunction:s("aANNX"),GetNewValue:s("hoIQ4"),GetProps:s("dwqbq"),GetTargets:s("8Hbk7"),GetTweens:s("2zEft"),GetValueOp:s("i2BXh"),NumberTweenBuilder:s("bJ9WV"),StaggerBuilder:s("lvk9S"),TimelineBuilder:s("agb2N"),TweenBuilder:s("fZhty")}}),r("hoIQ4",function(t,e){t.exports=function(t,e,i){return t.hasOwnProperty(e)?"function"==typeof t[e]?function(i,n,s,r,o,a){return t[e](i,n,s,r,o,a)}:function(){return t[e]}:"function"==typeof i?i:function(){return i}}}),r("dwqbq",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("enabc");t.exports=function(t){var e,n=[];//  First see if we have a props object
if(t.hasOwnProperty("props"))for(e in t.props)"_"!==e.substr(0,1)&&n.push({key:e,value:t.props[e]});else for(e in t)-1===i.indexOf(e)&&"_"!==e.substr(0,1)&&n.push({key:e,value:t[e]});return n}}),r("enabc",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *///  RESERVED properties that a Tween config object uses
//  completeDelay: The time the tween will wait before the onComplete event is dispatched once it has completed
//  delay: The time the tween will wait before it first starts
//  duration: The duration of the tween
//  ease: The ease function used by the tween
//  easeParams: The parameters to go with the ease function (if any)
//  flipX: flip X the GameObject on tween end
//  flipY: flip Y the GameObject on tween end//  hold: The time the tween will pause before running a yoyo
//  hold: The time the tween will pause before running a yoyo
//  loop: The time the tween will pause before starting either a yoyo or returning to the start for a repeat
//  loopDelay: 
//  offset: Used when the Tween is part of a Timeline
//  paused: Does the tween start in a paused state, or playing?
//  props: The properties being tweened by the tween
//  repeat: The number of times the tween will repeat itself (a value of 1 means the tween will play twice, as it repeated once)
//  repeatDelay: The time the tween will pause for before starting a repeat. The tween holds in the start state.
//  targets: The targets the tween is updating.
//  useFrames: Use frames or milliseconds?
//  yoyo: boolean - Does the tween reverse itself (yoyo) when it reaches the end?
t.exports=["callbackScope","completeDelay","delay","duration","ease","easeParams","flipX","flipY","hold","loop","loopDelay","offset","onActive","onActiveParams","onActiveScope","onComplete","onCompleteParams","onCompleteScope","onLoop","onLoopParams","onLoopScope","onRepeat","onRepeatParams","onRepeatScope","onStart","onStartParams","onStartScope","onUpdate","onUpdateParams","onUpdateScope","onYoyo","onYoyoParams","onYoyoScope","paused","props","repeat","repeatDelay","targets","useFrames","yoyo"]}),r("8Hbk7",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5pMDk");t.exports=function(t){var e=i(t,"targets",null);return null===e||("function"==typeof e&&(e=e.call()),Array.isArray(e)||(e=[e])),e}}),r("2zEft",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5pMDk");t.exports=function(t){var e=i(t,"tweens",null);return null===e?[]:("function"==typeof e&&(e=e.call()),Array.isArray(e)||(e=[e]),e)}}),r("i2BXh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @ignore
 */function i(t){return!!t.getActive&&"function"==typeof t.getActive}/**
 * @ignore
 */function n(t){return!!t.getStart&&"function"==typeof t.getStart}/**
 * @ignore
 */function s(t){return!!t.getEnd&&"function"==typeof t.getEnd}/**
 * Returns `getActive`, `getStart` and `getEnd` functions for a TweenData based on a target property and end value.
 * 
 * `getActive` if not null, is invoked _immediately_ as soon as the TweenData is running, and is set on the target property.
 * `getEnd` is invoked once any start delays have expired and returns what the value should tween to.
 * `getStart` is invoked when the tween reaches the end and needs to either repeat or yoyo, it returns the value to go back to.
 *
 * If the end value is a number, it will be treated as an absolute value and the property will be tweened to it.
 * A string can be provided to specify a relative end value which consists of an operation
 * (`+=` to add to the current value, `-=` to subtract from the current value, `*=` to multiply the current
 * value, or `/=` to divide the current value) followed by its operand.
 * 
 * A function can be provided to allow greater control over the end value; it will receive the target
 * object being tweened, the name of the property being tweened, and the current value of the property
 * as its arguments.
 * 
 * If both the starting and the ending values need to be controlled, an object with `getStart` and `getEnd`
 * callbacks, which will receive the same arguments, can be provided instead. If an object with a `value`
 * property is provided, the property will be used as the effective value under the same rules described here.
 *
 * @function Phaser.Tweens.Builders.GetValueOp
 * @since 3.0.0
 *
 * @param {string} key - The name of the property to modify.
 * @param {*} propertyValue - The ending value of the property, as described above.
 *
 * @return {function} An array of functions, `getActive`, `getStart` and `getEnd`, which return the starting and the ending value of the property based on the provided value.
 */var r=function(t,e){//  The returned value sets what the property will be at the END of the Tween (usually called at the start of the Tween)
var o,a=function(t,e,i){return i},h=function(t,e,i){return i},l=null,u=typeof e;if("number"===u)//     x: 400,
//     y: 300
// }
a=function(){return e};else if("string"===u){// props: {
//     x: '+=400',
//     y: '-=300',
//     z: '*=2',
//     w: '/=2'
// }
var c=e[0],d=parseFloat(e.substr(2));switch(c){case"+":a=function(t,e,i){return i+d};break;case"-":a=function(t,e,i){return i-d};break;case"*":a=function(t,e,i){return i*d};break;case"/":a=function(t,e,i){return i/d};break;default:a=function(){return parseFloat(e)}}}else if("function"===u)// props: {
//     x: function (target, key, value, targetIndex, totalTargets, tween) { return value + 50); },
// }
a=e;else if("object"===u){if(n(e)||s(e)||i(e))i(e)&&(l=e.getActive),s(e)&&(a=e.getEnd),n(e)&&(h=e.getStart);else if(e.hasOwnProperty("value"))// props: {
//     x: { value: 400, ... },
//     y: { value: 300, ... }
// }
o=r(t,e.value);else{//  'from' and 'to' may still be a string, function or a number
// props: {
//     x: { from: 400, to: 600 },
//     y: { from: 300, to: 500 }
// }
//  Same as above, but the 'start' value is set immediately on the target
// props: {
//     x: { start: 400, to: 600 },
//     y: { start: 300, to: 500 }
// }
//  'start' value is set immediately, then it goes 'from' to 'to' during the tween
// props: {
//     x: { start: 200, from: 400, to: 600 },
//     y: { start: 300, from: 300, to: 500 }
// }
var f=e.hasOwnProperty("to"),p=e.hasOwnProperty("from"),g=e.hasOwnProperty("start");if(f&&(p||g)){if(o=r(t,e.to),g){var v=r(t,e.start);o.getActive=v.getEnd}if(p){var m=r(t,e.from);o.getStart=m.getEnd}}}}return o||(o={getActive:l,getEnd:a,getStart:h}),o};t.exports=r}),r("bJ9WV",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6AqCF"),n=s("cSaNN"),r=s("iuXOO"),o=s("aANNX"),a=s("hoIQ4"),h=s("5pMDk"),l=s("i2BXh"),u=s("9JoMY"),c=s("b70cP");t.exports=function(t,e,s){void 0===s&&(s=i);//  var tween = this.tweens.addCounter({
//      from: 100,
//      to: 200,
//      ... (normal tween properties)
//  })
//
//  Then use it in your game via:
//
//  tween.getValue()
var d=h(e,"from",0),f=h(e,"to",1),p=[{value:d}],g=a(e,"delay",s.delay),v=a(e,"duration",s.duration),m=h(e,"easeParams",s.easeParams),y=o(h(e,"ease",s.ease),m),x=a(e,"hold",s.hold),w=a(e,"repeat",s.repeat),T=a(e,"repeatDelay",s.repeatDelay),b=r(e,"yoyo",s.yoyo),S=[],A=l("value",f),E=c(p[0],0,"value",A.getEnd,A.getStart,A.getActive,y,g,v,b,x,w,T,!1,!1);E.start=d,E.current=d,E.to=f,S.push(E);var _=new u(t,S,p);_.offset=n(e,"offset",null),_.completeDelay=n(e,"completeDelay",0),_.loop=Math.round(n(e,"loop",0)),_.loopDelay=Math.round(n(e,"loopDelay",0)),_.paused=r(e,"paused",!1),_.useFrames=r(e,"useFrames",!1);for(var C=h(e,"callbackScope",_),M=[_,null],P=u.TYPES,O=0;O<P.length;O++){var R=P[O],L=h(e,R,!1);if(L){var k=h(e,R+"Scope",C),D=h(e,R+"Params",[]);//  The null is reset to be the Tween target
_.setCallback(R,L,M.concat(D),k)}}return _}}),r("6AqCF",function(t,e){t.exports={targets:null,delay:0,duration:1e3,ease:"Power0",easeParams:null,hold:0,repeat:0,repeatDelay:0,yoyo:!1,flipX:!1,flipY:!1}}),r("9JoMY",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("3vRz3"),r=s("gkXcN"),o=s("ebQQp"),a=s("kge7H"),h=s("7lENH"),l=s("bNtDi"),u=new i({Extends:n,initialize:function(t,e,i){n.call(this),/**
         * A reference to the parent of this Tween.
         * Either the Tween Manager or a Tween Timeline instance.
         *
         * @name Phaser.Tweens.Tween#parent
         * @type {(Phaser.Tweens.TweenManager|Phaser.Tweens.Timeline)}
         * @since 3.0.0
         */this.parent=t,/**
         * Is the parent of this Tween a Timeline?
         *
         * @name Phaser.Tweens.Tween#parentIsTimeline
         * @type {boolean}
         * @since 3.0.0
         */this.parentIsTimeline=t.hasOwnProperty("isTimeline"),/**
         * An array of TweenData objects, each containing a unique property and target being tweened.
         *
         * @name Phaser.Tweens.Tween#data
         * @type {Phaser.Types.Tweens.TweenDataConfig[]}
         * @since 3.0.0
         */this.data=e,/**
         * The cached length of the data array.
         *
         * @name Phaser.Tweens.Tween#totalData
         * @type {integer}
         * @since 3.0.0
         */this.totalData=e.length,/**
         * An array of references to the target/s this Tween is operating on.
         *
         * @name Phaser.Tweens.Tween#targets
         * @type {object[]}
         * @since 3.0.0
         */this.targets=i,/**
         * Cached target total (not necessarily the same as the data total)
         *
         * @name Phaser.Tweens.Tween#totalTargets
         * @type {integer}
         * @since 3.0.0
         */this.totalTargets=i.length,/**
         * If `true` then duration, delay, etc values are all frame totals.
         *
         * @name Phaser.Tweens.Tween#useFrames
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.useFrames=!1,/**
         * Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.
         * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.
         *
         * @name Phaser.Tweens.Tween#timeScale
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.timeScale=1,/**
         * Loop this tween? Can be -1 for an infinite loop, or an integer.
         * When enabled it will play through ALL TweenDatas again. Use TweenData.repeat to loop a single element.
         *
         * @name Phaser.Tweens.Tween#loop
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.loop=0,/**
         * Time in ms/frames before the tween loops.
         *
         * @name Phaser.Tweens.Tween#loopDelay
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.loopDelay=0,/**
         * How many loops are left to run?
         *
         * @name Phaser.Tweens.Tween#loopCounter
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.loopCounter=0,/**
         * Time in ms/frames before the 'onStart' event fires.
         * This is the shortest `delay` value across all of the TweenDatas of this Tween.
         *
         * @name Phaser.Tweens.Tween#startDelay
         * @type {number}
         * @default 0
         * @since 3.19.0
         */this.startDelay=0,/**
         * Has this Tween started playback yet?
         * This boolean is toggled when the Tween leaves the 'delayed' state and starts running.
         *
         * @name Phaser.Tweens.Tween#hasStarted
         * @type {boolean}
         * @readonly
         * @since 3.19.0
         */this.hasStarted=!1,/**
         * Is this Tween currently seeking?
         * This boolean is toggled in the `Tween.seek` method.
         * When a tween is seeking it will not dispatch any events or callbacks.
         *
         * @name Phaser.Tweens.Tween#isSeeking
         * @type {boolean}
         * @readonly
         * @since 3.19.0
         */this.isSeeking=!1,/**
         * Time in ms/frames before the 'onComplete' event fires. This never fires if loop = -1 (as it never completes)
         *
         * @name Phaser.Tweens.Tween#completeDelay
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.completeDelay=0,/**
         * Countdown timer (used by timeline offset, loopDelay and completeDelay)
         *
         * @name Phaser.Tweens.Tween#countdown
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.countdown=0,/**
         * Set only if this Tween is part of a Timeline.
         *
         * @name Phaser.Tweens.Tween#offset
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.offset=0,/**
         * Set only if this Tween is part of a Timeline. The calculated offset amount.
         *
         * @name Phaser.Tweens.Tween#calculatedOffset
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.calculatedOffset=0,/**
         * The current state of the tween
         *
         * @name Phaser.Tweens.Tween#state
         * @type {integer}
         * @since 3.0.0
         */this.state=h.PENDING_ADD,/**
         * The state of the tween when it was paused (used by Resume)
         *
         * @name Phaser.Tweens.Tween#_pausedState
         * @type {integer}
         * @private
         * @since 3.0.0
         */this._pausedState=h.INIT,/**
         * Does the Tween start off paused? (if so it needs to be started with Tween.play)
         *
         * @name Phaser.Tweens.Tween#paused
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.paused=!1,/**
         * Elapsed time in ms/frames of this run through the Tween.
         *
         * @name Phaser.Tweens.Tween#elapsed
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.elapsed=0,/**
         * Total elapsed time in ms/frames of the entire Tween, including looping.
         *
         * @name Phaser.Tweens.Tween#totalElapsed
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.totalElapsed=0,/**
         * Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays.
         *
         * @name Phaser.Tweens.Tween#duration
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.duration=0,/**
         * Value between 0 and 1. The amount through the Tween, excluding loops.
         *
         * @name Phaser.Tweens.Tween#progress
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.progress=0,/**
         * Time in ms/frames for the Tween to complete (including looping)
         *
         * @name Phaser.Tweens.Tween#totalDuration
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.totalDuration=0,/**
         * Value between 0 and 1. The amount through the entire Tween, including looping.
         *
         * @name Phaser.Tweens.Tween#totalProgress
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.totalProgress=0,/**
         * An object containing the different Tween callback functions.
         * 
         * You can either set these in the Tween config, or by calling the `Tween.setCallback` method.
         * 
         * `onActive` When the Tween is moved from the pending to the active list in the Tween Manager, even if playback paused.
         * `onStart` When the Tween starts playing after a delayed state. Will happen at the same time as `onActive` if it has no delay.
         * `onYoyo` When a TweenData starts a yoyo. This happens _after_ the `hold` delay expires, if set.
         * `onRepeat` When a TweenData repeats playback. This happens _after_ the `repeatDelay` expires, if set.
         * `onComplete` When the Tween finishes playback fully or `Tween.stop` is called. Never invoked if tween is set to repeat infinitely.
         * `onUpdate` When a TweenData updates a property on a source target during playback.
         * `onLoop` When a Tween loops. This happens _after_ the `loopDelay` expires, if set.
         *
         * @name Phaser.Tweens.Tween#callbacks
         * @type {object}
         * @since 3.0.0
         */this.callbacks={onActive:null,onComplete:null,onLoop:null,onRepeat:null,onStart:null,onUpdate:null,onYoyo:null},/**
         * The context in which all callbacks are invoked.
         *
         * @name Phaser.Tweens.Tween#callbackScope
         * @type {any}
         * @since 3.0.0
         */this.callbackScope},/**	
     * Returns the current value of the specified Tween Data.
     *
     * @method Phaser.Tweens.Tween#getValue
     * @since 3.0.0
     * 
     * @param {integer} [index=0] - The Tween Data to return the value from.
     *
     * @return {number} The value of the requested Tween Data.
     */getValue:function(t){return void 0===t&&(t=0),this.data[t].current},/**
     * Set the scale the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.
     *
     * @method Phaser.Tweens.Tween#setTimeScale
     * @since 3.0.0
     *
     * @param {number} value - The scale factor for timescale.
     *
     * @return {this} - This Tween instance.
     */setTimeScale:function(t){return this.timeScale=t,this},/**
     * Returns the scale of the time applied to this Tween.
     *
     * @method Phaser.Tweens.Tween#getTimeScale
     * @since 3.0.0
     *
     * @return {number} The timescale of this tween (between 0 and 1)
     */getTimeScale:function(){return this.timeScale},/**
     * Checks if the Tween is currently active.
     *
     * @method Phaser.Tweens.Tween#isPlaying
     * @since 3.0.0
     *
     * @return {boolean} `true` if the Tween is active, otherwise `false`.
     */isPlaying:function(){return this.state===h.ACTIVE},/**
     * Checks if the Tween is currently paused.
     *
     * @method Phaser.Tweens.Tween#isPaused
     * @since 3.0.0
     *
     * @return {boolean} `true` if the Tween is paused, otherwise `false`.
     */isPaused:function(){return this.state===h.PAUSED},/**
     * See if this Tween is currently acting upon the given target.
     *
     * @method Phaser.Tweens.Tween#hasTarget
     * @since 3.0.0
     *
     * @param {object} target - The target to check against this Tween.
     *
     * @return {boolean} `true` if the given target is a target of this Tween, otherwise `false`.
     */hasTarget:function(t){return -1!==this.targets.indexOf(t)},/**
     * Updates the 'end' value of the given property across all matching targets.
     * 
     * Calling this does not adjust the duration of the tween, or the current progress.
     * 
     * You can optionally tell it to set the 'start' value to be the current value (before the change).
     *
     * @method Phaser.Tweens.Tween#updateTo
     * @since 3.0.0
     *
     * @param {string} key - The property to set the new value for.
     * @param {*} value - The new value of the property.
     * @param {boolean} [startToCurrent=false] - Should this change set the start value to be the current value?
     *
     * @return {this} - This Tween instance.
     */updateTo:function(t,e,i){void 0===i&&(i=!1);for(var n=0;n<this.totalData;n++){var s=this.data[n];s.key===t&&(s.end=e,i&&(s.start=s.current))}return this},/**
     * Restarts the tween from the beginning.
     *
     * @method Phaser.Tweens.Tween#restart
     * @since 3.0.0
     *
     * @return {this} This Tween instance.
     */restart:function(){return(//  Reset these so they're ready for the next update
this.elapsed=0,this.progress=0,this.totalElapsed=0,this.totalProgress=0,this.state===h.ACTIVE)?this.seek(0):this.state===h.REMOVED?(this.seek(0),this.parent.makeActive(this),this):this.state===h.PENDING_ADD?this:this.play()},/**
     * Internal method that calculates the overall duration of the Tween.
     *
     * @method Phaser.Tweens.Tween#calcDuration
     * @since 3.0.0
     */calcDuration:function(){for(var t=0,e=l.MAX_SAFE_INTEGER,i=this.data,n=0;n<this.totalData;n++){var s=i[n];//  Set t1 (duration + hold + yoyo)
s.t1=s.duration+s.hold,s.yoyo&&(s.t1+=s.duration),//  Set t2 (repeatDelay + duration + hold + yoyo)
s.t2=s.t1+s.repeatDelay,//  Total Duration
s.totalDuration=s.delay+s.t1,-1===s.repeat?s.totalDuration+=999999999999*s.t2:s.repeat>0&&(s.totalDuration+=s.t2*s.repeat),s.totalDuration>t&&(t=s.totalDuration),s.delay<e&&(e=s.delay)}//  Excludes loop values
//  If duration has been set to 0 then we give it a super-low value so that it always
//  renders at least 1 frame, but no more, without causing divided by zero errors elsewhere.
this.duration=Math.max(t,.001),this.loopCounter=-1===this.loop?999999999999:this.loop,this.loopCounter>0?this.totalDuration=this.duration+this.completeDelay+(this.duration+this.loopDelay)*this.loopCounter:this.totalDuration=this.duration+this.completeDelay,//  How long before this Tween starts playback?
this.startDelay=e},/**
     * Called by TweenManager.preUpdate as part of its loop to check pending and active tweens.
     * Should not be called directly.
     *
     * @method Phaser.Tweens.Tween#init
     * @since 3.0.0
     *
     * @return {boolean} Returns `true` if this Tween should be moved from the pending list to the active list by the Tween Manager.
     */init:function(){//  You can't have a paused Tween if it's part of a Timeline
if(this.paused&&!this.parentIsTimeline)return this.state=h.PENDING_ADD,this._pausedState=h.INIT,!1;for(var t=this.data,e=this.totalTargets,i=0;i<this.totalData;i++){var n=t[i],s=n.target,r=n.gen,o=n.key,a=n.index;//  Old function signature: i, totalTargets, target
//  New function signature: target, key, value, index, total, tween
n.delay=r.delay(s,o,0,a,e,this),n.duration=Math.max(r.duration(s,o,0,a,e,this),.001),n.hold=r.hold(s,o,0,a,e,this),n.repeat=r.repeat(s,o,0,a,e,this),n.repeatDelay=r.repeatDelay(s,o,0,a,e,this)}return this.calcDuration(),this.progress=0,this.totalProgress=0,this.elapsed=0,this.totalElapsed=0,this.state=h.INIT,!0},/**
     * Internal method that makes this Tween active within the TweenManager
     * and emits the onActive event and callback.
     *
     * @method Phaser.Tweens.Tween#makeActive
     * @fires Phaser.Tweens.Events#TWEEN_ACTIVE
     * @since 3.19.0
     */makeActive:function(){this.parent.makeActive(this),this.dispatchTweenEvent(r.TWEEN_ACTIVE,this.callbacks.onActive)},/**
     * Internal method that advances to the next state of the Tween during playback.
     *
     * @method Phaser.Tweens.Tween#nextState
     * @fires Phaser.Tweens.Events#TWEEN_COMPLETE
     * @fires Phaser.Tweens.Events#TWEEN_LOOP
     * @since 3.0.0
     */nextState:function(){this.loopCounter>0?(this.elapsed=0,this.progress=0,this.loopCounter--,this.resetTweenData(!0),this.loopDelay>0?(this.countdown=this.loopDelay,this.state=h.LOOP_DELAY):(this.state=h.ACTIVE,this.dispatchTweenEvent(r.TWEEN_LOOP,this.callbacks.onLoop))):this.completeDelay>0?(this.state=h.COMPLETE_DELAY,this.countdown=this.completeDelay):(this.state=h.PENDING_REMOVE,this.dispatchTweenEvent(r.TWEEN_COMPLETE,this.callbacks.onComplete))},/**
     * Pauses the Tween immediately. Use `resume` to continue playback.
     *
     * @method Phaser.Tweens.Tween#pause
     * @since 3.0.0
     *
     * @return {this} - This Tween instance.
     */pause:function(){return this.state===h.PAUSED||(this.paused=!0,this._pausedState=this.state,this.state=h.PAUSED),this},/**
     * Starts a Tween playing.
     * 
     * You only need to call this method if you have configured the tween to be paused on creation.
     * 
     * If the Tween is already playing, calling this method again will have no effect. If you wish to
     * restart the Tween, use `Tween.restart` instead.
     * 
     * Calling this method after the Tween has completed will start the Tween playing again from the start.
     * This is the same as calling `Tween.seek(0)` and then `Tween.play()`.
     *
     * @method Phaser.Tweens.Tween#play
     * @since 3.0.0
     *
     * @param {boolean} [resetFromTimeline=false] - Is this Tween being played as part of a Timeline?
     *
     * @return {this} This Tween instance.
     */play:function(t){void 0===t&&(t=!1);var e=this.state;return e!==h.INIT||this.parentIsTimeline?e===h.ACTIVE||e===h.PENDING_ADD&&this._pausedState===h.PENDING_ADD||(this.parentIsTimeline||e!==h.PENDING_REMOVE&&e!==h.REMOVED?this.parentIsTimeline?(this.resetTweenData(t),0===this.calculatedOffset?this.state=h.ACTIVE:(this.countdown=this.calculatedOffset,this.state=h.OFFSET_DELAY)):(this.paused?this.paused=!1:(this.resetTweenData(t),this.state=h.ACTIVE),this.makeActive()):(this.seek(0),this.parent.makeActive(this))):(this.resetTweenData(!1),this.state=h.ACTIVE),this},/**
     * Internal method that resets all of the Tween Data, including the progress and elapsed values.
     *
     * @method Phaser.Tweens.Tween#resetTweenData
     * @since 3.0.0
     *
     * @param {boolean} resetFromLoop - Has this method been called as part of a loop?
     */resetTweenData:function(t){for(var e=this.data,i=this.totalData,n=this.totalTargets,s=0;s<i;s++){var r=e[s],o=r.target,a=r.key,l=r.index;r.progress=0,r.elapsed=0,r.repeatCounter=-1===r.repeat?999999999999:r.repeat,t?(r.start=r.getStartValue(o,a,r.start,l,n,this),r.end=r.getEndValue(o,a,r.end,l,n,this),r.current=r.start,r.state=h.PLAYING_FORWARD):r.state=h.PENDING_RENDER,r.delay>0&&(r.elapsed=r.delay,r.state=h.DELAY),r.getActiveValue&&(o[a]=r.getActiveValue(r.target,r.key,r.start))}},/**
     * Resumes the playback of a previously paused Tween.
     *
     * @method Phaser.Tweens.Tween#resume
     * @since 3.0.0
     *
     * @return {this} - This Tween instance.
     */resume:function(){return this.state===h.PAUSED?(this.paused=!1,this.state=this._pausedState):this.play(),this},/**
     * Seeks to a specific point in the Tween.
     * 
     * **Note:** You cannot seek a Tween that repeats or loops forever, or that has an unusually long total duration.
     * 
     * The given position is a value between 0 and 1 which represents how far through the Tween to seek to.
     * A value of 0.5 would seek to half-way through the Tween, where-as a value of zero would seek to the start.
     * 
     * Note that the seek takes the entire duration of the Tween into account, including delays, loops and repeats.
     * For example, a Tween that lasts for 2 seconds, but that loops 3 times, would have a total duration of 6 seconds,
     * so seeking to 0.5 would seek to 3 seconds into the Tween, as that's half-way through its _entire_ duration.
     * 
     * Seeking works by resetting the Tween to its initial values and then iterating through the Tween at `delta`
     * jumps per step. The longer the Tween, the longer this can take.
     *
     * @method Phaser.Tweens.Tween#seek
     * @since 3.0.0
     *
     * @param {number} toPosition - A value between 0 and 1 which represents the progress point to seek to.
     * @param {number} [delta=16.6] - The size of each step when seeking through the Tween. A higher value completes faster but at a cost of less precision.
     *
     * @return {this} This Tween instance.
     */seek:function(t,e){if(void 0===e&&(e=16.6),this.totalDuration>=36e5)return console.warn("Tween.seek duration too long"),this;this.state===h.REMOVED&&this.makeActive(),this.elapsed=0,this.progress=0,this.totalElapsed=0,this.totalProgress=0;for(var i=this.data,n=this.totalTargets,s=0;s<this.totalData;s++){var r=i[s],o=r.target,a=r.gen,l=r.key,u=r.index;r.progress=0,r.elapsed=0,r.repeatCounter=-1===r.repeat?999999999999:r.repeat,//  Old function signature: i, totalTargets, target
//  New function signature: target, key, value, index, total, tween
r.delay=a.delay(o,l,0,u,n,this),r.duration=Math.max(a.duration(o,l,0,u,n,this),.001),r.hold=a.hold(o,l,0,u,n,this),r.repeat=a.repeat(o,l,0,u,n,this),r.repeatDelay=a.repeatDelay(o,l,0,u,n,this),r.current=r.start,r.state=h.PLAYING_FORWARD,this.updateTweenData(this,r,0,u,n),r.delay>0&&(r.elapsed=r.delay,r.state=h.DELAY)}this.calcDuration();var c=!1;this.state===h.PAUSED&&(c=!0,this.state=h.ACTIVE),this.isSeeking=!0;do this.update(0,e);while(this.totalProgress<t)return this.isSeeking=!1,c&&(this.state=h.PAUSED),this},/**
     * Sets an event based callback to be invoked during playback.
     * 
     * Calling this method will replace a previously set callback for the given type, if any exists.
     * 
     * The types available are:
     * 
     * `onActive` When the Tween is moved from the pending to the active list in the Tween Manager, even if playback paused.
     * `onStart` When the Tween starts playing after a delayed state. Will happen at the same time as `onActive` if it has no delay.
     * `onYoyo` When a TweenData starts a yoyo. This happens _after_ the `hold` delay expires, if set.
     * `onRepeat` When a TweenData repeats playback. This happens _after_ the `repeatDelay` expires, if set.
     * `onComplete` When the Tween finishes playback fully or `Tween.stop` is called. Never invoked if tween is set to repeat infinitely.
     * `onUpdate` When a TweenData updates a property on a source target during playback.
     * `onLoop` When a Tween loops. This happens _after_ the `loopDelay` expires, if set.
     *
     * @method Phaser.Tweens.Tween#setCallback
     * @since 3.0.0
     *
     * @param {string} type - Type of the callback to set.
     * @param {function} callback - The function to invoke when this callback happens.
     * @param {array} [params] - An array of parameters for specified callbacks types.
     * @param {any} [scope] - The context the callback will be invoked in.
     *
     * @return {this} This Tween instance.
     */setCallback:function(t,e,i,n){return this.callbacks[t]={func:e,scope:n,params:i},this},/**
     * Flags the Tween as being complete, whatever stage of progress it is at.
     *
     * If an onComplete callback has been defined it will automatically invoke it, unless a `delay`
     * argument is provided, in which case the Tween will delay for that period of time before calling the callback.
     *
     * If you don't need a delay, or have an onComplete callback, then call `Tween.stop` instead.
     *
     * @method Phaser.Tweens.Tween#complete
     * @fires Phaser.Tweens.Events#TWEEN_COMPLETE
     * @since 3.2.0
     *
     * @param {number} [delay=0] - The time to wait before invoking the complete callback. If zero it will fire immediately.
     *
     * @return {this} This Tween instance.
     */complete:function(t){return void 0===t&&(t=0),t?(this.state=h.COMPLETE_DELAY,this.countdown=t):(this.state=h.PENDING_REMOVE,this.dispatchTweenEvent(r.TWEEN_COMPLETE,this.callbacks.onComplete)),this},/**
     * Immediately removes this Tween from the TweenManager and all of its internal arrays,
     * no matter what stage it as it. Then sets the tween state to `REMOVED`.
     * 
     * You should dispose of your reference to this tween after calling this method, to
     * free it from memory.
     *
     * @method Phaser.Tweens.Tween#remove
     * @since 3.17.0
     *
     * @return {this} This Tween instance.
     */remove:function(){return this.parent.remove(this),this},/**
     * Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager.
     *
     * @method Phaser.Tweens.Tween#stop
     * @since 3.0.0
     *
     * @param {number} [resetTo] - If you want to seek the tween, provide a value between 0 and 1.
     *
     * @return {this} This Tween instance.
     */stop:function(t){return this.state===h.ACTIVE&&void 0!==t&&this.seek(t),this.state!==h.REMOVED&&((this.state===h.PAUSED||this.state===h.PENDING_ADD)&&(this.parentIsTimeline?(this.parent.manager._destroy.push(this),this.parent.manager._toProcess++):(this.parent._destroy.push(this),this.parent._toProcess++)),this.removeAllListeners(),this.state=h.PENDING_REMOVE),this},/**
     * Internal method that advances the Tween based on the time values.
     *
     * @method Phaser.Tweens.Tween#update
     * @fires Phaser.Tweens.Events#TWEEN_COMPLETE
     * @fires Phaser.Tweens.Events#TWEEN_LOOP
     * @fires Phaser.Tweens.Events#TWEEN_START
     * @since 3.0.0
     *
     * @param {number} timestamp - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     *
     * @return {boolean} Returns `true` if this Tween has finished and should be removed from the Tween Manager, otherwise returns `false`.
     */update:function(t,e){if(this.state===h.PAUSED)return!1;switch(this.useFrames&&(e=1*this.parent.timeScale),e*=this.timeScale,this.elapsed+=e,this.progress=Math.min(this.elapsed/this.duration,1),this.totalElapsed+=e,this.totalProgress=Math.min(this.totalElapsed/this.totalDuration,1),this.state){case h.ACTIVE:this.hasStarted||this.isSeeking||(this.startDelay-=e,this.startDelay<=0&&(this.hasStarted=!0,this.dispatchTweenEvent(r.TWEEN_START,this.callbacks.onStart)));for(var i=!1,n=0;n<this.totalData;n++){var s=this.data[n];this.updateTweenData(this,s,e)&&(i=!0)}//  Anything still running? If not, we're done
i||this.nextState();break;case h.LOOP_DELAY:this.countdown-=e,this.countdown<=0&&(this.state=h.ACTIVE,this.dispatchTweenEvent(r.TWEEN_LOOP,this.callbacks.onLoop));break;case h.OFFSET_DELAY:this.countdown-=e,this.countdown<=0&&(this.state=h.ACTIVE);break;case h.COMPLETE_DELAY:this.countdown-=e,this.countdown<=0&&(this.state=h.PENDING_REMOVE,this.dispatchTweenEvent(r.TWEEN_COMPLETE,this.callbacks.onComplete))}return this.state===h.PENDING_REMOVE},/**
     * Internal method that will emit a TweenData based Event and invoke the given callback.
     *
     * @method Phaser.Tweens.Tween#dispatchTweenDataEvent
     * @since 3.19.0
     *
     * @param {Phaser.Types.Tweens.Event} event - The Event to be dispatched.
     * @param {function} callback - The callback to be invoked. Can be `null` or `undefined` to skip invocation.
     * @param {Phaser.Types.Tweens.TweenDataConfig} tweenData - The TweenData object that caused this event.
     */dispatchTweenDataEvent:function(t,e,i){!this.isSeeking&&(this.emit(t,this,i.key,i.target,i.current,i.previous),e&&(e.params[1]=i.target,e.func.apply(e.scope,e.params)))},/**
     * Internal method that will emit a Tween based Event and invoke the given callback.
     *
     * @method Phaser.Tweens.Tween#dispatchTweenEvent
     * @since 3.19.0
     *
     * @param {Phaser.Types.Tweens.Event} event - The Event to be dispatched.
     * @param {function} callback - The callback to be invoked. Can be `null` or `undefined` to skip invocation.
     */dispatchTweenEvent:function(t,e){!this.isSeeking&&(this.emit(t,this,this.targets),e&&(e.params[1]=this.targets,e.func.apply(e.scope,e.params)))},/**
     * Internal method used as part of the playback process that sets a tween to play in reverse.
     *
     * @method Phaser.Tweens.Tween#setStateFromEnd
     * @fires Phaser.Tweens.Events#TWEEN_REPEAT
     * @fires Phaser.Tweens.Events#TWEEN_YOYO
     * @since 3.0.0
     *
     * @param {Phaser.Tweens.Tween} tween - The Tween to update.
     * @param {Phaser.Types.Tweens.TweenDataConfig} tweenData - The TweenData property to update.
     * @param {number} diff - Any extra time that needs to be accounted for in the elapsed and progress values.
     *
     * @return {integer} The state of this Tween.
     */setStateFromEnd:function(t,e,i){return e.yoyo?(//  We've hit the end of a Playing Forward TweenData and we have a yoyo
//  Account for any extra time we got from the previous frame
e.elapsed=i,e.progress=i/e.duration,e.flipX&&e.target.toggleFlipX(),e.flipY&&e.target.toggleFlipY(),this.dispatchTweenDataEvent(r.TWEEN_YOYO,t.callbacks.onYoyo,e),e.start=e.getStartValue(e.target,e.key,e.start,e.index,t.totalTargets,t),h.PLAYING_BACKWARD):e.repeatCounter>0?//  Delay?
(//  We've hit the end of a Playing Forward TweenData and we have a Repeat.
//  So we're going to go right back to the start to repeat it again.
e.repeatCounter--,//  Account for any extra time we got from the previous frame
e.elapsed=i,e.progress=i/e.duration,e.flipX&&e.target.toggleFlipX(),e.flipY&&e.target.toggleFlipY(),e.start=e.getStartValue(e.target,e.key,e.start,e.index,t.totalTargets,t),e.end=e.getEndValue(e.target,e.key,e.start,e.index,t.totalTargets,t),e.repeatDelay>0)?(e.elapsed=e.repeatDelay-i,e.current=e.start,e.target[e.key]=e.current,h.REPEAT_DELAY):(this.dispatchTweenDataEvent(r.TWEEN_REPEAT,t.callbacks.onRepeat,e),h.PLAYING_FORWARD):h.COMPLETE},/**
     * Internal method used as part of the playback process that sets a tween to play from the start.
     *
     * @method Phaser.Tweens.Tween#setStateFromStart
     * @fires Phaser.Tweens.Events#TWEEN_REPEAT
     * @since 3.0.0
     *
     * @param {Phaser.Tweens.Tween} tween - The Tween to update.
     * @param {Phaser.Types.Tweens.TweenDataConfig} tweenData - The TweenData property to update.
     * @param {number} diff - Any extra time that needs to be accounted for in the elapsed and progress values.
     *
     * @return {integer} The state of this Tween.
     */setStateFromStart:function(t,e,i){return e.repeatCounter>0?//  Delay?
(e.repeatCounter--,//  Account for any extra time we got from the previous frame
e.elapsed=i,e.progress=i/e.duration,e.flipX&&e.target.toggleFlipX(),e.flipY&&e.target.toggleFlipY(),e.end=e.getEndValue(e.target,e.key,e.start,e.index,t.totalTargets,t),e.repeatDelay>0)?(e.elapsed=e.repeatDelay-i,e.current=e.start,e.target[e.key]=e.current,h.REPEAT_DELAY):(this.dispatchTweenDataEvent(r.TWEEN_REPEAT,t.callbacks.onRepeat,e),h.PLAYING_FORWARD):h.COMPLETE},/**
     * Internal method that advances the TweenData based on the time value given.
     *
     * @method Phaser.Tweens.Tween#updateTweenData
     * @fires Phaser.Tweens.Events#TWEEN_UPDATE
     * @fires Phaser.Tweens.Events#TWEEN_REPEAT
     * @since 3.0.0
     *
     * @param {Phaser.Tweens.Tween} tween - The Tween to update.
     * @param {Phaser.Types.Tweens.TweenDataConfig} tweenData - The TweenData property to update.
     * @param {number} delta - Either a value in ms, or 1 if Tween.useFrames is true.
     *
     * @return {boolean} True if the tween is not complete (e.g., playing), or false if the tween is complete.
     */updateTweenData:function(t,e,i){var n=e.target;switch(e.state){case h.PLAYING_FORWARD:case h.PLAYING_BACKWARD:if(!n){e.state=h.COMPLETE;break}var s=e.elapsed,o=e.duration,a=0;(s+=i)>o&&(a=s-o,s=o);var l=e.state===h.PLAYING_FORWARD,u=s/o;if(e.elapsed=s,e.progress=u,e.previous=e.current,1===u)l?(e.current=e.end,n[e.key]=e.end,e.hold>0?(e.elapsed=e.hold-a,e.state=h.HOLD_DELAY):e.state=this.setStateFromEnd(t,e,a)):(e.current=e.start,n[e.key]=e.start,e.state=this.setStateFromStart(t,e,a));else{var c=l?e.ease(u):e.ease(1-u);e.current=e.start+(e.end-e.start)*c,n[e.key]=e.current}this.dispatchTweenDataEvent(r.TWEEN_UPDATE,t.callbacks.onUpdate,e);break;case h.DELAY:e.elapsed-=i,e.elapsed<=0&&(e.elapsed=Math.abs(e.elapsed),e.state=h.PENDING_RENDER);break;case h.REPEAT_DELAY:e.elapsed-=i,e.elapsed<=0&&(e.elapsed=Math.abs(e.elapsed),e.state=h.PLAYING_FORWARD,this.dispatchTweenDataEvent(r.TWEEN_REPEAT,t.callbacks.onRepeat,e));break;case h.HOLD_DELAY:e.elapsed-=i,e.elapsed<=0&&(e.state=this.setStateFromEnd(t,e,Math.abs(e.elapsed)));break;case h.PENDING_RENDER:n?(e.start=e.getStartValue(n,e.key,n[e.key],e.index,t.totalTargets,t),e.end=e.getEndValue(n,e.key,e.start,e.index,t.totalTargets,t),e.current=e.start,n[e.key]=e.start,e.state=h.PLAYING_FORWARD):e.state=h.COMPLETE}//  Return TRUE if this TweenData still playing, otherwise return FALSE
return e.state!==h.COMPLETE}});//  onActive = 'active' event = When the Tween is moved from the pending to the active list in the manager, even if playback delayed
//  onStart = 'start' event = When the Tween starts playing from a delayed state (will happen same time as onActive if no delay)
//  onYoyo = 'yoyo' event = When the Tween starts a yoyo
//  onRepeat = 'repeat' event = When a TweenData repeats playback (if any)
//  onComplete = 'complete' event = When the Tween finishes all playback (can sometimes never happen if repeat -1), also when 'stop' called
//  onUpdate = 'update' event = When the Tween updates a TweenData during playback (expensive!)
//  onLoop = 'loop' event = Used to loop ALL TweenDatas in a Tween
u.TYPES=["onActive","onComplete","onLoop","onRepeat","onStart","onUpdate","onYoyo"],/**
 * Creates a new Tween object.
 *
 * Note: This method will only be available if Tweens have been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#tween
 * @since 3.0.0
 *
 * @param {Phaser.Types.Tweens.TweenBuilderConfig|object} config - The Tween configuration.
 *
 * @return {Phaser.Tweens.Tween} The Tween that was created.
 */a.register("tween",function(t){return this.scene.sys.tweens.add(t)}),//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
/**
 * Creates a new Tween object and returns it.
 *
 * Note: This method will only be available if Tweens have been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#tween
 * @since 3.0.0
 *
 * @param {Phaser.Types.Tweens.TweenBuilderConfig|object} config - The Tween configuration.
 *
 * @return {Phaser.Tweens.Tween} The Tween that was created.
 */o.register("tween",function(t){return this.scene.sys.tweens.create(t)}),//  When registering a factory function 'this' refers to the GameObjectCreator context.
t.exports=u}),r("gkXcN",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Tweens.Events
 */t.exports={TIMELINE_COMPLETE:s("4Lxtd"),TIMELINE_LOOP:s("77Jsk"),TIMELINE_PAUSE:s("jRrki"),TIMELINE_RESUME:s("haaKV"),TIMELINE_START:s("lD4eF"),TIMELINE_UPDATE:s("9rJg3"),TWEEN_ACTIVE:s("7I3sP"),TWEEN_COMPLETE:s("eXeBB"),TWEEN_LOOP:s("hPIiG"),TWEEN_REPEAT:s("27I83"),TWEEN_START:s("5BaYx"),TWEEN_UPDATE:s("3xVxX"),TWEEN_YOYO:s("1WmlE")}}),r("4Lxtd",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Timeline Complete Event.
 * 
 * This event is dispatched by a Tween Timeline when it completes playback.
 * 
 * Listen to it from a Timeline instance using `Timeline.on('complete', listener)`, i.e.:
 * 
 * ```javascript
 * var timeline = this.tweens.timeline({
 *     targets: image,
 *     ease: 'Power1',
 *     duration: 3000,
 *     tweens: [ { x: 600 }, { y: 500 }, { x: 100 }, { y: 100 } ]
 * });
 * timeline.on('complete', listener);
 * timeline.play();
 * ```
 *
 * @event Phaser.Tweens.Events#TIMELINE_COMPLETE
 * @since 3.0.0
 * 
 * @param {Phaser.Tweens.Timeline} timeline - A reference to the Timeline instance that emitted the event.
 */t.exports="complete"}),r("77Jsk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Timeline Loop Event.
 * 
 * This event is dispatched by a Tween Timeline every time it loops.
 * 
 * Listen to it from a Timeline instance using `Timeline.on('loop', listener)`, i.e.:
 * 
 * ```javascript
 * var timeline = this.tweens.timeline({
 *     targets: image,
 *     ease: 'Power1',
 *     duration: 3000,
 *     loop: 4,
 *     tweens: [ { x: 600 }, { y: 500 }, { x: 100 }, { y: 100 } ]
 * });
 * timeline.on('loop', listener);
 * timeline.play();
 * ```
 *
 * @event Phaser.Tweens.Events#TIMELINE_LOOP
 * @since 3.0.0
 * 
 * @param {Phaser.Tweens.Timeline} timeline - A reference to the Timeline instance that emitted the event.
 */t.exports="loop"}),r("jRrki",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Timeline Pause Event.
 * 
 * This event is dispatched by a Tween Timeline when it is paused.
 * 
 * Listen to it from a Timeline instance using `Timeline.on('pause', listener)`, i.e.:
 * 
 * ```javascript
 * var timeline = this.tweens.timeline({
 *     targets: image,
 *     ease: 'Power1',
 *     duration: 3000,
 *     tweens: [ { x: 600 }, { y: 500 }, { x: 100 }, { y: 100 } ]
 * });
 * timeline.on('pause', listener);
 * // At some point later ...
 * timeline.pause();
 * ```
 *
 * @event Phaser.Tweens.Events#TIMELINE_PAUSE
 * @since 3.0.0
 * 
 * @param {Phaser.Tweens.Timeline} timeline - A reference to the Timeline instance that emitted the event.
 */t.exports="pause"}),r("haaKV",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Timeline Resume Event.
 * 
 * This event is dispatched by a Tween Timeline when it is resumed from a paused state.
 * 
 * Listen to it from a Timeline instance using `Timeline.on('resume', listener)`, i.e.:
 * 
 * ```javascript
 * var timeline = this.tweens.timeline({
 *     targets: image,
 *     ease: 'Power1',
 *     duration: 3000,
 *     tweens: [ { x: 600 }, { y: 500 }, { x: 100 }, { y: 100 } ]
 * });
 * timeline.on('resume', listener);
 * // At some point later ...
 * timeline.resume();
 * ```
 *
 * @event Phaser.Tweens.Events#TIMELINE_RESUME
 * @since 3.0.0
 * 
 * @param {Phaser.Tweens.Timeline} timeline - A reference to the Timeline instance that emitted the event.
 */t.exports="resume"}),r("lD4eF",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Timeline Start Event.
 * 
 * This event is dispatched by a Tween Timeline when it starts.
 * 
 * Listen to it from a Timeline instance using `Timeline.on('start', listener)`, i.e.:
 * 
 * ```javascript
 * var timeline = this.tweens.timeline({
 *     targets: image,
 *     ease: 'Power1',
 *     duration: 3000,
 *     tweens: [ { x: 600 }, { y: 500 }, { x: 100 }, { y: 100 } ]
 * });
 * timeline.on('start', listener);
 * timeline.play();
 * ```
 *
 * @event Phaser.Tweens.Events#TIMELINE_START
 * @since 3.0.0
 * 
 * @param {Phaser.Tweens.Timeline} timeline - A reference to the Timeline instance that emitted the event.
 */t.exports="start"}),r("9rJg3",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Timeline Update Event.
 * 
 * This event is dispatched by a Tween Timeline every time it updates, which can happen a lot of times per second,
 * so be careful about listening to this event unless you absolutely require it.
 * 
 * Listen to it from a Timeline instance using `Timeline.on('update', listener)`, i.e.:
 * 
 * ```javascript
 * var timeline = this.tweens.timeline({
 *     targets: image,
 *     ease: 'Power1',
 *     duration: 3000,
 *     tweens: [ { x: 600 }, { y: 500 }, { x: 100 }, { y: 100 } ]
 * });
 * timeline.on('update', listener);
 * timeline.play();
 * ```
 *
 * @event Phaser.Tweens.Events#TIMELINE_UPDATE
 * @since 3.0.0
 * 
 * @param {Phaser.Tweens.Timeline} timeline - A reference to the Timeline instance that emitted the event.
 */t.exports="update"}),r("7I3sP",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Tween Active Event.
 * 
 * This event is dispatched by a Tween when it becomes active within the Tween Manager.
 * 
 * An 'active' Tween is one that is now progressing, although it may not yet be updating
 * any target properties, due to settings such as `delay`. If you need an event for when
 * the Tween starts actually updating its first property, see `TWEEN_START`.
 * 
 * Listen to it from a Tween instance using `Tween.on('active', listener)`, i.e.:
 * 
 * ```javascript
 * var tween = this.tweens.add({
 *     targets: image,
 *     x: 500,
 *     ease: 'Power1',
 *     duration: 3000
 * });
 * tween.on('active', listener);
 * ```
 *
 * @event Phaser.Tweens.Events#TWEEN_ACTIVE
 * @since 3.19.0
 * 
 * @param {Phaser.Tweens.Tween} tween - A reference to the Tween instance that emitted the event.
 * @param {any[]} targets - An array of references to the target/s the Tween is operating on.
 */t.exports="active"}),r("eXeBB",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Tween Complete Event.
 * 
 * This event is dispatched by a Tween when it completes playback entirely, factoring in repeats and loops.
 * 
 * If the Tween has been set to loop or repeat infinitely, this event will not be dispatched
 * unless the `Tween.stop` method is called.
 * 
 * If a Tween has a `completeDelay` set, this event will fire after that delay expires.
 * 
 * Listen to it from a Tween instance using `Tween.on('complete', listener)`, i.e.:
 * 
 * ```javascript
 * var tween = this.tweens.add({
 *     targets: image,
 *     x: 500,
 *     ease: 'Power1',
 *     duration: 3000
 * });
 * tween.on('complete', listener);
 * ```
 *
 * @event Phaser.Tweens.Events#TWEEN_COMPLETE
 * @since 3.19.0
 * 
 * @param {Phaser.Tweens.Tween} tween - A reference to the Tween instance that emitted the event.
 * @param {any[]} targets - An array of references to the target/s the Tween is operating on.
 */t.exports="complete"}),r("hPIiG",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Tween Loop Event.
 * 
 * This event is dispatched by a Tween when it loops.
 * 
 * This event will only be dispatched if the Tween has a loop count set.
 * 
 * If a Tween has a `loopDelay` set, this event will fire after that delay expires.
 * 
 * The difference between `loop` and `repeat` is that `repeat` is a property setting,
 * where-as `loop` applies to the entire Tween.
 * 
 * Listen to it from a Tween instance using `Tween.on('loop', listener)`, i.e.:
 * 
 * ```javascript
 * var tween = this.tweens.add({
 *     targets: image,
 *     x: 500,
 *     ease: 'Power1',
 *     duration: 3000,
 *     loop: 6
 * });
 * tween.on('loop', listener);
 * ```
 *
 * @event Phaser.Tweens.Events#TWEEN_LOOP
 * @since 3.19.0
 * 
 * @param {Phaser.Tweens.Tween} tween - A reference to the Tween instance that emitted the event.
 * @param {any[]} targets - An array of references to the target/s the Tween is operating on.
 */t.exports="loop"}),r("27I83",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Tween Repeat Event.
 * 
 * This event is dispatched by a Tween when one of the properties it is tweening repeats.
 * 
 * This event will only be dispatched if the Tween has a property with a repeat count set.
 * 
 * If a Tween has a `repeatDelay` set, this event will fire after that delay expires.
 * 
 * The difference between `loop` and `repeat` is that `repeat` is a property setting,
 * where-as `loop` applies to the entire Tween.
 * 
 * Listen to it from a Tween instance using `Tween.on('repeat', listener)`, i.e.:
 * 
 * ```javascript
 * var tween = this.tweens.add({
 *     targets: image,
 *     x: 500,
 *     ease: 'Power1',
 *     duration: 3000,
 *     repeat: 4
 * });
 * tween.on('repeat', listener);
 * ```
 *
 * @event Phaser.Tweens.Events#TWEEN_REPEAT
 * @since 3.19.0
 * 
 * @param {Phaser.Tweens.Tween} tween - A reference to the Tween instance that emitted the event.
 * @param {string} key - The key of the property that just repeated.
 * @param {any} target - The target that the property just repeated on.
 */t.exports="repeat"}),r("5BaYx",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Tween Start Event.
 * 
 * This event is dispatched by a Tween when it starts tweening its first property.
 * 
 * A Tween will only emit this event once, as it can only start once.
 * 
 * If a Tween has a `delay` set, this event will fire after that delay expires.
 * 
 * Listen to it from a Tween instance using `Tween.on('start', listener)`, i.e.:
 * 
 * ```javascript
 * var tween = this.tweens.add({
 *     targets: image,
 *     x: 500,
 *     ease: 'Power1',
 *     duration: 3000
 * });
 * tween.on('start', listener);
 * ```
 *
 * @event Phaser.Tweens.Events#TWEEN_START
 * @since 3.19.0
 * 
 * @param {Phaser.Tweens.Tween} tween - A reference to the Tween instance that emitted the event.
 * @param {any[]} targets - An array of references to the target/s the Tween is operating on.
 */t.exports="start"}),r("3xVxX",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Tween Update Event.
 * 
 * This event is dispatched by a Tween every time it updates _any_ of the properties it is tweening.
 * 
 * A Tween that is changing 3 properties of a target will emit this event 3 times per change, once per property.
 * 
 * **Note:** This is a very high frequency event and may be dispatched multiple times, every single frame.
 * 
 * Listen to it from a Tween instance using `Tween.on('update', listener)`, i.e.:
 * 
 * ```javascript
 * var tween = this.tweens.add({
 *     targets: image,
 *     x: 500,
 *     ease: 'Power1',
 *     duration: 3000,
 * });
 * tween.on('update', listener);
 * ```
 *
 * @event Phaser.Tweens.Events#TWEEN_UPDATE
 * @since 3.19.0
 * 
 * @param {Phaser.Tweens.Tween} tween - A reference to the Tween instance that emitted the event.
 * @param {string} key - The property that was updated, i.e. `x` or `scale`.
 * @param {any} target - The target object that was updated. Usually a Game Object, but can be of any type.
 * @param {number} current - The current value of the property that was tweened.
 * @param {number} previous - The previous value of the property that was tweened, prior to this update.
 */t.exports="update"}),r("1WmlE",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * The Tween Yoyo Event.
 * 
 * This event is dispatched by a Tween whenever a property it is tweening yoyos.
 * 
 * This event will only be dispatched if the Tween has a property with `yoyo` set.
 * 
 * If the Tween has a `hold` value, this event is dispatched when the hold expires.
 * 
 * This event is dispatched for every property, and for every target, that yoyos.
 * For example, if a Tween was updating 2 properties and had 10 targets, this event
 * would be dispatched 20 times (twice per target). So be careful how you use it!
 * 
 * Listen to it from a Tween instance using `Tween.on('yoyo', listener)`, i.e.:
 * 
 * ```javascript
 * var tween = this.tweens.add({
 *     targets: image,
 *     x: 500,
 *     ease: 'Power1',
 *     duration: 3000,
 *     yoyo: true
 * });
 * tween.on('yoyo', listener);
 * ```
 *
 * @event Phaser.Tweens.Events#TWEEN_YOYO
 * @since 3.19.0
 * 
 * @param {Phaser.Tweens.Tween} tween - A reference to the Tween instance that emitted the event.
 * @param {string} key - The property that yoyo'd, i.e. `x` or `scale`.
 * @param {any} target - The target object that was yoyo'd. Usually a Game Object, but can be of any type.
 */t.exports="yoyo"}),r("b70cP",function(t,e){t.exports=function(t,e,i,n,s,r,o,a,h,l,u,c,d,f,p){return{//  The target to tween
target:t,//  The index of the target within the tween targets array
index:e,//  The property of the target to tween
key:i,//  What to set the property to the moment the TweenData is invoked.
getActiveValue:r,//  The returned value sets what the property will be at the END of the Tween.
getEndValue:n,//  The returned value sets what the property will be at the START of the Tween.
getStartValue:s,//  The ease function this tween uses.
ease:o,//  Duration of the tween in ms/frames, excludes time for yoyo or repeats.
duration:0,//  The total calculated duration of this TweenData (based on duration, repeat, delay and yoyo)
totalDuration:0,//  Time in ms/frames before tween will start.
delay:0,//  Cause the tween to return back to its start value after hold has expired.
yoyo:l,//  Time in ms/frames the tween will pause before running the yoyo or starting a repeat.
hold:0,//  Number of times to repeat the tween. The tween will always run once regardless, so a repeat value of '1' will play the tween twice.
repeat:0,//  Time in ms/frames before the repeat will start.
repeatDelay:0,//  Automatically call toggleFlipX when the TweenData yoyos or repeats
flipX:f,//  Automatically call toggleFlipY when the TweenData yoyos or repeats
flipY:p,//  Between 0 and 1 showing completion of this TweenData.
progress:0,//  Delta counter.
elapsed:0,//  How many repeats are left to run?
repeatCounter:0,//  Ease Value Data:
start:0,previous:0,current:0,end:0,//  Time Durations
t1:0,t2:0,//  LoadValue generation functions
gen:{delay:a,duration:h,hold:u,repeat:c,repeatDelay:d},//  TWEEN_CONST.CREATED
state:0}}}),r("lvk9S",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("aANNX"),n=s("5pMDk"),r=s("bNtDi");t.exports=function(t,e){void 0===e&&(e={});var s=n(e,"start",0),o=n(e,"ease",null),a=n(e,"grid",null),h=n(e,"from",0),l="first"===h,u="center"===h,c="last"===h,d="number"==typeof h,f=Array.isArray(t),p=f?parseFloat(t[0]):parseFloat(t),g=f?parseFloat(t[1]):0,v=Math.max(p,g);if(f&&(s+=p),a){//  Pre-calc the grid to save doing it for ever tweendata update
var m=a[0],y=a[1],x=0,w=0,T=0,b=0,S=[];c?(x=m-1,w=y-1):d?(x=h%m,w=Math.floor(h/m)):u&&(x=(m-1)/2,w=(y-1)/2);for(var A=r.MIN_SAFE_INTEGER,E=0;E<y;E++){S[E]=[];for(var _=0;_<m;_++){var C=Math.sqrt((T=x-_)*T+(b=w-E)*b);C>A&&(A=C),S[E][_]=C}}}var M=o?i(o):null;return a?function(t,e,i,n){var r,o=0,a=n%m,h=Math.floor(n/m);if(a>=0&&a<m&&h>=0&&h<y&&(o=S[h][a]),f){var l=g-p;r=M?o/A*l*M(o/A):o/A*l}else r=M?o*p*M(o/A):o*p;return r+s}:function(t,e,i,n,r){var o,a,m;return(//  zero offset
r--,l?o=n:u?o=Math.abs(r/2-n):c?o=r-n:d&&(o=Math.abs(h-n)),f?(m=u?(g-p)/r*(2*o):(g-p)/r*o,a=M?m*M(o/r):m):a=M?r*v*M(o/r):o*p,a+s)}}}),r("agb2N",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5pqmQ"),n=s("6AqCF"),r=s("cSaNN"),o=s("iuXOO"),a=s("aANNX"),h=s("hoIQ4"),l=s("8Hbk7"),u=s("2zEft"),c=s("5pMDk"),d=s("haSds"),f=s("fZhty");t.exports=function(t,e){var s=new d(t),p=u(e);if(0===p.length)return s.paused=!0,s;var g=i(n);g.targets=l(e);//  totalDuration: If specified each tween in the Timeline is given an equal portion of the totalDuration
var v=r(e,"totalDuration",0);v>0?g.duration=Math.floor(v/p.length):g.duration=h(e,"duration",g.duration),g.delay=h(e,"delay",g.delay),g.easeParams=c(e,"easeParams",g.easeParams),g.ease=a(c(e,"ease",g.ease),g.easeParams),g.hold=h(e,"hold",g.hold),g.repeat=h(e,"repeat",g.repeat),g.repeatDelay=h(e,"repeatDelay",g.repeatDelay),g.yoyo=o(e,"yoyo",g.yoyo),g.flipX=o(e,"flipX",g.flipX),g.flipY=o(e,"flipY",g.flipY);//  Create the Tweens
for(var m=0;m<p.length;m++)s.queue(f(s,p[m],g));s.completeDelay=r(e,"completeDelay",0),s.loop=Math.round(r(e,"loop",0)),s.loopDelay=Math.round(r(e,"loopDelay",0)),s.paused=o(e,"paused",!1),s.useFrames=o(e,"useFrames",!1);//  Callbacks
var y=c(e,"callbackScope",s),x=[s],w=c(e,"onStart",!1);//  The Start of the Timeline
if(w){var T=c(e,"onStartScope",y),b=c(e,"onStartParams",[]);s.setCallback("onStart",w,x.concat(b),T)}var S=c(e,"onUpdate",!1);//  Every time the Timeline updates (regardless which Tweens are running)
if(S){var A=c(e,"onUpdateScope",y),E=c(e,"onUpdateParams",[]);s.setCallback("onUpdate",S,x.concat(E),A)}var _=c(e,"onLoop",!1);//  Called when the whole Timeline loops
if(_){var C=c(e,"onLoopScope",y),M=c(e,"onLoopParams",[]);s.setCallback("onLoop",_,x.concat(M),C)}var P=c(e,"onYoyo",!1);//  Called when a Timeline yoyos
if(P){var O=c(e,"onYoyoScope",y),R=c(e,"onYoyoParams",[]);s.setCallback("onYoyo",P,x.concat(null,R),O)}var L=c(e,"onComplete",!1);//  Called when the Timeline completes, after the completeDelay, etc.
if(L){var k=c(e,"onCompleteScope",y),D=c(e,"onCompleteParams",[]);s.setCallback("onComplete",L,x.concat(D),k)}return s}}),r("haSds",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("jwj1g"),n=s("3vRz3"),r=s("gkXcN"),o=s("fZhty"),a=s("7lENH"),h=new i({Extends:n,initialize:function(t){n.call(this),/**
         * The Tween Manager which owns this Timeline.
         *
         * @name Phaser.Tweens.Timeline#manager
         * @type {Phaser.Tweens.TweenManager}
         * @since 3.0.0
         */this.manager=t,/**
         * A constant value which allows this Timeline to be easily identified as one.
         *
         * @name Phaser.Tweens.Timeline#isTimeline
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.isTimeline=!0,/**
         * An array of Tween objects, each containing a unique property and target being tweened.
         *
         * @name Phaser.Tweens.Timeline#data
         * @type {array}
         * @default []
         * @since 3.0.0
         */this.data=[],/**
         * The cached size of the data array.
         *
         * @name Phaser.Tweens.Timeline#totalData
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.totalData=0,/**
         * If true then duration, delay, etc values are all frame totals, rather than ms.
         *
         * @name Phaser.Tweens.Timeline#useFrames
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.useFrames=!1,/**
         * Scales the time applied to this Timeline. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.
         * Value isn't used when calculating total duration of the Timeline, it's a run-time delta adjustment only.
         *
         * @name Phaser.Tweens.Timeline#timeScale
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.timeScale=1,/**
         * Loop this Timeline? Can be -1 for an infinite loop, or an integer.
         * When enabled it will play through ALL Tweens again (use Tween.repeat to loop a single tween)
         *
         * @name Phaser.Tweens.Timeline#loop
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.loop=0,/**
         * Time in ms/frames before this Timeline loops.
         *
         * @name Phaser.Tweens.Timeline#loopDelay
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.loopDelay=0,/**
         * How many loops are left to run?
         *
         * @name Phaser.Tweens.Timeline#loopCounter
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.loopCounter=0,/**
         * Time in ms/frames before the 'onComplete' event fires. This never fires if loop = true (as it never completes)
         *
         * @name Phaser.Tweens.Timeline#completeDelay
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.completeDelay=0,/**
         * Countdown timer value, as used by `loopDelay` and `completeDelay`.
         *
         * @name Phaser.Tweens.Timeline#countdown
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.countdown=0,/**
         * The current state of the Timeline.
         *
         * @name Phaser.Tweens.Timeline#state
         * @type {integer}
         * @since 3.0.0
         */this.state=a.PENDING_ADD,/**
         * The state of the Timeline when it was paused (used by Resume)
         *
         * @name Phaser.Tweens.Timeline#_pausedState
         * @type {integer}
         * @private
         * @since 3.0.0
         */this._pausedState=a.PENDING_ADD,/**
         * Does the Timeline start off paused? (if so it needs to be started with Timeline.play)
         *
         * @name Phaser.Tweens.Timeline#paused
         * @type {boolean}
         * @default false
         * @since 3.0.0
         */this.paused=!1,/**
         * Elapsed time in ms/frames of this run through of the Timeline.
         *
         * @name Phaser.Tweens.Timeline#elapsed
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.elapsed=0,/**
         * Total elapsed time in ms/frames of the entire Timeline, including looping.
         *
         * @name Phaser.Tweens.Timeline#totalElapsed
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.totalElapsed=0,/**
         * Time in ms/frames for the whole Timeline to play through once, excluding loop amounts and loop delays.
         *
         * @name Phaser.Tweens.Timeline#duration
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.duration=0,/**
         * Value between 0 and 1. The amount of progress through the Timeline, _excluding loops_.
         *
         * @name Phaser.Tweens.Timeline#progress
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.progress=0,/**
         * Time in ms/frames for all Tweens in this Timeline to complete (including looping)
         *
         * @name Phaser.Tweens.Timeline#totalDuration
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.totalDuration=0,/**
         * Value between 0 and 1. The amount through the entire Timeline, including looping.
         *
         * @name Phaser.Tweens.Timeline#totalProgress
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.totalProgress=0,/**
         * An object containing the different Tween callback functions.
         * 
         * You can either set these in the Tween config, or by calling the `Tween.setCallback` method.
         * 
         * `onComplete` When the Timeline finishes playback fully or `Timeline.stop` is called. Never invoked if timeline is set to repeat infinitely.
         * `onLoop` When a Timeline loops.
         * `onStart` When the Timeline starts playing.
         * `onUpdate` When a Timeline updates a child Tween.
         * `onYoyo` When a Timeline starts a yoyo.
         *
         * @name Phaser.Tweens.Timeline#callbacks
         * @type {object}
         * @since 3.0.0
         */this.callbacks={onComplete:null,onLoop:null,onStart:null,onUpdate:null,onYoyo:null},/**
         * The context in which all callbacks are invoked.
         *
         * @name Phaser.Tweens.Timeline#callbackScope
         * @type {any}
         * @since 3.0.0
         */this.callbackScope},/**
     * Internal method that will emit a Timeline based Event and invoke the given callback.
     *
     * @method Phaser.Tweens.Timeline#dispatchTimelineEvent
     * @since 3.19.0
     *
     * @param {Phaser.Types.Tweens.Event} event - The Event to be dispatched.
     * @param {function} callback - The callback to be invoked. Can be `null` or `undefined` to skip invocation.
     */dispatchTimelineEvent:function(t,e){this.emit(t,this),e&&e.func.apply(e.scope,e.params)},/**
     * Sets the value of the time scale applied to this Timeline. A value of 1 runs in real-time.
     * A value of 0.5 runs 50% slower, and so on.
     * 
     * The value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.
     *
     * @method Phaser.Tweens.Timeline#setTimeScale
     * @since 3.0.0
     *
     * @param {number} value - The time scale value to set.
     *
     * @return {this} This Timeline object.
     */setTimeScale:function(t){return this.timeScale=t,this},/**
     * Gets the value of the time scale applied to this Timeline. A value of 1 runs in real-time.
     * A value of 0.5 runs 50% slower, and so on.
     *
     * @method Phaser.Tweens.Timeline#getTimeScale
     * @since 3.0.0
     *
     * @return {number} The value of the time scale applied to this Timeline.
     */getTimeScale:function(){return this.timeScale},/**
     * Check whether or not the Timeline is playing.
     *
     * @method Phaser.Tweens.Timeline#isPlaying
     * @since 3.0.0
     *
     * @return {boolean} `true` if this Timeline is active, otherwise `false`.
     */isPlaying:function(){return this.state===a.ACTIVE},/**
     * Creates a new Tween, based on the given Tween Config, and adds it to this Timeline.
     *
     * @method Phaser.Tweens.Timeline#add
     * @since 3.0.0
     *
     * @param {(Phaser.Types.Tweens.TweenBuilderConfig|object)} config - The configuration object for the Tween.
     *
     * @return {this} This Timeline object.
     */add:function(t){return this.queue(o(this,t))},/**
     * Adds an existing Tween to this Timeline.
     *
     * @method Phaser.Tweens.Timeline#queue
     * @since 3.0.0
     *
     * @param {Phaser.Tweens.Tween} tween - The Tween to be added to this Timeline.
     *
     * @return {this} This Timeline object.
     */queue:function(t){return this.isPlaying()||(t.parent=this,t.parentIsTimeline=!0,this.data.push(t),this.totalData=this.data.length),this},/**
     * Checks whether a Tween has an offset value.
     *
     * @method Phaser.Tweens.Timeline#hasOffset
     * @since 3.0.0
     *
     * @param {Phaser.Tweens.Tween} tween - The Tween to check.
     *
     * @return {boolean} `true` if the tween has a non-null offset.
     */hasOffset:function(t){return null!==t.offset},/**
     * Checks whether the offset value is a number or a directive that is relative to previous tweens.
     *
     * @method Phaser.Tweens.Timeline#isOffsetAbsolute
     * @since 3.0.0
     *
     * @param {number} value - The offset value to be evaluated.
     *
     * @return {boolean} `true` if the result is a number, `false` if it is a directive like " -= 1000".
     */isOffsetAbsolute:function(t){return"number"==typeof t},/**
     * Checks if the offset is a relative value rather than an absolute one.
     * If the value is just a number, this returns false.
     *
     * @method Phaser.Tweens.Timeline#isOffsetRelative
     * @since 3.0.0
     *
     * @param {string} value - The offset value to be evaluated.
     *
     * @return {boolean} `true` if the value is relative, i.e " -= 1000". If `false`, the offset is absolute.
     */isOffsetRelative:function(t){if("string"==typeof t){var e=t[0];if("-"===e||"+"===e)return!0}return!1},/**
     * Parses the relative offset value, returning a positive or negative number.
     *
     * @method Phaser.Tweens.Timeline#getRelativeOffset
     * @since 3.0.0
     *
     * @param {string} value - The relative offset, in the format of '-=500', for example. The first character determines whether it will be a positive or negative number. Spacing matters here.
     * @param {number} base - The value to use as the offset.
     *
     * @return {number} The parsed offset value.
     */getRelativeOffset:function(t,e){var i=t[0],n=parseFloat(t.substr(2)),s=e;switch(i){case"+":s+=n;break;case"-":s-=n}//  Cannot ever be < 0
return Math.max(0,s)},/**
     * Calculates the total duration of the timeline.
     * 
     * Computes all tween durations and returns the full duration of the timeline.
     * 
     * The resulting number is stored in the timeline, not as a return value.
     *
     * @method Phaser.Tweens.Timeline#calcDuration
     * @since 3.0.0
     */calcDuration:function(){for(var t=0,e=0,i=0,n=0;n<this.totalData;n++){var s=this.data[n];s.init(),this.hasOffset(s)?this.isOffsetAbsolute(s.offset)?(//  An actual number, so it defines the start point from the beginning of the timeline
s.calculatedOffset=s.offset,0===s.offset&&(i=0)):this.isOffsetRelative(s.offset)&&(s.calculatedOffset=this.getRelativeOffset(s.offset,t)):s.calculatedOffset=i,t=s.totalDuration+s.calculatedOffset,e+=s.totalDuration,i+=s.totalDuration}//  Excludes loop values
this.duration=e,this.loopCounter=-1===this.loop?999999999999:this.loop,this.loopCounter>0?this.totalDuration=this.duration+this.completeDelay+(this.duration+this.loopDelay)*this.loopCounter:this.totalDuration=this.duration+this.completeDelay},/**
     * Initializes the timeline, which means all Tweens get their init() called, and the total duration will be computed.
     * Returns a boolean indicating whether the timeline is auto-started or not.
     *
     * @method Phaser.Tweens.Timeline#init
     * @since 3.0.0
     *
     * @return {boolean} `true` if the Timeline is started. `false` if it is paused.
     */init:function(){return this.calcDuration(),this.progress=0,this.totalProgress=0,!this.paused||(this.state=a.PAUSED,!1)},/**
     * Resets all of the timeline's tweens back to their initial states.
     * The boolean parameter indicates whether tweens that are looping should reset as well, or not.
     *
     * @method Phaser.Tweens.Timeline#resetTweens
     * @since 3.0.0
     *
     * @param {boolean} resetFromLoop - If `true`, resets all looping tweens to their initial values.
     */resetTweens:function(t){for(var e=0;e<this.totalData;e++)this.data[e].play(t)},/**
     * Sets a callback for the Timeline.
     *
     * @method Phaser.Tweens.Timeline#setCallback
     * @since 3.0.0
     *
     * @param {string} type - The internal type of callback to set.
     * @param {function} callback - Timeline allows multiple tweens to be linked together to create a streaming sequence.
     * @param {array} [params] - The parameters to pass to the callback.
     * @param {object} [scope] - The context scope of the callback.
     *
     * @return {this} This Timeline object.
     */setCallback:function(t,e,i,n){return -1!==h.TYPES.indexOf(t)&&(this.callbacks[t]={func:e,scope:n,params:i}),this},/**
     * Passed a Tween to the Tween Manager and requests it be made active.
     *
     * @method Phaser.Tweens.Timeline#makeActive
     * @since 3.3.0
     *
     * @param {Phaser.Tweens.Tween} tween - The tween object to make active.
     *
     * @return {Phaser.Tweens.TweenManager} The Timeline's Tween Manager reference.
     */makeActive:function(t){return this.manager.makeActive(t)},/**
     * Starts playing the Timeline.
     *
     * @method Phaser.Tweens.Timeline#play
     * @fires Phaser.Tweens.Events#TIMELINE_START
     * @since 3.0.0
     */play:function(){if(this.state!==a.ACTIVE){if(this.paused){this.paused=!1,this.manager.makeActive(this);return}this.resetTweens(!1),this.state=a.ACTIVE,this.dispatchTimelineEvent(r.TIMELINE_START,this.callbacks.onStart)}},/**
     * Updates the Timeline's `state` and fires callbacks and events.
     *
     * @method Phaser.Tweens.Timeline#nextState
     * @fires Phaser.Tweens.Events#TIMELINE_COMPLETE
     * @fires Phaser.Tweens.Events#TIMELINE_LOOP
     * @since 3.0.0
     *
     * @see Phaser.Tweens.Timeline#update
     */nextState:function(){this.loopCounter>0?(//  Reset the elapsed time
this.elapsed=0,this.progress=0,this.loopCounter--,this.resetTweens(!0),this.loopDelay>0?(this.countdown=this.loopDelay,this.state=a.LOOP_DELAY):(this.state=a.ACTIVE,this.dispatchTimelineEvent(r.TIMELINE_LOOP,this.callbacks.onLoop))):this.completeDelay>0?(this.state=a.COMPLETE_DELAY,this.countdown=this.completeDelay):(this.state=a.PENDING_REMOVE,this.dispatchTimelineEvent(r.TIMELINE_COMPLETE,this.callbacks.onComplete))},/**
     * Returns 'true' if this Timeline has finished and should be removed from the Tween Manager.
     * Otherwise, returns false.
     *
     * @method Phaser.Tweens.Timeline#update
     * @fires Phaser.Tweens.Events#TIMELINE_COMPLETE
     * @fires Phaser.Tweens.Events#TIMELINE_UPDATE
     * @since 3.0.0
     *
     * @param {number} timestamp - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     *
     * @return {boolean} Returns `true` if this Timeline has finished and should be removed from the Tween Manager.
     */update:function(t,e){if(this.state!==a.PAUSED){switch(this.useFrames&&(e=1*this.manager.timeScale),e*=this.timeScale,this.elapsed+=e,this.progress=Math.min(this.elapsed/this.duration,1),this.totalElapsed+=e,this.totalProgress=Math.min(this.totalElapsed/this.totalDuration,1),this.state){case a.ACTIVE:for(var i=this.totalData,n=0;n<this.totalData;n++)this.data[n].update(t,e)&&i--;this.dispatchTimelineEvent(r.TIMELINE_UPDATE,this.callbacks.onUpdate),0===i&&this.nextState();break;case a.LOOP_DELAY:this.countdown-=e,this.countdown<=0&&(this.state=a.ACTIVE,this.dispatchTimelineEvent(r.TIMELINE_LOOP,this.callbacks.onLoop));break;case a.COMPLETE_DELAY:this.countdown-=e,this.countdown<=0&&(this.state=a.PENDING_REMOVE,this.dispatchTimelineEvent(r.TIMELINE_COMPLETE,this.callbacks.onComplete))}return this.state===a.PENDING_REMOVE}},/**
     * Stops the Timeline immediately, whatever stage of progress it is at and flags it for removal by the TweenManager.
     *
     * @method Phaser.Tweens.Timeline#stop
     * @since 3.0.0
     */stop:function(){this.state=a.PENDING_REMOVE},/**
     * Pauses the Timeline, retaining its internal state.
     * 
     * Calling this on a Timeline that is already paused has no effect and fires no event.
     *
     * @method Phaser.Tweens.Timeline#pause
     * @fires Phaser.Tweens.Events#TIMELINE_PAUSE
     * @since 3.0.0
     *
     * @return {this} This Timeline object.
     */pause:function(){if(this.state!==a.PAUSED)return this.paused=!0,this._pausedState=this.state,this.state=a.PAUSED,this.emit(r.TIMELINE_PAUSE,this),this},/**
     * Resumes a paused Timeline from where it was when it was paused.
     * 
     * Calling this on a Timeline that isn't paused has no effect and fires no event.
     *
     * @method Phaser.Tweens.Timeline#resume
     * @fires Phaser.Tweens.Events#TIMELINE_RESUME
     * @since 3.0.0
     *
     * @return {this} This Timeline object.
     */resume:function(){return this.state===a.PAUSED&&(this.paused=!1,this.state=this._pausedState,this.emit(r.TIMELINE_RESUME,this)),this},/**
     * Checks if any of the Tweens in this Timeline as operating on the target object.
     * 
     * Returns `false` if no Tweens operate on the target object.
     *
     * @method Phaser.Tweens.Timeline#hasTarget
     * @since 3.0.0
     *
     * @param {object} target - The target to check all Tweens against.
     *
     * @return {boolean} `true` if there is at least a single Tween that operates on the target object, otherwise `false`.
     */hasTarget:function(t){for(var e=0;e<this.data.length;e++)if(this.data[e].hasTarget(t))return!0;return!1},/**
     * Stops all the Tweens in the Timeline immediately, whatever stage of progress they are at and flags
     * them for removal by the TweenManager.
     *
     * @method Phaser.Tweens.Timeline#destroy
     * @since 3.0.0
     */destroy:function(){for(var t=0;t<this.data.length;t++)this.data[t].stop()}});h.TYPES=["onStart","onUpdate","onLoop","onComplete","onYoyo"],t.exports=h}),r("fZhty",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("6AqCF"),n=s("cSaNN"),r=s("iuXOO"),o=s("aANNX"),a=s("hoIQ4"),h=s("dwqbq"),l=s("8Hbk7"),u=s("5pMDk"),c=s("i2BXh"),d=s("9JoMY"),f=s("b70cP");t.exports=function(t,e,s){void 0===s&&(s=i);//  Loop through every property defined in the Tween, i.e.: props { x, y, alpha }
for(var p=s.targets?s.targets:l(e),g=h(e),v=a(e,"delay",s.delay),m=a(e,"duration",s.duration),y=u(e,"easeParams",s.easeParams),x=o(u(e,"ease",s.ease),y),w=a(e,"hold",s.hold),T=a(e,"repeat",s.repeat),b=a(e,"repeatDelay",s.repeatDelay),S=r(e,"yoyo",s.yoyo),A=r(e,"flipX",s.flipX),E=r(e,"flipY",s.flipY),_=[],C=0;C<g.length;C++)//  Create 1 TweenData per target, per property
for(var M=g[C].key,P=g[C].value,O=0;O<p.length;O++){var R=c(M,P),L=f(p[O],O,M,R.getEnd,R.getStart,R.getActive,o(u(P,"ease",x),y),a(P,"delay",v),a(P,"duration",m),r(P,"yoyo",S),a(P,"hold",w),a(P,"repeat",T),a(P,"repeatDelay",b),r(P,"flipX",A),r(P,"flipY",E));_.push(L)}//  Create arrays of the Targets and the Properties
var k=new d(t,_,p);k.offset=n(e,"offset",null),k.completeDelay=n(e,"completeDelay",0),k.loop=Math.round(n(e,"loop",0)),k.loopDelay=Math.round(n(e,"loopDelay",0)),k.paused=r(e,"paused",!1),k.useFrames=r(e,"useFrames",!1);for(var D=u(e,"callbackScope",k),F=[k,null],I=d.TYPES,B=0;B<I.length;B++){var N=I[B],Y=u(e,N,!1);if(Y){var z=u(e,N+"Scope",D),j=u(e,N+"Params",[]);//  The null is reset to be the Tween target
k.setCallback(N,Y,F.concat(j),z)}}return k}}),r("dA6JL",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("2SW6f"),n=s("jwj1g"),r=s("bJ9WV"),o=s("7AzQW"),a=s("4rtgc"),h=s("lvk9S"),l=s("agb2N"),u=s("7lENH"),c=s("fZhty"),d=new n({initialize:function(t){/**
         * The Scene which owns this Tween Manager.
         *
         * @name Phaser.Tweens.TweenManager#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * The Systems object of the Scene which owns this Tween Manager.
         *
         * @name Phaser.Tweens.TweenManager#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,/**
         * The time scale of the Tween Manager.
         *
         * This value scales the time delta between two frames, thus influencing the speed of time for all Tweens owned by this Tween Manager.
         *
         * @name Phaser.Tweens.TweenManager#timeScale
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.timeScale=1,/**
         * An array of Tweens and Timelines which will be added to the Tween Manager at the start of the frame.
         *
         * @name Phaser.Tweens.TweenManager#_add
         * @type {array}
         * @private
         * @since 3.0.0
         */this._add=[],/**
         * An array of Tweens and Timelines pending to be later added to the Tween Manager.
         *
         * @name Phaser.Tweens.TweenManager#_pending
         * @type {array}
         * @private
         * @since 3.0.0
         */this._pending=[],/**
         * An array of Tweens and Timelines which are still incomplete and are actively processed by the Tween Manager.
         *
         * @name Phaser.Tweens.TweenManager#_active
         * @type {array}
         * @private
         * @since 3.0.0
         */this._active=[],/**
         * An array of Tweens and Timelines which will be removed from the Tween Manager at the start of the frame.
         *
         * @name Phaser.Tweens.TweenManager#_destroy
         * @type {array}
         * @private
         * @since 3.0.0
         */this._destroy=[],/**
         * The number of Tweens and Timelines which need to be processed by the Tween Manager at the start of the frame.
         *
         * @name Phaser.Tweens.TweenManager#_toProcess
         * @type {integer}
         * @private
         * @default 0
         * @since 3.0.0
         */this._toProcess=0,t.sys.events.once(a.BOOT,this.boot,this),t.sys.events.on(a.START,this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.Tweens.TweenManager#boot
     * @private
     * @since 3.5.1
     */boot:function(){this.systems.events.once(a.DESTROY,this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.Tweens.TweenManager#start
     * @private
     * @since 3.5.0
     */start:function(){var t=this.systems.events;t.on(a.PRE_UPDATE,this.preUpdate,this),t.on(a.UPDATE,this.update,this),t.once(a.SHUTDOWN,this.shutdown,this),this.timeScale=1},/**
     * Create a Tween Timeline and return it, but do NOT add it to the active or pending Tween lists.
     *
     * @method Phaser.Tweens.TweenManager#createTimeline
     * @since 3.0.0
     *
     * @param {Phaser.Types.Tweens.TimelineBuilderConfig} [config] - The configuration object for the Timeline and its Tweens.
     *
     * @return {Phaser.Tweens.Timeline} The created Timeline object.
     */createTimeline:function(t){return l(this,t)},/**
     * Create a Tween Timeline and add it to the active Tween list/
     *
     * @method Phaser.Tweens.TweenManager#timeline
     * @since 3.0.0
     *
     * @param {Phaser.Types.Tweens.TimelineBuilderConfig} [config] - The configuration object for the Timeline and its Tweens.
     *
     * @return {Phaser.Tweens.Timeline} The created Timeline object.
     */timeline:function(t){var e=l(this,t);return!e.paused&&(this._add.push(e),this._toProcess++),e},/**
     * Create a Tween and return it, but do NOT add it to the active or pending Tween lists.
     *
     * @method Phaser.Tweens.TweenManager#create
     * @since 3.0.0
     *
     * @param {Phaser.Types.Tweens.TweenBuilderConfig|object} config - The configuration object for the Tween.
     *
     * @return {Phaser.Tweens.Tween} The created Tween object.
     */create:function(t){return c(this,t)},/**
     * Create a Tween and add it to the active Tween list.
     *
     * @method Phaser.Tweens.TweenManager#add
     * @since 3.0.0
     *
     * @param {Phaser.Types.Tweens.TweenBuilderConfig|object} config - The configuration object for the Tween.
     *
     * @return {Phaser.Tweens.Tween} The created Tween.
     */add:function(t){var e=c(this,t);return this._add.push(e),this._toProcess++,e},/**
     * Add an existing tween into the active Tween list.
     *
     * @method Phaser.Tweens.TweenManager#existing
     * @since 3.0.0
     *
     * @param {Phaser.Tweens.Tween} tween - The Tween to add.
     *
     * @return {Phaser.Tweens.TweenManager} This Tween Manager object.
     */existing:function(t){return this._add.push(t),this._toProcess++,this},/**
     * Create a Number Tween and add it to the active Tween list.
     *
     * @method Phaser.Tweens.TweenManager#addCounter
     * @since 3.0.0
     *
     * @param {Phaser.Types.Tweens.NumberTweenBuilderConfig} config - The configuration object for the Number Tween.
     *
     * @return {Phaser.Tweens.Tween} The created Number Tween.
     */addCounter:function(t){var e=r(this,t);return this._add.push(e),this._toProcess++,e},/**
     * Creates a Stagger function to be used by a Tween property.
     * 
     * The stagger function will allow you to stagger changes to the value of the property across all targets of the tween.
     * 
     * This is only worth using if the tween has multiple targets.
     * 
     * The following will stagger the delay by 100ms across all targets of the tween, causing them to scale down to 0.2
     * over the duration specified:
     * 
     * ```javascript
     * this.tweens.add({
     *     targets: [ ... ],
     *     scale: 0.2,
     *     ease: 'linear',
     *     duration: 1000,
     *     delay: this.tweens.stagger(100)
     * });
     * ```
     * 
     * The following will stagger the delay by 500ms across all targets of the tween using a 10 x 6 grid, staggering
     * from the center out, using a cubic ease.
     * 
     * ```javascript
     * this.tweens.add({
     *     targets: [ ... ],
     *     scale: 0.2,
     *     ease: 'linear',
     *     duration: 1000,
     *     delay: this.tweens.stagger(500, { grid: [ 10, 6 ], from: 'center', ease: 'cubic.out' })
     * });
     * ```
     *
     * @method Phaser.Tweens.TweenManager#stagger
     * @since 3.19.0
     *
     * @param {(number|number[])} value - The amount to stagger by, or an array containing two elements representing the min and max values to stagger between.
     * @param {Phaser.Types.Tweens.StaggerConfig} config - The configuration object for the Stagger function.
     *
     * @return {function} The stagger function.
     */stagger:function(t,e){return h(t,e)},/**
     * Updates the Tween Manager's internal lists at the start of the frame.
     *
     * This method will return immediately if no changes have been indicated.
     *
     * @method Phaser.Tweens.TweenManager#preUpdate
     * @since 3.0.0
     */preUpdate:function(){if(0!==this._toProcess){var t,e,i=this._destroy,n=this._active,s=this._pending;//  Clear the 'destroy' list
for(t=0;t<i.length;t++){e=i[t];//  Remove from the 'active' array
var r=n.indexOf(e);-1===r?//  Not in the active array, is it in pending instead?
(r=s.indexOf(e))>-1&&(e.state=u.REMOVED,s.splice(r,1)):(e.state=u.REMOVED,n.splice(r,1))}for(t=0,i.length=0,//  Process the addition list
//  This stops callbacks and out of sync events from populating the active array mid-way during the update
i=this._add;t<i.length;t++)(e=i[t]).state===u.PENDING_ADD&&(e.init()?(e.play(),this._active.push(e)):this._pending.push(e));i.length=0,this._toProcess=0}},/**
     * Updates all Tweens and Timelines of the Tween Manager.
     *
     * @method Phaser.Tweens.TweenManager#update
     * @since 3.0.0
     *
     * @param {number} timestamp - The current time in milliseconds.
     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
     */update:function(t,e){//  Process active tweens
var i,n=this._active;//  Scale the delta
e*=this.timeScale;for(var s=0;s<n.length;s++)//  If Tween.update returns 'true' then it means it has completed,
//  so move it to the destroy list
(i=n[s]).update(t,e)&&(this._destroy.push(i),this._toProcess++)},/**
     * Removes the given tween from the Tween Manager, regardless of its state (pending or active).
     *
     * @method Phaser.Tweens.TweenManager#remove
     * @since 3.17.0
     *
     * @param {Phaser.Tweens.Tween} tween - The Tween to be removed.
     *
     * @return {Phaser.Tweens.TweenManager} This Tween Manager object.
     */remove:function(t){return i(this._add,t),i(this._pending,t),i(this._active,t),i(this._destroy,t),t.state=u.REMOVED,this},/**
     * Checks if a Tween or Timeline is active and adds it to the Tween Manager at the start of the frame if it isn't.
     *
     * @method Phaser.Tweens.TweenManager#makeActive
     * @since 3.0.0
     *
     * @param {Phaser.Tweens.Tween} tween - The Tween to check.
     *
     * @return {Phaser.Tweens.TweenManager} This Tween Manager object.
     */makeActive:function(t){if(-1!==this._add.indexOf(t)||-1!==this._active.indexOf(t))return this;var e=this._pending.indexOf(t);return -1!==e&&this._pending.splice(e,1),this._add.push(t),t.state=u.PENDING_ADD,this._toProcess++,this},/**
     * Passes all Tweens to the given callback.
     *
     * @method Phaser.Tweens.TweenManager#each
     * @since 3.0.0
     *
     * @param {function} callback - The function to call.
     * @param {object} [scope] - The scope (`this` object) to call the function with.
     * @param {...*} [args] - The arguments to pass into the function. Its first argument will always be the Tween currently being iterated.
     */each:function(t,e){for(var i=[null],n=1;n<arguments.length;n++)i.push(arguments[n]);for(var s in this.list)i[0]=this.list[s],t.apply(e,i)},/**
     * Returns an array of all active Tweens and Timelines in the Tween Manager.
     *
     * @method Phaser.Tweens.TweenManager#getAllTweens
     * @since 3.0.0
     *
     * @return {Phaser.Tweens.Tween[]} A new array containing references to all active Tweens and Timelines.
     */getAllTweens:function(){for(var t=this._active,e=[],i=0;i<t.length;i++)e.push(t[i]);return e},/**
     * Returns the scale of the time delta for all Tweens and Timelines owned by this Tween Manager.
     *
     * @method Phaser.Tweens.TweenManager#getGlobalTimeScale
     * @since 3.0.0
     *
     * @return {number} The scale of the time delta, usually 1.
     */getGlobalTimeScale:function(){return this.timeScale},/**
     * Returns an array of all Tweens or Timelines in the Tween Manager which affect the given target or array of targets.
     *
     * @method Phaser.Tweens.TweenManager#getTweensOf
     * @since 3.0.0
     *
     * @param {(object|array)} target - The target to look for. Provide an array to look for multiple targets.
     *
     * @return {Phaser.Tweens.Tween[]} A new array containing all Tweens and Timelines which affect the given target(s).
     */getTweensOf:function(t){var e,i,n=this._active,s=[];if(Array.isArray(t))for(i=0;i<n.length;i++){e=n[i];for(var r=0;r<t.length;r++)e.hasTarget(t[r])&&s.push(e)}else for(i=0;i<n.length;i++)(e=n[i]).hasTarget(t)&&s.push(e);return s},/**
     * Checks if the given object is being affected by a playing Tween.
     *
     * @method Phaser.Tweens.TweenManager#isTweening
     * @since 3.0.0
     *
     * @param {object} target - target Phaser.Tweens.Tween object
     *
     * @return {boolean} returns if target tween object is active or not
     */isTweening:function(t){for(var e,i=this._active,n=0;n<i.length;n++)if((e=i[n]).hasTarget(t)&&e.isPlaying())return!0;return!1},/**
     * Stops all Tweens in this Tween Manager. They will be removed at the start of the frame.
     *
     * @method Phaser.Tweens.TweenManager#killAll
     * @since 3.0.0
     *
     * @return {Phaser.Tweens.TweenManager} This Tween Manager.
     */killAll:function(){for(var t=this.getAllTweens(),e=0;e<t.length;e++)t[e].stop();return this},/**
     * Stops all Tweens which affect the given target or array of targets. The Tweens will be removed from the Tween Manager at the start of the frame.
     *
     * @see {@link #getTweensOf}
     *
     * @method Phaser.Tweens.TweenManager#killTweensOf
     * @since 3.0.0
     *
     * @param {(object|array)} target - The target to look for. Provide an array to look for multiple targets.
     *
     * @return {Phaser.Tweens.TweenManager} This Tween Manager.
     */killTweensOf:function(t){for(var e=this.getTweensOf(t),i=0;i<e.length;i++)e[i].stop();return this},/**
     * Pauses all Tweens in this Tween Manager.
     *
     * @method Phaser.Tweens.TweenManager#pauseAll
     * @since 3.0.0
     *
     * @return {Phaser.Tweens.TweenManager} This Tween Manager.
     */pauseAll:function(){for(var t=this._active,e=0;e<t.length;e++)t[e].pause();return this},/**
     * Resumes all Tweens in this Tween Manager.
     *
     * @method Phaser.Tweens.TweenManager#resumeAll
     * @since 3.0.0
     *
     * @return {Phaser.Tweens.TweenManager} This Tween Manager.
     */resumeAll:function(){for(var t=this._active,e=0;e<t.length;e++)t[e].resume();return this},/**
     * Sets a new scale of the time delta for this Tween Manager.
     *
     * The time delta is the time elapsed between two consecutive frames and influences the speed of time for this Tween Manager and all Tweens it owns. Values higher than 1 increase the speed of time, while values smaller than 1 decrease it. A value of 0 freezes time and is effectively equivalent to pausing all Tweens.
     *
     * @method Phaser.Tweens.TweenManager#setGlobalTimeScale
     * @since 3.0.0
     *
     * @param {number} value - The new scale of the time delta, where 1 is the normal speed.
     *
     * @return {Phaser.Tweens.TweenManager} This Tween Manager.
     */setGlobalTimeScale:function(t){return this.timeScale=t,this},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.Tweens.TweenManager#shutdown
     * @since 3.0.0
     */shutdown:function(){this.killAll(),this._add=[],this._pending=[],this._active=[],this._destroy=[],this._toProcess=0;var t=this.systems.events;t.off(a.PRE_UPDATE,this.preUpdate,this),t.off(a.UPDATE,this.update,this),t.off(a.SHUTDOWN,this.shutdown,this)},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.Tweens.TweenManager#destroy
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.scene.sys.events.off(a.START,this.start,this),this.scene=null,this.systems=null}});o.register("TweenManager",d,"tweens"),t.exports=d}),r("cdLjm",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Utils
 */t.exports={Array:s("3Mp2n"),Base64:s("f6gU8"),Objects:s("jLmb6"),String:s("cKPAn")}}),r("f6gU8",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Utils.Base64
 */t.exports={ArrayBufferToBase64:s("9PiRy"),Base64ToArrayBuffer:s("8wlD1")}}),r("9PiRy",function(t,e){/**
 * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";t.exports=function(t,e){for(var n=new Uint8Array(t),s=n.length,r=e?"data:"+e+";base64,":"",o=0;o<s;o+=3)r+=i[n[o]>>2]+i[(3&n[o])<<4|n[o+1]>>4]+i[(15&n[o+1])<<2|n[o+2]>>6]+i[63&n[o+2]];return s%3==2?r=r.substring(0,r.length-1)+"=":s%3==1&&(r=r.substring(0,r.length-2)+"=="),r}}),r("jLmb6",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Utils.Objects
 */t.exports={Clone:s("5pqmQ"),Extend:s("hVk4C"),GetAdvancedValue:s("cSaNN"),GetFastValue:s("7BSWl"),GetMinMaxValue:s("jIMDW"),GetValue:s("5pMDk"),HasAll:s("d8dV9"),HasAny:s("88Y8i"),HasValue:s("evjs6"),IsPlainObject:s("jC9MQ"),Merge:s("awyQk"),MergeRight:s("5lm26"),Pick:s("Ljig0"),SetValue:s("knQyO")}}),r("jIMDW",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5pMDk"),n=s("iEUUO");t.exports=function(t,e,s,r,o){return void 0===o&&(o=s),n(i(t,e,o),s,r)}}),r("d8dV9",function(t,e){t.exports=function(t,e){for(var i=0;i<e.length;i++)if(!t.hasOwnProperty(e[i]))return!1;return!0}}),r("5lm26",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */var i=s("5pqmQ");t.exports=function(t,e){var n=i(t);for(var s in e)n.hasOwnProperty(s)&&(n[s]=e[s]);return n}}),r("cKPAn",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Utils.String
 */t.exports={Format:s("37dMI"),Pad:s("7y2Q8"),Reverse:s("ct2lj"),UppercaseFirst:s("aEzMt"),UUID:s("gS40I")}}),r("37dMI",function(t,e){t.exports=function(t,e){return t.replace(/%([0-9]+)/g,function(t,i){return e[Number(i)-1]})}}),r("ct2lj",function(t,e){t.exports=function(t){return t.split("").reverse().join("")}}),r("gNVRh",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 *//**
 * @namespace Phaser.Sound
 */t.exports={SoundManagerCreator:s("jskqO"),Events:s("kcpiS"),BaseSound:s("4x7f5"),BaseSoundManager:s("hw6uH"),WebAudioSound:s("auhY5"),WebAudioSoundManager:s("d69lL"),HTML5AudioSound:s("1jI3b"),HTML5AudioSoundManager:s("4eU0A"),NoAudioSound:s("4Z5ti"),NoAudioSoundManager:s("5wl8F")}}),r("hRsbN",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 *//**
 * @namespace Phaser.Cameras.Sprite3D
 */t.exports={Camera:s("4j1Dk"),CameraManager:s("YV809"),OrthographicCamera:s("eARah"),PerspectiveCamera:s("hbpve")}}),r("4j1Dk",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */var i=s("jwj1g"),n=s("hD0DV"),r=s("aBiCH"),o=s("5ojVH"),a=s("iV7dk"),h=s("lxxnL"),l=s("dK9Ze"),u=s("7SBSk"),c=s("gbKIZ"),d=s("27QVG"),f=new c,p=new d,g=new c,v=new c,m=new n,y=new i({initialize:function(t){/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#displayList
         * @type {Phaser.GameObjects.DisplayList}
         * @since 3.0.0
         */this.displayList=t.sys.displayList,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#updateList
         * @type {Phaser.GameObjects.UpdateList}
         * @since 3.0.0
         */this.updateList=t.sys.updateList,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#name
         * @type {string}
         * @default ''
         * @since 3.0.0
         */this.name="",/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#direction
         * @type {Phaser.Math.Vector3}
         * @since 3.0.0
         */this.direction=new c(0,0,-1),/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#up
         * @type {Phaser.Math.Vector3}
         * @since 3.0.0
         */this.up=new c(0,1,0),/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#position
         * @type {Phaser.Math.Vector3}
         * @since 3.0.0
         */this.position=new c,/**
         *  The mapping from 3D size units to pixels.
         *  In the default case 1 3D unit = 128 pixels. So a sprite that is
         *  256 x 128 px in size will be 2 x 1 units.
         *  Change to whatever best fits your game assets.
         *
         * @name Phaser.Cameras.Sprite3D#pixelScale
         * @type {number}
         * @since 3.0.0
         */this.pixelScale=128,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#projection
         * @type {Phaser.Math.Matrix4}
         * @since 3.0.0
         */this.projection=new n,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#view
         * @type {Phaser.Math.Matrix4}
         * @since 3.0.0
         */this.view=new n,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#combined
         * @type {Phaser.Math.Matrix4}
         * @since 3.0.0
         */this.combined=new n,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#invProjectionView
         * @type {Phaser.Math.Matrix4}
         * @since 3.0.0
         */this.invProjectionView=new n,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#near
         * @type {number}
         * @default 1
         * @since 3.0.0
         */this.near=1,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#far
         * @type {number}
         * @since 3.0.0
         */this.far=100,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#ray
         * @type {RayDef}
         * @since 3.0.0
         */this.ray={origin:new c,direction:new c},/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#viewportWidth
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.viewportWidth=0,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#viewportHeight
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.viewportHeight=0,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#billboardMatrixDirty
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.billboardMatrixDirty=!0,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D#children
         * @type {Phaser.Structs.Set.<Phaser.GameObjects.GameObject>}
         * @since 3.0.0
         */this.children=new h},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#setPosition
     * @since 3.0.0
     *
     * @param {number} x - [description]
     * @param {number} y - [description]
     * @param {number} z - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */setPosition:function(t,e,i){return this.position.set(t,e,i),this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#setScene
     * @since 3.0.0
     *
     * @param {Phaser.Scene} scene - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */setScene:function(t){return this.scene=t,this},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#setPixelScale
     * @since 3.0.0
     *
     * @param {number} value - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */setPixelScale:function(t){return this.pixelScale=t,this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#add
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Sprite3D} sprite3D - [description]
     *
     * @return {Phaser.GameObjects.Sprite3D} [description]
     */add:function(t){return this.children.set(t),this.displayList.add(t.gameObject),this.updateList.add(t.gameObject),this.updateChildren(),t},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#remove
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.GameObject} child - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */remove:function(t){return this.displayList.remove(t.gameObject),this.updateList.remove(t.gameObject),this.children.delete(t),this},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#clear
     * @since 3.0.0
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */clear:function(){for(var t=this.getChildren(),e=0;e<t.length;e++)this.remove(t[e]);return this},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#getChildren
     * @since 3.0.0
     *
     * @return {array} [description]
     */getChildren:function(){return this.children.entries},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#create
     * @since 3.0.0
     *
     * @param {number} x - [description]
     * @param {number} y - [description]
     * @param {number} z - [description]
     * @param {string} key - [description]
     * @param {(string|number)} frame - [description]
     * @param {boolean} [visible=true] - [description]
     *
     * @return {Phaser.GameObjects.Sprite3D} [description]
     */create:function(t,e,i,n,s,r){void 0===r&&(r=!0);var o=new l(this.scene,t,e,i,n,s);return this.displayList.add(o.gameObject),this.updateList.add(o.gameObject),o.visible=r,this.children.set(o),this.updateChildren(),o},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#createMultiple
     * @since 3.0.0
     *
     * @param {number} quantity - [description]
     * @param {string} key - [description]
     * @param {(string|number)} frame - [description]
     * @param {boolean} [visible=true] - [description]
     *
     * @return {Phaser.GameObjects.Sprite3D[]} [description]
     */createMultiple:function(t,e,i,n){void 0===n&&(n=!0);for(var s=[],r=0;r<t;r++){var o=new l(this.scene,0,0,0,e,i);this.displayList.add(o.gameObject),this.updateList.add(o.gameObject),o.visible=n,this.children.set(o),s.push(o)}return s},//  Create a bunch of Sprite3D objects in a rectangle
//  size and spacing are Vec3s (or if integers are converted to vec3s)
/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#createRect
     * @since 3.0.0
     *
     * @param {(number|{x:number,y:number})} size - [description]
     * @param {(number|{x:number,y:number,z:number})} spacing - [description]
     * @param {string} key - [description]
     * @param {(string|number)} [frame] - [description]
     *
     * @return {Phaser.GameObjects.Sprite3D[]} [description]
     */createRect:function(t,e,i,n){"number"==typeof t&&(t={x:t,y:t,z:t}),"number"==typeof e&&(e={x:e,y:e,z:e});for(var s=t.x*t.y*t.z,r=this.createMultiple(s,i,n),o=0,a=.5-t.z/2;a<t.z/2;a++)for(var h=.5-t.y/2;h<t.y/2;h++)for(var l=.5-t.x/2;l<t.x/2;l++){var u=l*e.x,c=h*e.y,d=a*e.z;r[o].position.set(u,c,d),o++}return this.update(),r},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#randomSphere
     * @since 3.0.0
     *
     * @param {number} [radius=1] - [description]
     * @param {Phaser.GameObjects.Sprite3D[]} [sprites] - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */randomSphere:function(t,e){void 0===e&&(e=this.getChildren());for(var i=0;i<e.length;i++)r(e[i].position,t);return this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#randomCube
     * @since 3.0.0
     *
     * @param {number} [scale=1] - [description]
     * @param {Phaser.GameObjects.Sprite3D[]} [sprites] - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */randomCube:function(t,e){void 0===e&&(e=this.getChildren());for(var i=0;i<e.length;i++)o(e[i].position,t);return this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#translateChildren
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} vec3 - [description]
     * @param {Phaser.GameObjects.Sprite3D[]} sprites - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */translateChildren:function(t,e){void 0===e&&(e=this.getChildren());for(var i=0;i<e.length;i++)e[i].position.add(t);return this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#transformChildren
     * @since 3.0.0
     *
     * @param {Phaser.Math.Matrix4} mat4 - [description]
     * @param {Phaser.GameObjects.Sprite3D[]} sprites - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */transformChildren:function(t,e){void 0===e&&(e=this.getChildren());for(var i=0;i<e.length;i++)e[i].position.transformMat4(t);return this.update()},/**
     * Sets the width and height of the viewport. Does not update any matrices.
     *
     * @method Phaser.Cameras.Sprite3D.Camera#setViewport
     * @since 3.0.0
     *
     * @param {number} width - [description]
     * @param {number} height - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */setViewport:function(t,e){return this.viewportWidth=t,this.viewportHeight=e,this.update()},/**
     * Translates this camera by a specified Vector3 object
     * or x, y, z parameters. Any undefined x y z values will
     * default to zero, leaving that component unaffected.
     * If you wish to set the camera position directly call setPosition instead.
     *
     * @method Phaser.Cameras.Sprite3D.Camera#translate
     * @since 3.0.0
     *
     * @param {(number|object)} x - [description]
     * @param {number} [y] - [description]
     * @param {number} [z] - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */translate:function(t,e,i){return"object"==typeof t?(this.position.x+=t.x||0,this.position.y+=t.y||0,this.position.z+=t.z||0):(this.position.x+=t||0,this.position.y+=e||0,this.position.z+=i||0),this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#lookAt
     * @since 3.0.0
     *
     * @param {(number|object)} x - [description]
     * @param {number} [y] - [description]
     * @param {number} [z] - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */lookAt:function(t,e,i){var n=this.direction,s=this.up;return"object"==typeof t?n.copy(t):n.set(t,e,i),n.subtract(this.position).normalize(),//  Calculate right vector
f.copy(n).cross(s).normalize(),//  Calculate up vector
s.copy(f).cross(n).normalize(),this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#rotate
     * @since 3.0.0
     *
     * @param {number} radians - [description]
     * @param {Phaser.Math.Vector3} axis - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */rotate:function(t,e){return a(this.direction,e,t),a(this.up,e,t),this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#rotateAround
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} point - [description]
     * @param {number} radians - [description]
     * @param {Phaser.Math.Vector3} axis - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */rotateAround:function(t,e,i){return f.copy(t).subtract(this.position),this.translate(f),this.rotate(e,i),this.translate(f.negate()),this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#project
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector3} vec - [description]
     * @param {Phaser.Math.Vector4} out - [description]
     *
     * @return {Phaser.Math.Vector4} [description]
     */project:function(t,e){void 0===e&&(e=new d);//  TODO: support viewport XY
var i=this.viewportWidth,n=this.viewportHeight,s=y.NEAR_RANGE,r=y.FAR_RANGE;return(//  For useful Z and W values we should do the usual steps: clip space -> NDC -> window coords
//  Implicit 1.0 for w component
p.set(t.x,t.y,t.z,1),//  Transform into clip space
p.transformMat4(this.combined),0===p.w&&(p.w=1),//  Now into NDC
p.x=p.x/p.w,p.y=p.y/p.w,p.z=p.z/p.w,//  And finally into window coordinates
e.x=i/2*p.x+(0+i/2),e.y=n/2*p.y+(0+n/2),e.z=(r-s)/2*p.z+(r+s)/2,(0===e.w||e.w)&&(e.w=1/p.w),e)},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#unproject
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector4} vec - [description]
     * @param {Phaser.Math.Vector3} out - [description]
     *
     * @return {Phaser.Math.Vector3} [description]
     */unproject:function(t,e){void 0===e&&(e=new c);var i=p.set(0,0,this.viewportWidth,this.viewportHeight);return e.copy(t).unproject(i,this.invProjectionView)},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#getPickRay
     * @since 3.0.0
     *
     * @param {number} x - [description]
     * @param {number} [y] - [description]
     *
     * @return {RayDef} [description]
     */getPickRay:function(t,e){var i=this.ray.origin.set(t,e,0),n=this.ray.direction.set(t,e,1),s=p.set(0,0,this.viewportWidth,this.viewportHeight),r=this.invProjectionView;return i.unproject(s,r),n.unproject(s,r),n.subtract(i).normalize(),this.ray},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#updateChildren
     * @since 3.0.0
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */updateChildren:function(){for(var t=this.children.entries,e=0;e<t.length;e++)t[e].project(this);return this},//  Overridden by subclasses
/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#update
     * @since 3.0.0
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */update:function(){return this.updateChildren()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#updateBillboardMatrix
     * @since 3.0.0
     */updateBillboardMatrix:function(){var t=g.set(this.direction).negate(),e=v.set(this.up).cross(t).normalize(),i=f.set(t).cross(e).normalize(),n=m.val;n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=0,n[4]=i.x,n[5]=i.y,n[6]=i.z,n[7]=0,n[8]=t.x,n[9]=t.y,n[10]=t.z,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this.billboardMatrixDirty=!1},/**
     * This is a utility function for canvas 3D rendering,
     * which determines the "point size" of a camera-facing
     * sprite billboard given its 3D world position
     * (origin at center of sprite) and its world width
     * and height in x/y.
     *
     * We place into the output Vector2 the scaled width
     * and height. If no `out` is specified, a new Vector2
     * will be created for convenience (this should be avoided
     * in tight loops).
     *
     * @method Phaser.Cameras.Sprite3D.Camera#getPointSize
     * @since 3.0.0
     *
     * @param {Phaser.Math.Vector2} vec - The position of the 3D Sprite.
     * @param {Phaser.Math.Vector2} size - The x and y dimensions.
     * @param {Phaser.Math.Vector2} out - The result, scaled x and y dimensions.
     *
     * @return {Phaser.Math.Vector2} [description]
     */getPointSize:function(t,e,i){void 0===i&&(i=new u),this.billboardMatrixDirty&&this.updateBillboardMatrix();var n=e.x/this.pixelScale/2,s=e.y/this.pixelScale/2;f.set(-n,-s,0).transformMat4(m).add(t),this.project(f,f);var r=f.x,o=f.y;f.set(n,s,0).transformMat4(m).add(t),this.project(f,f);var a=f.x,h=f.y;return i.set(a-r,h-o)},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#destroy
     * @since 3.0.0
     */destroy:function(){this.children.clear(),this.scene=void 0,this.children=void 0},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#setX
     * @since 3.0.0
     *
     * @param {number} value - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */setX:function(t){return this.position.x=t,this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#setY
     * @since 3.0.0
     *
     * @param {number} value - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */setY:function(t){return this.position.y=t,this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.Camera#setZ
     * @since 3.0.0
     *
     * @param {number} value - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.
     */setZ:function(t){return this.position.z=t,this.update()},/**
     * [description]
     *
     * @name Phaser.Cameras.Sprite3D.Camera#x
     * @type {number}
     * @since 3.0.0
     */x:{get:function(){return this.position.x},set:function(t){this.position.x=t,this.update()}},/**
     * [description]
     *
     * @name Phaser.Cameras.Sprite3D.Camera#y
     * @type {number}
     * @since 3.0.0
     */y:{get:function(){return this.position.y},set:function(t){this.position.y=t,this.update()}},/**
     * [description]
     *
     * @name Phaser.Cameras.Sprite3D.Camera#z
     * @type {number}
     * @since 3.0.0
     */z:{get:function(){return this.position.z},set:function(t){this.position.z=t,this.update()}}});y.FAR_RANGE=1,y.NEAR_RANGE=0,t.exports=y}),r("dK9Ze",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */var i=s("jwj1g"),n=s("1zqlR"),r=s("gXuc8"),o=s("7SBSk"),a=s("27QVG"),h=new i({Extends:n,initialize:function(t,e,i,s,h,l){n.call(this,t,"Sprite3D"),/**
         * The encapsulated Sprite.
         *
         * @name Phaser.GameObjects.Sprite3D#gameObject
         * @type {Phaser.GameObjects.GameObject}
         * @since 3.0.0
         */this.gameObject=new r(t,0,0,h,l),/**
         * The position of the Sprite.
         *
         * @name Phaser.GameObjects.Sprite3D#position
         * @type {Phaser.Math.Vector4}
         * @since 3.0.0
         */this.position=new a(e,i,s),/**
         * The 2D size of the Sprite.
         *
         * @name Phaser.GameObjects.Sprite3D#size
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.size=new o(this.gameObject.width,this.gameObject.height),/**
         * The 2D scale of the Sprite.
         *
         * @name Phaser.GameObjects.Sprite3D#scale
         * @type {Phaser.Math.Vector2}
         * @since 3.0.0
         */this.scale=new o(1,1),/**
         * Whether to automatically set the horizontal scale of the encapsulated Sprite.
         *
         * @name Phaser.GameObjects.Sprite3D#adjustScaleX
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.adjustScaleX=!0,/**
         * Whether to automatically set the vertical scale of the encapsulated Sprite.
         *
         * @name Phaser.GameObjects.Sprite3D#adjustScaleY
         * @type {boolean}
         * @default true
         * @since 3.0.0
         */this.adjustScaleY=!0,/**
         * The visible state of the Game Object.
         *
         * @name Phaser.GameObjects.Sprite3D#_visible
         * @type {boolean}
         * @default true
         * @private
         * @since 3.0.0
         */this._visible=!0},/**
     * Project this Sprite onto the given 3D Camera.
     *
     * @method Phaser.GameObjects.Sprite3D#project
     * @since 3.0.0
     *
     * @param {Phaser.Cameras.Sprite3D.Camera} camera - The 3D Camera onto which to project this Sprite.
     */project:function(t){var e=this.position,i=this.gameObject;t.project(e,i),t.getPointSize(e,this.size,this.scale),this.scale.x<=0||this.scale.y<=0?i.setVisible(!1):(i.visible||i.setVisible(!0),this.adjustScaleX&&(i.scaleX=this.scale.x),this.adjustScaleY&&(i.scaleY=this.scale.y),i.setDepth(-1*i.z))},/**
     * Set the visible state of the Game Object.
     *
     * @method Phaser.GameObjects.Sprite3D#setVisible
     * @since 3.0.0
     *
     * @param {boolean} value - The visible state of the Game Object.
     *
     * @return {Phaser.GameObjects.Sprite3D} This Sprite3D Object.
     */setVisible:function(t){return this.visible=t,this},/**
     * The visible state of the Game Object.
     *
     * An invisible Game Object will skip rendering, but will still process update logic.
     *
     * @name Phaser.GameObjects.Sprite3D#visible
     * @type {boolean}
     * @since 3.0.0
     */visible:{get:function(){return this._visible},set:function(t){this._visible=t,this.gameObject.visible=t}},/**
     * The x position of this Game Object.
     *
     * @name Phaser.GameObjects.Sprite3D#x
     * @type {number}
     * @since 3.0.0
     */x:{get:function(){return this.position.x},set:function(t){this.position.x=t}},/**
     * The y position of this Game Object.
     *
     * @name Phaser.GameObjects.Sprite3D#y
     * @type {number}
     * @since 3.0.0
     */y:{get:function(){return this.position.y},set:function(t){this.position.y=t}},/**
     * The z position of this Game Object.
     *
     * @name Phaser.GameObjects.Sprite3D#z
     * @type {number}
     * @since 3.0.0
     */z:{get:function(){return this.position.z},set:function(t){this.position.z=t}}});t.exports=h}),r("YV809",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */var i=s("jwj1g"),n=s("eARah"),r=s("hbpve"),o=s("7AzQW"),a=new i({initialize:function(t){/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D.CameraManager#scene
         * @type {Phaser.Scene}
         * @since 3.0.0
         */this.scene=t,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D.CameraManager#systems
         * @type {Phaser.Scenes.Systems}
         * @since 3.0.0
         */this.systems=t.sys,/**
         * An Array of the Camera objects being managed by this Camera Manager.
         *
         * @name Phaser.Cameras.Sprite3D.CameraManager#cameras
         * @type {Phaser.Cameras.Sprite3D.Camera[]}
         * @since 3.0.0
         */this.cameras=[],t.sys.events.once("boot",this.boot,this),t.sys.events.on("start",this.start,this)},/**
     * This method is called automatically, only once, when the Scene is first created.
     * Do not invoke it directly.
     *
     * @method Phaser.Cameras.Scene3D.CameraManager#boot
     * @private
     * @since 3.5.1
     */boot:function(){this.systems.events.once("destroy",this.destroy,this)},/**
     * This method is called automatically by the Scene when it is starting up.
     * It is responsible for creating local systems, properties and listening for Scene events.
     * Do not invoke it directly.
     *
     * @method Phaser.Cameras.Sprite3D.CameraManager#start
     * @private
     * @since 3.5.0
     */start:function(){var t=this.systems.events;t.on("update",this.update,this),t.once("shutdown",this.shutdown,this)},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.CameraManager#add
     * @since 3.0.0
     *
     * @param {number} [fieldOfView=80] - [description]
     * @param {number} [width] - [description]
     * @param {number} [height] - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.PerspectiveCamera} [description]
     */add:function(t,e,i){return this.addPerspectiveCamera(t,e,i)},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.CameraManager#addOrthographicCamera
     * @since 3.0.0
     *
     * @param {number} width - [description]
     * @param {number} height - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.OrthographicCamera} [description]
     */addOrthographicCamera:function(t,e){var i=this.scene.sys.game.config;void 0===t&&(t=i.width),void 0===e&&(e=i.height);var s=new n(this.scene,t,e);return this.cameras.push(s),s},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.CameraManager#addPerspectiveCamera
     * @since 3.0.0
     *
     * @param {number} [fieldOfView=80] - [description]
     * @param {number} [width] - [description]
     * @param {number} [height] - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.PerspectiveCamera} [description]
     */addPerspectiveCamera:function(t,e,i){var n=this.scene.sys.game.config;void 0===t&&(t=80),void 0===e&&(e=n.width),void 0===i&&(i=n.height);var s=new r(this.scene,t,e,i);return this.cameras.push(s),s},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.CameraManager#getCamera
     * @since 3.0.0
     *
     * @param {string} name - [description]
     *
     * @return {(Phaser.Cameras.Sprite3D.OrthographicCamera|Phaser.Cameras.Sprite3D.PerspectiveCamera)} [description]
     */getCamera:function(t){for(var e=0;e<this.cameras.length;e++)if(this.cameras[e].name===t)return this.cameras[e];return null},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.CameraManager#removeCamera
     * @since 3.0.0
     *
     * @param {(Phaser.Cameras.Sprite3D.OrthographicCamera|Phaser.Cameras.Sprite3D.PerspectiveCamera)} camera - [description]
     */removeCamera:function(t){var e=this.cameras.indexOf(t);-1!==e&&this.cameras.splice(e,1)},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.CameraManager#removeAll
     * @since 3.0.0
     *
     * @return {(Phaser.Cameras.Sprite3D.OrthographicCamera|Phaser.Cameras.Sprite3D.PerspectiveCamera)} [description]
     */removeAll:function(){for(;this.cameras.length>0;)this.cameras.pop().destroy();return this.main},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.CameraManager#update
     * @since 3.0.0
     *
     * @param {number} timestep - [description]
     * @param {number} delta - [description]
     */update:function(t,e){for(var i=0,n=this.cameras.length;i<n;++i)this.cameras[i].update(t,e)},/**
     * The Scene that owns this plugin is shutting down.
     * We need to kill and reset all internal properties as well as stop listening to Scene events.
     *
     * @method Phaser.Cameras.Sprite3D.CameraManager#shutdown
     * @private
     * @since 3.0.0
     */shutdown:function(){var t=this.systems.events;t.off("update",this.update,this),t.off("shutdown",this.shutdown,this),this.removeAll()},/**
     * The Scene that owns this plugin is being destroyed.
     * We need to shutdown and then kill off all external references.
     *
     * @method Phaser.Cameras.Sprite3D.CameraManager#destroy
     * @private
     * @since 3.0.0
     */destroy:function(){this.shutdown(),this.scene.sys.events.off("start",this.start,this),this.scene=null,this.systems=null}});o.register("CameraManager3D",a,"cameras3d"),t.exports=a}),r("eARah",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */var i=s("4j1Dk"),n=s("jwj1g"),r=new(s("gbKIZ")),o=new n({Extends:i,initialize:function(t,e,n){void 0===e&&(e=0),void 0===n&&(n=0),i.call(this,t),/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D.OrthographicCamera#viewportWidth
         * @type {integer}
         * @since 3.0.0
         */this.viewportWidth=e,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D.OrthographicCamera#viewportHeight
         * @type {integer}
         * @since 3.0.0
         */this.viewportHeight=n,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D.OrthographicCamera#_zoom
         * @type {number}
         * @private
         * @since 3.0.0
         */this._zoom=1,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D.OrthographicCamera#near
         * @type {number}
         * @default 0
         * @since 3.0.0
         */this.near=0,this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.OrthographicCamera#setToOrtho
     * @since 3.0.0
     *
     * @param {number} yDown - [description]
     * @param {number} [viewportWidth] - [description]
     * @param {number} [viewportHeight] - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.OrthographicCamera} [description]
     */setToOrtho:function(t,e,i){void 0===e&&(e=this.viewportWidth),void 0===i&&(i=this.viewportHeight);var n=this.zoom;return this.up.set(0,t?-1:1,0),this.direction.set(0,0,t?1:-1),this.position.set(n*e/2,n*i/2,0),this.viewportWidth=e,this.viewportHeight=i,this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.OrthographicCamera#update
     * @since 3.0.0
     *
     * @return {Phaser.Cameras.Sprite3D.OrthographicCamera} [description]
     */update:function(){var t=this.viewportWidth,e=this.viewportHeight,i=Math.abs(this.near),n=Math.abs(this.far),s=this.zoom;return 0===t||0===e||(this.projection.ortho(-(s*t)/2,s*t/2,-(s*e)/2,s*e/2,i,n),//  Build the view matrix
r.copy(this.position).add(this.direction),this.view.lookAt(this.position,r,this.up),//  Projection * view matrix
this.combined.copy(this.projection).multiply(this.view),//  Invert combined matrix, used for unproject
this.invProjectionView.copy(this.combined).invert(),this.billboardMatrixDirty=!0,this.updateChildren()),this},/**
     * [description]
     *
     * @name Phaser.Cameras.Sprite3D.OrthographicCamera#zoom
     * @type {number}
     * @since 3.0.0
     */zoom:{get:function(){return this._zoom},set:function(t){this._zoom=t,this.update()}}});t.exports=o}),r("hbpve",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */var i=s("4j1Dk"),n=s("jwj1g"),r=new(s("gbKIZ")),o=new n({Extends:i,//  FOV is converted to radians automatically
initialize:function(t,e,n,s){void 0===e&&(e=80),void 0===n&&(n=0),void 0===s&&(s=0),i.call(this,t),/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D.PerspectiveCamera#viewportWidth
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.viewportWidth=n,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D.PerspectiveCamera#viewportHeight
         * @type {integer}
         * @default 0
         * @since 3.0.0
         */this.viewportHeight=s,/**
         * [description]
         *
         * @name Phaser.Cameras.Sprite3D.PerspectiveCamera#fieldOfView
         * @type {integer}
         * @default 80
         * @since 3.0.0
         */this.fieldOfView=e*Math.PI/180,this.update()},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.PerspectiveCamera#setFOV
     * @since 3.0.0
     *
     * @param {number} value - [description]
     *
     * @return {Phaser.Cameras.Sprite3D.PerspectiveCamera} [description]
     */setFOV:function(t){return this.fieldOfView=t*Math.PI/180,this},/**
     * [description]
     *
     * @method Phaser.Cameras.Sprite3D.PerspectiveCamera#update
     * @since 3.0.0
     *
     * @return {Phaser.Cameras.Sprite3D.PerspectiveCamera} [description]
     */update:function(){var t=this.viewportWidth/this.viewportHeight;return(//  Create a perspective matrix for our camera
this.projection.perspective(this.fieldOfView,t,Math.abs(this.near),Math.abs(this.far)),//  Build the view matrix
r.copy(this.position).add(this.direction),this.view.lookAt(this.position,r,this.up),//  Projection * view matrix
this.combined.copy(this.projection).multiply(this.view),//  Invert combined matrix, used for unproject
this.invProjectionView.copy(this.combined).invert(),this.billboardMatrixDirty=!0,this.updateChildren(),this)}});t.exports=o}),r("1p1UC",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */var i=s("dK9Ze");/**
 * Creates a new Sprite3D Game Object and adds it to the Scene.
 *
 * Note: This method will only be available if the Sprite3D Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectFactory#sprite3D
 * @since 3.0.0
 *
 * @param {number} x - The horizontal position of this Game Object.
 * @param {number} y - The vertical position of this Game Object.
 * @param {number} z - The z position of this Game Object.
 * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
 * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.
 *
 * @return {Phaser.GameObjects.Sprite3D} The Game Object that was created.
 */s("kge7H").register("sprite3D",function(t,e,n,s,r){var o=new i(this.scene,t,e,n,s,r);return this.displayList.add(o.gameObject),this.updateList.add(o.gameObject),o});//  When registering a factory function 'this' refers to the GameObjectFactory context.
//
//  There are several properties available to use:
//
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns
}),r("9gGHw",function(t,e){/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */var i=s("i9cSP"),n=s("cDuAM"),r=s("ebQQp"),o=s("cSaNN"),a=s("dK9Ze");/**
 * Creates a new Sprite3D Game Object and returns it.
 *
 * Note: This method will only be available if the Sprite3D Game Object has been built into Phaser.
 *
 * @method Phaser.GameObjects.GameObjectCreator#sprite3D
 * @since 3.0.0
 *
 * @param {object} config - The configuration object this Game Object will use to create itself.
 * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
 *
 * @return {Phaser.GameObjects.Sprite3D} The Game Object that was created.
 */r.register("sprite3D",function(t,e){void 0===t&&(t={});var s=o(t,"key",null),r=o(t,"frame",null),h=new a(this.scene,0,0,s,r);return void 0!==e&&(t.add=e),i(this.scene,h,t),//  Sprite specific config options:
n(h,t),h});//  When registering a factory function 'this' refers to the GameObjectCreator context.
}),r("6S8Iy",function(t,e){// Generated by CoffeeScript 1.8.0
(function(){var e,i,n,s,r,o,a,h,l,u,c,d,f,p,g,v;n=Math.floor,u=Math.min,/*
  Default comparison function to be used
   */i=function(t,e){return t<e?-1:t>e?1:0},/*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */l=function(t,e,s,r,o){var a;if(null==s&&(s=0),null==o&&(o=i),s<0)throw Error("lo must be non-negative");for(null==r&&(r=t.length);s<r;)0>o(e,t[a=n((s+r)/2)])?r=a:s=a+1;return[].splice.apply(t,[s,s-s].concat(e)),e},/*
  Push item onto heap, maintaining the heap invariant.
   */o=function(t,e,n){return null==n&&(n=i),t.push(e),p(t,0,t.length-1,n)},/*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */r=function(t,e){var n,s;return null==e&&(e=i),n=t.pop(),t.length?(s=t[0],t[0]=n,g(t,0,e)):s=n,s},/*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */h=function(t,e,n){var s;return null==n&&(n=i),s=t[0],t[0]=e,g(t,0,n),s},/*
  Fast version of a heappush followed by a heappop.
   */a=function(t,e,n){var s;return null==n&&(n=i),t.length&&0>n(t[0],e)&&(e=(s=[t[0],e])[0],t[0]=s[1],g(t,0,n)),e},/*
  Transform list into a heap, in-place, in O(array.length) time.
   */s=function(t,e){var s,r,o,a,h,l;for(null==e&&(e=i),a=(function(){l=[];for(var e=0,i=n(t.length/2);0<=i?e<i:e>i;0<=i?e++:e--)l.push(e);return l}).apply(this).reverse(),h=[],r=0,o=a.length;r<o;r++)s=a[r],h.push(g(t,s,e));return h},/*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */f=function(t,e,n){var s;if(null==n&&(n=i),-1!==(s=t.indexOf(e)))return p(t,0,s,n),g(t,s,n)},/*
  Find the n largest elements in a dataset.
   */c=function(t,e,n){var r,o,h,l;if(null==n&&(n=i),!(r=t.slice(0,e)).length)return r;for(s(r,n),o=0,h=(l=t.slice(e)).length;o<h;o++)a(r,l[o],n);return r.sort(n).reverse()},/*
  Find the n smallest elements in a dataset.
   */d=function(t,e,n){var o,a,h,c,d,f,p,g,v;if(null==n&&(n=i),10*e<=t.length){if(!(h=t.slice(0,e).sort(n)).length)return h;for(c=0,a=h[h.length-1],f=(p=t.slice(e)).length;c<f;c++)0>n(o=p[c],a)&&(l(h,o,0,null,n),h.pop(),a=h[h.length-1]);return h}for(s(t,n),v=[],d=0,g=u(e,t.length);0<=g?d<g:d>g;0<=g?++d:--d)v.push(r(t,n));return v},p=function(t,e,n,s){var r,o,a;for(null==s&&(s=i),r=t[n];n>e;){if(0>s(r,o=t[a=n-1>>1])){t[n]=o,n=a;continue}break}return t[n]=r},g=function(t,e,n){var s,r,o,a,h;for(null==n&&(n=i),r=t.length,h=e,o=t[e],s=2*e+1;s<r;)(a=s+1)<r&&!(0>n(t[s],t[a]))&&(s=a),t[e]=t[s],s=2*(e=s)+1;return t[e]=o,p(t,h,e,n)},e=function(){function t(t){this.cmp=null!=t?t:i,this.nodes=[]}return t.push=o,t.pop=r,t.replace=h,t.pushpop=a,t.heapify=s,t.updateItem=f,t.nlargest=c,t.nsmallest=d,t.prototype.push=function(t){return o(this.nodes,t,this.cmp)},t.prototype.pop=function(){return r(this.nodes,this.cmp)},t.prototype.peek=function(){return this.nodes[0]},t.prototype.contains=function(t){return -1!==this.nodes.indexOf(t)},t.prototype.replace=function(t){return h(this.nodes,t,this.cmp)},t.prototype.pushpop=function(t){return a(this.nodes,t,this.cmp)},t.prototype.heapify=function(){return s(this.nodes,this.cmp)},t.prototype.updateItem=function(t){return f(this.nodes,t,this.cmp)},t.prototype.clear=function(){return this.nodes=[]},t.prototype.empty=function(){return 0===this.nodes.length},t.prototype.size=function(){return this.nodes.length},t.prototype.clone=function(){var e;return(e=new t).nodes=this.nodes.slice(0),e},t.prototype.toArray=function(){return this.nodes.slice(0)},t.prototype.insert=t.prototype.push,t.prototype.top=t.prototype.peek,t.prototype.front=t.prototype.peek,t.prototype.has=t.prototype.contains,t.prototype.copy=t.prototype.clone,t}(),v=function(){return e},"function"==typeof define&&define.amd?define([],v):t.exports=v()}).call(t.exports)});var o={};Array.prototype.forEach||(Array.prototype.forEach=function(t/*, thisArg */){if(void 0===this||this===null)throw TypeError();var e=Object(this),i=e.length>>>0;if("function"!=typeof t)throw TypeError();for(var n=arguments.length>=2?arguments[1]:void 0,s=0;s<i;s++)s in e&&t.call(n,e[s],s,e)}),Array.isArray||(Array.isArray=function(t){return"[object Array]"===Object.prototype.toString.call(t)}),/* Copyright 2013 Chris Wilson

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*//*

This monkeypatch library is intended to be included in projects that are
written to the proper AudioContext spec (instead of webkitAudioContext),
and that use the new naming and proper bits of the Web Audio API (e.g.
using BufferSourceNode.start() instead of BufferSourceNode.noteOn()), but may
have to run on systems that only support the deprecated bits.

This library should be harmless to include if the browser supports
unprefixed "AudioContext", and/or if it supports the new names.

The patches this library handles:
if window.AudioContext is unsupported, it will be aliased to webkitAudioContext().
if AudioBufferSourceNode.start() is unimplemented, it will be routed to noteOn() or
noteGrainOn(), depending on parameters.

The following aliases only take effect if the new names are not already in place:

AudioBufferSourceNode.stop() is aliased to noteOff()
AudioContext.createGain() is aliased to createGainNode()
AudioContext.createDelay() is aliased to createDelayNode()
AudioContext.createScriptProcessor() is aliased to createJavaScriptNode()
AudioContext.createPeriodicWave() is aliased to createWaveTable()
OscillatorNode.start() is aliased to noteOn()
OscillatorNode.stop() is aliased to noteOff()
OscillatorNode.setPeriodicWave() is aliased to setWaveTable()
AudioParam.setTargetAtTime() is aliased to setTargetValueAtTime()

This library does NOT patch the enumerated type changes, as it is
recommended in the specification that implementations support both integer
and string types for AudioPannerNode.panningModel, AudioPannerNode.distanceModel
BiquadFilterNode.type and OscillatorNode.type.

*/function(){function t(t){t&&!t.setTargetAtTime&&(t.setTargetAtTime=t.setTargetValueAtTime)}window.hasOwnProperty("webkitAudioContext")&&!window.hasOwnProperty("AudioContext")&&(window.AudioContext=webkitAudioContext,AudioContext.prototype.hasOwnProperty("createGain")||(AudioContext.prototype.createGain=AudioContext.prototype.createGainNode),AudioContext.prototype.hasOwnProperty("createDelay")||(AudioContext.prototype.createDelay=AudioContext.prototype.createDelayNode),AudioContext.prototype.hasOwnProperty("createScriptProcessor")||(AudioContext.prototype.createScriptProcessor=AudioContext.prototype.createJavaScriptNode),AudioContext.prototype.hasOwnProperty("createPeriodicWave")||(AudioContext.prototype.createPeriodicWave=AudioContext.prototype.createWaveTable),AudioContext.prototype.internal_createGain=AudioContext.prototype.createGain,AudioContext.prototype.createGain=function(){var e=this.internal_createGain();return t(e.gain),e},AudioContext.prototype.internal_createDelay=AudioContext.prototype.createDelay,AudioContext.prototype.createDelay=function(e){var i=e?this.internal_createDelay(e):this.internal_createDelay();return t(i.delayTime),i},AudioContext.prototype.internal_createBufferSource=AudioContext.prototype.createBufferSource,AudioContext.prototype.createBufferSource=function(){var e=this.internal_createBufferSource();return e.start?(e.internal_start=e.start,e.start=function(t,i,n){void 0!==n?e.internal_start(t||0,i,n):e.internal_start(t||0,i||0)}):e.start=function(t,e,i){e||i?this.noteGrainOn(t||0,e,i):this.noteOn(t||0)},e.stop?(e.internal_stop=e.stop,e.stop=function(t){e.internal_stop(t||0)}):e.stop=function(t){this.noteOff(t||0)},t(e.playbackRate),e},AudioContext.prototype.internal_createDynamicsCompressor=AudioContext.prototype.createDynamicsCompressor,AudioContext.prototype.createDynamicsCompressor=function(){var e=this.internal_createDynamicsCompressor();return t(e.threshold),t(e.knee),t(e.ratio),t(e.reduction),t(e.attack),t(e.release),e},AudioContext.prototype.internal_createBiquadFilter=AudioContext.prototype.createBiquadFilter,AudioContext.prototype.createBiquadFilter=function(){var e=this.internal_createBiquadFilter();return t(e.frequency),t(e.detune),t(e.Q),t(e.gain),e},AudioContext.prototype.hasOwnProperty("createOscillator")&&(AudioContext.prototype.internal_createOscillator=AudioContext.prototype.createOscillator,AudioContext.prototype.createOscillator=function(){var e=this.internal_createOscillator();return e.start?(e.internal_start=e.start,e.start=function(t){e.internal_start(t||0)}):e.start=function(t){this.noteOn(t||0)},e.stop?(e.internal_stop=e.stop,e.stop=function(t){e.internal_stop(t||0)}):e.stop=function(t){this.noteOff(t||0)},e.setPeriodicWave||(e.setPeriodicWave=e.setWaveTable),t(e.frequency),t(e.detune),e})),window.hasOwnProperty("webkitOfflineAudioContext")&&!window.hasOwnProperty("OfflineAudioContext")&&(window.OfflineAudioContext=webkitOfflineAudioContext)}(),window.console||(window.console={},window.console.log=window.console.assert=function(){},window.console.warn=window.console.assert=function(){}),Math.trunc||(Math.trunc=function(t){return t<0?Math.ceil(t):Math.floor(t)}),/**
 * performance.now
 */function(){if("performance"in window==!1&&(window.performance={}),//  Thanks IE8
Date.now=Date.now||function(){return new Date().getTime()},"now"in window.performance==!1){var t=Date.now();performance.timing&&performance.timing.navigationStart&&(t=performance.timing.navigationStart),window.performance.now=function(){return Date.now()-t}}}();for(var a=Date.now(),h=["ms","moz","webkit","o"],l=0;l<h.length&&!window.requestAnimationFrame;l++)window.requestAnimationFrame=window[h[l]+"RequestAnimationFrame"],window.cancelAnimationFrame=window[h[l]+"CancelAnimationFrame"]||window[h[l]+"CancelRequestAnimationFrame"];/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/if(window.requestAnimationFrame||(window.requestAnimationFrame=function(t){if("function"!=typeof t)throw TypeError(t+"is not a function");var e=Date.now(),i=16+a-e;return i<0&&(i=0),a=e,setTimeout(function(){a=Date.now(),t(performance.now())},i)}),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(t){clearTimeout(t)}),"function"!=typeof window.Uint32Array&&"object"!=typeof window.Uint32Array){var u=function(t){window[t]=function(t){if("number"==typeof t){Array.call(this,t),this.length=t;for(var e=0;e<this.length;e++)this[e]=0}else{Array.call(this,t.length),this.length=t.length;for(var e=0;e<this.length;e++)this[e]=t[e]}},window[t].prototype=[],window[t].constructor=window[t]};u("Float32Array"),u("Uint32Array"),u("Uint16Array"),u("Int16Array"),u("ArrayBuffer")}var c=s("bRAqZ"),d=s("hVk4C"),f={Actions:s("fs3fn"),Animations:s("gc8vS"),BlendModes:s("3qUcC"),Cache:s("dRHWx"),Cameras:s("cjvhk"),Core:s("b8jwN"),Class:s("jwj1g"),Create:s("avk0U"),Curves:s("fIfAn"),Data:s("fvFEG"),Display:s("g2mK1"),DOM:s("4SM0m"),Events:s("1ZXFk"),Game:s("L2T5H"),GameObjects:s("kNR1J"),Geom:s("kNZrp"),Input:s("lKFyN"),Loader:s("89Da5"),Math:s("5OyGi"),Physics:s("kZqOf"),Plugins:s("UoAVD"),Renderer:s("28d72"),Scale:s("59R71"),ScaleModes:s("1iebW"),Scene:s("iXVlb"),Scenes:s("kULhB"),Structs:s("i2sgM"),Textures:s("rZmIK"),Tilemaps:s("s5oWw"),Time:s("4Tb60"),Tweens:s("145t6"),Utils:s("cdLjm")};f.Sound=s("gNVRh"),f.Cameras.Sprite3D=s("hRsbN"),f.GameObjects.Sprite3D=s("dK9Ze"),f.GameObjects.Factories.Sprite3D=s("1p1UC"),f.GameObjects.Creators.Sprite3D=s("9gGHw"),f.FacebookInstantGamesPlugin=s("LHpuq"),/**
 * The root types namespace.
 * 
 * @namespace Phaser.Types
 * @since 3.17.0
 *///  Export it
o=//   Merge in the consts
f=d(!1,f,c),e.Phaser=f;var p={},g={},v={};/**
 * Represents a single instance of EasyStar.
 * A path that is in the queue to eventually be found.
 */v=function(){this.pointsToAvoid={},this.startX,this.callback,this.startY,this.endX,this.endY,this.nodeHash={},this.openList};var m={};/**
* A simple Node that represents a single tile on the grid.
* @param {Object} parent The parent node.
* @param {Number} x The x position on the grid.
* @param {Number} y The y position on the grid.
* @param {Number} costSoFar How far this node is in moves*cost from the start.
* @param {Number} simpleDistanceToTarget Manhatten distance to the end point.
**/m=function(t,e,i,n,s){this.parent=t,this.x=e,this.y=i,this.costSoFar=n,this.simpleDistanceToTarget=s,/**
    * @return {Number} Best guess distance of a cost using this node.
    **/this.bestGuessDistance=function(){return this.costSoFar+this.simpleDistanceToTarget}};var y={};y=s("6S8Iy"),p=g;var x=1;g.js=function(){var t,e,i,n=!1,s={},r={},o={},a={},h=!0,l={},u=[],c=Number.MAX_VALUE,d=!1;/**
    * Sets the collision grid that EasyStar uses.
    *
    * @param {Array|Number} tiles An array of numbers that represent
    * which tiles in your grid should be considered
    * acceptable, or "walkable".
    **/this.setAcceptableTiles=function(t){t instanceof Array?i=t:!isNaN(parseFloat(t))&&isFinite(t)&&(i=[t])},/**
    * Enables sync mode for this EasyStar instance..
    * if you're into that sort of thing.
    **/this.enableSync=function(){n=!0},/**
    * Disables sync mode for this EasyStar instance.
    **/this.disableSync=function(){n=!1},/**
     * Enable diagonal pathfinding.
     */this.enableDiagonals=function(){d=!0},/**
     * Disable diagonal pathfinding.
     */this.disableDiagonals=function(){d=!1},/**
    * Sets the collision grid that EasyStar uses.
    *
    * @param {Array} grid The collision grid that this EasyStar instance will read from.
    * This should be a 2D Array of Numbers.
    **/this.setGrid=function(e){t=e;//Setup cost map
for(var i=0;i<t.length;i++)for(var n=0;n<t[0].length;n++)r[t[i][n]]||(r[t[i][n]]=1)},/**
    * Sets the tile cost for a particular tile type.
    *
    * @param {Number} The tile type to set the cost for.
    * @param {Number} The multiplicative cost associated with the given tile.
    **/this.setTileCost=function(t,e){r[t]=e},/**
    * Sets the an additional cost for a particular point.
    * Overrides the cost from setTileCost.
    *
    * @param {Number} x The x value of the point to cost.
    * @param {Number} y The y value of the point to cost.
    * @param {Number} The multiplicative cost associated with the given point.
    **/this.setAdditionalPointCost=function(t,e,i){void 0===o[e]&&(o[e]={}),o[e][t]=i},/**
    * Remove the additional cost for a particular point.
    *
    * @param {Number} x The x value of the point to stop costing.
    * @param {Number} y The y value of the point to stop costing.
    **/this.removeAdditionalPointCost=function(t,e){void 0!==o[e]&&delete o[e][t]},/**
    * Remove all additional point costs.
    **/this.removeAllAdditionalPointCosts=function(){o={}},/**
    * Sets a directional condition on a tile
    *
    * @param {Number} x The x value of the point.
    * @param {Number} y The y value of the point.
    * @param {Array.<String>} allowedDirections A list of all the allowed directions that can access
    * the tile.
    **/this.setDirectionalCondition=function(t,e,i){void 0===a[e]&&(a[e]={}),a[e][t]=i},/**
    * Remove all directional conditions
    **/this.removeAllDirectionalConditions=function(){a={}},/**
    * Sets the number of search iterations per calculation.
    * A lower number provides a slower result, but more practical if you
    * have a large tile-map and don't want to block your thread while
    * finding a path.
    *
    * @param {Number} iterations The number of searches to prefrom per calculate() call.
    **/this.setIterationsPerCalculation=function(t){c=t},/**
    * Avoid a particular point on the grid,
    * regardless of whether or not it is an acceptable tile.
    *
    * @param {Number} x The x value of the point to avoid.
    * @param {Number} y The y value of the point to avoid.
    **/this.avoidAdditionalPoint=function(t,e){void 0===s[e]&&(s[e]={}),s[e][t]=1},/**
    * Stop avoiding a particular point on the grid.
    *
    * @param {Number} x The x value of the point to stop avoiding.
    * @param {Number} y The y value of the point to stop avoiding.
    **/this.stopAvoidingAdditionalPoint=function(t,e){void 0!==s[e]&&delete s[e][t]},/**
    * Enables corner cutting in diagonal movement.
    **/this.enableCornerCutting=function(){h=!0},/**
    * Disables corner cutting in diagonal movement.
    **/this.disableCornerCutting=function(){h=!1},/**
    * Stop avoiding all additional points on the grid.
    **/this.stopAvoidingAllAdditionalPoints=function(){s={}},/**
    * Find a path.
    *
    * @param {Number} startX The X position of the starting point.
    * @param {Number} startY The Y position of the starting point.
    * @param {Number} endX The X position of the ending point.
    * @param {Number} endY The Y position of the ending point.
    * @param {Function} callback A function that is called when your path
    * is found, or no path is found.
    * @return {Number} A numeric, non-zero value which identifies the created instance. This value can be passed to cancelPath to cancel the path calculation.
    *
    **/this.findPath=function(e,s,r,o,a){// Wraps the callback for sync vs async logic
var h=function(t){n?a(t):setTimeout(function(){a(t)})};// No acceptable tiles were set
if(void 0===i)throw Error("You can't set a path without first calling setAcceptableTiles() on EasyStar.");// No grid was set
if(void 0===t)throw Error("You can't set a path without first calling setGrid() on EasyStar.");// Start or endpoint outside of scope.
if(e<0||s<0||r<0||o<0||e>t[0].length-1||s>t.length-1||r>t[0].length-1||o>t.length-1)throw Error("Your start or end point is outside the scope of your grid.");// Start and end are the same tile.
if(e===r&&s===o){h([]);return}for(var c=t[o][r],d=!1,f=0;f<i.length;f++)if(c===i[f]){d=!0;break}if(!1===d){h(null);return}// Create the instance
var p=new v;p.openList=new y(function(t,e){return t.bestGuessDistance()-e.bestGuessDistance()}),p.isDoneCalculating=!1,p.nodeHash={},p.startX=e,p.startY=s,p.endX=r,p.endY=o,p.callback=h,p.openList.push(b(p,p.startX,p.startY,null,1));var g=x++;return l[g]=p,u.push(g),g},/**
     * Cancel a path calculation.
     *
     * @param {Number} instanceId The instance ID of the path being calculated
     * @return {Boolean} True if an instance was found and cancelled.
     *
     **/this.cancelPath=function(t){return t in l&&(delete l[t],!0)},/**
    * This method steps through the A* Algorithm in an attempt to
    * find your path(s). It will search 4-8 tiles (depending on diagonals) for every calculation.
    * You can change the number of calculations done in a call by using
    * easystar.setIteratonsPerCalculation().
    **/this.calculate=function(){if(0!==u.length&&void 0!==t&&void 0!==i)for(e=0;e<c;e++){if(0===u.length)return;n&&(e=0);var s=u[0],r=l[s];if(void 0===r){// This instance was cancelled
u.shift();continue}// Couldn't find a path.
if(0===r.openList.size()){r.callback(null),delete l[s],u.shift();continue}var o=r.openList.pop();// Handles the case where we have found the destination
if(r.endX===o.x&&r.endY===o.y){var a=[];a.push({x:o.x,y:o.y});for(var g=o.parent;null!=g;)a.push({x:g.x,y:g.y}),g=g.parent;a.reverse(),r.callback(a),delete l[s],u.shift();continue}o.list=0,o.y>0&&f(r,o,0,-1,1*T(o.x,o.y-1)),o.x<t[0].length-1&&f(r,o,1,0,1*T(o.x+1,o.y)),o.y<t.length-1&&f(r,o,0,1,1*T(o.x,o.y+1)),o.x>0&&f(r,o,-1,0,1*T(o.x-1,o.y)),d&&(o.x>0&&o.y>0&&(h||p(t,i,o.x,o.y-1,o)&&p(t,i,o.x-1,o.y,o))&&f(r,o,-1,-1,1.4*T(o.x-1,o.y-1)),o.x<t[0].length-1&&o.y<t.length-1&&(h||p(t,i,o.x,o.y+1,o)&&p(t,i,o.x+1,o.y,o))&&f(r,o,1,1,1.4*T(o.x+1,o.y+1)),o.x<t[0].length-1&&o.y>0&&(h||p(t,i,o.x,o.y-1,o)&&p(t,i,o.x+1,o.y,o))&&f(r,o,1,-1,1.4*T(o.x+1,o.y-1)),o.x>0&&o.y<t.length-1&&(h||p(t,i,o.x,o.y+1,o)&&p(t,i,o.x-1,o.y,o))&&f(r,o,-1,1,1.4*T(o.x-1,o.y+1)))}};// Private methods follow
var f=function(e,n,r,o,a){var h=n.x+r,l=n.y+o;if((void 0===s[l]||void 0===s[l][h])&&p(t,i,h,l,n)){var u=b(e,h,l,n,a);void 0===u.list?(u.list=1,e.openList.push(u)):n.costSoFar+a<u.costSoFar&&(u.costSoFar=n.costSoFar+a,u.parent=n,e.openList.updateItem(u))}},p=function(t,e,i,n,s){var r=a[n]&&a[n][i];if(r){var o=w(s.x-i,s.y-n);if(!function(){for(var t=0;t<r.length;t++)if(r[t]===o)return!0;return!1}())return!1}for(var h=0;h<e.length;h++)if(t[n][i]===e[h])return!0;return!1},w=function(t,e){if(0===t&&-1===e)return g.TOP;if(1===t&&-1===e)return g.TOP_RIGHT;if(1===t&&0===e)return g.RIGHT;if(1===t&&1===e)return g.BOTTOM_RIGHT;if(0===t&&1===e)return g.BOTTOM;if(-1===t&&1===e)return g.BOTTOM_LEFT;if(-1===t&&0===e)return g.LEFT;else if(-1===t&&-1===e)return g.TOP_LEFT;throw Error("These differences are not valid: "+t+", "+e)},T=function(e,i){return o[i]&&o[i][e]||r[t[i][e]]},b=function(t,e,i,n,s){if(void 0!==t.nodeHash[i]){if(void 0!==t.nodeHash[i][e])return t.nodeHash[i][e]}else t.nodeHash[i]={};var r=S(e,i,t.endX,t.endY);if(null!==n)var o=n.costSoFar+s;else o=0;var a=new m(n,e,i,o,r);return t.nodeHash[i][e]=a,a},S=function(t,e,i,n){if(d){// Octile distance
var s=Math.abs(t-i),r=Math.abs(e-n);return s<r?1.4*s+r:1.4*r+s}// Manhattan distance
var s=Math.abs(t-i),r=Math.abs(e-n);return s+r}},g.TOP="TOP",g.TOP_RIGHT="TOP_RIGHT",g.RIGHT="RIGHT",g.BOTTOM_RIGHT="BOTTOM_RIGHT",g.BOTTOM="BOTTOM",g.BOTTOM_LEFT="BOTTOM_LEFT",g.LEFT="LEFT",g.TOP_LEFT="TOP_LEFT";const w=[[2,2,1,1,4,4,1,6,2,2,2,2,2,2,1,1,4,4,1,6,2,2,2],[2,6,1,0,4,4,0,0,2,2,2,2,2,6,1,0,4,4,0,0,2,2,2],[6,1,0,0,4,4,0,0,2,2,2,2,6,1,0,0,4,4,0,0,2,2,2],[0,0,0,0,4,4,0,0,0,2,2,2,0,0,0,0,4,4,0,0,0,2,2],[0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0],[0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0],[0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0],[0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0],[1,1,7,1,3,3,1,7,1,1,1,1,1,1,7,1,3,3,1,7,1,1,1],[3,7,3,3,3,3,3,3,7,3,3,1,3,7,3,3,3,3,3,3,7,3,3],[7,1,7,7,3,3,7,7,1,1,7,1,7,1,7,7,3,3,7,7,1,1,7],[2,2,1,1,4,4,1,6,2,2,2,2,2,2,1,1,4,4,1,6,2,2,2],[2,6,1,0,4,4,0,0,2,2,2,2,2,6,1,0,4,4,0,0,2,2,2],[6,1,0,0,4,4,0,0,2,2,2,2,6,1,0,0,4,4,0,0,2,2,2],[0,0,0,0,4,4,0,0,0,2,2,2,0,0,0,0,4,4,0,0,0,2,2],[0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0],[0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0],[0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0],[0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0],[1,1,7,1,3,3,1,7,1,1,1,1,1,1,7,1,3,3,1,7,1,1,1],[3,7,3,3,3,3,3,3,7,3,3,1,3,7,3,3,3,3,3,3,7,3,3],[7,1,7,7,3,3,7,7,1,1,7,1,7,1,7,7,3,3,7,7,1,1,7]],T=[[1,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,0,0,3,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,2,2,0,5,0,0,0,0,0,0,0,0,2,2,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,1,4,0,0,4,0,0,4,3,1,2,3,0,0,0,0,0,0,4,2,0],[0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,0,0,3,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,2,2,0,5,0,0,0,0,0,0,0,0,2,2,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,1,4,0,0,4,0,0,4,3,1,2,3,0,0,0,0,0,0,4,2,0],[0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0]],b=[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,1,1,1,1]],S=[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1],[1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,1,1],[0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,1,1],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0],[1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,0,1,1],[1,1,1,0,1,1,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,1,1],[1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1],[1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,1,1],[0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,1,1],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0],[1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,0,1,1],[1,1,1,0,1,1,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,1,1],[1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1]],A={type:/*@__PURE__*/t(o).AUTO,width:window.innerWidth,height:window.innerHeight,scene:{preload:function(){this.load.atlas("tileset","assets/sprites/tileset.png","assets/sprites/tileset.json"),this.load.atlas("char","assets/sprites/char.png","assets/sprites/char.json"),this.load.atlas("object","assets/sprites/object.png","assets/sprites/object.json"),this.load.glsl("waterShader","assets/waterShader.glsl")},create:function(){let e=this.input.keyboard.createCursorKeys();this.easystar=new/*@__PURE__*/(t(p)).js,this.easystar.setGrid(S),this.easystar.setAcceptableTiles([1]),this.finding=!1,this.cameras.main.setZoom(1);let i={camera:this.cameras.main,left:e.left,right:e.right,up:e.up,down:e.down,acceleration:.05,drag:5e-4,maxSpeed:.4};this.controls=new/*@__PURE__*/(t(o)).Cameras.Controls.SmoothedKeyControl(i);// Create a group to hold your tiles
let n=this.add.group(),s=[];s[0]="water",s[1]="sand",s[2]="grass",s[3]="stone",s[4]="wood",s[5]="watersand",s[6]="grasssand",s[7]="sandstone",s[8]="bush1",s[9]="bush2",s[10]="mushroom",s[11]="wall",s[12]="window";let r=[];r[0]="",r[1]="bush_2",r[2]="bush_3",r[3]="bush_5",r[4]="oak3",r[5]="oak2";for(let t=0;t<w.length;t++)for(let e=0;e<w[t].length;e++){// Calculate the isometric position
let i=(e-t)*32,r=(e+t)*16,o=w[t][e],a=s[o],h=this.add.sprite(i,r,"tileset",a);if(h.setOrigin(1,1),h.setDepth(0),n.add(h),0===o&&(// Add to water tiles
h.setDepth(-4),E.push(h)),4===o){// Make bridge higher
h.setDepth(4);// Put tile under bridge
let t=this.add.sprite(i,r,"tileset",s[0]);//waterUnderBridge.anchor.set(0.5, 1);
//waterUnderBridge.initialZ = -4;
t.originX=.5,t.originY=1,t.setDepth(-4),E.push(t)}}for(let t=0;t<w.length;t++)for(let e=0;e<w[t].length;e++){let i=(e-t)*32,s=(e+t)*16,o=T[t][e];if(0!==o){let a=r[o],h=this.add.sprite(i,s,"object",a);h.setOrigin(1,1),h.originX=b[t][e],h.originY=1,n.add(h),h.setDepth(10)}// Set a specific tile image based on the value in the mapData
}}//# sourceMappingURL=index.3e282935.js.map
,update:function(t,e){this.controls.update(e)}}};var E=[];new/*@__PURE__*/(t(o)).Game(A);
//# sourceMappingURL=index.3e282935.js.map
